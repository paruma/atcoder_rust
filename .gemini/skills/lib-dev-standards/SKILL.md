---
name: lib-dev-standards
description: 競技プログラミング用 Rust ライブラリ開発の設計指針（抽象代数的設計、構造的対称性、スニペットの依存分離、コーディング規約）を適用する。
---

# Library Development Standards

高品質で汎用性が高く、メンテナンスしやすい Rust ライブラリを構築するための設計思想と指針。この文書は、新たな知見が得られるたびに更新・進化し続けるものである。

## 1. 抽象代数的設計 (Abstract Algebraic Design)
特定の型（`i64` 等）やそのドメイン（定義域）への依存を排除し、計算に本質的に必要な「代数的性質」のみを要求する。

- **ドメイン依存からの脱却**: `From<i64>` を避ける本質的な理由は、型 `T` が「整数そのもの」であるという強い仮定を排除することにある。
- **「変換」から「作用・系内部の演算」への転換**:
    - **スカラー倍の作用 (`Mul<i64>`)**: 整数 $n$ を `T` に「変換」して掛けるのではなく、`T` に対して整数 $n$ が「作用（スカラー倍）」できることを要求する。
    - **系内部での単位元生成 (`Sum`, `Product`)**: `0.into()` や `1.into()` の代わりに、代数系が持つ演算ルールから単位元を導き出す。具体的には、モジュール内に定義した `fn zero<T: Sum>() -> T { std::iter::empty::<T>().sum() }` や `fn one<T: Product>() -> T { std::iter::empty::<T>().product() }` を使用する。`num-traits` の `Zero`/`One` を避ける理由は、`ac-library-rs` の `ModInt` 等がこれらを実装していない場合があるためである。
- **インターフェースの純粋化**: 型の「ドメイン」ではなく「能力」に基づいてトレイト境界を定義する。

## 2. 構造的対称性の維持 (Structural Symmetry)
対になる概念（最小/最大など）を扱うファイル群は、ミラー構造を維持する。

- **クローン構造の追求**: 行数、空行の位置、インポートの順序、メソッドの定義順を完全に一致させる。
- **メンテナンス性の同期**: `symmetry-syncer` スキルを用い、スタイル上のノイズを徹底的に排除する。

## 3. スニペット設計・実装指針 (Snippet Design and Implementation)
`cargo-snippet` で展開されるコードの品質と、展開後のコンパイル成功を保証するための基準。

### 3.1 設計指針 (Architectural Design)
- **依存グラフの最小化**: `cargo-snippet` で展開されるコードの依存グラフを最小限に保つ。
- **依存方向の管理**: 具体的な機能を提供するスニペット（例：`RangeAffineDualSegtree`）側で `include` 属性を使い、汎用的なコアスニペットを呼び出す形にする。これにより、コア実装が特定の具体例に汚染されるのを防ぐ。
- **外部トレイト実装の分離**: 自作の型に対して、**別のスニペットで定義されたトレイト**を実装する場合（例：`ExtInt` への `BoundedAbove` 実装など）、その実装自体を独立したスニペット（例：`mod_ext_int_bounded`）として定義する。これにより、そのトレイトを必要としない利用シーンでコアスニペットの依存関係が増えるのを防ぐ。
- **統合テストの配置**: 原則として「依存する側」のファイルにテストを記述し、コア側に不要な依存が混入するのを防ぐ。

### 3.2 実装規約 (Implementation Conventions)
スニペットは提出時にフラットなコンテキスト（`main.rs` 等）に展開される。この展開プロセスを考慮した実装を行う。

- **属性の記述形式**: 複数の属性引数（`prefix`, `include` 等）がある場合、`#[snippet(prefix = "...", include = "...")]` のように1行にまとめて記述する。
- **インポートの配置**:
    - **`std` / `ac_library` 等の外部依存**: スニペット貼り付け先でも常に利用可能であるため、`#[snippet]` が付与された **`mod` ブロックの内部**で直接 `use` 宣言を行う。
    - **ローカルスニペットへの依存**: 
        1.  ファイルの先頭（`pub mod` の外）で `crate::...` を用いて、依存する型やトレイトをインポートする（IDE/開発環境用）。
        2.  `mod` ブロックの内部で **`use super::{SymbolA, SymbolB};` のように、必要なシンボルを明示的にインポートする**。
        3.  `include` 属性で依存関係を紐付ける。
- **禁止事項とその理由**:
    - **`use crate::...` の禁止**: `snippet_linter` により厳禁。展開後は `crate` が存在しないため、必ず相対パス（`super`）を使用する。
    - **`use super::*` の禁止**: `cargo-snippet` は `mod` ブロックの外側を切り捨てるため、ブロック外の依存関係はすべて失われる。`*` を使うと「何に依存しているか」がスニペット単体で不明確になり、かつ展開先のルートにある無関係なシンボルをすべて引き込んでしまうため、必ずシンボルを個別に指定する。

## 4. コーディング規約 (Coding Conventions)

### 4.1. `rand` クレートの利用
- **バージョン**: `0.9.2` を使用。
- **メソッド**: `rng.random_range` を使用（`gen_range` は不可）。
- **初期化**: `from_os_rng` を使用（`from_entropy` は不可）。

### 4.2. ランダムテスト
- ランダムテストを実装する際には必ず `#[ignore]` 属性を付与すること。
- 実装の詳細は [random-testing.md](references/random-testing.md) を参照。

### 4.3. コメント
- **既存のコードを編集、または既存のコードから新しいコードを作るとき、既存のコードのコメントを消してはいけません。**
- 日本語で記述する。
- 「何をしているか (What)」ではなく、コードが存在する「なぜ (Why)」やロジックの「要点」を説明する。
- コードから直接読み取れる自明なコメント（ノイズ）は書かない。
- 「ここを変更」のような将来的に不要になる一時的なコメントは避ける。

### 4.4. コーディングスタイル
- できるだけ手続き的ではなく宣言的なコードを書く。
- `mutable` な変数よりも `immutable` な変数を優先する。ただし、可読性や計算量の観点で手続き的・`mutable` な実装が勝る場合はその限りではない。

### 4.5. ドキュメントコメント (Doc comments)
- **形式**: `///` を使用し、Markdown 形式で記述する。
- **要約と詳細の分離**:
    - **1行目の要約**: 最初の1行はアイテムの機能を簡潔に示す要約文とする。
    - **空行の強制**: 要約文と、その後に続く詳細な説明や例示の間には**必ず空行**を挿入する。空行がない場合、レンダリング時にこれらが1行に結合されてしまうため。
    - **例外**: 箇条書き（`-` や `*`）などの Markdown のブロック要素が続く場合は、空行がなくても結合されないため、必ずしも空行は必要ない。

## 5. シンボル名変更時の整合性維持 (Naming Consistency)
リファクタリングにより型、関数、定数などのシンボル名を変更した際は、ドキュメントコメントやテスト関数名も一貫性を持って同期させる。

## 6. 代数演算子の設計指針 (Algebraic Operator Design)
- **無限大と 0 の乗算**: Z-加群としての作用を模す場合、原則として $ \infty \times 0 = 0 $ と定義する（「無限大を 0 回足した結果は単位元である」という解釈）。
- **ドメイン外の入力とパニック**: 演算の引数が前提を外れる場合は、妥協して結果を返すのではなく、速やかに `panic!` させる。

## 7. 既存の記載の尊重と意図しない削除の防止 (Respect for Existing Content and Prevention of Unintentional Deletion)
元の実装にある記載を尊重し、意図しない削除を徹底的に防ぐ。

- **既存資産の維持**:
    - 元の実装に含まれているテスト、コメント、関数などを、明確な理由なく削除してはならない。
- **削除時の提案プロセス**:
    - コードの整理に伴い既存の要素を削除すべきと判断した場合は、独断で削除せず、必ず理由を添えてユーザーに提案し、承諾を得ること。
- **git diff による検証**:
    - 実装前後の `git diff` を入念に確認し、元の実装にあった記載（テストケースやコメントなど）が意図せず失われていないかを必ず検証する。

## 8. 指針の継続的改善 (Continuous Improvement)
- 知見が得られるたびに本スキルを更新し、設計品質を底上げする。
