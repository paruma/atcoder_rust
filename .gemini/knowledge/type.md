# Rust の型推論と整数リテラルの挙動

Rust の型推論は強力であり、周囲のコンテキストに基づいてリテラルの型を決定します。

## 1. 整数リテラルの型推論 (Fallback)

整数リテラル（`1`, `42` など）は、それ単体では特定の型を持ちませんが、比較や代入の対象となる変数の型に合わせて自動的に決定されます。

### 比較時の型決定
比較演算子（`==`, `!=`, `<`, `>` など）の対象となる変数の型が確定している場合、リテラル側はその型として推論されます。

```rust
let main_ans: usize = xs.len(); // usize 型
let naive_ans = 1;              // 推論前

if main_ans != naive_ans {      // main_ans が usize なので、naive_ans も usize と推論される
    // ...
}
```

このため、`usize` と `1`（デフォルトでは `i32` と思われがち）の比較でコンパイルエラーが発生することはありません。

### 型の固定 (Fallback)
もし周囲に型を決定する情報が一切ない場合、整数リテラルは `i32` に、浮動小数点リテラルは `f64` にデフォルトで推論（fallback）されます。

## 2. 範囲リテラルの型推論

`rng.random_range(0..10)` のような範囲指定においても、戻り値を受け取る変数の型や、比較対象の型から逆算してリテラルの型が決定されます。

```rust
let n: usize = rng.random_range(1..=10); // 1, 10 は usize として扱われる
```

## 3. 注意点
リテラルではなく、**既に型が確定している変数同士** の比較（例：`usize` 型の変数と `i32` 型の変数）は、明示的なキャスト（`as`）がない限りコンパイルエラーになります。あくまで「リテラル」が柔軟に型を変えられるという点に注意が必要です。
