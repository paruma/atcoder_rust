{
  "bin_search": {
    "scope": "rust",
    "prefix": "bin_search",
    "body": [
      "pub fn bin_search<F>(mut ok: i64, mut ng: i64, mut p: F) -> i64",
      "where",
      "    F: FnMut(i64) -> bool,",
      "{",
      "    while num::abs(ok - ng) > 1 {",
      "        let mid = (ok + ng) / 2;",
      "        if p(mid) {",
      "            ok = mid;",
      "        } else {",
      "            ng = mid;",
      "        }",
      "    }",
      "    ok",
      "}"
    ]
  },
  "fn_guard": {
    "scope": "rust",
    "prefix": "fn_guard",
    "body": [
      "pub fn guard(p: bool) -> Option<()> {",
      "    if p {",
      "        Some(())",
      "    } else {",
      "        None",
      "    }",
      "}"
    ]
  },
  "iter_product": {
    "scope": "rust",
    "prefix": "iter_product",
    "body": [
      "use iter_product::*;",
      "mod iter_product {",
      "    pub trait Product2<A>: Sized {",
      "        fn product2<I: Iterator<Item = A>>(iter: I) -> Self;",
      "    }",
      "    impl<'a, T: num::One + std::ops::Mul<T, Output = T> + Copy> Product2<&'a T> for T {",
      "        fn product2<I: Iterator<Item = &'a T>>(iter: I) -> Self {",
      "            iter.fold(Self::one(), |acc, x| acc * (*x))",
      "        }",
      "    }",
      "    impl<T: num::One + std::ops::Mul<T, Output = T> + Copy> Product2<T> for T {",
      "        fn product2<I: Iterator<Item = T>>(iter: I) -> Self {",
      "            iter.fold(Self::one(), |acc, x| acc * x)",
      "        }",
      "    }",
      "    pub trait IteratorExtProduct2: Iterator + Sized {",
      "        fn product2<S>(self) -> S",
      "        where",
      "            Self: Sized,",
      "            S: Product2<Self::Item>,",
      "        {",
      "            Product2::product2(self)",
      "        }",
      "    }",
      "    impl<T: Iterator> IteratorExtProduct2 for T {}",
      "}"
    ]
  },
  "iter_sum": {
    "scope": "rust",
    "prefix": "iter_sum",
    "body": [
      "use iter_sum::*;",
      "pub mod iter_sum {",
      "    pub trait Sum2<A>: Sized {",
      "        fn sum2<I: Iterator<Item = A>>(iter: I) -> Self;",
      "    }",
      "    impl<'a, T: num::Zero + std::ops::Add<T, Output = T> + Copy> Sum2<&'a T> for T {",
      "        fn sum2<I: Iterator<Item = &'a T>>(iter: I) -> Self {",
      "            iter.fold(Self::zero(), |acc, x| acc + *x)",
      "        }",
      "    }",
      "    impl<T: num::Zero + std::ops::Add<T, Output = T> + Copy> Sum2<T> for T {",
      "        fn sum2<I: Iterator<Item = T>>(iter: I) -> Self {",
      "            iter.fold(Self::zero(), |acc, x| acc + x)",
      "        }",
      "    }",
      "    pub trait IteratorExtSum2: Iterator + Sized {",
      "        fn sum2<S>(self) -> S",
      "        where",
      "            Self: Sized,",
      "            S: Sum2<Self::Item>,",
      "        {",
      "            Sum2::sum2(self)",
      "        }",
      "    }",
      "    impl<T: Iterator> IteratorExtSum2 for T {}",
      "}"
    ]
  },
  "math_tools": {
    "scope": "rust",
    "prefix": "math_tools",
    "body": [
      "use math_tools::*;",
      "pub mod math_tools {",
      "    use num::Integer;",
      "    pub fn divisor(n: i64) -> Vec<i64> {",
      "        assert!(n >= 1);",
      "        let mut retval: Vec<i64> = Vec::new();",
      "        for i in 1..=num_integer::sqrt(n) {",
      "            if n.is_multiple_of(&i) {",
      "                retval.push(i);",
      "                if i * i != n {",
      "                    retval.push(n / i);",
      "                }",
      "            }",
      "        }",
      "        retval",
      "    }",
      "    fn frac0<T>(n: T, acc: T) -> T",
      "    where",
      "        T: std::ops::Sub<Output = T> + std::ops::Mul + num::Zero + num::One + Copy,",
      "    {",
      "        if n.is_zero() {",
      "            acc",
      "        } else {",
      "            frac0(n - T::one(), n * acc)",
      "        }",
      "    }",
      "    pub fn frac<T>(n: T) -> T",
      "    where",
      "        T: std::ops::Sub<Output = T> + std::ops::Mul + num::Zero + num::One + Copy,",
      "    {",
      "        frac0(n, T::one())",
      "    }",
      "    pub fn permutation<T>(n: T, k: T) -> T",
      "    where",
      "        T: std::ops::Sub<Output = T>",
      "            + std::ops::Mul",
      "            + std::ops::Div<Output = T>",
      "            + num::Zero",
      "            + num::One",
      "            + Copy,",
      "    {",
      "        frac(n) / frac(n - k)",
      "    }",
      "    pub fn comb<T>(n: T, k: T) -> T",
      "    where",
      "        T: std::ops::Sub<Output = T>",
      "            + std::ops::Mul",
      "            + std::ops::Div<Output = T>",
      "            + num::Zero",
      "            + num::One",
      "            + Copy,",
      "    {",
      "        frac(n) / frac(n - k) / frac(k)",
      "    }",
      "}"
    ]
  },
  "print_arr": {
    "scope": "rust",
    "prefix": "print_arr",
    "body": [
      "use print_arr::*;",
      "pub mod print_arr {",
      "    use ndarray::{Array2, Array3};",
      "    pub fn print_arr<T: std::fmt::Debug>(arr: &[T]) {",
      "        for a in arr {",
      "            print!(\"{:?} \", a);",
      "        }",
      "        println!();",
      "    }",
      "    pub fn print_arr2<T: std::fmt::Debug>(arr: &Array2<T>) {",
      "        for i in 0..arr.nrows() {",
      "            for j in 0..arr.ncols() {",
      "                print!(\"{:?} \", arr[[i, j]]);",
      "            }",
      "            println!();",
      "        }",
      "    }",
      "    pub fn print_arr3<T: std::fmt::Debug>(arr: &Array3<T>) {",
      "        let shape = arr.shape();",
      "        for i in 0..shape[0] {",
      "            for j in 0..shape[1] {",
      "                for k in 0..shape[2] {",
      "                    print!(\"{:?} \", arr[[i, j, k]]);",
      "                }",
      "                println!();",
      "            }",
      "            println!();",
      "        }",
      "    }",
      "}"
    ]
  },
  "rf": {
    "scope": "rust",
    "prefix": "rf",
    "body": [
      "use num::{One, Zero};",
      "use rf::*;",
      "pub mod rf {",
      "    pub const MOD: i64 = 1_000_000_007;",
      "    #[allow()]",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Default)]",
      "    pub struct RF {",
      "        rep: i64,",
      "    }",
      "    impl RF {",
      "        pub fn new(x: i64) -> RF {",
      "            RF {",
      "                rep: x.rem_euclid(MOD),",
      "            }",
      "        }",
      "        pub fn rep(self) -> i64 {",
      "            self.rep",
      "        }",
      "    }",
      "    impl RF {",
      "        pub fn inv(self) -> Self {",
      "            num::pow(self, (MOD - 2) as usize)",
      "        }",
      "    }",
      "    impl num_traits::Zero for RF {",
      "        fn zero() -> Self {",
      "            RF::new(0)",
      "        }",
      "        fn is_zero(&self) -> bool {",
      "            self.rep == 0",
      "        }",
      "    }",
      "    impl num_traits::One for RF {",
      "        fn one() -> Self {",
      "            RF::new(1)",
      "        }",
      "    }",
      "    macro_rules ! bi_ops_impl {(\\$ std_ops : ident , \\$ fn : ident , \\$ op : tt ) => {impl std :: ops ::\\$ std_ops for RF {type Output = Self ; fn \\$ fn (self , rhs : Self ) -> Self :: Output {RF :: new (self . rep \\$ op rhs . rep ) } } } ; }",
      "    bi_ops_impl ! (Add , add , + ) ;",
      "    bi_ops_impl ! (Sub , sub , - ) ;",
      "    bi_ops_impl ! (Mul , mul , * ) ;",
      "    impl std::ops::Div for RF {",
      "        type Output = Self;",
      "        fn div(self, rhs: Self) -> Self::Output {",
      "            std::ops::Mul::mul(self, rhs.inv())",
      "        }",
      "    }",
      "    macro_rules ! bi_ops_assign_impl {(\\$ std_ops_assign : ident , \\$ fn_assign : ident , \\$ op : tt ) => {impl std :: ops ::\\$ std_ops_assign for RF {fn \\$ fn_assign (& mut self , rhs : Self ) {* self = * self \\$ op rhs } } } ; }",
      "    bi_ops_assign_impl ! (AddAssign , add_assign , + ) ;",
      "    bi_ops_assign_impl ! (SubAssign , sub_assign , - ) ;",
      "    bi_ops_assign_impl ! (MulAssign , mul_assign , * ) ;",
      "    bi_ops_assign_impl ! (DivAssign , div_assign , / ) ;",
      "    impl std::ops::Neg for RF {",
      "        type Output = Self;",
      "        fn neg(self) -> Self::Output {",
      "            RF::new(-self.rep)",
      "        }",
      "    }",
      "}"
    ]
  },
  "rf_fake": {
    "scope": "rust",
    "prefix": "rf_fake",
    "body": [
      "use num::{One, Zero};",
      "use rf_fake::*;",
      "pub mod rf_fake {",
      "    #[derive(Clone, Copy, Debug, PartialEq, Default)]",
      "    pub struct RF {",
      "        rep: f64,",
      "    }",
      "    impl RF {",
      "        pub fn new(x: f64) -> RF {",
      "            RF { rep: x }",
      "        }",
      "        pub fn rep(self) -> f64 {",
      "            self.rep",
      "        }",
      "    }",
      "    impl RF {",
      "        pub fn inv(self) -> Self {",
      "            RF::new(1.0 / self.rep)",
      "        }",
      "    }",
      "    impl num_traits::Zero for RF {",
      "        fn zero() -> Self {",
      "            RF::new(0.0)",
      "        }",
      "        fn is_zero(&self) -> bool {",
      "            f64::is_zero(&self.rep)",
      "        }",
      "    }",
      "    impl num_traits::One for RF {",
      "        fn one() -> Self {",
      "            RF::new(1.0)",
      "        }",
      "    }",
      "    macro_rules ! bi_ops_impl {(\\$ std_ops : ident , \\$ fn : ident , \\$ op : tt ) => {impl std :: ops ::\\$ std_ops for RF {type Output = Self ; fn \\$ fn (self , rhs : Self ) -> Self :: Output {RF :: new (self . rep \\$ op rhs . rep ) } } } ; }",
      "    bi_ops_impl ! (Add , add , + ) ;",
      "    bi_ops_impl ! (Sub , sub , - ) ;",
      "    bi_ops_impl ! (Mul , mul , * ) ;",
      "    bi_ops_impl ! (Div , div , / ) ;",
      "    macro_rules ! bi_ops_assign_impl {(\\$ std_ops_assign : ident , \\$ fn_assign : ident , \\$ op : tt ) => {impl std :: ops ::\\$ std_ops_assign for RF {fn \\$ fn_assign (& mut self , rhs : Self ) {* self = * self \\$ op rhs } } } ; }",
      "    bi_ops_assign_impl ! (AddAssign , add_assign , + ) ;",
      "    bi_ops_assign_impl ! (SubAssign , sub_assign , - ) ;",
      "    bi_ops_assign_impl ! (MulAssign , mul_assign , * ) ;",
      "    bi_ops_assign_impl ! (DivAssign , div_assign , / ) ;",
      "    impl std::ops::Neg for RF {",
      "        type Output = Self;",
      "        fn neg(self) -> Self::Output {",
      "            RF::new(-self.rep)",
      "        }",
      "    }",
      "}"
    ]
  },
  "rr": {
    "scope": "rust",
    "prefix": "rr",
    "body": [
      "use num::{One, Zero};",
      "use rr::*;",
      "pub mod rr {",
      "    pub const MOD: i64 = 1_000_000_007;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Default)]",
      "    pub struct RR {",
      "        rep: i64,",
      "    }",
      "    impl RR {",
      "        pub fn new(x: i64) -> RR {",
      "            RR {",
      "                rep: x.rem_euclid(MOD),",
      "            }",
      "        }",
      "        pub fn rep(self) -> i64 {",
      "            self.rep",
      "        }",
      "    }",
      "    impl num_traits::Zero for RR {",
      "        fn zero() -> Self {",
      "            RR::new(0)",
      "        }",
      "        fn is_zero(&self) -> bool {",
      "            self.rep == 0",
      "        }",
      "    }",
      "    impl num_traits::One for RR {",
      "        fn one() -> Self {",
      "            RR::new(1)",
      "        }",
      "    }",
      "    macro_rules ! bi_ops_impl {(\\$ std_ops : ident , \\$ fn : ident , \\$ op : tt ) => {impl std :: ops ::\\$ std_ops for RR {type Output = Self ; fn \\$ fn (self , rhs : Self ) -> Self :: Output {RR :: new (self . rep \\$ op rhs . rep ) } } } ; }",
      "    bi_ops_impl ! (Add , add , + ) ;",
      "    bi_ops_impl ! (Sub , sub , - ) ;",
      "    bi_ops_impl ! (Mul , mul , * ) ;",
      "    macro_rules ! bi_ops_assign_impl {(\\$ std_ops_assign : ident , \\$ fn_assign : ident , \\$ op : tt ) => {impl std :: ops ::\\$ std_ops_assign for RR {fn \\$ fn_assign (& mut self , rhs : Self ) {* self = * self \\$ op rhs } } } ; }",
      "    bi_ops_assign_impl ! (AddAssign , add_assign , + ) ;",
      "    bi_ops_assign_impl ! (SubAssign , sub_assign , - ) ;",
      "    bi_ops_assign_impl ! (MulAssign , mul_assign , * ) ;",
      "    impl std::ops::Neg for RR {",
      "        type Output = Self;",
      "        fn neg(self) -> Self::Output {",
      "            RR::new(-self.rep)",
      "        }",
      "    }",
      "}"
    ]
  },
  "scan_iter": {
    "scope": "rust",
    "prefix": "scan_iter",
    "body": [
      "use scan_iter::*;",
      "pub mod scan_iter {",
      "    #[derive(Clone)]",
      "    pub struct Scanl<I, B, F> {",
      "        iter: I,",
      "        state: Option<B>,",
      "        f: F,",
      "    }",
      "    impl<I, B, F> Scanl<I, B, F> {",
      "        fn new(iter: I, init: B, f: F) -> Scanl<I, B, F> {",
      "            Scanl {",
      "                iter,",
      "                state: Some(init),",
      "                f,",
      "            }",
      "        }",
      "    }",
      "    impl<I, B, F> Iterator for Scanl<I, B, F>",
      "    where",
      "        B: Clone + Copy,",
      "        I: Iterator,",
      "        F: FnMut(&mut B, I::Item) -> B,",
      "    {",
      "        type Item = B;",
      "        #[inline]",
      "        fn next(&mut self) -> Option<B> {",
      "            let retval = self.state?;",
      "            let a_opt = self.iter.next();",
      "            self.state = self",
      "                .state",
      "                .and_then(|mut s| a_opt.map(|a| (self.f)(&mut s, a)));",
      "            Some(retval)",
      "        }",
      "    }",
      "    pub trait IteratorExtScanLeft: Iterator + Sized {",
      "        fn scanl<B, F>(self, init: B, f: F) -> Scanl<Self, B, F>",
      "        where",
      "            Self: Sized,",
      "            F: FnMut(&mut B, Self::Item) -> B,",
      "        {",
      "            Scanl::new(self, init, f)",
      "        }",
      "    }",
      "    impl<T: Iterator> IteratorExtScanLeft for T {}",
      "}"
    ]
  },
  "scan_vec": {
    "scope": "rust",
    "prefix": "scan_vec",
    "body": [
      "use scan_vec::*;",
      "pub mod scan_vec {",
      "    pub fn scanl<A, B, F>(vec: &[A], init: B, mut f: F) -> Vec<B>",
      "    where",
      "        F: FnMut(&mut B, &A) -> B,",
      "        B: Copy,",
      "    {",
      "        let mut ret: Vec<B> = Vec::new();",
      "        let mut acc = init;",
      "        ret.push(acc);",
      "        for x in vec {",
      "            acc = f(&mut acc, &x);",
      "            ret.push(acc);",
      "        }",
      "        ret",
      "    }",
      "    pub fn scanr<A, B, F>(vec: &[A], init: B, f: F) -> Vec<B>",
      "    where",
      "        F: FnMut(&mut B, &A) -> B,",
      "        A: Clone,",
      "        B: Copy,",
      "    {",
      "        let vec2 = vec.to_vec().into_iter().rev().collect::<Vec<A>>();",
      "        let vec3 = scanl(&vec2, init, f);",
      "        vec3.to_vec().into_iter().rev().collect::<Vec<B>>()",
      "    }",
      "    pub fn cumsum<T>(vec: &[T]) -> Vec<T>",
      "    where",
      "        T: std::ops::Add + num::Zero + Copy,",
      "    {",
      "        scanl(vec, T::zero(), |acc, x| *acc + *x)",
      "    }",
      "    pub struct CumSum<T>",
      "    where",
      "        T: std::ops::Add<Output = T> + std::ops::Sub<Output = T> + num::Zero + Copy,",
      "    {",
      "        cumsum: Vec<T>,",
      "    }",
      "    impl<T: std::ops::Add<Output = T> + std::ops::Sub<Output = T> + num::Zero + Copy> CumSum<T> {",
      "        pub fn make(vec: &[T]) -> CumSum<T> {",
      "            CumSum {",
      "                cumsum: cumsum(vec),",
      "            }",
      "        }",
      "        pub fn partial_sum(&self, begin: usize, end: usize) -> T {",
      "            self.cumsum[end] - self.cumsum[begin]",
      "        }",
      "    }",
      "}"
    ]
  },
  "tropical": {
    "scope": "rust",
    "prefix": "tropical",
    "body": [
      "use tropical::Trop::{self, *};",
      "pub mod tropical {",
      "    use std::{cmp::Ordering, ops::Add};",
      "    use Trop::*;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub enum Trop {",
      "        Inf,",
      "        Fin(i64),",
      "    }",
      "    impl Trop {",
      "        pub fn get_fin(self) -> i64 {",
      "            match self {",
      "                Fin(val) => val,",
      "                Inf => panic!(\"called `Trop::get_fin()` on a `Fin` value\"),",
      "            }",
      "        }",
      "        pub fn get_fin_or(self, default: i64) -> i64 {",
      "            match self {",
      "                Fin(val) => val,",
      "                Inf => default,",
      "            }",
      "        }",
      "        pub fn is_fin(self) -> bool {",
      "            matches!(self, Fin(_))",
      "        }",
      "        pub fn is_inf(self) -> bool {",
      "            matches!(self, Inf)",
      "        }",
      "        pub fn to_option(self) -> Option<i64> {",
      "            match self {",
      "                Inf => None,",
      "                Fin(a) => Some(a),",
      "            }",
      "        }",
      "    }",
      "    impl Add for Trop {",
      "        type Output = Trop;",
      "        fn add(self, rhs: Self) -> Self::Output {",
      "            match (self, rhs) {",
      "                (Inf, Inf) => Inf,",
      "                (Inf, Fin(_)) => Inf,",
      "                (Fin(_), Inf) => Inf,",
      "                (Fin(a), Fin(b)) => Fin(a + b),",
      "            }",
      "        }",
      "    }",
      "    impl PartialOrd for Trop {",
      "        fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {",
      "            match (self, other) {",
      "                (Inf, Inf) => Some(Ordering::Equal),",
      "                (Inf, Fin(_)) => Some(Ordering::Greater),",
      "                (Fin(_), Inf) => Some(Ordering::Less),",
      "                (Fin(a), Fin(b)) => PartialOrd::partial_cmp(a, b),",
      "            }",
      "        }",
      "    }",
      "    impl Ord for Trop {",
      "        fn cmp(&self, other: &Self) -> Ordering {",
      "            self.partial_cmp(other).unwrap()",
      "        }",
      "    }",
      "}"
    ]
  },
  "union_find": {
    "scope": "rust",
    "prefix": "union_find",
    "body": [
      "use union_find::*;",
      "pub mod union_find {",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    struct Root {",
      "        count: i32,",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    enum Node {",
      "        Root { root: Root },",
      "        NonRoot { parent_index: usize },",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    struct RootAndIndex {",
      "        root: Root,",
      "        index: usize,",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    pub struct UnionFind {",
      "        nodes: Vec<Node>,",
      "    }",
      "    impl UnionFind {",
      "        pub fn new(n: usize) -> UnionFind {",
      "            UnionFind {",
      "                nodes: vec![",
      "                    Node::Root {",
      "                        root: Root { count: 1 }",
      "                    };",
      "                    n",
      "                ],",
      "            }",
      "        }",
      "        fn root_node(&mut self, index: usize) -> RootAndIndex {",
      "            match self.nodes[index] {",
      "                Node::Root { root } => RootAndIndex { root, index },",
      "                Node::NonRoot { parent_index } => {",
      "                    let root_and_index = self.root_node(parent_index);",
      "                    self.nodes[index] = Node::NonRoot {",
      "                        parent_index: root_and_index.index,",
      "                    };",
      "                    root_and_index",
      "                }",
      "            }",
      "        }",
      "        pub fn root(&mut self, index: usize) -> usize {",
      "            self.root_node(index).index",
      "        }",
      "        pub fn same_count(&mut self, index: usize) -> i32 {",
      "            self.root_node(index).root.count",
      "        }",
      "        pub fn same(&mut self, x: usize, y: usize) -> bool {",
      "            self.root(x) == self.root(y)",
      "        }",
      "        pub fn num_groups(&self) -> usize {",
      "            self.nodes",
      "                .iter()",
      "                .filter(|&node| matches ! (node , Node :: Root {.. } ))",
      "                .count()",
      "        }",
      "        pub fn unite(&mut self, x: usize, y: usize) {",
      "            if self.same(x, y) {",
      "                return;",
      "            }",
      "            let x_root_node = self.root_node(x);",
      "            let y_root_node = self.root_node(y);",
      "            let x_count = x_root_node.root.count;",
      "            let y_count = y_root_node.root.count;",
      "            let x_root_index = x_root_node.index;",
      "            let y_root_index = y_root_node.index;",
      "            if x_count < y_count {",
      "                self.nodes[x_root_index] = Node::NonRoot {",
      "                    parent_index: y_root_index,",
      "                };",
      "                self.nodes[y_root_index] = Node::Root {",
      "                    root: Root {",
      "                        count: x_count + y_count,",
      "                    },",
      "                }",
      "            } else {",
      "                self.nodes[y_root_index] = Node::NonRoot {",
      "                    parent_index: x_root_index,",
      "                };",
      "                self.nodes[x_root_index] = Node::Root {",
      "                    root: Root {",
      "                        count: x_count + y_count,",
      "                    },",
      "                }",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  }
}
