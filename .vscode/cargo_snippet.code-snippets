{
  "Grid": {
    "scope": "rust",
    "prefix": "Grid",
    "body": [
      "use std::ops::{Index, IndexMut};",
      "pub struct Grid {",
      "    pub grid: Vec<Vec<char>>,",
      "    pub h: usize,",
      "    pub w: usize,",
      "}",
      "impl Index<Pos> for Grid {",
      "    type Output = char;",
      "    fn index(&self, index: Pos) -> &Self::Output {",
      "        if self.is_within(index) {",
      "            self.grid.index(index)",
      "        } else {",
      "            &'#'",
      "        }",
      "    }",
      "}",
      "impl IndexMut<Pos> for Grid {",
      "    fn index_mut(&mut self, index: Pos) -> &mut Self::Output {",
      "        self.grid.index_mut(index)",
      "    }",
      "}",
      "impl Grid {",
      "    pub fn new(grid: Vec<Vec<char>>) -> Grid {",
      "        let h = grid.len();",
      "        let w = grid[0].len();",
      "        Grid { grid, h, w }",
      "    }",
      "    pub fn is_within(&self, pos: Pos) -> bool {",
      "        let h = self.h as i64;",
      "        let w = self.w as i64;",
      "        0 <= pos.y && pos.y < h && 0 <= pos.x && pos.x < w",
      "    }",
      "    pub fn can_move(&self, pos: Pos) -> bool {",
      "        ['.'].contains(&self[pos])",
      "    }",
      "    pub fn all_pos_iter(&self) -> impl Iterator<Item = Pos> {",
      "        iproduct!(0..self.h, 0..self.w).map(|(y, x)| Pos::new(x as i64, y as i64))",
      "    }",
      "    pub fn find_pos_of(&self, ch: char) -> Option<Pos> {",
      "        self.all_pos_iter().find(|pos| self[*pos] == ch)",
      "    }",
      "    pub fn encode(&self, pos: Pos) -> usize {",
      "        (pos.y * self.w as i64 + pos.x) as usize",
      "    }",
      "    pub fn decode(&self, i: usize) -> Pos {",
      "        let y = (i / self.w) as i64;",
      "        let x = (i % self.w) as i64;",
      "        Pos::new(x, y)",
      "    }",
      "    pub fn debug(&self) {",
      "        for row in &self.grid {",
      "            eprintln!(\"{}\", row.iter().collect::<String>());",
      "        }",
      "        eprintln!();",
      "    }",
      "    /// pos の部分は背景を灰色にして出力する",
      "    pub fn debug_with_pos(&self, pos: Pos) {",
      "        const GRAY: &str = \"\\x1b[48;2;127;127;127;37m\";",
      "        const RESET: &str = \"\\x1b[0m\";",
      "        for y in 0..self.h {",
      "            let row = (0..self.w)",
      "                .map(|x| {",
      "                    if pos == Pos::new(x as i64, y as i64) {",
      "                        format!(\"{}{}{}\", GRAY, self.grid[y][x], RESET)",
      "                    } else {",
      "                        self.grid[y][x].to_string()",
      "                    }",
      "                })",
      "                .join(\"\");",
      "            eprintln!(\"{}\", row);",
      "        }",
      "        eprintln!();",
      "    }",
      "}"
    ]
  },
  "GridUnionFind": {
    "scope": "rust",
    "prefix": "GridUnionFind",
    "body": [
      "pub struct GridUnionFind {",
      "    pub uf: UnionFind,",
      "    pub h: usize,",
      "    pub w: usize,",
      "}",
      "impl GridUnionFind {",
      "    pub fn new(h: usize, w: usize) -> GridUnionFind {",
      "        GridUnionFind {",
      "            uf: UnionFind::new(h * w),",
      "            h,",
      "            w,",
      "        }",
      "    }",
      "    pub fn encode(&self, pos: Pos) -> usize {",
      "        (pos.y * self.w as i64 + pos.x) as usize",
      "    }",
      "    pub fn decode(&self, i: usize) -> Pos {",
      "        let y = (i / self.w) as i64;",
      "        let x = (i % self.w) as i64;",
      "        Pos::new(x, y)",
      "    }",
      "    pub fn same_count(&mut self, pos: Pos) -> usize {",
      "        self.uf.same_count(self.encode(pos))",
      "    }",
      "    pub fn same(&mut self, pos1: Pos, pos2: Pos) -> bool {",
      "        self.uf.same(self.encode(pos1), self.encode(pos2))",
      "    }",
      "    pub fn num_groups(&self) -> usize {",
      "        self.uf.num_groups()",
      "    }",
      "    pub fn unite(&mut self, pos1: Pos, pos2: Pos) {",
      "        self.uf.unite(self.encode(pos1), self.encode(pos2));",
      "    }",
      "    pub fn groups(&mut self) -> Vec<Vec<Pos>> {",
      "        self.uf",
      "            .groups()",
      "            .into_iter()",
      "            .map(|group| group.iter().copied().map(|i| self.decode(i)).collect_vec())",
      "            .collect_vec()",
      "    }",
      "}"
    ]
  },
  "abstract_segtree_beats": {
    "scope": "rust",
    "prefix": "abstract_segtree_beats",
    "body": [
      "use abstract_segtree_beats::*;",
      "pub mod abstract_segtree_beats {",
      "    fn ceil_pow2(n: u32) -> u32 {",
      "        32 - n.saturating_sub(1).leading_zeros()",
      "    }",
      "    pub trait MonoidBeats {",
      "        type S: Clone;",
      "        fn identity() -> Self::S;",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S;",
      "        fn fails(a: &Self::S) -> bool;",
      "    }",
      "    pub trait MapMonoidBeats {",
      "        type M: MonoidBeats;",
      "        type F: Clone;",
      "        fn identity_element() -> <Self::M as MonoidBeats>::S {",
      "            Self::M::identity()",
      "        }",
      "        fn binary_operation(",
      "            a: &<Self::M as MonoidBeats>::S,",
      "            b: &<Self::M as MonoidBeats>::S,",
      "        ) -> <Self::M as MonoidBeats>::S {",
      "            Self::M::binary_operation(a, b)",
      "        }",
      "        fn fails(a: &<Self::M as MonoidBeats>::S) -> bool {",
      "            Self::M::fails(a)",
      "        }",
      "        fn identity_map() -> Self::F;",
      "        fn mapping(f: &Self::F, x: &<Self::M as MonoidBeats>::S) -> <Self::M as MonoidBeats>::S;",
      "        fn composition(f: &Self::F, g: &Self::F) -> Self::F;",
      "    }",
      "    impl<F: MapMonoidBeats> Default for SegtreeBeats<F> {",
      "        fn default() -> Self {",
      "            Self::new(0)",
      "        }",
      "    }",
      "    impl<F: MapMonoidBeats> SegtreeBeats<F> {",
      "        pub fn new(n: usize) -> Self {",
      "            vec![F::identity_element(); n].into()",
      "        }",
      "    }",
      "    impl<F: MapMonoidBeats> From<Vec<<F::M as MonoidBeats>::S>> for SegtreeBeats<F> {",
      "        fn from(v: Vec<<F::M as MonoidBeats>::S>) -> Self {",
      "            let n = v.len();",
      "            let log = ceil_pow2(n as u32) as usize;",
      "            let size = 1 << log;",
      "            let mut d = vec![F::identity_element(); 2 * size];",
      "            let lz = vec![F::identity_map(); size];",
      "            d[size..(size + n)].clone_from_slice(&v);",
      "            let mut ret = SegtreeBeats {",
      "                n,",
      "                size,",
      "                log,",
      "                d,",
      "                lz,",
      "            };",
      "            for i in (1..size).rev() {",
      "                ret.update(i);",
      "            }",
      "            ret",
      "        }",
      "    }",
      "    impl<F: MapMonoidBeats> SegtreeBeats<F> {",
      "        pub fn set(&mut self, mut p: usize, x: <F::M as MonoidBeats>::S) {",
      "            assert!(p < self.n);",
      "            p += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(p >> i);",
      "            }",
      "            self.d[p] = x;",
      "            for i in 1..=self.log {",
      "                self.update(p >> i);",
      "            }",
      "        }",
      "        pub fn get(&mut self, mut p: usize) -> <F::M as MonoidBeats>::S {",
      "            assert!(p < self.n);",
      "            p += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(p >> i);",
      "            }",
      "            self.d[p].clone()",
      "        }",
      "        pub fn prod<R>(&mut self, range: R) -> <F::M as MonoidBeats>::S",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            if range.start_bound() == Bound::Unbounded && range.end_bound() == Bound::Unbounded {",
      "                return self.all_prod();",
      "            }",
      "            let mut r = match range.end_bound() {",
      "                Bound::Included(r) => r + 1,",
      "                Bound::Excluded(r) => *r,",
      "                Bound::Unbounded => self.n,",
      "            };",
      "            let mut l = match range.start_bound() {",
      "                Bound::Included(l) => *l,",
      "                Bound::Excluded(l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            assert!(l <= r && r <= self.n);",
      "            if l == r {",
      "                return F::identity_element();",
      "            }",
      "            l += self.size;",
      "            r += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                if ((l >> i) << i) != l {",
      "                    self.push(l >> i);",
      "                }",
      "                if ((r >> i) << i) != r {",
      "                    self.push(r >> i);",
      "                }",
      "            }",
      "            let mut sml = F::identity_element();",
      "            let mut smr = F::identity_element();",
      "            while l < r {",
      "                if l & 1 != 0 {",
      "                    sml = F::binary_operation(&sml, &self.d[l]);",
      "                    l += 1;",
      "                }",
      "                if r & 1 != 0 {",
      "                    r -= 1;",
      "                    smr = F::binary_operation(&self.d[r], &smr);",
      "                }",
      "                l >>= 1;",
      "                r >>= 1;",
      "            }",
      "            F::binary_operation(&sml, &smr)",
      "        }",
      "        pub fn all_prod(&self) -> <F::M as MonoidBeats>::S {",
      "            self.d[1].clone()",
      "        }",
      "        pub fn apply(&mut self, mut p: usize, f: F::F) {",
      "            assert!(p < self.n);",
      "            p += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(p >> i);",
      "            }",
      "            self.d[p] = F::mapping(&f, &self.d[p]);",
      "            for i in 1..=self.log {",
      "                self.update(p >> i);",
      "            }",
      "        }",
      "        pub fn apply_range<R>(&mut self, range: R, f: F::F)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            let mut r = match range.end_bound() {",
      "                Bound::Included(r) => r + 1,",
      "                Bound::Excluded(r) => *r,",
      "                Bound::Unbounded => self.n,",
      "            };",
      "            let mut l = match range.start_bound() {",
      "                Bound::Included(l) => *l,",
      "                Bound::Excluded(l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            assert!(l <= r && r <= self.n);",
      "            if l == r {",
      "                return;",
      "            }",
      "            l += self.size;",
      "            r += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                if ((l >> i) << i) != l {",
      "                    self.push(l >> i);",
      "                }",
      "                if ((r >> i) << i) != r {",
      "                    self.push((r - 1) >> i);",
      "                }",
      "            }",
      "            {",
      "                let l2 = l;",
      "                let r2 = r;",
      "                while l < r {",
      "                    if l & 1 != 0 {",
      "                        self.all_apply(l, f.clone());",
      "                        l += 1;",
      "                    }",
      "                    if r & 1 != 0 {",
      "                        r -= 1;",
      "                        self.all_apply(r, f.clone());",
      "                    }",
      "                    l >>= 1;",
      "                    r >>= 1;",
      "                }",
      "                l = l2;",
      "                r = r2;",
      "            }",
      "            for i in 1..=self.log {",
      "                if ((l >> i) << i) != l {",
      "                    self.update(l >> i);",
      "                }",
      "                if ((r >> i) << i) != r {",
      "                    self.update((r - 1) >> i);",
      "                }",
      "            }",
      "        }",
      "        pub fn max_right<G>(&mut self, mut l: usize, g: G) -> usize",
      "        where",
      "            G: Fn(<F::M as MonoidBeats>::S) -> bool,",
      "        {",
      "            assert!(l <= self.n);",
      "            assert!(g(F::identity_element()));",
      "            if l == self.n {",
      "                return self.n;",
      "            }",
      "            l += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(l >> i);",
      "            }",
      "            let mut sm = F::identity_element();",
      "            while {",
      "                while l % 2 == 0 {",
      "                    l >>= 1;",
      "                }",
      "                if !g(F::binary_operation(&sm, &self.d[l])) {",
      "                    while l < self.size {",
      "                        self.push(l);",
      "                        l *= 2;",
      "                        let res = F::binary_operation(&sm, &self.d[l]);",
      "                        if g(res.clone()) {",
      "                            sm = res;",
      "                            l += 1;",
      "                        }",
      "                    }",
      "                    return l - self.size;",
      "                }",
      "                sm = F::binary_operation(&sm, &self.d[l]);",
      "                l += 1;",
      "                {",
      "                    let l = l as isize;",
      "                    (l & -l) != l",
      "                }",
      "            } {}",
      "            self.n",
      "        }",
      "        pub fn min_left<G>(&mut self, mut r: usize, g: G) -> usize",
      "        where",
      "            G: Fn(<F::M as MonoidBeats>::S) -> bool,",
      "        {",
      "            assert!(r <= self.n);",
      "            assert!(g(F::identity_element()));",
      "            if r == 0 {",
      "                return 0;",
      "            }",
      "            r += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push((r - 1) >> i);",
      "            }",
      "            let mut sm = F::identity_element();",
      "            while {",
      "                r -= 1;",
      "                while r > 1 && r % 2 != 0 {",
      "                    r >>= 1;",
      "                }",
      "                if !g(F::binary_operation(&self.d[r], &sm)) {",
      "                    while r < self.size {",
      "                        self.push(r);",
      "                        r = 2 * r + 1;",
      "                        let res = F::binary_operation(&self.d[r], &sm);",
      "                        if g(res.clone()) {",
      "                            sm = res;",
      "                            r -= 1;",
      "                        }",
      "                    }",
      "                    return r + 1 - self.size;",
      "                }",
      "                sm = F::binary_operation(&self.d[r], &sm);",
      "                {",
      "                    let r = r as isize;",
      "                    (r & -r) != r",
      "                }",
      "            } {}",
      "            0",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<<F::M as MonoidBeats>::S> {",
      "            (0..self.n).map(|i| self.get(i)).collect()",
      "        }",
      "    }",
      "    pub struct SegtreeBeats<F>",
      "    where",
      "        F: MapMonoidBeats,",
      "    {",
      "        n: usize,",
      "        size: usize,",
      "        log: usize,",
      "        d: Vec<<F::M as MonoidBeats>::S>,",
      "        lz: Vec<F::F>,",
      "    }",
      "    impl<F> SegtreeBeats<F>",
      "    where",
      "        F: MapMonoidBeats,",
      "    {",
      "        fn update(&mut self, k: usize) {",
      "            self.d[k] = F::binary_operation(&self.d[2 * k], &self.d[2 * k + 1]);",
      "        }",
      "        fn all_apply(&mut self, k: usize, f: F::F) {",
      "            self.d[k] = F::mapping(&f, &self.d[k]);",
      "            if k < self.size {",
      "                self.lz[k] = F::composition(&f, &self.lz[k]);",
      "                if F::fails(&self.d[k]) {",
      "                    self.push(k);",
      "                    self.update(k)",
      "                }",
      "            }",
      "        }",
      "        fn push(&mut self, k: usize) {",
      "            self.all_apply(2 * k, self.lz[k].clone());",
      "            self.all_apply(2 * k + 1, self.lz[k].clone());",
      "            self.lz[k] = F::identity_map();",
      "        }",
      "    }",
      "    use std::{",
      "        fmt::{Debug, Error, Formatter, Write},",
      "        ops::{Bound, RangeBounds},",
      "    };",
      "    impl<F> Debug for SegtreeBeats<F>",
      "    where",
      "        F: MapMonoidBeats,",
      "        F::F: Debug,",
      "        <F::M as MonoidBeats>::S: Debug,",
      "    {",
      "        fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {",
      "            for i in 0..self.log {",
      "                for j in 0..1 << i {",
      "                    f.write_fmt(format_args!(",
      "                        \"{:?}[{:?}]\\t\",",
      "                        self.d[(1 << i) + j],",
      "                        self.lz[(1 << i) + j]",
      "                    ))?;",
      "                }",
      "                f.write_char('\\n')?;",
      "            }",
      "            for i in 0..self.size {",
      "                f.write_fmt(format_args!(\"{:?}\\t\", self.d[self.size + i]))?;",
      "            }",
      "            Ok(())",
      "        }",
      "    }",
      "}"
    ]
  },
  "argcmp": {
    "scope": "rust",
    "prefix": "argcmp",
    "body": [
      "/// x軸正の向きを0度として、反時計回りを正とする偏角で順序を決める",
      "/// (0, 0) は未考慮",
      "pub fn argcmp((x0, y0): (i64, i64), (x1, y1): (i64, i64)) -> Ordering {",
      "    ((y0, x0) < (0, 0))",
      "        .cmp(&((y1, x1) < (0, 0)))",
      "        .then_with(|| (x1 * y0).cmp(&(x0 * y1)))",
      "}"
    ]
  },
  "array_2d_transformation": {
    "scope": "rust",
    "prefix": "array_2d_transformation",
    "body": [
      "use array_2d_transformation::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod array_2d_transformation {",
      "    pub fn rotate_right<T>(table: &[Vec<T>]) -> Vec<Vec<T>>",
      "    where",
      "        T: Default + Clone + Copy,",
      "    {",
      "        let h = table.len();",
      "        let w = table[0].len();",
      "        let mut table_after = vec![vec![T::default(); h]; w];",
      "        for (y, row) in table.iter().enumerate() {",
      "            for (x, v) in row.iter().enumerate() {",
      "                table_after[x][h - 1 - y] = *v;",
      "            }",
      "        }",
      "        table_after",
      "    }",
      "    pub fn rotate_left<T>(table: &[Vec<T>]) -> Vec<Vec<T>>",
      "    where",
      "        T: Default + Clone + Copy,",
      "    {",
      "        let h = table.len();",
      "        let w = table[0].len();",
      "        let mut table_after = vec![vec![T::default(); h]; w];",
      "        for (y, row) in table.iter().enumerate() {",
      "            for (x, v) in row.iter().enumerate() {",
      "                table_after[w - 1 - x][y] = *v;",
      "            }",
      "        }",
      "        table_after",
      "    }",
      "    pub fn rotate_180_deg<T>(table: &[Vec<T>]) -> Vec<Vec<T>>",
      "    where",
      "        T: Default + Clone + Copy,",
      "    {",
      "        let h = table.len();",
      "        let w = table[0].len();",
      "        let mut table_after = vec![vec![T::default(); w]; h];",
      "        for (y, row) in table.iter().enumerate() {",
      "            for (x, v) in row.iter().enumerate() {",
      "                table_after[h - 1 - y][w - 1 - x] = *v;",
      "            }",
      "        }",
      "        table_after",
      "    }",
      "    pub fn transpose<T>(table: &[Vec<T>]) -> Vec<Vec<T>>",
      "    where",
      "        T: Default + Clone + Copy,",
      "    {",
      "        let h = table.len();",
      "        let w = table[0].len();",
      "        let mut table_after = vec![vec![T::default(); h]; w];",
      "        for (y, row) in table.iter().enumerate() {",
      "            for (x, v) in row.iter().enumerate() {",
      "                table_after[x][y] = *v;",
      "            }",
      "        }",
      "        table_after",
      "    }",
      "    pub fn reflect_x_axis<T>(table: &[Vec<T>]) -> Vec<Vec<T>>",
      "    where",
      "        T: Default + Clone + Copy,",
      "    {",
      "        let h = table.len();",
      "        let w = table[0].len();",
      "        let mut table_after = vec![vec![T::default(); w]; h];",
      "        for (y, row) in table.iter().enumerate() {",
      "            for (x, v) in row.iter().enumerate() {",
      "                table_after[h - 1 - y][x] = *v;",
      "            }",
      "        }",
      "        table_after",
      "    }",
      "    pub fn reflect_y_axis<T>(table: &[Vec<T>]) -> Vec<Vec<T>>",
      "    where",
      "        T: Default + Clone + Copy,",
      "    {",
      "        let h = table.len();",
      "        let w = table[0].len();",
      "        let mut table_after = vec![vec![T::default(); w]; h];",
      "        for (y, row) in table.iter().enumerate() {",
      "            for (x, v) in row.iter().enumerate() {",
      "                table_after[y][w - 1 - x] = *v;",
      "            }",
      "        }",
      "        table_after",
      "    }",
      "}"
    ]
  },
  "bfs_order": {
    "scope": "rust",
    "prefix": "bfs_order",
    "body": [
      "use mod_queue::*;",
      "pub mod mod_queue {",
      "    use std::collections::VecDeque;",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Queue<T> {",
      "        raw: VecDeque<T>,",
      "    }",
      "    impl<T> Queue<T> {",
      "        pub fn new() -> Self {",
      "            Queue {",
      "                raw: VecDeque::new(),",
      "            }",
      "        }",
      "        pub fn push(&mut self, value: T) {",
      "            self.raw.push_back(value)",
      "        }",
      "        pub fn pop(&mut self) -> Option<T> {",
      "            self.raw.pop_front()",
      "        }",
      "        pub fn peek(&self) -> Option<&T> {",
      "            self.raw.front()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.raw.len()",
      "        }",
      "    }",
      "    impl<T> Default for Queue<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "}",
      "pub fn bfs_order(adj: &[Vec<usize>], init: usize) -> Vec<usize> {",
      "    let nv = adj.len();",
      "    let mut order = vec![];",
      "    let mut visited = vec![false; nv];",
      "    let mut open = Queue::new();",
      "    open.push(init);",
      "    order.push(init);",
      "    visited[init] = true;",
      "    while let Some(current) = open.pop() {",
      "        for &next in &adj[current] {",
      "            if !visited[next] {",
      "                order.push(next);",
      "                visited[next] = true;",
      "                open.push(next);",
      "            }",
      "        }",
      "    }",
      "    order",
      "}"
    ]
  },
  "bin_search": {
    "scope": "rust",
    "prefix": "bin_search",
    "body": [
      "/// 二分探索をする",
      "/// ```text",
      "/// ng ng ng ok ok ok",
      "///          ↑ここの引数の値を返す",
      "/// ```",
      "/// 計算量: O(log(|ok - ng|))",
      "/// ## Arguments",
      "/// * ok != ng",
      "/// * |ok - ng| <= 2^63 - 1, |ok + ng| <= 2^63 - 1",
      "/// * p の定義域について",
      "///     * ng < ok の場合、p は区間 ng..ok で定義されている。",
      "///     * ok < ng の場合、p は区間 ok..ng で定義されている。",
      "/// * p の単調性について",
      "///     * ng < ok の場合、p は単調増加",
      "///     * ok < ng の場合、p は単調減少",
      "/// ## Return",
      "/// * ng < ok の場合: I = { i in ng..ok | p(i) == true } としたとき",
      "///     * I が空でなければ、min I を返す。",
      "///     * I が空ならば、ok を返す。",
      "/// * ok < ng の場合: I = { i in ok..ng | p(i) == true } としたとき",
      "///     * I が空でなければ、max I を返す。",
      "///     * I が空ならば、ok を返す。",
      "pub fn bin_search<F>(mut ok: i64, mut ng: i64, mut p: F) -> i64",
      "where",
      "    F: FnMut(i64) -> bool,",
      "{",
      "    debug_assert!(ok != ng);",
      "    debug_assert!(ok.checked_sub(ng).is_some());",
      "    debug_assert!(ok.checked_add(ng).is_some());",
      "    while num::abs(ok - ng) > 1 {",
      "        let mid = (ok + ng) / 2;",
      "        debug_assert!(mid != ok);",
      "        debug_assert!(mid != ng);",
      "        if p(mid) {",
      "            ok = mid;",
      "        } else {",
      "            ng = mid;",
      "        }",
      "    }",
      "    ok",
      "}"
    ]
  },
  "bitset": {
    "scope": "rust",
    "prefix": "bitset",
    "body": [
      "use bitset::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod bitset {",
      "    use itertools::Itertools;",
      "    use std::{",
      "        fmt::{Error, Formatter},",
      "        ops::{BitAnd, BitOr, BitXor, Index, IndexMut},",
      "    };",
      "    #[derive(Clone, Copy, PartialEq, Eq)]",
      "    pub struct BitSet {",
      "        bit: usize,",
      "    }",
      "    impl BitSet {",
      "        #[inline]",
      "        pub fn new(bit: usize) -> BitSet {",
      "            BitSet { bit }",
      "        }",
      "        pub fn to_bit(self) -> usize {",
      "            self.bit",
      "        }",
      "        /// 持っている要素を Vec<usize> で返す",
      "        pub fn to_vec(self, len: usize) -> Vec<usize> {",
      "            (0..len).filter(|i| (self.bit >> i) & 1 == 1).collect_vec()",
      "        }",
      "        /// 持っている要素を Iterator で返す",
      "        pub fn to_iter(self, len: usize) -> impl Iterator<Item = usize> {",
      "            (0..len).filter(move |i| (self.bit >> i) & 1 == 1)",
      "        }",
      "        pub fn contains(self, x: usize) -> bool {",
      "            (self.bit >> x) & 1 == 1",
      "        }",
      "        pub fn len(self) -> usize {",
      "            self.bit.count_ones() as usize",
      "        }",
      "        pub fn inserted(self, x: usize) -> BitSet {",
      "            BitSet::new(self.bit | (1 << x))",
      "        }",
      "        pub fn removed(self, x: usize) -> BitSet {",
      "            BitSet::new(self.bit & !(1 << x))",
      "        }",
      "        pub fn empty() -> BitSet {",
      "            BitSet::new(0)",
      "        }",
      "        pub fn universal_set(size: usize) -> BitSet {",
      "            BitSet::new((1 << size) - 1)",
      "        }",
      "        pub fn complement(self, size: usize) -> BitSet {",
      "            BitSet::new(self.bit ^ ((1 << size) - 1))",
      "        }",
      "        pub fn set_minus(self, other: BitSet) -> BitSet {",
      "            BitSet::new(self.bit & !other.bit)",
      "        }",
      "        pub fn is_empty(self) -> bool {",
      "            self.bit == 0",
      "        }",
      "        pub fn is_subset(self, other: BitSet) -> bool {",
      "            self | other == other",
      "        }",
      "        pub fn all_subset(size: usize) -> impl Iterator<Item = BitSet> {",
      "            (0..(1 << size)).map(BitSet::new)",
      "        }",
      "        pub fn subsets(self) -> impl Iterator<Item = BitSet> {",
      "            std::iter::successors(Some(self.bit), move |x| {",
      "                if *x == 0 {",
      "                    None",
      "                } else {",
      "                    Some((x - 1) & self.bit)",
      "                }",
      "            })",
      "            .map(BitSet::new)",
      "        }",
      "    }",
      "    impl BitAnd for BitSet {",
      "        type Output = BitSet;",
      "        fn bitand(self, rhs: BitSet) -> BitSet {",
      "            BitSet::new(self.bit & rhs.bit)",
      "        }",
      "    }",
      "    impl BitOr for BitSet {",
      "        type Output = BitSet;",
      "        fn bitor(self, rhs: BitSet) -> BitSet {",
      "            BitSet::new(self.bit | rhs.bit)",
      "        }",
      "    }",
      "    impl BitXor for BitSet {",
      "        type Output = BitSet;",
      "        fn bitxor(self, rhs: BitSet) -> BitSet {",
      "            BitSet::new(self.bit ^ rhs.bit)",
      "        }",
      "    }",
      "    use std::fmt::Debug;",
      "    impl Debug for BitSet {",
      "        fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {",
      "            f.write_fmt(format_args!(\"{:#b}\", self.bit))?;",
      "            Ok(())",
      "        }",
      "    }",
      "    impl<T> Index<BitSet> for [T] {",
      "        type Output = T;",
      "        fn index(&self, s: BitSet) -> &Self::Output {",
      "            &self[s.to_bit()]",
      "        }",
      "    }",
      "    impl<T> IndexMut<BitSet> for [T] {",
      "        fn index_mut(&mut self, s: BitSet) -> &mut Self::Output {",
      "            &mut self[s.to_bit()]",
      "        }",
      "    }",
      "    impl<T> Index<BitSet> for Vec<T> {",
      "        type Output = T;",
      "        fn index(&self, s: BitSet) -> &Self::Output {",
      "            &self[..][s]",
      "        }",
      "    }",
      "    impl<T> IndexMut<BitSet> for Vec<T> {",
      "        fn index_mut(&mut self, s: BitSet) -> &mut Self::Output {",
      "            &mut self[..][s]",
      "        }",
      "    }",
      "}"
    ]
  },
  "btree_multiset": {
    "scope": "rust",
    "prefix": "btree_multiset",
    "body": [
      "use btree_multiset::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod btree_multiset {",
      "    use std::{",
      "        borrow::Borrow,",
      "        collections::{btree_map::Range, BTreeMap},",
      "        ops::RangeBounds,",
      "    };",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct BTreeMultiSet<T> {",
      "        map: BTreeMap<T, usize>,",
      "        length: usize,",
      "    }",
      "    impl<T> BTreeMultiSet<T> {",
      "        pub const fn new() -> BTreeMultiSet<T> {",
      "            BTreeMultiSet {",
      "                map: BTreeMap::new(),",
      "                length: 0,",
      "            }",
      "        }",
      "        pub fn range<R>(&self, range: R) -> Range<'_, T, usize>",
      "        where",
      "            T: Ord,",
      "            R: RangeBounds<T>,",
      "        {",
      "            self.map.range(range)",
      "        }",
      "        pub fn iter(&self) -> impl Iterator<Item = (&T, &usize)> {",
      "            self.map.iter()",
      "        }",
      "        pub fn insert(&mut self, value: T)",
      "        where",
      "            T: Ord,",
      "        {",
      "            *self.map.entry(value).or_insert(0) += 1;",
      "            self.length += 1;",
      "        }",
      "        pub fn remove1<Q: ?Sized>(&mut self, value: &Q) -> bool",
      "        where",
      "            T: Borrow<Q> + Ord,",
      "            Q: Ord,",
      "        {",
      "            if let Some(cnt) = self.map.get_mut(value) {",
      "                *cnt -= 1;",
      "                if *cnt == 0 {",
      "                    self.map.remove(value);",
      "                }",
      "                self.length -= 1;",
      "                return true;",
      "            }",
      "            false",
      "        }",
      "        pub fn remove_all<Q: ?Sized>(&mut self, value: &Q) -> bool",
      "        where",
      "            T: Borrow<Q> + Ord,",
      "            Q: Ord,",
      "        {",
      "            if let Some(cnt) = self.map.get(value) {",
      "                self.length -= cnt;",
      "                self.map.remove(value);",
      "                return true;",
      "            }",
      "            false",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.length",
      "        }",
      "        pub fn set_len(&self) -> usize {",
      "            self.map.len()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.length == 0",
      "        }",
      "        pub fn count<Q: ?Sized>(&self, value: &Q) -> usize",
      "        where",
      "            T: Borrow<Q> + Ord,",
      "            Q: Ord,",
      "        {",
      "            self.map.get(value).copied().unwrap_or(0)",
      "        }",
      "        pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool",
      "        where",
      "            T: Borrow<Q> + Ord,",
      "            Q: Ord,",
      "        {",
      "            self.map.contains_key(value)",
      "        }",
      "    }",
      "    impl<T: Ord> FromIterator<T> for BTreeMultiSet<T> {",
      "        fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> BTreeMultiSet<T> {",
      "            let mut set = BTreeMultiSet::new();",
      "            for x in iter {",
      "                set.insert(x);",
      "            }",
      "            set",
      "        }",
      "    }",
      "}"
    ]
  },
  "calc_dist": {
    "scope": "rust",
    "prefix": "calc_dist",
    "body": [
      "use mod_queue::*;",
      "pub mod mod_queue {",
      "    use std::collections::VecDeque;",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Queue<T> {",
      "        raw: VecDeque<T>,",
      "    }",
      "    impl<T> Queue<T> {",
      "        pub fn new() -> Self {",
      "            Queue {",
      "                raw: VecDeque::new(),",
      "            }",
      "        }",
      "        pub fn push(&mut self, value: T) {",
      "            self.raw.push_back(value)",
      "        }",
      "        pub fn pop(&mut self) -> Option<T> {",
      "            self.raw.pop_front()",
      "        }",
      "        pub fn peek(&self) -> Option<&T> {",
      "            self.raw.front()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.raw.len()",
      "        }",
      "    }",
      "    impl<T> Default for Queue<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "}",
      "/// init から各点への距離を求める",
      "pub fn calc_dist(adj: &[Vec<usize>], init: usize) -> Vec<usize> {",
      "    let nv = adj.len();",
      "    let mut visited = vec![false; nv];",
      "    let mut dist = vec![usize::MAX; nv];",
      "    let mut open = Queue::new();",
      "    visited[init] = true;",
      "    dist[init] = 0;",
      "    open.push(init);",
      "    while let Some(current) = open.pop() {",
      "        for &next in &adj[current] {",
      "            if !visited[next] {",
      "                visited[next] = true;",
      "                dist[next] = dist[current] + 1;",
      "                open.push(next);",
      "            }",
      "        }",
      "    }",
      "    dist",
      "}"
    ]
  },
  "chminmax": {
    "scope": "rust",
    "prefix": "chminmax",
    "body": [
      "#[allow(clippy::module_inception)]",
      "#[macro_use]",
      "pub mod chminmax {",
      "    #[allow(unused_macros)]",
      "    #[macro_export]",
      "    macro_rules! chmin {",
      "        (\\$ a : expr , \\$ b : expr ) => {",
      "            if \\$a > \\$b {",
      "                \\$a = \\$b;",
      "                true",
      "            } else {",
      "                false",
      "            }",
      "        };",
      "    }",
      "    #[allow(unused_macros)]",
      "    #[macro_export]",
      "    macro_rules! chmax {",
      "        (\\$ a : expr , \\$ b : expr ) => {",
      "            if \\$a < \\$b {",
      "                \\$a = \\$b;",
      "                true",
      "            } else {",
      "                false",
      "            }",
      "        };",
      "    }",
      "}"
    ]
  },
  "coordinate_compression": {
    "scope": "rust",
    "prefix": "coordinate_compression",
    "body": [
      "use coordinate_compression::*;",
      "pub mod coordinate_compression {",
      "    use itertools::Itertools;",
      "    use superslice::Ext;",
      "    pub struct CoordinateCompression {",
      "        space: Vec<i64>,",
      "    }",
      "    impl CoordinateCompression {",
      "        /// 計算量: O(|space|log(|space|))",
      "        pub fn new(space: &[i64]) -> Self {",
      "            let space = space.iter().copied().sorted().dedup().collect_vec();",
      "            Self { space }",
      "        }",
      "        /// 計算量: O(log(|space|))",
      "        pub fn compress(&self, x: i64) -> usize {",
      "            self.space.binary_search(&x).unwrap()",
      "        }",
      "        /// 座標圧縮前の空間のうち x 以上である最小の値を座標圧縮したものを返す",
      "        /// 計算量: O(log(|space|))",
      "        pub fn compress_floor(&self, x: i64) -> usize {",
      "            self.space.upper_bound(&x) - 1",
      "        }",
      "        /// 座標圧縮前の空間のうち x 以下である最大の値を座標圧縮したものを返す",
      "        /// 計算量: O(log(|space|))",
      "        pub fn compress_ceil(&self, x: i64) -> usize {",
      "            self.space.lower_bound(&x)",
      "        }",
      "        /// 計算量: O(|xs|log(|space|))",
      "        pub fn compress_vec(&self, xs: &[i64]) -> Vec<usize> {",
      "            xs.iter().copied().map(|x| self.compress(x)).collect_vec()",
      "        }",
      "        /// 計算量: O(1)",
      "        pub fn decompress(&self, i: usize) -> i64 {",
      "            self.space[i]",
      "        }",
      "        pub fn space_size(&self) -> usize {",
      "            self.space.len()",
      "        }",
      "    }",
      "}"
    ]
  },
  "cum_monoid": {
    "scope": "rust",
    "prefix": "cum_monoid",
    "body": [
      "use cum_monoid::*;",
      "pub mod cum_monoid {",
      "    use ac_library::{Max, Min, Monoid};",
      "    pub struct CumMonoid<M>",
      "    where",
      "        M: Monoid,",
      "    {",
      "        prefix_prod: Vec<M::S>,",
      "        suffix_prod: Vec<M::S>,",
      "    }",
      "    impl<M> CumMonoid<M>",
      "    where",
      "        M: Monoid,",
      "    {",
      "        pub fn new(xs: &[M::S]) -> CumMonoid<M> {",
      "            let mut prefix_prod = vec![M::identity(); xs.len() + 1];",
      "            let mut suffix_prod = vec![M::identity(); xs.len() + 1];",
      "            for i in 0..xs.len() {",
      "                prefix_prod[i + 1] = M::binary_operation(&prefix_prod[i], &xs[i]);",
      "            }",
      "            for i in (0..xs.len()).rev() {",
      "                suffix_prod[i] = M::binary_operation(&xs[i], &suffix_prod[i + 1]);",
      "            }",
      "            CumMonoid {",
      "                prefix_prod,",
      "                suffix_prod,",
      "            }",
      "        }",
      "        /// [0, i) の総積 (前から累積)",
      "        pub fn prefix_prod(&self, i: usize) -> M::S {",
      "            self.prefix_prod[i].clone()",
      "        }",
      "        /// [i, n) の総積 (後ろから累積)",
      "        pub fn suffix_prod(&self, i: usize) -> M::S {",
      "            self.suffix_prod[i].clone()",
      "        }",
      "        /// [0, i), [i + 1, n) の区間で総積を取る",
      "        pub fn prod_without1(&self, i: usize) -> M::S {",
      "            M::binary_operation(&self.prefix_prod[i], &self.suffix_prod[i + 1])",
      "        }",
      "        pub fn prod_without_range(&self, l: usize, r: usize) -> M::S {",
      "            M::binary_operation(&self.prefix_prod[l], &self.suffix_prod[r])",
      "        }",
      "    }",
      "    pub struct CumMin {",
      "        cum: CumMonoid<Min<i64>>,",
      "    }",
      "    impl CumMin {",
      "        pub fn new(xs: &[i64]) -> CumMin {",
      "            CumMin {",
      "                cum: CumMonoid::new(xs),",
      "            }",
      "        }",
      "        /// [0, i) の総積 (前から累積)",
      "        pub fn prefix_min(&self, i: usize) -> i64 {",
      "            self.cum.prefix_prod(i)",
      "        }",
      "        /// [i, n) の総積 (後ろから累積)",
      "        pub fn suffix_min(&self, i: usize) -> i64 {",
      "            self.cum.suffix_prod(i)",
      "        }",
      "        /// [0, i), [i + 1, n) の区間で総積を取る",
      "        pub fn min_without1(&self, i: usize) -> i64 {",
      "            self.cum.prod_without1(i)",
      "        }",
      "        pub fn min_without_range(&self, l: usize, r: usize) -> i64 {",
      "            self.cum.prod_without_range(l, r)",
      "        }",
      "    }",
      "    pub struct CumMax {",
      "        cum: CumMonoid<Max<i64>>,",
      "    }",
      "    impl CumMax {",
      "        pub fn new(xs: &[i64]) -> CumMax {",
      "            CumMax {",
      "                cum: CumMonoid::new(xs),",
      "            }",
      "        }",
      "        /// [0, i) の総積 (前から累積)",
      "        pub fn prefix_max(&self, i: usize) -> i64 {",
      "            self.cum.prefix_prod(i)",
      "        }",
      "        /// [i, n) の総積 (後ろから累積)",
      "        pub fn suffix_max(&self, i: usize) -> i64 {",
      "            self.cum.suffix_prod(i)",
      "        }",
      "        /// [0, i), [i + 1, n) の区間で総積を取る",
      "        pub fn max_without1(&self, i: usize) -> i64 {",
      "            self.cum.prod_without1(i)",
      "        }",
      "        pub fn max_without_range(&self, l: usize, r: usize) -> i64 {",
      "            self.cum.prod_without_range(l, r)",
      "        }",
      "    }",
      "}"
    ]
  },
  "cumsum": {
    "scope": "rust",
    "prefix": "cumsum",
    "body": [
      "use cumsum::*;",
      "pub mod cumsum {",
      "    pub fn prefix_sum(xs: &[i64]) -> Vec<i64> {",
      "        let mut prefix_sum = vec![0; xs.len() + 1];",
      "        for i in 1..xs.len() + 1 {",
      "            prefix_sum[i] = prefix_sum[i - 1] + xs[i - 1];",
      "        }",
      "        prefix_sum",
      "    }",
      "    use std::ops::{Bound, Range, RangeBounds};",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct CumSum {",
      "        pub cumsum: Vec<i64>,",
      "    }",
      "    impl CumSum {",
      "        /// 計算量: O(|xs|)",
      "        pub fn new(xs: &[i64]) -> CumSum {",
      "            let mut cumsum = vec![0; xs.len() + 1];",
      "            for i in 1..xs.len() + 1 {",
      "                cumsum[i] = cumsum[i - 1] + xs[i - 1];",
      "            }",
      "            CumSum { cumsum }",
      "        }",
      "        fn open(&self, range: impl RangeBounds<usize>) -> Range<usize> {",
      "            use Bound::Excluded;",
      "            use Bound::Included;",
      "            use Bound::Unbounded;",
      "            let begin = match range.start_bound() {",
      "                Unbounded => 0,",
      "                Included(&x) => x,",
      "                Excluded(&x) => x + 1,",
      "            };",
      "            let end = match range.end_bound() {",
      "                Excluded(&x) => x,",
      "                Included(&x) => x + 1,",
      "                Unbounded => self.cumsum.len() - 1,",
      "            };",
      "            begin..end",
      "        }",
      "        /// 計算量: O(1)",
      "        pub fn range_sum(&self, range: impl RangeBounds<usize>) -> i64 {",
      "            let range = self.open(range);",
      "            self.cumsum[range.end] - self.cumsum[range.start]",
      "        }",
      "        pub fn prefix_sum(&self, end: usize) -> i64 {",
      "            self.cumsum[end]",
      "        }",
      "        pub fn suffix_sum(&self, begin: usize) -> i64 {",
      "            self.cumsum[self.cumsum.len() - 1] - self.cumsum[begin]",
      "        }",
      "    }",
      "}"
    ]
  },
  "cumsum_2d": {
    "scope": "rust",
    "prefix": "cumsum_2d",
    "body": [
      "use cumsum_2d::*;",
      "pub mod cumsum_2d {",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct CumSum2D {",
      "        pub cumsum: Vec<Vec<i64>>,",
      "    }",
      "    impl CumSum2D {",
      "        pub fn new(xss: &[Vec<i64>]) -> CumSum2D {",
      "            if xss.is_empty() {",
      "                return CumSum2D {",
      "                    cumsum: vec![vec![0]],",
      "                };",
      "            }",
      "            let height = xss.len();",
      "            let width = xss[0].len();",
      "            let mut cumsum = vec![vec![0; width + 1]; height + 1];",
      "            for y in 1..height + 1 {",
      "                for x in 1..width + 1 {",
      "                    cumsum[y][x] = cumsum[y - 1][x] + cumsum[y][x - 1] - cumsum[y - 1][x - 1]",
      "                        + xss[y - 1][x - 1];",
      "                }",
      "            }",
      "            CumSum2D { cumsum }",
      "        }",
      "        pub fn rect_sum(&self, (x1, y1): (usize, usize), (x2, y2): (usize, usize)) -> i64 {",
      "            self.cumsum[y2][x2] - self.cumsum[y2][x1] - self.cumsum[y1][x2] + self.cumsum[y1][x1]",
      "        }",
      "    }",
      "}"
    ]
  },
  "cycle_detection": {
    "scope": "rust",
    "prefix": "cycle_detection",
    "body": [
      "pub mod cycle_detection {",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    struct EdgeIndex {",
      "        src: usize,",
      "        dst: usize,",
      "        idx: usize,",
      "    }",
      "    struct CycleDetectionSolver {",
      "        nv: usize,",
      "        adj: Vec<Vec<EdgeIndex>>,",
      "    }",
      "    impl CycleDetectionSolver {",
      "        fn new(nv: usize, edges: &[(usize, usize)]) -> CycleDetectionSolver {",
      "            let edges = edges",
      "                .iter()",
      "                .copied()",
      "                .enumerate()",
      "                .map(|(i, e)| EdgeIndex {",
      "                    src: e.0,",
      "                    dst: e.1,",
      "                    idx: i,",
      "                })",
      "                .collect::<Vec<_>>();",
      "            let adj = edges.iter().copied().fold(vec![vec![]; nv], |mut acc, e| {",
      "                acc[e.src].push(e);",
      "                acc",
      "            });",
      "            CycleDetectionSolver { nv, adj }",
      "        }",
      "        fn dfs(",
      "            &self,",
      "            current_v: usize,",
      "            prev_e: Option<EdgeIndex>,",
      "            visited_pre: &mut Vec<bool>,",
      "            visited_post: &mut Vec<bool>,",
      "            history: &mut Vec<EdgeIndex>,",
      "        ) -> Option<usize> {",
      "            visited_pre[current_v] = true;",
      "            if let Some(prev_e) = prev_e {",
      "                assert_eq!(current_v, prev_e.dst);",
      "                history.push(prev_e);",
      "            }",
      "            for e in &self.adj[current_v] {",
      "                if visited_pre[e.dst] && !visited_post[e.dst] {",
      "                    history.push(*e);",
      "                    return Some(e.dst);",
      "                }",
      "                if visited_pre[e.dst] {",
      "                    continue;",
      "                }",
      "                let vertex_on_cycle = self.dfs(e.dst, Some(*e), visited_pre, visited_post, history);",
      "                if vertex_on_cycle.is_some() {",
      "                    return vertex_on_cycle;",
      "                }",
      "            }",
      "            history.pop();",
      "            visited_post[current_v] = true;",
      "            None",
      "        }",
      "        fn construct_cycle(&self, vertex_on_cycle: usize, history: &[EdgeIndex]) -> Vec<usize> {",
      "            let mut rev_cycle = vec![];",
      "            for e in history.iter().rev() {",
      "                rev_cycle.push(*e);",
      "                if e.src == vertex_on_cycle {",
      "                    break;",
      "                }",
      "            }",
      "            rev_cycle.iter().copied().rev().map(|e| e.idx).collect()",
      "        }",
      "        fn solve(&self) -> Option<Vec<usize>> {",
      "            let mut visited_pre = vec![false; self.nv];",
      "            let mut visited_post = vec![false; self.nv];",
      "            for start in 0..self.nv {",
      "                if visited_pre[start] {",
      "                    continue;",
      "                }",
      "                let mut history = vec![];",
      "                let vertex_on_cycle = self.dfs(",
      "                    start,",
      "                    None,",
      "                    &mut visited_pre,",
      "                    &mut visited_post,",
      "                    &mut history,",
      "                );",
      "                if let Some(vertex_on_cycle) = vertex_on_cycle {",
      "                    return Some(self.construct_cycle(vertex_on_cycle, &history));",
      "                }",
      "            }",
      "            None",
      "        }",
      "    }",
      "    /// 与えられた有向グラフにサイクルが存在するか判定して、存在したらサイクル上の点を返す",
      "    /// 有向グラフは以下の２つの情報で与えられる",
      "    /// * `nv`: 頂点の数 `nv`",
      "    /// * `edges`: 辺のリスト。辺は始点と終点のペアで与えられる",
      "    /// 計算量: O(E+V) (V は頂点の数, E は辺の数)",
      "    pub fn cycle_detection(nv: usize, edges: &[(usize, usize)]) -> Option<Vec<usize>> {",
      "        CycleDetectionSolver::new(nv, edges).solve()",
      "    }",
      "}"
    ]
  },
  "default_hash_map": {
    "scope": "rust",
    "prefix": "default_hash_map",
    "body": [
      "use default_hash_map::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod default_hash_map {",
      "    use std::hash::Hash;",
      "    use std::{",
      "        borrow::Borrow,",
      "        collections::{",
      "            hash_map::{Iter, IterMut, Keys, Values, ValuesMut},",
      "            HashMap,",
      "        },",
      "    };",
      "    #[derive(Clone, Debug)]",
      "    pub struct DefaultHashMap<K, V> {",
      "        raw: HashMap<K, V>,",
      "        default: V,",
      "    }",
      "    impl<K, V> DefaultHashMap<K, V> {",
      "        pub fn new(default: V) -> DefaultHashMap<K, V> {",
      "            DefaultHashMap {",
      "                raw: HashMap::new(),",
      "                default,",
      "            }",
      "        }",
      "        pub fn from_hash_map(hash_map: HashMap<K, V>, default: V) -> DefaultHashMap<K, V> {",
      "            DefaultHashMap {",
      "                raw: hash_map,",
      "                default,",
      "            }",
      "        }",
      "        pub fn raw(&mut self) -> &mut HashMap<K, V> {",
      "            &mut self.raw",
      "        }",
      "        pub fn keys(&self) -> Keys<K, V> {",
      "            self.raw.keys()",
      "        }",
      "        pub fn values(&self) -> Values<K, V> {",
      "            self.raw.values()",
      "        }",
      "        pub fn values_mut(&mut self) -> ValuesMut<K, V> {",
      "            self.raw.values_mut()",
      "        }",
      "        pub fn iter(&self) -> Iter<K, V> {",
      "            self.raw.iter()",
      "        }",
      "        pub fn iter_mut(&mut self) -> IterMut<K, V> {",
      "            self.raw.iter_mut()",
      "        }",
      "        pub fn len(&mut self) -> usize {",
      "            self.raw.len()",
      "        }",
      "        pub fn is_empty(&mut self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "    }",
      "    impl<K, V> DefaultHashMap<K, V>",
      "    where",
      "        K: Eq + Hash,",
      "    {",
      "        pub fn get<Q: ?Sized>(&self, k: &Q) -> &V",
      "        where",
      "            K: Borrow<Q>,",
      "            Q: Hash + Eq,",
      "        {",
      "            self.raw.get(k).unwrap_or(&self.default)",
      "        }",
      "        pub fn get_mut(&mut self, k: K) -> &mut V",
      "        where",
      "            V: Clone,",
      "        {",
      "            self.raw.entry(k).or_insert(self.default.clone())",
      "        }",
      "        pub fn insert(&mut self, k: K, v: V) -> Option<V> {",
      "            self.raw.insert(k, v)",
      "        }",
      "        pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>",
      "        where",
      "            K: Borrow<Q>,",
      "            Q: Hash + Eq,",
      "        {",
      "            self.raw.remove(k)",
      "        }",
      "    }",
      "    impl<K, V> PartialEq for DefaultHashMap<K, V>",
      "    where",
      "        K: Eq + Hash,",
      "        V: PartialEq,",
      "    {",
      "        fn eq(&self, other: &DefaultHashMap<K, V>) -> bool {",
      "            self.raw == other.raw && self.default == other.default",
      "        }",
      "    }",
      "    impl<K, V> Eq for DefaultHashMap<K, V>",
      "    where",
      "        K: Eq + Hash,",
      "        V: Eq,",
      "    {",
      "    }",
      "    impl<K, V> Default for DefaultHashMap<K, V>",
      "    where",
      "        V: Default,",
      "    {",
      "        fn default() -> DefaultHashMap<K, V> {",
      "            DefaultHashMap::new(V::default())",
      "        }",
      "    }",
      "    impl<K, V> std::ops::Index<K> for DefaultHashMap<K, V>",
      "    where",
      "        K: Eq + Hash,",
      "    {",
      "        type Output = V;",
      "        #[inline]",
      "        fn index(&self, key: K) -> &V {",
      "            self.get(&key)",
      "        }",
      "    }",
      "    impl<K, V> std::ops::IndexMut<K> for DefaultHashMap<K, V>",
      "    where",
      "        K: Eq + Hash,",
      "        V: Clone,",
      "    {",
      "        #[inline]",
      "        fn index_mut(&mut self, key: K) -> &mut V {",
      "            self.get_mut(key)",
      "        }",
      "    }",
      "}"
    ]
  },
  "dfs_post_order": {
    "scope": "rust",
    "prefix": "dfs_post_order",
    "body": [
      "use mod_stack::*;",
      "pub mod mod_stack {",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Stack<T> {",
      "        raw: Vec<T>,",
      "    }",
      "    impl<T> Stack<T> {",
      "        pub fn new() -> Self {",
      "            Stack { raw: Vec::new() }",
      "        }",
      "        pub fn push(&mut self, value: T) {",
      "            self.raw.push(value)",
      "        }",
      "        pub fn pop(&mut self) -> Option<T> {",
      "            self.raw.pop()",
      "        }",
      "        pub fn peek(&self) -> Option<&T> {",
      "            self.raw.last()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.raw.len()",
      "        }",
      "    }",
      "    impl<T> Default for Stack<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "}",
      "pub fn dfs_post_order(adj: &[Vec<usize>], init: usize) -> Vec<usize> {",
      "    fn dfs(",
      "        adj: &[Vec<usize>],",
      "        current: usize,",
      "        visited: &mut Vec<bool>,",
      "        post_order: &mut Vec<usize>,",
      "    ) {",
      "        visited[current] = true;",
      "        for &next in &adj[current] {",
      "            if !visited[next] {",
      "                dfs(adj, next, visited, post_order);",
      "            }",
      "        }",
      "        post_order.push(current);",
      "    }",
      "    let nv = adj.len();",
      "    let mut visited = vec![false; nv];",
      "    let mut post_order = vec![];",
      "    dfs(adj, init, &mut visited, &mut post_order);",
      "    post_order",
      "}"
    ]
  },
  "dfs_pre_order": {
    "scope": "rust",
    "prefix": "dfs_pre_order",
    "body": [
      "use mod_stack::*;",
      "pub mod mod_stack {",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Stack<T> {",
      "        raw: Vec<T>,",
      "    }",
      "    impl<T> Stack<T> {",
      "        pub fn new() -> Self {",
      "            Stack { raw: Vec::new() }",
      "        }",
      "        pub fn push(&mut self, value: T) {",
      "            self.raw.push(value)",
      "        }",
      "        pub fn pop(&mut self) -> Option<T> {",
      "            self.raw.pop()",
      "        }",
      "        pub fn peek(&self) -> Option<&T> {",
      "            self.raw.last()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.raw.len()",
      "        }",
      "    }",
      "    impl<T> Default for Stack<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "}",
      "pub fn dfs_pre_order(adj: &[Vec<usize>], init: usize) -> Vec<usize> {",
      "    fn dfs(",
      "        adj: &[Vec<usize>],",
      "        current: usize,",
      "        visited: &mut Vec<bool>,",
      "        pre_order: &mut Vec<usize>,",
      "    ) {",
      "        visited[current] = true;",
      "        pre_order.push(current);",
      "        for &next in &adj[current] {",
      "            if !visited[next] {",
      "                dfs(adj, next, visited, pre_order);",
      "            }",
      "        }",
      "    }",
      "    let nv = adj.len();",
      "    let mut visited = vec![false; nv];",
      "    let mut pre_order = vec![];",
      "    dfs(adj, init, &mut visited, &mut pre_order);",
      "    pre_order",
      "}"
    ]
  },
  "divisors": {
    "scope": "rust",
    "prefix": "divisors",
    "body": [
      "/// O(sqrt(n))",
      "pub fn divisors(n: i64) -> Vec<i64> {",
      "    use num::Integer;",
      "    use num_integer::Roots;",
      "    assert!(n >= 1);",
      "    let mut retval: Vec<i64> = Vec::new();",
      "    for i in 1..=n.sqrt() {",
      "        if n.is_multiple_of(&i) {",
      "            retval.push(i);",
      "            if i * i != n {",
      "                retval.push(n / i);",
      "            }",
      "        }",
      "    }",
      "    retval",
      "}"
    ]
  },
  "doubling": {
    "scope": "rust",
    "prefix": "doubling",
    "body": [
      "use doubling::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod doubling {",
      "    pub struct Doubling {",
      "        n: usize,",
      "        log: usize,",
      "        dp: Vec<Vec<usize>>,",
      "    }",
      "    impl Doubling {",
      "        /// doubling 前処理の構築をする",
      "        /// k は 合成回数の最大値 (k>=1)",
      "        /// [計算量]",
      "        /// n = f.len() としたとき、O(n log k)",
      "        pub fn new(f: &[usize], k: usize) -> Doubling {",
      "            let n = f.len();",
      "            let log = (usize::BITS - k.leading_zeros()) as usize;",
      "            let mut dp = vec![vec![0; n]; log];",
      "            if k >= 1 {",
      "                dp[0] = f.to_vec();",
      "            }",
      "            for i in 1..log {",
      "                for x in 0..n {",
      "                    let f = &dp[i - 1];",
      "                    dp[i][x] = f[f[x]];",
      "                }",
      "            }",
      "            Doubling { n, log, dp }",
      "        }",
      "        /// (f の k回合成)(x) を求める。",
      "        /// 計算量: O(log k)",
      "        pub fn eval(&self, k: usize, x: usize) -> usize {",
      "            assert!((0..self.n).contains(&x));",
      "            assert!(k < (1 << self.log));",
      "            if k == 0 {",
      "                return x;",
      "            }",
      "            self.dp",
      "                .iter()",
      "                .enumerate()",
      "                .filter(|(i, _)| (k >> i) & 1 == 1)",
      "                .map(|(_, f)| f)",
      "                .fold(x, |acc, f| f[acc])",
      "        }",
      "    }",
      "}"
    ]
  },
  "dual_segtree": {
    "scope": "rust",
    "prefix": "dual_segtree",
    "body": [
      "use dual_segtree::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod dual_segtree {",
      "    use std::ops::{Bound, RangeBounds};",
      "    fn ceil_pow2(n: u32) -> u32 {",
      "        32 - n.saturating_sub(1).leading_zeros()",
      "    }",
      "    pub trait MapMonoid {",
      "        type F: Clone;",
      "        type S: Clone;",
      "        fn identity_map() -> Self::F;",
      "        fn mapping(f: &Self::F, x: &Self::S) -> Self::S;",
      "        fn composition(f: &Self::F, g: &Self::F) -> Self::F;",
      "    }",
      "    impl<F: MapMonoid> Default for DualSegtree<F>",
      "    where",
      "        F::S: Default,",
      "    {",
      "        fn default() -> Self {",
      "            Self::new(0)",
      "        }",
      "    }",
      "    impl<F: MapMonoid> DualSegtree<F> {",
      "        pub fn new(n: usize) -> Self",
      "        where",
      "            F::S: Default,",
      "        {",
      "            vec![F::S::default(); n].into()",
      "        }",
      "    }",
      "    impl<F: MapMonoid> From<Vec<F::S>> for DualSegtree<F>",
      "    where",
      "        F::S: Default,",
      "    {",
      "        fn from(v: Vec<F::S>) -> Self {",
      "            let n = v.len();",
      "            let log = ceil_pow2(n as u32) as usize;",
      "            let size = 1 << log;",
      "            let mut d = vec![F::S::default(); size];",
      "            let lz = vec![F::identity_map(); size];",
      "            d[..n].clone_from_slice(&v);",
      "            DualSegtree {",
      "                n,",
      "                size,",
      "                log,",
      "                d,",
      "                lz,",
      "            }",
      "        }",
      "    }",
      "    impl<F: MapMonoid> DualSegtree<F> {",
      "        pub fn set(&mut self, p: usize, x: F::S) {",
      "            assert!(p < self.n);",
      "            for i in (1..=self.log).rev() {",
      "                self.push((p + self.size) >> i);",
      "            }",
      "            self.d[p] = x;",
      "        }",
      "        pub fn get(&mut self, p: usize) -> F::S {",
      "            assert!(p < self.n);",
      "            for i in (1..=self.log).rev() {",
      "                self.push((p + self.size) >> i);",
      "            }",
      "            self.d[p].clone()",
      "        }",
      "        pub fn apply(&mut self, p: usize, f: F::F) {",
      "            assert!(p < self.n);",
      "            for i in (1..=self.log).rev() {",
      "                self.push((p + self.size) >> i);",
      "            }",
      "            self.d[p] = F::mapping(&f, &self.d[p]);",
      "        }",
      "        pub fn apply_range<R>(&mut self, range: R, f: F::F)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            let mut r = match range.end_bound() {",
      "                Bound::Included(r) => r + 1,",
      "                Bound::Excluded(r) => *r,",
      "                Bound::Unbounded => self.n,",
      "            };",
      "            let mut l = match range.start_bound() {",
      "                Bound::Included(l) => *l,",
      "                Bound::Excluded(l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            assert!(l <= r && r <= self.n);",
      "            if l == r {",
      "                return;",
      "            }",
      "            l += self.size;",
      "            r += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                if ((l >> i) << i) != l {",
      "                    self.push(l >> i);",
      "                }",
      "                if ((r >> i) << i) != r {",
      "                    self.push((r - 1) >> i);",
      "                }",
      "            }",
      "            {",
      "                while l < r {",
      "                    if l & 1 != 0 {",
      "                        self.all_apply(l, f.clone());",
      "                        l += 1;",
      "                    }",
      "                    if r & 1 != 0 {",
      "                        r -= 1;",
      "                        self.all_apply(r, f.clone());",
      "                    }",
      "                    l >>= 1;",
      "                    r >>= 1;",
      "                }",
      "            }",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<F::S> {",
      "            (0..self.n).map(|i| self.get(i)).collect()",
      "        }",
      "    }",
      "    pub struct DualSegtree<F>",
      "    where",
      "        F: MapMonoid,",
      "    {",
      "        n: usize,",
      "        size: usize,",
      "        log: usize,",
      "        d: Vec<F::S>,",
      "        lz: Vec<F::F>,",
      "    }",
      "    impl<F> DualSegtree<F>",
      "    where",
      "        F: MapMonoid,",
      "    {",
      "        fn all_apply(&mut self, k: usize, f: F::F) {",
      "            if k < self.size {",
      "                self.lz[k] = F::composition(&f, &self.lz[k]);",
      "            } else {",
      "                self.d[k - self.size] = F::mapping(&f, &self.d[k - self.size]);",
      "            }",
      "        }",
      "        fn push(&mut self, k: usize) {",
      "            self.all_apply(2 * k, self.lz[k].clone());",
      "            self.all_apply(2 * k + 1, self.lz[k].clone());",
      "            self.lz[k] = F::identity_map();",
      "        }",
      "    }",
      "}"
    ]
  },
  "dynamic_monoid": {
    "scope": "rust",
    "prefix": "dynamic_monoid",
    "body": [
      "use dynamic_monoid::*;",
      "pub mod dynamic_monoid {",
      "    pub trait DynamicMonoid {",
      "        type S: Clone;",
      "        fn identity(&self) -> Self::S;",
      "        fn binary_operation(&self, a: &Self::S, b: &Self::S) -> Self::S;",
      "        /// base^n を求める",
      "        fn pow(&self, base: &Self::S, n: usize) -> Self::S {",
      "            let mut base = base.clone();",
      "            let mut ans = self.identity();",
      "            let mut n = n;",
      "            while n > 0 {",
      "                if n & 1 == 1 {",
      "                    ans = self.binary_operation(&ans, &base);",
      "                }",
      "                base = self.binary_operation(&base, &base);",
      "                n >>= 1;",
      "            }",
      "            ans",
      "        }",
      "    }",
      "}"
    ]
  },
  "eratosthenes_sieve": {
    "scope": "rust",
    "prefix": "eratosthenes_sieve",
    "body": [
      "use eratosthenes_sieve::*;",
      "pub mod eratosthenes_sieve {",
      "    use std::collections::HashMap;",
      "    pub struct EratosthenesSieve {",
      "        is_prime_list: Vec<bool>,",
      "        min_factor_list: Vec<Option<usize>>,",
      "    }",
      "    impl EratosthenesSieve {",
      "        /// [0, n] の区間でエラトステネスのふるいをする",
      "        /// 計算量: O(n log(log(n)))",
      "        pub fn new(n: usize) -> Self {",
      "            let mut is_prime_list = vec![true; n + 1];",
      "            let mut min_factor_list = vec![None; n + 1];",
      "            is_prime_list[0] = false;",
      "            is_prime_list[1] = false;",
      "            for p in 2..=n {",
      "                if !is_prime_list[p] {",
      "                    continue;",
      "                }",
      "                min_factor_list[p] = Some(p);",
      "                for q in (p * 2..=n).step_by(p) {",
      "                    is_prime_list[q] = false;",
      "                    if min_factor_list[q].is_none() {",
      "                        min_factor_list[q] = Some(p);",
      "                    }",
      "                }",
      "            }",
      "            Self {",
      "                is_prime_list,",
      "                min_factor_list,",
      "            }",
      "        }",
      "        /// 計算量: O(1)",
      "        pub fn is_prime(&self, n: usize) -> bool {",
      "            self.is_prime_list[n]",
      "        }",
      "        /// 計算量: O(log n)",
      "        pub fn prime_factorize(&self, n: usize) -> HashMap<usize, usize> {",
      "            let mut n = n;",
      "            let mut cnt_table: HashMap<usize, usize> = HashMap::new();",
      "            while n > 1 {",
      "                let p = self.min_factor_list[n].unwrap();",
      "                let mut exp = 0;",
      "                while self.min_factor_list[n] == Some(p) {",
      "                    n /= p;",
      "                    exp += 1;",
      "                }",
      "                cnt_table.insert(p, exp);",
      "            }",
      "            cnt_table",
      "        }",
      "        /// 計算量: O(nの約数の個数)",
      "        pub fn divisors(&self, n: usize) -> Vec<usize> {",
      "            let mut res = vec![1];",
      "            let pf = self.prime_factorize(n);",
      "            for (p, e) in pf {",
      "                for i in 0..res.len() {",
      "                    let mut tmp = 1;",
      "                    for _ in 0..e {",
      "                        tmp *= p;",
      "                        res.push(res[i] * tmp);",
      "                    }",
      "                }",
      "            }",
      "            res",
      "        }",
      "    }",
      "}"
    ]
  },
  "euler_phi": {
    "scope": "rust",
    "prefix": "euler_phi",
    "body": [
      "/// 計算量: O(sqrt(n))",
      "pub fn prime_factorize(n: i64) -> HashMap<i64, i64> {",
      "    use num::Integer;",
      "    use num_integer::Roots;",
      "    assert!(n >= 1);",
      "    let mut cnt_table: HashMap<i64, i64> = HashMap::new();",
      "    let mut n = n;",
      "    for i in 2..=n.sqrt() {",
      "        if n.is_multiple_of(&i) {",
      "            let mut cnt = 0;",
      "            while n.is_multiple_of(&i) {",
      "                n /= i;",
      "                cnt += 1;",
      "            }",
      "            cnt_table.insert(i, cnt);",
      "        }",
      "    }",
      "    if n != 1 {",
      "        cnt_table.insert(n, 1);",
      "    }",
      "    cnt_table",
      "}",
      "/// 計算量: O(sqrt(n))",
      "pub fn euler_phi(n: i64) -> i64 {",
      "    assert!(n >= 1);",
      "    let pf = prime_factorize(n);",
      "    let mut res = n;",
      "    for p in pf.keys() {",
      "        res = res / p * (p - 1);",
      "    }",
      "    res",
      "}"
    ]
  },
  "euler_tour": {
    "scope": "rust",
    "prefix": "euler_tour",
    "body": [
      "use euler_tour::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod euler_tour {",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub enum InOut {",
      "        In(usize),",
      "        Out(usize),",
      "    }",
      "    pub struct EulerTour {",
      "        pub tour: Vec<InOut>,",
      "        pub in_time: Vec<usize>,",
      "        pub out_time: Vec<usize>,",
      "    }",
      "    impl EulerTour {",
      "        pub fn new(tree_parent: &[usize]) -> Self {",
      "            let nv = tree_parent.len();",
      "            let tree_children = tree_parent.iter().copied().enumerate().fold(",
      "                vec![vec![]; nv],",
      "                |mut acc, (child, parent)| {",
      "                    if child != parent {",
      "                        acc[parent].push(child);",
      "                    }",
      "                    acc",
      "                },",
      "            );",
      "            let root = (0..nv).find(|&v| tree_parent[v] == v).unwrap();",
      "            let tour = {",
      "                fn dfs(tour: &mut Vec<InOut>, current: usize, tree_children: &[Vec<usize>]) {",
      "                    tour.push(InOut::In(current));",
      "                    for &child in &tree_children[current] {",
      "                        dfs(tour, child, tree_children);",
      "                    }",
      "                    tour.push(InOut::Out(current));",
      "                }",
      "                let mut tour = Vec::with_capacity(2 * nv);",
      "                dfs(&mut tour, root, &tree_children);",
      "                tour",
      "            };",
      "            let (in_time, out_time) = {",
      "                let mut in_time = vec![0; nv];",
      "                let mut out_time = vec![0; nv];",
      "                for (time, edge) in tour.iter().copied().enumerate() {",
      "                    match edge {",
      "                        InOut::In(v) => {",
      "                            in_time[v] = time;",
      "                        }",
      "                        InOut::Out(v) => {",
      "                            out_time[v] = time;",
      "                        }",
      "                    }",
      "                }",
      "                (in_time, out_time)",
      "            };",
      "            EulerTour {",
      "                tour,",
      "                in_time,",
      "                out_time,",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "extend_acl_monoid": {
    "scope": "rust",
    "prefix": "extend_acl_monoid",
    "body": [
      "use extend_acl_monoid::*;",
      "pub mod extend_acl_monoid {",
      "    use ac_library::Monoid;",
      "    pub trait MonoidExtPow: Monoid {",
      "        /// base^n を求める",
      "        fn pow(base: &Self::S, n: usize) -> Self::S {",
      "            let mut base = base.clone();",
      "            let mut ans = Self::identity();",
      "            let mut n = n;",
      "            while n > 0 {",
      "                if n & 1 == 1 {",
      "                    ans = Self::binary_operation(&ans, &base);",
      "                }",
      "                base = Self::binary_operation(&base, &base);",
      "                n >>= 1;",
      "            }",
      "            ans",
      "        }",
      "    }",
      "    impl<T> MonoidExtPow for T where T: Monoid {}",
      "}"
    ]
  },
  "fenwick_tree_to_vec": {
    "scope": "rust",
    "prefix": "fenwick_tree_to_vec",
    "body": [
      "pub fn fenwick_tree_to_vec<T>(fenwick_tree: &ac_library::FenwickTree<T>, len: usize) -> Vec<T>",
      "where",
      "    T: Clone + std::ops::AddAssign<T> + std::ops::Sub<Output = T>,",
      "{",
      "    (0..len).map(|i| fenwick_tree.sum(i..=i)).collect()",
      "}"
    ]
  },
  "has_cycle_directed_by_topo_sort": {
    "scope": "rust",
    "prefix": "has_cycle_directed_by_topo_sort",
    "body": [
      "use mod_queue::*;",
      "pub fn topo_sort(adj: &Vec<Vec<usize>>) -> Vec<usize> {",
      "    let n_vertex = adj.len();",
      "    let mut in_deg = vec![0; n_vertex];",
      "    for current in 0..n_vertex {",
      "        for &next in &adj[current] {",
      "            in_deg[next] += 1;",
      "        }",
      "    }",
      "    let mut open: Queue<usize> = Queue::new();",
      "    for v in 0..n_vertex {",
      "        if in_deg[v] == 0 {",
      "            open.push(v);",
      "        }",
      "    }",
      "    let mut ans = vec![];",
      "    while let Some(current) = open.pop() {",
      "        ans.push(current);",
      "        for &next in &adj[current] {",
      "            in_deg[next] -= 1;",
      "            if in_deg[next] == 0 {",
      "                open.push(next);",
      "            }",
      "        }",
      "    }",
      "    ans",
      "}",
      "pub mod mod_queue {",
      "    use std::collections::VecDeque;",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Queue<T> {",
      "        raw: VecDeque<T>,",
      "    }",
      "    impl<T> Queue<T> {",
      "        pub fn new() -> Self {",
      "            Queue {",
      "                raw: VecDeque::new(),",
      "            }",
      "        }",
      "        pub fn push(&mut self, value: T) {",
      "            self.raw.push_back(value)",
      "        }",
      "        pub fn pop(&mut self) -> Option<T> {",
      "            self.raw.pop_front()",
      "        }",
      "        pub fn peek(&self) -> Option<&T> {",
      "            self.raw.front()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.raw.len()",
      "        }",
      "    }",
      "    impl<T> Default for Queue<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "}",
      "pub fn has_cycle_directed_by_topo_sort(adj: &Vec<Vec<usize>>) -> bool {",
      "    let topo_sorted = topo_sort(adj);",
      "    topo_sorted.len() != adj.len()",
      "}"
    ]
  },
  "has_cycle_undirected": {
    "scope": "rust",
    "prefix": "has_cycle_undirected",
    "body": [
      "pub fn has_cycle_undirected(n_vertex: usize, edges: &[(usize, usize)]) -> bool {",
      "    use petgraph::unionfind::UnionFind;",
      "    let mut uf = UnionFind::new(n_vertex);",
      "    for &(from, to) in edges {",
      "        if uf.equiv(from, to) {",
      "            return true;",
      "        }",
      "        uf.union(from, to);",
      "    }",
      "    false",
      "}"
    ]
  },
  "i64_combinatorics": {
    "scope": "rust",
    "prefix": "i64_combinatorics",
    "body": [
      "use mod_combinatorics::*;",
      "pub mod i64_combinatorics {",
      "    pub fn comb(n: i64, k: i64) -> i64 {",
      "        if n < 0 || k < 0 || n < k {",
      "            return 0;",
      "        }",
      "        (1..=k).fold(1, |acc, i| acc * (n - i + 1) / i)",
      "    }",
      "    pub fn perm(n: i64, k: i64) -> i64 {",
      "        if n < 0 || k < 0 || n < k {",
      "            return 0;",
      "        }",
      "        (n - k + 1..=n).product::<i64>()",
      "    }",
      "    pub fn factorial(n: i64) -> i64 {",
      "        if n < 0 {",
      "            return 0;",
      "        }",
      "        (1..=n).product::<i64>()",
      "    }",
      "}"
    ]
  },
  "imos_1d": {
    "scope": "rust",
    "prefix": "imos_1d",
    "body": [
      "use imos_1d::*;",
      "pub mod imos_1d {",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Imos1D {",
      "        raw: Vec<i64>,",
      "        begin: i64,",
      "        end: i64,",
      "    }",
      "    impl Imos1D {",
      "        /// [begin, end) の区間で考える",
      "        /// 注意: 差分の回数分だけ end を広めに取る",
      "        pub fn new(begin: i64, end: i64) -> Self {",
      "            debug_assert!(begin < end);",
      "            let len = (end - begin) as usize;",
      "            let raw = vec![0; len];",
      "            Self { raw, begin, end }",
      "        }",
      "        fn is_within(&self, i: i64) -> bool {",
      "            (self.begin..self.end).contains(&i)",
      "        }",
      "        pub fn get(&self, i: i64) -> i64 {",
      "            if cfg!(debug_assertions) && !self.is_within(i) {",
      "                panic!(",
      "                    \"index out of bounds: the range is [{}, {}) but the index is {}\",",
      "                    self.begin, self.end, i",
      "                );",
      "            }",
      "            self.raw[(i - self.begin) as usize]",
      "        }",
      "        pub fn add(&mut self, i: i64, val: i64) {",
      "            if cfg!(debug_assertions) && !self.is_within(i) {",
      "                panic!(",
      "                    \"index out of bounds: the range is [{}, {}) but the index is {}\",",
      "                    self.begin, self.end, i",
      "                );",
      "            }",
      "            self.raw[(i - self.begin) as usize] += val;",
      "        }",
      "        pub fn summation(&mut self) {",
      "            for i in 1..self.raw.len() {",
      "                self.raw[i] += self.raw[i - 1]",
      "            }",
      "        }",
      "        /// デバッグ用",
      "        pub fn difference(&mut self) {",
      "            for i in (1..self.raw.len()).rev() {",
      "                self.raw[i] -= self.raw[i - 1];",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "imos_2d": {
    "scope": "rust",
    "prefix": "imos_2d",
    "body": [
      "use imos_2d::*;",
      "pub mod imos_2d {",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Imos2D {",
      "        raw: Vec<Vec<i64>>,",
      "        row_begin: i64,",
      "        row_end: i64,",
      "        col_begin: i64,",
      "        col_end: i64,",
      "    }",
      "    impl Imos2D {",
      "        /// [row_begin, row_end) × [col_begin, col_end) の範囲で考える",
      "        /// 注意: 差分の取る回数・取り方に応じて begin, end を広めに取る",
      "        pub fn new(row_begin: i64, row_end: i64, col_begin: i64, col_end: i64) -> Self {",
      "            debug_assert!(row_begin < row_end);",
      "            debug_assert!(col_begin < col_end);",
      "            let height = (row_end - row_begin) as usize;",
      "            let width = (col_end - col_begin) as usize;",
      "            let raw = vec![vec![0; width]; height];",
      "            Self {",
      "                raw,",
      "                row_begin,",
      "                row_end,",
      "                col_begin,",
      "                col_end,",
      "            }",
      "        }",
      "        fn is_within(&self, row: i64, col: i64) -> bool {",
      "            (self.row_begin..self.row_end).contains(&row)",
      "                && (self.col_begin..self.col_end).contains(&col)",
      "        }",
      "        pub fn get(&self, row: i64, col: i64) -> i64 {",
      "            if cfg!(debug_assertions) && !self.is_within(row, col) {",
      "                panic ! (\"index out of bounds: the domain is [{}, {}) × [{}, {}) but the index is ({}, {})\" , self . row_begin , self . row_end , self . col_begin , self . col_end , row , col );",
      "            }",
      "            self.raw[(row - self.row_begin) as usize][(col - self.col_begin) as usize]",
      "        }",
      "        pub fn add(&mut self, row: i64, col: i64, val: i64) {",
      "            if cfg!(debug_assertions) && !self.is_within(row, col) {",
      "                panic ! (\"index out of bounds: the domain is [{}, {}) × [{}, {}) but the index is ({}, {})\" , self . row_begin , self . row_end , self . col_begin , self . col_end , row , col );",
      "            }",
      "            self.raw[(row - self.row_begin) as usize][(col - self.col_begin) as usize] += val;",
      "        }",
      "        pub fn summation(&mut self, d_row: i64, d_col: i64) {",
      "            debug_assert_ne!((d_row, d_col), (0, 0));",
      "            let height = self.row_end - self.row_begin;",
      "            let width = self.col_end - self.col_begin;",
      "            if d_row > 0 || (d_row == 0 && d_col > 0) {",
      "                for row in 0..height {",
      "                    for col in 0..width {",
      "                        let prev_row = row - d_row;",
      "                        let prev_col = col - d_col;",
      "                        if (0..height).contains(&prev_row) && (0..width).contains(&prev_col) {",
      "                            self.raw[row as usize][col as usize] +=",
      "                                self.raw[prev_row as usize][prev_col as usize]",
      "                        }",
      "                    }",
      "                }",
      "            } else {",
      "                for row in (0..height).rev() {",
      "                    for col in (0..width).rev() {",
      "                        let prev_row = row - d_row;",
      "                        let prev_col = col - d_col;",
      "                        if (0..height).contains(&prev_row) && (0..width).contains(&prev_col) {",
      "                            self.raw[row as usize][col as usize] +=",
      "                                self.raw[prev_row as usize][prev_col as usize]",
      "                        }",
      "                    }",
      "                }",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "impl_readable_for_enum": {
    "scope": "rust",
    "prefix": "impl_readable_for_enum",
    "body": [
      "pub mod impl_readable_for_enum {",
      "    /// 利用例",
      "    /// ```",
      "    /// #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    /// enum Query {",
      "    ///     Move { p: usize, h: usize },",
      "    ///     Swap { h1: usize, h2: usize },",
      "    ///     Output { p: usize },",
      "    /// }",
      "    /// impl_readable_for_enum! {",
      "    ///     Query {",
      "    ///         1 => Move { p: Usize1, h: Usize1 },",
      "    ///         2 => Swap { h1: Usize1, h2: Usize1 },",
      "    ///         3 => Output { p: Usize1 },",
      "    ///     }",
      "    /// }",
      "    /// ```",
      "    #[macro_export]",
      "    macro_rules ! impl_readable_for_enum {(\\$ enum_name : ident {\\$ (\\$ idx : literal => \\$ variant : ident \\$ ({\\$ (\\$ field : ident : \\$ ty : ty ) ,* } ) ? ) ,* \\$ (, ) ? } ) => {impl proconio :: source :: Readable for \\$ enum_name {type Output = \\$ enum_name ; fn read < R : std :: io :: BufRead , S : proconio :: source :: Source < R >> (source : & mut S ) -> \\$ enum_name {input ! {from & mut * source , t : usize } match t {\\$ (\\$ idx => {impl_readable_for_enum ! (@ read_variant source , \\$ enum_name , \\$ variant \\$ ({\\$ (\\$ field : \\$ ty ) ,* } ) ? ) } ) ,*, _ => unreachable ! () , } } } } ; (@ read_variant \\$ source : ident , \\$ enum_name : ident , \\$ variant : ident {\\$ (\\$ field : ident : \\$ ty : ty ) ,* } ) => {{input ! {from & mut *\\$ source , \\$ (\\$ field : \\$ ty ) ,* } ; \\$ enum_name ::\\$ variant {\\$ (\\$ field ) ,* } } } ; (@ read_variant \\$ source : ident , \\$ enum_name : ident , \\$ variant : ident ) => {{\\$ enum_name ::\\$ variant } } ; }",
      "}"
    ]
  },
  "inversion_number": {
    "scope": "rust",
    "prefix": "inversion_number",
    "body": [
      "/// 転倒数 #{(i, j) | i < j and xs[i] > xs[j]} を求める",
      "/// 計算量: O(m log m + n)",
      "/// (m = max(xs), n = xs.len())",
      "pub fn inversion_number(xs: &[usize]) -> i64 {",
      "    use ac_library::FenwickTree;",
      "    if xs.is_empty() {",
      "        return 0;",
      "    }",
      "    let max_val = xs.iter().copied().max().unwrap();",
      "    let mut fenwick = FenwickTree::new(max_val + 1, 0_i64);",
      "    let mut cnt = 0;",
      "    for &x in xs {",
      "        cnt += fenwick.sum(x + 1..);",
      "        fenwick.add(x, 1);",
      "    }",
      "    cnt",
      "}"
    ]
  },
  "is_bipartite_graph": {
    "scope": "rust",
    "prefix": "is_bipartite_graph",
    "body": [
      "use mod_queue::*;",
      "pub mod mod_queue {",
      "    use std::collections::VecDeque;",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Queue<T> {",
      "        raw: VecDeque<T>,",
      "    }",
      "    impl<T> Queue<T> {",
      "        pub fn new() -> Self {",
      "            Queue {",
      "                raw: VecDeque::new(),",
      "            }",
      "        }",
      "        pub fn push(&mut self, value: T) {",
      "            self.raw.push_back(value)",
      "        }",
      "        pub fn pop(&mut self) -> Option<T> {",
      "            self.raw.pop_front()",
      "        }",
      "        pub fn peek(&self) -> Option<&T> {",
      "            self.raw.front()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.raw.len()",
      "        }",
      "    }",
      "    impl<T> Default for Queue<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::collapsible_else_if)]",
      "pub fn is_bipartite_graph(adj: &[Vec<usize>]) -> bool {",
      "    let n_vertex = adj.len();",
      "    let mut visited = vec![false; n_vertex];",
      "    let mut odd_even_list = vec![-1; n_vertex];",
      "    for init in 0..n_vertex {",
      "        if visited[init] {",
      "            continue;",
      "        }",
      "        let mut open: Queue<usize> = Queue::new();",
      "        open.push(init);",
      "        visited[init] = true;",
      "        odd_even_list[init] = 0;",
      "        while let Some(current) = open.pop() {",
      "            for &next in &adj[current] {",
      "                if !visited[next] {",
      "                    visited[next] = true;",
      "                    open.push(next);",
      "                    odd_even_list[next] = 1 - odd_even_list[current];",
      "                } else {",
      "                    if odd_even_list[current] == odd_even_list[next] {",
      "                        return false;",
      "                    }",
      "                }",
      "            }",
      "        }",
      "    }",
      "    true",
      "}"
    ]
  },
  "is_bipartite_graph_by_uf": {
    "scope": "rust",
    "prefix": "is_bipartite_graph_by_uf",
    "body": [
      "pub fn is_bipartite_graph_by_uf(n_vertex: usize, edges: &[(usize, usize)]) -> bool {",
      "    use petgraph::unionfind::UnionFind;",
      "    let mut uf = UnionFind::new(2 * n_vertex);",
      "    for &(from, to) in edges {",
      "        uf.union(from, to + n_vertex);",
      "        uf.union(from + n_vertex, to);",
      "    }",
      "    (0..n_vertex).all(|i| !uf.equiv(i, i + n_vertex))",
      "}"
    ]
  },
  "is_prime": {
    "scope": "rust",
    "prefix": "is_prime",
    "body": [
      "/// 計算量: O(sqrt(n))",
      "pub fn is_prime(n: i64) -> bool {",
      "    use num::Integer;",
      "    use num_integer::Roots;",
      "    if n <= 1 {",
      "        return false;",
      "    }",
      "    for i in 2..=n.sqrt() {",
      "        if n.is_multiple_of(&i) {",
      "            return false;",
      "        }",
      "    }",
      "    true",
      "}"
    ]
  },
  "lazy_segtree_to_vec": {
    "scope": "rust",
    "prefix": "lazy_segtree_to_vec",
    "body": [
      "pub fn lazy_segtree_to_vec<F: ac_library::MapMonoid>(",
      "    seg: &mut ac_library::LazySegtree<F>,",
      "    len: usize,",
      ") -> Vec<<F::M as ac_library::Monoid>::S> {",
      "    (0..len).map(|i| seg.get(i)).collect()",
      "}"
    ]
  },
  "lca": {
    "scope": "rust",
    "prefix": "lca",
    "body": [
      "use lca::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod lca {",
      "    use ac_library::{Monoid, Segtree};",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    pub struct MinI64Usize(Infallible);",
      "    impl Monoid for MinI64Usize {",
      "        type S = (i64, usize);",
      "        fn identity() -> Self::S {",
      "            (i64::MAX, usize::MAX)",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            std::cmp::min(*a, *b)",
      "        }",
      "    }",
      "    pub struct Lca {",
      "        dist: Vec<i64>,",
      "        euler_tour_dist: Segtree<MinI64Usize>,",
      "        euler_tour_in_time: Vec<usize>,",
      "        #[allow(dead_code)]",
      "        euler_tour_out_time: Vec<usize>,",
      "    }",
      "    impl Lca {",
      "        /// tree_parent[i]: i の 親 を表す。根の場合は tree_parent[i] == i",
      "        /// 計算量: O(nv log(nv)) (nv は頂点の数とする)",
      "        pub fn new(tree_parent: &[usize]) -> Self {",
      "            let nv = tree_parent.len();",
      "            let tree_children = tree_parent.iter().copied().enumerate().fold(",
      "                vec![vec![]; nv],",
      "                |mut acc, (child, parent)| {",
      "                    if child != parent {",
      "                        acc[parent].push(child);",
      "                    }",
      "                    acc",
      "                },",
      "            );",
      "            let root = (0..nv).find(|&v| tree_parent[v] == v).unwrap();",
      "            let dist = {",
      "                fn dfs(dist: &mut [i64], current: usize, tree_children: &[Vec<usize>]) {",
      "                    for &child in &tree_children[current] {",
      "                        dist[child] = dist[current] + 1;",
      "                        dfs(dist, child, tree_children);",
      "                    }",
      "                }",
      "                let mut dist = vec![0; nv];",
      "                dfs(&mut dist, root, &tree_children);",
      "                dist",
      "            };",
      "            let (euler_tour, euler_tour_in_time, euler_tour_out_time) = {",
      "                fn dfs(",
      "                    tour: &mut Vec<usize>,",
      "                    in_time: &mut [usize],",
      "                    out_time: &mut [usize],",
      "                    current: usize,",
      "                    tree_children: &[Vec<usize>],",
      "                ) {",
      "                    in_time[current] = in_time[current].min(tour.len());",
      "                    out_time[current] = out_time[current].max(tour.len());",
      "                    tour.push(current);",
      "                    for &child in &tree_children[current] {",
      "                        dfs(tour, in_time, out_time, child, tree_children);",
      "                        in_time[current] = in_time[current].min(tour.len());",
      "                        out_time[current] = out_time[current].max(tour.len());",
      "                        tour.push(current);",
      "                    }",
      "                }",
      "                let mut tour = vec![];",
      "                let mut in_time = vec![usize::MAX; nv];",
      "                let mut out_time = vec![usize::MIN; nv];",
      "                dfs(&mut tour, &mut in_time, &mut out_time, root, &tree_children);",
      "                (tour, in_time, out_time)",
      "            };",
      "            let euler_tour_dist = Segtree::<MinI64Usize>::from(",
      "                euler_tour",
      "                    .iter()",
      "                    .copied()",
      "                    .map(|v| (dist[v], v))",
      "                    .collect_vec(),",
      "            );",
      "            Lca {",
      "                dist,",
      "                euler_tour_dist,",
      "                euler_tour_in_time,",
      "                euler_tour_out_time,",
      "            }",
      "        }",
      "        /// u と v の LCA を求める",
      "        /// 計算量 O(log(頂点の数))",
      "        pub fn lca(&self, u: usize, v: usize) -> usize {",
      "            let (time_min, time_max) = {",
      "                use std::cmp::{max, min};",
      "                let t1 = self.euler_tour_in_time[u];",
      "                let t2 = self.euler_tour_in_time[v];",
      "                (min(t1, t2), max(t1, t2))",
      "            };",
      "            self.euler_tour_dist.prod(time_min..=time_max).1",
      "        }",
      "        /// 計算量: O(log(頂点の数))",
      "        pub fn dist(&self, u: usize, v: usize) -> i64 {",
      "            self.dist[u] + self.dist[v] - 2 * self.dist[self.lca(u, v)]",
      "        }",
      "        /// パス u-v 上に点 a があるかどうか",
      "        /// 計算量: O(log(頂点の数))",
      "        pub fn is_path_on(&self, u: usize, v: usize, a: usize) -> bool {",
      "            self.dist(u, a) + self.dist(a, v) == self.dist(u, v)",
      "        }",
      "    }",
      "}"
    ]
  },
  "lg": {
    "scope": "rust",
    "prefix": "lg",
    "body": [
      "use lg::*;",
      "pub mod lg {",
      "    use std::borrow::Borrow;",
      "    use std::fmt;",
      "    use std::iter::once;",
      "    /// Print the values with the line number.",
      "    /// # Examples",
      "    /// ```rust",
      "    /// # use lg::*;",
      "    /// let x = 42;",
      "    /// let y = 43;",
      "    /// lg!(x);",
      "    /// lg!(x, y);",
      "    /// lg!(42, x, 43, y);",
      "    /// ```",
      "    #[macro_export]",
      "    macro_rules ! lg {(@ contents \\$ head : expr \\$ (, \\$ tail : expr ) * ) => {{\\$ crate :: __lg_internal ! (\\$ head ) ; \\$ (eprint ! (\",\" ) ; \\$ crate :: __lg_internal ! (\\$ tail ) ; ) * eprintln ! () ; } } ; (\\$ (\\$ expr : expr ) ,* \\$ (, ) ? ) => {{eprint ! (\"{}\\u{276f}\" , line ! () ) ; \\$ crate :: lg ! (@ contents \\$ (\\$ expr ) ,* ) } } ; }",
      "    #[doc(hidden)]",
      "    #[macro_export]",
      "    macro_rules! __lg_internal {",
      "        (\\$ value : expr ) => {{",
      "            match \\$value {",
      "                head => {",
      "                    eprint!(",
      "                        \" {} = {}\",",
      "                        stringify!(\\$value),",
      "                        \\$crate::__quiet(format!(\"{:?}\", &head))",
      "                    );",
      "                }",
      "            }",
      "        }};",
      "    }",
      "    /// Print many 1D arrays side-by-side with the line number.",
      "    /// # Examples",
      "    /// ```rust",
      "    /// # use lg::*;",
      "    /// let a = [1, 2, 3];",
      "    /// let b = [4, 5, 6];",
      "    /// let c = [7, 8, 9];",
      "    /// rows! {",
      "    ///   \"id\", // the name of the index",
      "    ///   @\"a\" => a,",
      "    ///   b,",
      "    ///   @\"c\" => c,",
      "    /// }",
      "    /// ```",
      "    #[macro_export]",
      "    macro_rules ! rows {{\\$ index_label : literal , \\$ (@ offset \\$ offset : expr , ) ? \\$ (@ verticalbar \\$ verticalbar : expr , ) * \\$ (\\$ (@\\$ label : literal => ) ? \\$ values : expr ) ,* \\$ (, ) ? } => {{#! [allow (unused_assignments ) ] let mut rows = \\$ crate :: Rows :: default () ; rows . line_number (line ! () ) ; \\$ (rows . offset (\\$ offset ) ; ) ? \\$ (rows . verticalbar (\\$ verticalbar ) ; ) * rows . index_label (\\$ index_label ) ; \\$ ({let mut label = stringify ! (\\$ values ) . to_string () ; if label . starts_with (\"&\" ) {label = label [1 .. ] . to_string () ; } \\$ ({let label_ : &'static str = \\$ label ; label = label_ . to_string () ; } ) ? rows . row (label , \\$ values ) ; } ) * eprintln ! (\"{}\" , rows . to_string_table () ) ; } } ; }",
      "    /// Print the 2D array with the line number.",
      "    /// # Examples",
      "    /// ```rust",
      "    /// # use lg::*;",
      "    /// let a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];",
      "    /// table! {",
      "    ///    @\"a\" => a,",
      "    /// }",
      "    /// table! {",
      "    ///   a,",
      "    /// }",
      "    /// ```",
      "    #[macro_export]",
      "    macro_rules ! table {{\\$ (@\\$ name : literal => ) ? \\$ values : expr \\$ (, ) ? } => {{#! [allow (unused_assignments ) ] let mut name = stringify ! (\\$ values ) . to_string () ; if name . starts_with (\"&\" ) {name = name [1 .. ] . to_string () ; } \\$ ({let name_ : &'static str = \\$ name ; name = name_ . to_string () ; } ) ? let mut rows = \\$ crate :: Rows :: default () ; rows . line_number (line ! () ) ; rows . table_name (name ) ; # [allow (array_into_iter ) ] for (i , row ) in \\$ values . into_iter () . enumerate () {rows . row (i . to_string () , row ) ; } eprintln ! (\"{}\" , rows . to_string_table () ) ; } } ; }",
      "    #[doc(hidden)]",
      "    pub fn __quiet(s: impl AsRef<str>) -> String {",
      "        s.as_ref()",
      "            .replace(\"340282366920938463463374607431768211455\", \"*\")",
      "            .replace(\"170141183460469231731687303715884105727\", \"*\")",
      "            .replace(\"18446744073709551615\", \"*\")",
      "            .replace(\"9223372036854775807\", \"*\")",
      "            .replace(\"-9223372036854775808\", \"*\")",
      "            .replace(\"4294967295\", \"*\")",
      "            .replace(\"2147483647\", \"*\")",
      "            .replace(\"-2147483648\", \"*\")",
      "            .replace(\"None\", \"*\")",
      "            .replace(\"Some\", \"\")",
      "            .replace(\"true\", \"#\")",
      "            .replace(\"false\", \".\")",
      "            .replace(['\"', '\\''], \"\")",
      "    }",
      "    #[doc(hidden)]",
      "    #[derive(Default)]",
      "    pub struct Rows {",
      "        line_number: String,",
      "        index_label: String,",
      "        offset: usize,",
      "        verticalbars: Vec<usize>,",
      "        table_name: String,",
      "        rows: Vec<Row>,",
      "    }",
      "    impl Rows {",
      "        pub fn line_number(&mut self, line_number: u32) -> &mut Self {",
      "            self.line_number = format!(\"{}\", line_number);",
      "            self",
      "        }",
      "        pub fn index_label(&mut self, index_label: impl Into<String>) -> &mut Self {",
      "            self.index_label = index_label.into();",
      "            self",
      "        }",
      "        pub fn offset(&mut self, offset: usize) -> &mut Self {",
      "            self.offset = offset;",
      "            self",
      "        }",
      "        pub fn verticalbar(&mut self, verticalbar: impl IntoIterator<Item = usize>) -> &mut Self {",
      "            self.verticalbars.extend(verticalbar);",
      "            self",
      "        }",
      "        pub fn table_name(&mut self, table_name: impl Into<String>) -> &mut Self {",
      "            self.table_name = table_name.into();",
      "            self",
      "        }",
      "        pub fn row(",
      "            &mut self,",
      "            label: impl Into<String>,",
      "            values: impl IntoIterator<Item = impl fmt::Debug>,",
      "        ) -> &mut Self {",
      "            self.rows.push(Row {",
      "                label: label.into(),",
      "                values: values",
      "                    .into_iter()",
      "                    .map(|value| __quiet(format!(\"{:?}\", value)))",
      "                    .collect(),",
      "            });",
      "            self",
      "        }",
      "        pub fn to_string_table(self) -> StringTable {",
      "            let Self {",
      "                line_number,",
      "                index_label,",
      "                offset,",
      "                verticalbars,",
      "                table_name,",
      "                rows,",
      "            } = self;",
      "            let w = rows",
      "                .iter()",
      "                .map(|row| row.values.len())",
      "                .max()",
      "                .unwrap_or_default();",
      "            let mut verticalbar_count = vec![0; w + 1];",
      "            for &v in &verticalbars {",
      "                if (offset..=offset + w).contains(&v) {",
      "                    verticalbar_count[v - offset] += 1;",
      "                }",
      "            }",
      "            StringTable {",
      "                head: StringRow {",
      "                    label: format!(",
      "                        \"{line_number}❯ {table_name}{index_label}\",",
      "                        index_label = if index_label.is_empty() {",
      "                            String::new()",
      "                        } else {",
      "                            format!(\"[{}]\", index_label)",
      "                        }",
      "                    ),",
      "                    values: (offset..offset + w)",
      "                        .map(|index| index.to_string())",
      "                        .collect(),",
      "                },",
      "                body: rows",
      "                    .iter()",
      "                    .map(|row| StringRow {",
      "                        label: row.label.clone(),",
      "                        values: row.values.clone(),",
      "                    })",
      "                    .collect(),",
      "                verticalbar_count,",
      "            }",
      "        }",
      "    }",
      "    struct Row {",
      "        label: String,",
      "        values: Vec<String>,",
      "    }",
      "    #[doc(hidden)]",
      "    pub struct StringTable {",
      "        head: StringRow,",
      "        body: Vec<StringRow>,",
      "        verticalbar_count: Vec<usize>,",
      "    }",
      "    impl fmt::Display for StringTable {",
      "        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "            let Self {",
      "                head,",
      "                body,",
      "                verticalbar_count,",
      "            } = self;",
      "            let w = body",
      "                .iter()",
      "                .map(|row| row.values.len())",
      "                .max()",
      "                .unwrap_or_default();",
      "            let label_width = once(head.label.chars().count())",
      "                .chain(body.iter().map(|row| row.label.chars().count()))",
      "                .max()",
      "                .unwrap();",
      "            let value_width = (0..w)",
      "                .map(|j| {",
      "                    once(j.to_string().len())",
      "                        .chain(",
      "                            body.iter()",
      "                                .map(|row| row.values.get(j).map_or(0, |s| s.chars().count())),",
      "                        )",
      "                        .max()",
      "                        .unwrap()",
      "                })",
      "                .collect::<Vec<_>>();",
      "            gray(f)?;",
      "            write!(",
      "                f,",
      "                \"{}\",",
      "                head.to_string(label_width, &value_width, verticalbar_count, true)",
      "            )?;",
      "            resetln(f)?;",
      "            for row in body {",
      "                write!(",
      "                    f,",
      "                    \"{}\",",
      "                    row.to_string(label_width, &value_width, verticalbar_count, false)",
      "                )?;",
      "                writeln!(f)?;",
      "            }",
      "            Ok(())",
      "        }",
      "    }",
      "    struct StringRow {",
      "        label: String,",
      "        values: Vec<String>,",
      "    }",
      "    impl StringRow {",
      "        fn to_string(",
      "            &self,",
      "            label_width: usize,",
      "            value_width: &[usize],",
      "            varticalbars_count: &[usize],",
      "            label_align_left: bool,",
      "        ) -> String {",
      "            let Self { label, values } = self;",
      "            let w = value_width.len();",
      "            let mut s = String::new();",
      "            s.push_str(&if label_align_left {",
      "                format!(\"{label:<label_width\\$} |\")",
      "            } else {",
      "                format!(\"{label:^label_width\\$} |\")",
      "            });",
      "            for j in 0..w {",
      "                let value_width = value_width[j];",
      "                s.push_str(\"|\".repeat(varticalbars_count[j]).as_str());",
      "                if varticalbars_count[j] == 0 && j != 0 && value_width <= 1 {",
      "                    s.push(' ');",
      "                }",
      "                match values.get(j) {",
      "                    Some(value) => {",
      "                        s.push_str(&format!(\" {value:>value_width\\$}\",));",
      "                    }",
      "                    None => {",
      "                        s.push_str(\" \".repeat(value_width + 1).as_str());",
      "                    }",
      "                }",
      "            }",
      "            s",
      "        }",
      "    }",
      "    const GRAY: &str = \"\\x1b[48;2;127;127;127;37m\";",
      "    const RESET: &str = \"\\x1b[0m\";",
      "    fn gray(f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "        write!(f, \"{GRAY}\")",
      "    }",
      "    fn resetln(f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "        writeln!(f, \"{RESET}\")",
      "    }",
      "    /// Format a iterator of [`bool`]s.",
      "    pub fn bools<B, I>(iter: I) -> String",
      "    where",
      "        B: Borrow<bool>,",
      "        I: IntoIterator<Item = B>,",
      "    {",
      "        format!(",
      "            \"[{}]\",",
      "            iter.into_iter()",
      "                .map(|b| ['.', '#'][usize::from(*(b.borrow()))])",
      "                .collect::<String>(),",
      "        )",
      "    }",
      "}"
    ]
  },
  "lower_bound": {
    "scope": "rust",
    "prefix": "lower_bound",
    "body": [
      "/// 二分探索をする",
      "/// ```text",
      "/// ng ng ng ok ok ok",
      "///          ↑ここの引数の値を返す",
      "/// ```",
      "/// 計算量: O(log(|ok - ng|))",
      "/// ## Arguments",
      "/// * ok != ng",
      "/// * |ok - ng| <= 2^63 - 1, |ok + ng| <= 2^63 - 1",
      "/// * p の定義域について",
      "///     * ng < ok の場合、p は区間 ng..ok で定義されている。",
      "///     * ok < ng の場合、p は区間 ok..ng で定義されている。",
      "/// * p の単調性について",
      "///     * ng < ok の場合、p は単調増加",
      "///     * ok < ng の場合、p は単調減少",
      "/// ## Return",
      "/// * ng < ok の場合: I = { i in ng..ok | p(i) == true } としたとき",
      "///     * I が空でなければ、min I を返す。",
      "///     * I が空ならば、ok を返す。",
      "/// * ok < ng の場合: I = { i in ok..ng | p(i) == true } としたとき",
      "///     * I が空でなければ、max I を返す。",
      "///     * I が空ならば、ok を返す。",
      "pub fn bin_search<F>(mut ok: i64, mut ng: i64, mut p: F) -> i64",
      "where",
      "    F: FnMut(i64) -> bool,",
      "{",
      "    debug_assert!(ok != ng);",
      "    debug_assert!(ok.checked_sub(ng).is_some());",
      "    debug_assert!(ok.checked_add(ng).is_some());",
      "    while num::abs(ok - ng) > 1 {",
      "        let mid = (ok + ng) / 2;",
      "        debug_assert!(mid != ok);",
      "        debug_assert!(mid != ng);",
      "        if p(mid) {",
      "            ok = mid;",
      "        } else {",
      "            ng = mid;",
      "        }",
      "    }",
      "    ok",
      "}",
      "/// 指定された要素以上の値が現れる最初の位置を返す。",
      "/// 計算量: O(log(|xs|))",
      "/// ## Arguments",
      "/// * xs: 単調増加",
      "///     * 単調増加でなくても、 `|i| xs[i] >= key` が単調ならOK",
      "/// ## Return",
      "/// `I = {i in 0..xs.len() | xs[i] >= key}` としたとき、`min I` を返す。",
      "/// ただし、`I` が空の場合は `xs.len()` を返す",
      "/// 戻り値は、区間 `0..=xs.len()` の間で返る。",
      "pub fn lower_bound<T: PartialOrd>(xs: &[T], key: T) -> usize {",
      "    let pred = |i: i64| xs[i as usize] >= key;",
      "    bin_search(xs.len() as i64, -1_i64, pred) as usize",
      "}"
    ]
  },
  "lower_bound_dec": {
    "scope": "rust",
    "prefix": "lower_bound_dec",
    "body": [
      "/// 二分探索をする",
      "/// ```text",
      "/// ng ng ng ok ok ok",
      "///          ↑ここの引数の値を返す",
      "/// ```",
      "/// 計算量: O(log(|ok - ng|))",
      "/// ## Arguments",
      "/// * ok != ng",
      "/// * |ok - ng| <= 2^63 - 1, |ok + ng| <= 2^63 - 1",
      "/// * p の定義域について",
      "///     * ng < ok の場合、p は区間 ng..ok で定義されている。",
      "///     * ok < ng の場合、p は区間 ok..ng で定義されている。",
      "/// * p の単調性について",
      "///     * ng < ok の場合、p は単調増加",
      "///     * ok < ng の場合、p は単調減少",
      "/// ## Return",
      "/// * ng < ok の場合: I = { i in ng..ok | p(i) == true } としたとき",
      "///     * I が空でなければ、min I を返す。",
      "///     * I が空ならば、ok を返す。",
      "/// * ok < ng の場合: I = { i in ok..ng | p(i) == true } としたとき",
      "///     * I が空でなければ、max I を返す。",
      "///     * I が空ならば、ok を返す。",
      "pub fn bin_search<F>(mut ok: i64, mut ng: i64, mut p: F) -> i64",
      "where",
      "    F: FnMut(i64) -> bool,",
      "{",
      "    debug_assert!(ok != ng);",
      "    debug_assert!(ok.checked_sub(ng).is_some());",
      "    debug_assert!(ok.checked_add(ng).is_some());",
      "    while num::abs(ok - ng) > 1 {",
      "        let mid = (ok + ng) / 2;",
      "        debug_assert!(mid != ok);",
      "        debug_assert!(mid != ng);",
      "        if p(mid) {",
      "            ok = mid;",
      "        } else {",
      "            ng = mid;",
      "        }",
      "    }",
      "    ok",
      "}",
      "/// 指定された要素以下の値が現れる最初の位置を返す。",
      "/// 計算量: O(log(|xs|))",
      "/// ## Arguments",
      "/// * xs: 単調減少",
      "///     * 単調減少でなくても、 `|i| xs[i] <= key` が単調ならOK",
      "/// ## Return",
      "/// `I = {i in 0..xs.len() | xs[i] <= key}` としたとき、`min I` を返す。",
      "/// ただし、`I` が空の場合は `xs.len()` を返す",
      "/// 戻り値は、区間 `0..=xs.len()` の間で返る。",
      "pub fn lower_bound_dec<T: PartialOrd>(xs: &[T], key: T) -> usize {",
      "    let pred = |i: i64| xs[i as usize] <= key;",
      "    bin_search(xs.len() as i64, -1_i64, pred) as usize",
      "}"
    ]
  },
  "make_adj_from_directed": {
    "scope": "rust",
    "prefix": "make_adj_from_directed",
    "body": [
      "pub fn make_adj_from_directed(n_vertex: usize, edges: &[(usize, usize)]) -> Vec<Vec<usize>> {",
      "    let mut adj = vec![vec![]; n_vertex];",
      "    for &(from, to) in edges {",
      "        adj[from].push(to);",
      "    }",
      "    adj",
      "}"
    ]
  },
  "make_adj_from_undirected": {
    "scope": "rust",
    "prefix": "make_adj_from_undirected",
    "body": [
      "pub fn make_adj_from_undirected(n_vertex: usize, edges: &[(usize, usize)]) -> Vec<Vec<usize>> {",
      "    let mut adj = vec![vec![]; n_vertex];",
      "    for &(from, to) in edges {",
      "        adj[from].push(to);",
      "        adj[to].push(from);",
      "    }",
      "    adj",
      "}"
    ]
  },
  "make_adj_from_weighted_directed": {
    "scope": "rust",
    "prefix": "make_adj_from_weighted_directed",
    "body": [
      "pub fn make_adj_from_weighted_directed<T>(",
      "    n_vertex: usize,",
      "    edges: &[(usize, usize, T)],",
      ") -> Vec<Vec<(usize, T)>>",
      "where",
      "    T: Clone,",
      "{",
      "    let mut adj = vec![vec![]; n_vertex];",
      "    for (from, to, weight) in edges {",
      "        adj[*from].push((*to, weight.clone()));",
      "    }",
      "    adj",
      "}"
    ]
  },
  "make_adj_from_weighted_undirected": {
    "scope": "rust",
    "prefix": "make_adj_from_weighted_undirected",
    "body": [
      "pub fn make_adj_from_weighted_undirected<T>(",
      "    n_vertex: usize,",
      "    edges: &[(usize, usize, T)],",
      ") -> Vec<Vec<(usize, T)>>",
      "where",
      "    T: Clone,",
      "{",
      "    let mut adj = vec![vec![]; n_vertex];",
      "    for (from, to, weight) in edges {",
      "        adj[*from].push((*to, weight.clone()));",
      "        adj[*to].push((*from, weight.clone()));",
      "    }",
      "    adj",
      "}"
    ]
  },
  "map_monoid_template": {
    "scope": "rust",
    "prefix": "map_monoid_template",
    "body": [
      "use map_monoid_template::*;",
      "#[allow(unused_variables)]",
      "pub mod map_monoid_template {",
      "    use ac_library::lazysegtree::MapMonoid;",
      "    use ac_library::segtree::Monoid;",
      "    use std::convert::Infallible;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct RangeXxx {",
      "        pub len: usize,",
      "    }",
      "    impl RangeXxx {",
      "        pub fn unit(x: i64) -> Self {",
      "            Self { len: 1 }",
      "        }",
      "    }",
      "    pub struct RangeXxxMonoid(Infallible);",
      "    impl Monoid for RangeXxxMonoid {",
      "        type S = RangeXxx;",
      "        fn identity() -> Self::S {",
      "            RangeXxx { len: 0 }",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            RangeXxx { len: a.len + b.len }",
      "        }",
      "    }",
      "    pub struct RangeYyyRangeXxx(Infallible);",
      "    impl MapMonoid for RangeYyyRangeXxx {",
      "        type M = RangeXxxMonoid;",
      "        type F = ();",
      "        fn identity_map() -> Self::F {}",
      "        fn mapping(",
      "            f: &Self::F,",
      "            x: &<Self::M as ac_library::Monoid>::S,",
      "        ) -> <Self::M as ac_library::Monoid>::S {",
      "            RangeXxx { len: x.len }",
      "        }",
      "        fn composition(f: &Self::F, g: &Self::F) -> Self::F {}",
      "    }",
      "}"
    ]
  },
  "matrix22": {
    "scope": "rust",
    "prefix": "matrix22",
    "body": [
      "use matrix22::*;",
      "pub mod matrix22 {",
      "    use ac_library::Monoid;",
      "    use core::fmt::Debug;",
      "    use std::{",
      "        convert::Infallible,",
      "        iter::{Product, Sum},",
      "        marker::PhantomData,",
      "        ops::{Add, Mul},",
      "    };",
      "    #[derive(Clone, Copy, Debug, PartialEq)]",
      "    pub struct Matrix22<T>",
      "    where",
      "        T: Clone + Copy + Debug + PartialEq,",
      "    {",
      "        pub raw: [[T; 2]; 2],",
      "    }",
      "    impl<T> Matrix22<T>",
      "    where",
      "        T: Clone + Copy + Debug + PartialEq,",
      "    {",
      "        pub fn new(a00: T, a01: T, a10: T, a11: T) -> Self {",
      "            Self {",
      "                raw: [[a00, a01], [a10, a11]],",
      "            }",
      "        }",
      "        pub fn from_array(arr: [[T; 2]; 2]) -> Self {",
      "            Self { raw: arr }",
      "        }",
      "        pub fn apply(self, x: (T, T)) -> (T, T)",
      "        where",
      "            T: Add<Output = T> + Mul<Output = T>,",
      "        {",
      "            (",
      "                self.raw[0][0] * x.0 + self.raw[0][1] * x.1,",
      "                self.raw[1][0] * x.0 + self.raw[1][1] * x.1,",
      "            )",
      "        }",
      "        fn t_zero() -> T",
      "        where",
      "            T: Sum,",
      "        {",
      "            std::iter::empty().sum()",
      "        }",
      "        fn t_one() -> T",
      "        where",
      "            T: Product,",
      "        {",
      "            std::iter::empty().product()",
      "        }",
      "        pub fn identity() -> Self",
      "        where",
      "            T: Sum + Product,",
      "        {",
      "            Matrix22::from_array([",
      "                [Self::t_one(), Self::t_zero()],",
      "                [Self::t_zero(), Self::t_one()],",
      "            ])",
      "        }",
      "    }",
      "    impl<T> Add for Matrix22<T>",
      "    where",
      "        T: Clone + Copy + Debug + PartialEq + Add<Output = T>,",
      "    {",
      "        type Output = Matrix22<T>;",
      "        fn add(self, rhs: Self) -> Self::Output {",
      "            Matrix22::from_array([",
      "                [",
      "                    self.raw[0][0] + rhs.raw[0][0],",
      "                    self.raw[0][1] + rhs.raw[0][1],",
      "                ],",
      "                [",
      "                    self.raw[1][0] + rhs.raw[1][0],",
      "                    self.raw[1][1] + rhs.raw[1][1],",
      "                ],",
      "            ])",
      "        }",
      "    }",
      "    impl<T> Mul for Matrix22<T>",
      "    where",
      "        T: Clone + Copy + Debug + PartialEq + Add<Output = T> + Mul<Output = T>,",
      "    {",
      "        type Output = Matrix22<T>;",
      "        fn mul(self, rhs: Self) -> Self::Output {",
      "            Matrix22::from_array([",
      "                [",
      "                    self.raw[0][0] * rhs.raw[0][0] + self.raw[0][1] * rhs.raw[1][0],",
      "                    self.raw[0][0] * rhs.raw[0][1] + self.raw[0][1] * rhs.raw[1][1],",
      "                ],",
      "                [",
      "                    self.raw[1][0] * rhs.raw[0][0] + self.raw[1][1] * rhs.raw[1][0],",
      "                    self.raw[1][0] * rhs.raw[0][1] + self.raw[1][1] * rhs.raw[1][1],",
      "                ],",
      "            ])",
      "        }",
      "    }",
      "    pub struct Matrix22Mul<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for Matrix22Mul<T>",
      "    where",
      "        T: Clone + Copy + Debug + PartialEq + Sum + Product + Add<Output = T> + Mul<Output = T>,",
      "    {",
      "        type S = Matrix22<T>;",
      "        fn identity() -> Self::S {",
      "            Matrix22::identity()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            (*a) * (*b)",
      "        }",
      "    }",
      "}"
    ]
  },
  "mex": {
    "scope": "rust",
    "prefix": "mex",
    "body": [
      "/// 計算量: O(xs.len())",
      "pub fn mex(xs: &[usize]) -> usize {",
      "    let contains = xs",
      "        .iter()",
      "        .copied()",
      "        .fold(vec![false; xs.len()], |mut acc, x| {",
      "            if x < xs.len() {",
      "                acc[x] |= true;",
      "            }",
      "            acc",
      "        });",
      "    contains",
      "        .iter()",
      "        .copied()",
      "        .position(|p| !p)",
      "        .unwrap_or(xs.len())",
      "}"
    ]
  },
  "mod_combinatorics": {
    "scope": "rust",
    "prefix": "mod_combinatorics",
    "body": [
      "use mod_combinatorics::*;",
      "pub mod mod_combinatorics {",
      "    use ac_library::ModInt998244353 as Mint;",
      "    pub struct Comb {",
      "        fac: Vec<Mint>,",
      "        invfac: Vec<Mint>,",
      "    }",
      "    impl Comb {",
      "        pub fn new(max_val: usize) -> Self {",
      "            let mut inv = vec![Mint::new(0); max_val + 1];",
      "            let mut fac = vec![Mint::new(0); max_val + 1];",
      "            let mut invfac = vec![Mint::new(0); max_val + 1];",
      "            fac[0] = 1.into();",
      "            fac[1] = 1.into();",
      "            invfac[0] = 1.into();",
      "            invfac[1] = 1.into();",
      "            inv[1] = 1.into();",
      "            let modulus = Mint::modulus() as usize;",
      "            for i in 2..=max_val {",
      "                inv[i] = -inv[modulus % i] * Mint::new(modulus / i);",
      "                fac[i] = fac[i - 1] * Mint::new(i);",
      "                invfac[i] = invfac[i - 1] * inv[i];",
      "            }",
      "            Self { fac, invfac }",
      "        }",
      "        pub fn comb(&self, n: usize, k: usize) -> Mint {",
      "            if n < k {",
      "                0.into()",
      "            } else {",
      "                self.fac[n] * self.invfac[k] * self.invfac[n - k]",
      "            }",
      "        }",
      "        pub fn perm(&self, n: usize, k: usize) -> Mint {",
      "            if n < k {",
      "                0.into()",
      "            } else {",
      "                self.fac[n] * self.invfac[n - k]",
      "            }",
      "        }",
      "        pub fn factorial(&self, n: usize) -> Mint {",
      "            self.fac[n]",
      "        }",
      "        pub fn inv_factorial(&self, n: usize) -> Mint {",
      "            self.invfac[n]",
      "        }",
      "    }",
      "}"
    ]
  },
  "mod_ext_int": {
    "scope": "rust",
    "prefix": "mod_ext_int",
    "body": [
      "use mod_ext_int::*;",
      "pub mod mod_ext_int {",
      "    use ac_library::Monoid;",
      "    use std::{",
      "        cmp::Ordering,",
      "        convert::Infallible,",
      "        fmt,",
      "        ops::{Add, AddAssign, Sub, SubAssign},",
      "    };",
      "    pub const INF: ExtInt = ExtInt::INF;",
      "    pub fn fin(x: i64) -> ExtInt {",
      "        ExtInt::fin(x)",
      "    }",
      "    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]",
      "    pub struct ExtInt(i64);",
      "    impl ExtInt {",
      "        pub const INF: Self = Self(i64::MAX);",
      "        pub fn fin(x: i64) -> Self {",
      "            Self(x)",
      "        }",
      "        pub fn get_fin(self) -> i64 {",
      "            if self.is_fin() {",
      "                self.0",
      "            } else {",
      "                panic!(\"called `ExtInt::get_fin()` on a infinity\")",
      "            }",
      "        }",
      "        pub fn get_fin_or(self, default: i64) -> i64 {",
      "            if self.is_fin() {",
      "                self.0",
      "            } else {",
      "                default",
      "            }",
      "        }",
      "        #[inline]",
      "        pub fn is_fin(self) -> bool {",
      "            self.0 != i64::MAX",
      "        }",
      "        pub fn is_inf(self) -> bool {",
      "            self.0 == i64::MAX",
      "        }",
      "        pub fn to_option(self) -> Option<i64> {",
      "            if self.is_fin() {",
      "                Some(self.0)",
      "            } else {",
      "                None",
      "            }",
      "        }",
      "        pub fn from_option(opt: Option<i64>) -> ExtInt {",
      "            match opt {",
      "                Some(a) => Self(a),",
      "                None => Self::INF,",
      "            }",
      "        }",
      "        pub fn times(self, t: i64) -> Self {",
      "            match t.cmp(&0) {",
      "                Ordering::Less => panic!(\"t must be non-negative.\"),",
      "                Ordering::Equal => Self(0),",
      "                Ordering::Greater => {",
      "                    if self.is_fin() {",
      "                        Self(self.0 * t)",
      "                    } else {",
      "                        Self::INF",
      "                    }",
      "                }",
      "            }",
      "        }",
      "    }",
      "    impl Add for ExtInt {",
      "        type Output = ExtInt;",
      "        fn add(self, rhs: Self) -> Self::Output {",
      "            if self.is_inf() || rhs.is_inf() {",
      "                Self::INF",
      "            } else {",
      "                Self::fin(self.0 + rhs.0)",
      "            }",
      "        }",
      "    }",
      "    impl AddAssign for ExtInt {",
      "        fn add_assign(&mut self, rhs: Self) {",
      "            *self = *self + rhs;",
      "        }",
      "    }",
      "    impl Add<i64> for ExtInt {",
      "        type Output = ExtInt;",
      "        fn add(self, rhs: i64) -> Self::Output {",
      "            if self.is_inf() {",
      "                Self::INF",
      "            } else {",
      "                Self::fin(self.0 + rhs)",
      "            }",
      "        }",
      "    }",
      "    impl AddAssign<i64> for ExtInt {",
      "        fn add_assign(&mut self, rhs: i64) {",
      "            *self = *self + rhs;",
      "        }",
      "    }",
      "    impl Sub<i64> for ExtInt {",
      "        type Output = ExtInt;",
      "        fn sub(self, rhs: i64) -> Self::Output {",
      "            if self.is_inf() {",
      "                Self::INF",
      "            } else {",
      "                Self::fin(self.0 - rhs)",
      "            }",
      "        }",
      "    }",
      "    impl SubAssign<i64> for ExtInt {",
      "        fn sub_assign(&mut self, rhs: i64) {",
      "            *self = *self - rhs;",
      "        }",
      "    }",
      "    impl std::iter::Sum for ExtInt {",
      "        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {",
      "            let mut s = 0;",
      "            for x in iter {",
      "                if x.is_inf() {",
      "                    return Self::INF;",
      "                }",
      "                s += x.0;",
      "            }",
      "            Self::fin(s)",
      "        }",
      "    }",
      "    impl fmt::Display for ExtInt {",
      "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
      "            if self.is_inf() {",
      "                write!(f, \"+∞\")",
      "            } else {",
      "                write!(f, \"{}\", self.0)",
      "            }",
      "        }",
      "    }",
      "    impl fmt::Debug for ExtInt {",
      "        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "            if self.is_inf() {",
      "                write!(f, \"+∞\")",
      "            } else {",
      "                write!(f, \"{}\", self.0)",
      "            }",
      "        }",
      "    }",
      "    pub struct ExtIntAdditive(Infallible);",
      "    impl Monoid for ExtIntAdditive {",
      "        type S = ExtInt;",
      "        fn identity() -> Self::S {",
      "            ExtInt::fin(0)",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a + *b",
      "        }",
      "    }",
      "    pub struct ExtIntMin(Infallible);",
      "    impl Monoid for ExtIntMin {",
      "        type S = ExtInt;",
      "        fn identity() -> Self::S {",
      "            ExtInt::INF",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a.min(b)",
      "        }",
      "    }",
      "}"
    ]
  },
  "mod_neg_ext_int": {
    "scope": "rust",
    "prefix": "mod_neg_ext_int",
    "body": [
      "use mod_neg_ext_int::*;",
      "pub mod mod_neg_ext_int {",
      "    use ac_library::Monoid;",
      "    use std::{",
      "        cmp::Ordering,",
      "        convert::Infallible,",
      "        fmt,",
      "        ops::{Add, AddAssign, Sub, SubAssign},",
      "    };",
      "    pub const NEG_INF: NegExtInt = NegExtInt::NEG_INF;",
      "    pub fn fin(x: i64) -> NegExtInt {",
      "        NegExtInt::fin(x)",
      "    }",
      "    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]",
      "    pub struct NegExtInt(i64);",
      "    impl NegExtInt {",
      "        pub const NEG_INF: Self = Self(i64::MIN);",
      "        pub fn fin(x: i64) -> Self {",
      "            Self(x)",
      "        }",
      "        pub fn get_fin(self) -> i64 {",
      "            if self.is_fin() {",
      "                self.0",
      "            } else {",
      "                panic!(\"called `NegExtInt::get_fin()` on a negative infinity\")",
      "            }",
      "        }",
      "        pub fn get_fin_or(self, default: i64) -> i64 {",
      "            if self.is_fin() {",
      "                self.0",
      "            } else {",
      "                default",
      "            }",
      "        }",
      "        #[inline]",
      "        pub fn is_fin(self) -> bool {",
      "            self.0 != i64::MIN",
      "        }",
      "        pub fn is_neg_inf(self) -> bool {",
      "            self.0 == i64::MIN",
      "        }",
      "        pub fn to_option(self) -> Option<i64> {",
      "            if self.is_fin() {",
      "                Some(self.0)",
      "            } else {",
      "                None",
      "            }",
      "        }",
      "        pub fn from_option(opt: Option<i64>) -> NegExtInt {",
      "            match opt {",
      "                Some(a) => Self(a),",
      "                None => Self::NEG_INF,",
      "            }",
      "        }",
      "        pub fn times(self, t: i64) -> Self {",
      "            match t.cmp(&0) {",
      "                Ordering::Less => panic!(\"t must be non-negative.\"),",
      "                Ordering::Equal => Self(0),",
      "                Ordering::Greater => {",
      "                    if self.is_fin() {",
      "                        Self(self.0 * t)",
      "                    } else {",
      "                        Self::NEG_INF",
      "                    }",
      "                }",
      "            }",
      "        }",
      "    }",
      "    impl Add for NegExtInt {",
      "        type Output = NegExtInt;",
      "        fn add(self, rhs: Self) -> Self::Output {",
      "            if self.is_neg_inf() || rhs.is_neg_inf() {",
      "                Self::NEG_INF",
      "            } else {",
      "                Self::fin(self.0 + rhs.0)",
      "            }",
      "        }",
      "    }",
      "    impl AddAssign for NegExtInt {",
      "        fn add_assign(&mut self, rhs: Self) {",
      "            *self = *self + rhs;",
      "        }",
      "    }",
      "    impl Add<i64> for NegExtInt {",
      "        type Output = NegExtInt;",
      "        fn add(self, rhs: i64) -> Self::Output {",
      "            if self.is_neg_inf() {",
      "                Self::NEG_INF",
      "            } else {",
      "                Self::fin(self.0 + rhs)",
      "            }",
      "        }",
      "    }",
      "    impl AddAssign<i64> for NegExtInt {",
      "        fn add_assign(&mut self, rhs: i64) {",
      "            *self = *self + rhs;",
      "        }",
      "    }",
      "    impl Sub<i64> for NegExtInt {",
      "        type Output = NegExtInt;",
      "        fn sub(self, rhs: i64) -> Self::Output {",
      "            if self.is_neg_inf() {",
      "                Self::NEG_INF",
      "            } else {",
      "                Self::fin(self.0 - rhs)",
      "            }",
      "        }",
      "    }",
      "    impl SubAssign<i64> for NegExtInt {",
      "        fn sub_assign(&mut self, rhs: i64) {",
      "            *self = *self - rhs;",
      "        }",
      "    }",
      "    impl std::iter::Sum for NegExtInt {",
      "        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {",
      "            let mut s = 0;",
      "            for x in iter {",
      "                if x.is_neg_inf() {",
      "                    return Self::NEG_INF;",
      "                }",
      "                s += x.0;",
      "            }",
      "            Self::fin(s)",
      "        }",
      "    }",
      "    impl fmt::Display for NegExtInt {",
      "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
      "            if self.is_neg_inf() {",
      "                write!(f, \"-∞\")",
      "            } else {",
      "                write!(f, \"{}\", self.0)",
      "            }",
      "        }",
      "    }",
      "    impl fmt::Debug for NegExtInt {",
      "        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "            if self.is_neg_inf() {",
      "                write!(f, \"-∞\")",
      "            } else {",
      "                write!(f, \"{}\", self.0)",
      "            }",
      "        }",
      "    }",
      "    pub struct NegExtIntAdditive(Infallible);",
      "    impl Monoid for NegExtIntAdditive {",
      "        type S = NegExtInt;",
      "        fn identity() -> Self::S {",
      "            NegExtInt::fin(0)",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a + *b",
      "        }",
      "    }",
      "    pub struct NegExtIntMax(Infallible);",
      "    impl Monoid for NegExtIntMax {",
      "        type S = NegExtInt;",
      "        fn identity() -> Self::S {",
      "            NegExtInt::NEG_INF",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a.max(b)",
      "        }",
      "    }",
      "}"
    ]
  },
  "mod_queue": {
    "scope": "rust",
    "prefix": "mod_queue",
    "body": [
      "use mod_queue::*;",
      "pub mod mod_queue {",
      "    use std::collections::VecDeque;",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Queue<T> {",
      "        raw: VecDeque<T>,",
      "    }",
      "    impl<T> Queue<T> {",
      "        pub fn new() -> Self {",
      "            Queue {",
      "                raw: VecDeque::new(),",
      "            }",
      "        }",
      "        pub fn push(&mut self, value: T) {",
      "            self.raw.push_back(value)",
      "        }",
      "        pub fn pop(&mut self) -> Option<T> {",
      "            self.raw.pop_front()",
      "        }",
      "        pub fn peek(&self) -> Option<&T> {",
      "            self.raw.front()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.raw.len()",
      "        }",
      "    }",
      "    impl<T> Default for Queue<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "}"
    ]
  },
  "mod_stack": {
    "scope": "rust",
    "prefix": "mod_stack",
    "body": [
      "use mod_stack::*;",
      "pub mod mod_stack {",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Stack<T> {",
      "        raw: Vec<T>,",
      "    }",
      "    impl<T> Stack<T> {",
      "        pub fn new() -> Self {",
      "            Stack { raw: Vec::new() }",
      "        }",
      "        pub fn push(&mut self, value: T) {",
      "            self.raw.push(value)",
      "        }",
      "        pub fn pop(&mut self) -> Option<T> {",
      "            self.raw.pop()",
      "        }",
      "        pub fn peek(&self) -> Option<&T> {",
      "            self.raw.last()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.raw.len()",
      "        }",
      "    }",
      "    impl<T> Default for Stack<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "}"
    ]
  },
  "modint_to_rational": {
    "scope": "rust",
    "prefix": "modint_to_rational",
    "body": [
      "use modint_to_rational::*;",
      "pub mod modint_to_rational {",
      "    use num_rational::Rational64;",
      "    pub trait ToRational {",
      "        fn to_rational(&self) -> Option<Rational64>;",
      "        fn to_rational_str(&self) -> String {",
      "            self.to_rational()",
      "                .map(|x| x.to_string())",
      "                .unwrap_or(\"cannot reconstruct\".to_string())",
      "        }",
      "    }",
      "    impl ToRational for ac_library::ModInt998244353 {",
      "        /// 注意: 1000 * 2000 = 2*10^6 の計算をしている",
      "        fn to_rational(&self) -> Option<Rational64> {",
      "            if self.val() == 0 {",
      "                return Some(Rational64::new(0, 1));",
      "            }",
      "            for denom in 1..1000 {",
      "                let denom_inv = Self::new(denom).inv();",
      "                for numer in -1000..1000 {",
      "                    if *self == denom_inv * Self::new(numer) {",
      "                        return Some(Rational64::new(numer, denom));",
      "                    }",
      "                }",
      "            }",
      "            None",
      "        }",
      "    }",
      "}"
    ]
  },
  "modint_u64": {
    "scope": "rust",
    "prefix": "modint_u64",
    "body": [
      "use modint_u64::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod modint_u64 {",
      "    use std::{",
      "        convert::Infallible,",
      "        fmt,",
      "        hash::{Hash, Hasher},",
      "        iter::{Product, Sum},",
      "        marker::PhantomData,",
      "        ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign},",
      "        str::FromStr,",
      "    };",
      "    /// 2^61 -1",
      "    pub type ModInt2305843009213693951 = StaticModInt<Mod2305843009213693951>;",
      "    /// 10^18 + 3",
      "    pub type ModInt1000000000000000003 = StaticModInt<Mod1000000000000000003>;",
      "    pub type ModInt1000000007 = StaticModInt<Mod1000000007>;",
      "    pub type ModInt998244353 = StaticModInt<Mod998244353>;",
      "    /// Represents \\$\\mathbb{Z}/m\\mathbb{Z}\\$ where \\$m\\$ is a constant value.",
      "    /// Corresponds to `atcoder::static_modint` in the original ACL.",
      "    /// # Example",
      "    /// ```",
      "    /// use ac_library::ModInt1000000007 as Mint;",
      "    /// use proconio::{input, source::once::OnceSource};",
      "    /// input! {",
      "    ///     from OnceSource::from(\"1000000006 2\\n\"),",
      "    ///     a: Mint,",
      "    ///     b: Mint,",
      "    /// }",
      "    /// println!(\"{}\", a + b); // `1`",
      "    /// ```",
      "    #[derive(Copy, Clone, Eq, PartialEq)]",
      "    #[repr(transparent)]",
      "    pub struct StaticModInt<M> {",
      "        val: u64,",
      "        phantom: PhantomData<fn() -> M>,",
      "    }",
      "    impl<M: Modulus> StaticModInt<M> {",
      "        /// Returns the modulus, which is [`<M as Modulus>::VALUE`].",
      "        /// Corresponds to `atcoder::static_modint::mod` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::ModInt1000000007 as Mint;",
      "        /// assert_eq!(1_000_000_007, Mint::modulus());",
      "        /// ```",
      "        /// [`<M as Modulus>::VALUE`]: ../trait.Modulus.html#associatedconstant.VALUE",
      "        #[inline(always)]",
      "        pub fn modulus() -> u64 {",
      "            M::VALUE",
      "        }",
      "        /// Creates a new `StaticModInt`.",
      "        /// Takes [any primitive integer].",
      "        /// Corresponds to the constructor of `atcoder::static_modint` in the original ACL.",
      "        /// [any primitive integer]:  ../trait.RemEuclidU32.html",
      "        #[inline]",
      "        pub fn new<T: RemEuclidU64>(val: T) -> Self {",
      "            Self::raw(val.rem_euclid_u64(M::VALUE))",
      "        }",
      "        /// Constructs a `StaticModInt` from a `val < Self::modulus()` without checking it.",
      "        /// Corresponds to `atcoder::static_modint::raw` in the original ACL.",
      "        /// # Constraints",
      "        /// - `val` is less than `Self::modulus()`",
      "        /// See [`ModIntBase::raw`] for more more details.",
      "        /// [`ModIntBase::raw`]: ./trait.ModIntBase.html#tymethod.raw",
      "        #[inline]",
      "        pub fn raw(val: u64) -> Self {",
      "            Self {",
      "                val,",
      "                phantom: PhantomData,",
      "            }",
      "        }",
      "        /// Retruns the representative.",
      "        /// Corresponds to `atcoder::static_modint::val` in the original ACL.",
      "        #[inline]",
      "        pub fn val(self) -> u64 {",
      "            self.val",
      "        }",
      "        /// Returns `self` to the power of `n`.",
      "        /// Corresponds to `atcoder::static_modint::pow` in the original ACL.",
      "        #[inline]",
      "        pub fn pow(self, n: u64) -> Self {",
      "            <Self as ModIntBase>::pow(self, n)",
      "        }",
      "        /// Retruns the multiplicative inverse of `self`.",
      "        /// Corresponds to `atcoder::static_modint::inv` in the original ACL.",
      "        /// # Panics",
      "        /// Panics if the multiplicative inverse does not exist.",
      "        #[inline]",
      "        pub fn inv(self) -> Self {",
      "            if self.val() == 0 {",
      "                panic!(\"attempt to divide by zero\");",
      "            }",
      "            self.pow(M::VALUE - 2)",
      "        }",
      "    }",
      "    /// These methods are implemented for the struct.",
      "    /// You don't need to `use` `ModIntBase` to call methods of `StaticModInt`.",
      "    impl<M: Modulus> ModIntBase for StaticModInt<M> {",
      "        #[inline(always)]",
      "        fn modulus() -> u64 {",
      "            Self::modulus()",
      "        }",
      "        #[inline]",
      "        fn raw(val: u64) -> Self {",
      "            Self::raw(val)",
      "        }",
      "        #[inline]",
      "        fn val(self) -> u64 {",
      "            self.val()",
      "        }",
      "        #[inline]",
      "        fn inv(self) -> Self {",
      "            self.inv()",
      "        }",
      "    }",
      "    /// Represents a modulus.",
      "    /// # Example",
      "    /// ```",
      "    /// macro_rules! modulus {",
      "    ///     (\\$(\\$name:ident(\\$value:expr, \\$is_prime:expr)),*) => {",
      "    ///         \\$(",
      "    ///             #[derive(Copy, Clone, Eq, PartialEq)]",
      "    ///             enum \\$name {}",
      "    ///             impl ac_library::modint::Modulus for \\$name {",
      "    ///                 const VALUE: u32 = \\$value;",
      "    ///                 const HINT_VALUE_IS_PRIME: bool = \\$is_prime;",
      "    ///                 fn butterfly_cache() -> &'static ::std::thread::LocalKey<::std::cell::RefCell<::std::option::Option<ac_library::modint::ButterflyCache<Self>>>> {",
      "    ///                     thread_local! {",
      "    ///                         static BUTTERFLY_CACHE: ::std::cell::RefCell<::std::option::Option<ac_library::modint::ButterflyCache<\\$name>>> = ::std::default::Default::default();",
      "    ///                     }",
      "    ///                     &BUTTERFLY_CACHE",
      "    ///                 }",
      "    ///             }",
      "    ///         )*",
      "    ///     };",
      "    /// }",
      "    /// use ac_library::StaticModInt;",
      "    /// modulus!(Mod101(101, true), Mod103(103, true));",
      "    /// type Z101 = StaticModInt<Mod101>;",
      "    /// type Z103 = StaticModInt<Mod103>;",
      "    /// assert_eq!(Z101::new(101), Z101::new(0));",
      "    /// assert_eq!(Z103::new(103), Z103::new(0));",
      "    /// ```",
      "    pub trait Modulus: 'static + Copy + Eq {",
      "        const VALUE: u64;",
      "        const HINT_VALUE_IS_PRIME: bool;",
      "    }",
      "    /// Represents \\$2^{61}-1 = 2305843009213693951\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod2305843009213693951 {}",
      "    impl Modulus for Mod2305843009213693951 {",
      "        const VALUE: u64 = 2_305_843_009_213_693_951;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// Represents \\$10^{18}+3 = 1000000000000000003\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod1000000000000000003 {}",
      "    impl Modulus for Mod1000000000000000003 {",
      "        const VALUE: u64 = 1_000_000_000_000_000_003;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// Represents \\$1000000007\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod1000000007 {}",
      "    impl Modulus for Mod1000000007 {",
      "        const VALUE: u64 = 1_000_000_007;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// Represents \\$998244353\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod998244353 {}",
      "    impl Modulus for Mod998244353 {",
      "        const VALUE: u64 = 998_244_353;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// A trait for [`StaticModInt`] and [`DynamicModInt`].",
      "    /// Corresponds to `atcoder::internal::modint_base` in the original ACL.",
      "    /// [`StaticModInt`]: ../struct.StaticModInt.html",
      "    /// [`DynamicModInt`]: ../struct.DynamicModInt.html",
      "    pub trait ModIntBase:",
      "        Default",
      "        + FromStr",
      "        + From<i8>",
      "        + From<i16>",
      "        + From<i32>",
      "        + From<i64>",
      "        + From<i128>",
      "        + From<isize>",
      "        + From<u8>",
      "        + From<u16>",
      "        + From<u32>",
      "        + From<u64>",
      "        + From<u128>",
      "        + From<usize>",
      "        + Copy",
      "        + Eq",
      "        + Hash",
      "        + fmt::Display",
      "        + fmt::Debug",
      "        + Neg<Output = Self>",
      "        + Add<Output = Self>",
      "        + Sub<Output = Self>",
      "        + Mul<Output = Self>",
      "        + Div<Output = Self>",
      "        + AddAssign",
      "        + SubAssign",
      "        + MulAssign",
      "        + DivAssign",
      "    {",
      "        /// Returns the modulus.",
      "        /// Corresponds to `atcoder::static_modint::mod` and `atcoder::dynamic_modint::mod` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() {",
      "        ///     let _: u32 = Z::modulus();",
      "        /// }",
      "        /// ```",
      "        fn modulus() -> u64;",
      "        /// Constructs a `Self` from a `val < Self::modulus()` without checking it.",
      "        /// Corresponds to `atcoder::static_modint::raw` and `atcoder::dynamic_modint::raw` in the original ACL.",
      "        /// # Constraints",
      "        /// - `val` is less than `Self::modulus()`",
      "        /// **Note that all operations assume that inner values are smaller than the modulus.**",
      "        /// If `val` is greater than or equal to `Self::modulus()`, the behaviors are not defined.",
      "        /// ```should_panic",
      "        /// use ac_library::ModInt1000000007 as Mint;",
      "        /// let x = Mint::raw(1_000_000_007);",
      "        /// let y = x + x;",
      "        /// assert_eq!(0, y.val());",
      "        /// ```",
      "        /// ```text",
      "        /// thread 'main' panicked at 'assertion failed: `(left == right)`",
      "        ///   left: `0`,",
      "        ///  right: `1000000007`', src/modint.rs:8:1",
      "        /// note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace",
      "        /// ```",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() -> Z {",
      "        ///     debug_assert!(Z::modulus() >= 100);",
      "        ///     let mut acc = Z::new(0);",
      "        ///     for i in 0..100 {",
      "        ///         if i % 3 == 0 {",
      "        ///             // I know `i` is smaller than the modulus!",
      "        ///             acc += Z::raw(i);",
      "        ///         }",
      "        ///     }",
      "        ///     acc",
      "        /// }",
      "        /// ```",
      "        fn raw(val: u64) -> Self;",
      "        /// Retruns the representative.",
      "        /// Corresponds to `atcoder::static_modint::val` and `atcoder::dynamic_modint::val` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>(x: Z) {",
      "        ///     let _: u32 = x.val();",
      "        /// }",
      "        /// ```",
      "        fn val(self) -> u64;",
      "        /// Retruns the multiplicative inverse of `self`.",
      "        /// Corresponds to `atcoder::static_modint::inv` and `atcoder::dynamic_modint::inv` in the original ACL.",
      "        /// # Panics",
      "        /// Panics if the multiplicative inverse does not exist.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>(x: Z) {",
      "        ///     let _: Z = x.inv();",
      "        /// }",
      "        /// ```",
      "        fn inv(self) -> Self;",
      "        /// Creates a new `Self`.",
      "        /// Takes [any primitive integer].",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() {",
      "        ///     let _ = Z::new(1u32);",
      "        ///     let _ = Z::new(1usize);",
      "        ///     let _ = Z::new(-1i64);",
      "        /// }",
      "        /// ```",
      "        /// [any primitive integer]:  ../trait.RemEuclidU32.html",
      "        #[inline]",
      "        fn new<T: RemEuclidU64>(val: T) -> Self {",
      "            Self::raw(val.rem_euclid_u64(Self::modulus()))",
      "        }",
      "        /// Returns `self` to the power of `n`.",
      "        /// Corresponds to `atcoder::static_modint::pow` and `atcoder::dynamic_modint::pow` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() {",
      "        ///     let _: Z = Z::new(2).pow(3);",
      "        /// }",
      "        /// ```",
      "        #[inline]",
      "        fn pow(self, mut n: u64) -> Self {",
      "            let mut x = self;",
      "            let mut r = Self::raw(1);",
      "            while n > 0 {",
      "                if n & 1 == 1 {",
      "                    r *= x;",
      "                }",
      "                x *= x;",
      "                n >>= 1;",
      "            }",
      "            r",
      "        }",
      "    }",
      "    /// A trait for `{StaticModInt, DynamicModInt, ModIntBase}::new`.",
      "    pub trait RemEuclidU64 {",
      "        /// Calculates `self` \\$\\bmod\\$ `modulus` losslessly.",
      "        fn rem_euclid_u64(self, modulus: u64) -> u64;",
      "    }",
      "    macro_rules ! impl_rem_euclid_u64_for_small_signed {(\\$ (\\$ ty : tt ) ,* ) => {\\$ (impl RemEuclidU64 for \\$ ty {# [inline ] fn rem_euclid_u64 (self , modulus : u64 ) -> u64 {(self as i128 ) . rem_euclid (i128 :: from (modulus ) ) as _ } } ) * } }",
      "    impl_rem_euclid_u64_for_small_signed!(i8, i16, i32, i64, isize);",
      "    impl RemEuclidU64 for i128 {",
      "        #[inline]",
      "        fn rem_euclid_u64(self, modulus: u64) -> u64 {",
      "            self.rem_euclid(i128::from(modulus)) as _",
      "        }",
      "    }",
      "    macro_rules ! impl_rem_euclid_u64_for_small_unsigned {(\\$ (\\$ ty : tt ) ,* ) => {\\$ (impl RemEuclidU64 for \\$ ty {# [inline ] fn rem_euclid_u64 (self , modulus : u64 ) -> u64 {self as u64 % modulus } } ) * } }",
      "    macro_rules ! impl_rem_euclid_u64_for_large_unsigned {(\\$ (\\$ ty : tt ) ,* ) => {\\$ (impl RemEuclidU64 for \\$ ty {# [inline ] fn rem_euclid_u64 (self , modulus : u64 ) -> u64 {(self % (modulus as \\$ ty ) ) as _ } } ) * } }",
      "    impl_rem_euclid_u64_for_small_unsigned!(u8, u16, u32, u64, usize);",
      "    impl_rem_euclid_u64_for_large_unsigned!(u128);",
      "    trait InternalImplementations: ModIntBase {",
      "        #[inline]",
      "        fn default_impl() -> Self {",
      "            Self::raw(0)",
      "        }",
      "        #[inline]",
      "        fn from_str_impl(s: &str) -> Result<Self, Infallible> {",
      "            Ok(s.parse::<i64>()",
      "                .map(Self::new)",
      "                .unwrap_or_else(|_| todo!(\"parsing as an arbitrary precision integer?\")))",
      "        }",
      "        #[inline]",
      "        fn hash_impl(this: &Self, state: &mut impl Hasher) {",
      "            this.val().hash(state)",
      "        }",
      "        #[inline]",
      "        fn display_impl(this: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "            fmt::Display::fmt(&this.val(), f)",
      "        }",
      "        #[inline]",
      "        fn debug_impl(this: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "            fmt::Debug::fmt(&this.val(), f)",
      "        }",
      "        #[inline]",
      "        fn neg_impl(this: Self) -> Self {",
      "            Self::sub_impl(Self::raw(0), this)",
      "        }",
      "        #[inline]",
      "        fn add_impl(lhs: Self, rhs: Self) -> Self {",
      "            let modulus = Self::modulus();",
      "            let mut val = lhs.val() + rhs.val();",
      "            if val >= modulus {",
      "                val -= modulus;",
      "            }",
      "            Self::raw(val)",
      "        }",
      "        #[inline]",
      "        fn sub_impl(lhs: Self, rhs: Self) -> Self {",
      "            let modulus = Self::modulus();",
      "            let mut val = lhs.val().wrapping_sub(rhs.val());",
      "            if val >= modulus {",
      "                val = val.wrapping_add(modulus)",
      "            }",
      "            Self::raw(val)",
      "        }",
      "        fn mul_impl(lhs: Self, rhs: Self) -> Self;",
      "        #[inline]",
      "        fn div_impl(lhs: Self, rhs: Self) -> Self {",
      "            Self::mul_impl(lhs, rhs.inv())",
      "        }",
      "    }",
      "    impl<M: Modulus> InternalImplementations for StaticModInt<M> {",
      "        #[inline]",
      "        fn mul_impl(lhs: Self, rhs: Self) -> Self {",
      "            Self::raw((u128::from(lhs.val()) * u128::from(rhs.val()) % u128::from(M::VALUE)) as u64)",
      "        }",
      "    }",
      "    macro_rules ! impl_basic_traits {() => {} ; (impl <\\$ generic_param : ident : \\$ generic_param_bound : tt > _ for \\$ self : ty ; \\$ (\\$ rest : tt ) * ) => {impl <\\$ generic_param : \\$ generic_param_bound > Default for \\$ self {# [inline ] fn default () -> Self {Self :: default_impl () } } impl <\\$ generic_param : \\$ generic_param_bound > FromStr for \\$ self {type Err = Infallible ; # [inline ] fn from_str (s : & str ) -> Result < Self , Infallible > {Self :: from_str_impl (s ) } } impl <\\$ generic_param : \\$ generic_param_bound , V : RemEuclidU64 > From < V > for \\$ self {# [inline ] fn from (from : V ) -> Self {Self :: new (from ) } } # [allow (clippy :: derive_hash_xor_eq ) ] impl <\\$ generic_param : \\$ generic_param_bound > Hash for \\$ self {# [inline ] fn hash < H : Hasher > (& self , state : & mut H ) {Self :: hash_impl (self , state ) } } impl <\\$ generic_param : \\$ generic_param_bound > fmt :: Display for \\$ self {# [inline ] fn fmt (& self , f : & mut fmt :: Formatter <'_ > ) -> fmt :: Result {Self :: display_impl (self , f ) } } impl <\\$ generic_param : \\$ generic_param_bound > fmt :: Debug for \\$ self {# [inline ] fn fmt (& self , f : & mut fmt :: Formatter <'_ > ) -> fmt :: Result {Self :: debug_impl (self , f ) } } impl <\\$ generic_param : \\$ generic_param_bound > Neg for \\$ self {type Output = \\$ self ; # [inline ] fn neg (self ) -> \\$ self {Self :: neg_impl (self ) } } impl <\\$ generic_param : \\$ generic_param_bound > Neg for &'_ \\$ self {type Output = \\$ self ; # [inline ] fn neg (self ) -> \\$ self {<\\$ self >:: neg_impl (* self ) } } impl_basic_traits ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    impl_basic_traits! {impl < M : Modulus > _ for StaticModInt < M > ; }",
      "    macro_rules ! impl_bin_ops {() => {} ; (for <\\$ (\\$ generic_param : ident : \\$ generic_param_bound : tt ) ,*> <\\$ lhs_ty : ty > ~ <\\$ rhs_ty : ty > -> \\$ output : ty {{\\$ lhs_body : expr } ~ {\\$ rhs_body : expr } } \\$ (\\$ rest : tt ) * ) => {impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Add <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn add (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: add_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Sub <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn sub (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: sub_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Mul <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn mul (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: mul_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Div <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn div (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: div_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl_bin_ops ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    macro_rules ! impl_assign_ops {() => {} ; (for <\\$ (\\$ generic_param : ident : \\$ generic_param_bound : tt ) ,*> <\\$ lhs_ty : ty > ~= <\\$ rhs_ty : ty > {_ ~= {\\$ rhs_body : expr } } \\$ (\\$ rest : tt ) * ) => {impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> AddAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn add_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self + apply (\\$ rhs_body , rhs ) ; } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> SubAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn sub_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self - apply (\\$ rhs_body , rhs ) ; } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> MulAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn mul_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self * apply (\\$ rhs_body , rhs ) ; } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> DivAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn div_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self / apply (\\$ rhs_body , rhs ) ; } } impl_assign_ops ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    #[inline]",
      "    fn apply<F: FnOnce(X) -> O, X, O>(f: F, x: X) -> O {",
      "        f(x)",
      "    }",
      "    impl_bin_ops! {for < M : Modulus > < StaticModInt < M > > ~ < StaticModInt < M > > -> StaticModInt < M > {{| x | x } ~ {| x | x } } for < M : Modulus > < StaticModInt < M > > ~ <&'_ StaticModInt < M > > -> StaticModInt < M > {{| x | x } ~ {|& x | x } } for < M : Modulus > <&'_ StaticModInt < M > > ~ < StaticModInt < M > > -> StaticModInt < M > {{|& x | x } ~ {| x | x } } for < M : Modulus > <&'_ StaticModInt < M > > ~ <&'_ StaticModInt < M > > -> StaticModInt < M > {{|& x | x } ~ {|& x | x } } for < M : Modulus , T : RemEuclidU64 > < StaticModInt < M > > ~ < T > -> StaticModInt < M > {{| x | x } ~ {StaticModInt ::< M >:: new } } }",
      "    impl_assign_ops! {for < M : Modulus > < StaticModInt < M > > ~= < StaticModInt < M > > {_ ~= {| x | x } } for < M : Modulus > < StaticModInt < M > > ~= <&'_ StaticModInt < M > > {_ ~= {|& x | x } } for < M : Modulus , T : RemEuclidU64 > < StaticModInt < M > > ~= < T > {_ ~= {StaticModInt ::< M >:: new } } }",
      "    macro_rules ! impl_folding {() => {} ; (impl <\\$ generic_param : ident : \\$ generic_param_bound : tt > \\$ trait : ident < _ > for \\$ self : ty {fn \\$ method : ident (_ ) -> _ {_ (\\$ unit : expr , \\$ op : expr ) } } \\$ (\\$ rest : tt ) * ) => {impl <\\$ generic_param : \\$ generic_param_bound > \\$ trait < Self > for \\$ self {# [inline ] fn \\$ method < S > (iter : S ) -> Self where S : Iterator < Item = Self >, {iter . fold (\\$ unit , \\$ op ) } } impl <'a , \\$ generic_param : \\$ generic_param_bound > \\$ trait <&'a Self > for \\$ self {# [inline ] fn \\$ method < S > (iter : S ) -> Self where S : Iterator < Item = &'a Self >, {iter . fold (\\$ unit , \\$ op ) } } impl_folding ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    impl_folding! {impl < M : Modulus > Sum < _ > for StaticModInt < M > {fn sum (_ ) -> _ {_ (Self :: raw (0 ) , Add :: add ) } } impl < M : Modulus > Product < _ > for StaticModInt < M > {fn product (_ ) -> _ {_ (Self :: raw (1 ) , Mul :: mul ) } } }",
      "}"
    ]
  },
  "monoid_affine": {
    "scope": "rust",
    "prefix": "monoid_affine",
    "body": [
      "use monoid_affine::*;",
      "pub mod monoid_affine {",
      "    use ac_library::Monoid;",
      "    use std::{",
      "        convert::Infallible,",
      "        marker::PhantomData,",
      "        ops::{Add, Mul},",
      "    };",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct AffineTransform<T> {",
      "        slope: T,",
      "        intercept: T,",
      "    }",
      "    impl<T> AffineTransform<T> {",
      "        pub fn new(slope: T, intercept: T) -> Self {",
      "            Self { slope, intercept }",
      "        }",
      "        pub fn apply(&self, x: T) -> T",
      "        where",
      "            T: Copy + Mul<Output = T> + Add<Output = T>,",
      "        {",
      "            self.slope * x + self.intercept",
      "        }",
      "        pub fn identity() -> Self",
      "        where",
      "            T: From<i64>,",
      "        {",
      "            Self {",
      "                slope: 1.into(),",
      "                intercept: 0.into(),",
      "            }",
      "        }",
      "        pub fn composite(&self, rhs: &Self) -> Self",
      "        where",
      "            T: Copy + Mul<Output = T> + Add<Output = T>,",
      "        {",
      "            Self {",
      "                slope: self.slope * rhs.slope,",
      "                intercept: self.slope * rhs.intercept + self.intercept,",
      "            }",
      "        }",
      "    }",
      "    pub struct AffineComposition<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for AffineComposition<T>",
      "    where",
      "        T: Copy + From<i64> + Add<Output = T> + Mul<Output = T>,",
      "    {",
      "        type S = AffineTransform<T>;",
      "        fn identity() -> Self::S {",
      "            AffineTransform::identity()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            a.composite(b)",
      "        }",
      "    }",
      "}"
    ]
  },
  "monoid_bitwise": {
    "scope": "rust",
    "prefix": "monoid_bitwise",
    "body": [
      "use monoid_bitwise::*;",
      "pub mod monoid_bitwise {",
      "    use ac_library::Monoid;",
      "    use num_traits::Zero;",
      "    use std::{",
      "        convert::Infallible,",
      "        marker::PhantomData,",
      "        ops::{BitAnd, BitOr, BitXor, Not},",
      "    };",
      "    pub struct BitwiseOr<S>(Infallible, PhantomData<fn() -> S>);",
      "    impl<S> Monoid for BitwiseOr<S>",
      "    where",
      "        S: Copy + BitOr<Output = S> + Zero,",
      "    {",
      "        type S = S;",
      "        fn identity() -> Self::S {",
      "            S::zero()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a | *b",
      "        }",
      "    }",
      "    pub struct BitwiseAnd<S>(Infallible, PhantomData<fn() -> S>);",
      "    impl<S> Monoid for BitwiseAnd<S>",
      "    where",
      "        S: Copy + BitAnd<Output = S> + Not<Output = S> + Zero,",
      "    {",
      "        type S = S;",
      "        fn identity() -> Self::S {",
      "            !S::zero()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a & *b",
      "        }",
      "    }",
      "    pub struct BitwiseXor<S>(Infallible, PhantomData<fn() -> S>);",
      "    impl<S> Monoid for BitwiseXor<S>",
      "    where",
      "        S: Copy + BitXor<Output = S> + Zero,",
      "    {",
      "        type S = S;",
      "        fn identity() -> Self::S {",
      "            S::zero()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "    }",
      "}"
    ]
  },
  "monoid_gcd_lcm": {
    "scope": "rust",
    "prefix": "monoid_gcd_lcm",
    "body": [
      "use monoid_gcd_lcm::*;",
      "pub mod monoid_gcd_lcm {",
      "    use ac_library::Monoid;",
      "    use num_integer::Integer;",
      "    use std::{convert::Infallible, marker::PhantomData};",
      "    pub struct Gcd<S>(Infallible, PhantomData<fn() -> S>);",
      "    impl<S> Monoid for Gcd<S>",
      "    where",
      "        S: Integer + Clone,",
      "    {",
      "        type S = S;",
      "        fn identity() -> Self::S {",
      "            S::zero()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            a.gcd(b)",
      "        }",
      "    }",
      "    pub struct Lcm<S>(Infallible, PhantomData<fn() -> S>);",
      "    impl<S> Monoid for Lcm<S>",
      "    where",
      "        S: Integer + Clone,",
      "    {",
      "        type S = S;",
      "        fn identity() -> Self::S {",
      "            S::one()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            a.lcm(b)",
      "        }",
      "    }",
      "}"
    ]
  },
  "monoid_matrix_mul": {
    "scope": "rust",
    "prefix": "monoid_matrix_mul",
    "body": [
      "use dynamic_monoid::*;",
      "use monoid_matrix_mul::*;",
      "pub mod dynamic_monoid {",
      "    pub trait DynamicMonoid {",
      "        type S: Clone;",
      "        fn identity(&self) -> Self::S;",
      "        fn binary_operation(&self, a: &Self::S, b: &Self::S) -> Self::S;",
      "        /// base^n を求める",
      "        fn pow(&self, base: &Self::S, n: usize) -> Self::S {",
      "            let mut base = base.clone();",
      "            let mut ans = self.identity();",
      "            let mut n = n;",
      "            while n > 0 {",
      "                if n & 1 == 1 {",
      "                    ans = self.binary_operation(&ans, &base);",
      "                }",
      "                base = self.binary_operation(&base, &base);",
      "                n >>= 1;",
      "            }",
      "            ans",
      "        }",
      "    }",
      "}",
      "pub mod monoid_matrix_mul {",
      "    use super::dynamic_monoid::DynamicMonoid;",
      "    use itertools::Itertools;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct MatrixMul {",
      "        size: usize,",
      "    }",
      "    impl MatrixMul {",
      "        pub fn new(size: usize) -> Self {",
      "            Self { size }",
      "        }",
      "    }",
      "    impl DynamicMonoid for MatrixMul {",
      "        type S = Vec<Vec<i64>>;",
      "        fn identity(&self) -> Self::S {",
      "            (0..self.size)",
      "                .map(|y| {",
      "                    (0..self.size)",
      "                        .map(move |x| if x == y { 1 } else { 0 })",
      "                        .collect_vec()",
      "                })",
      "                .collect_vec()",
      "        }",
      "        fn binary_operation(&self, a: &Self::S, b: &Self::S) -> Self::S {",
      "            (0..self.size)",
      "                .map(|y| {",
      "                    (0..self.size)",
      "                        .map(move |x| (0..self.size).map(|k| a[y][k] * b[k][x]).sum())",
      "                        .collect_vec()",
      "                })",
      "                .collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "monoid_modint": {
    "scope": "rust",
    "prefix": "monoid_modint",
    "body": [
      "use monoid_modint::*;",
      "pub mod monoid_modint {",
      "    use ac_library::{Modulus, Monoid, StaticModInt};",
      "    use std::{convert::Infallible, marker::PhantomData};",
      "    pub struct MintAdditive<Mod>(Infallible, PhantomData<fn() -> Mod>);",
      "    impl<Mod> Monoid for MintAdditive<Mod>",
      "    where",
      "        Mod: Modulus,",
      "    {",
      "        type S = StaticModInt<Mod>;",
      "        fn identity() -> Self::S {",
      "            StaticModInt::raw(0)",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            a + b",
      "        }",
      "    }",
      "    pub struct MintMultiplicative<Mod>(Infallible, PhantomData<fn() -> Mod>);",
      "    impl<Mod> Monoid for MintMultiplicative<Mod>",
      "    where",
      "        Mod: Modulus,",
      "    {",
      "        type S = StaticModInt<Mod>;",
      "        fn identity() -> Self::S {",
      "            StaticModInt::raw(1)",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            a * b",
      "        }",
      "    }",
      "}"
    ]
  },
  "monoid_rolling_hash": {
    "scope": "rust",
    "prefix": "monoid_rolling_hash",
    "body": [
      "use modint_u64::*;",
      "use monoid_rolling_hash::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod modint_u64 {",
      "    use std::{",
      "        convert::Infallible,",
      "        fmt,",
      "        hash::{Hash, Hasher},",
      "        iter::{Product, Sum},",
      "        marker::PhantomData,",
      "        ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign},",
      "        str::FromStr,",
      "    };",
      "    /// 2^61 -1",
      "    pub type ModInt2305843009213693951 = StaticModInt<Mod2305843009213693951>;",
      "    /// 10^18 + 3",
      "    pub type ModInt1000000000000000003 = StaticModInt<Mod1000000000000000003>;",
      "    pub type ModInt1000000007 = StaticModInt<Mod1000000007>;",
      "    pub type ModInt998244353 = StaticModInt<Mod998244353>;",
      "    /// Represents \\$\\mathbb{Z}/m\\mathbb{Z}\\$ where \\$m\\$ is a constant value.",
      "    /// Corresponds to `atcoder::static_modint` in the original ACL.",
      "    /// # Example",
      "    /// ```",
      "    /// use ac_library::ModInt1000000007 as Mint;",
      "    /// use proconio::{input, source::once::OnceSource};",
      "    /// input! {",
      "    ///     from OnceSource::from(\"1000000006 2\\n\"),",
      "    ///     a: Mint,",
      "    ///     b: Mint,",
      "    /// }",
      "    /// println!(\"{}\", a + b); // `1`",
      "    /// ```",
      "    #[derive(Copy, Clone, Eq, PartialEq)]",
      "    #[repr(transparent)]",
      "    pub struct StaticModInt<M> {",
      "        val: u64,",
      "        phantom: PhantomData<fn() -> M>,",
      "    }",
      "    impl<M: Modulus> StaticModInt<M> {",
      "        /// Returns the modulus, which is [`<M as Modulus>::VALUE`].",
      "        /// Corresponds to `atcoder::static_modint::mod` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::ModInt1000000007 as Mint;",
      "        /// assert_eq!(1_000_000_007, Mint::modulus());",
      "        /// ```",
      "        /// [`<M as Modulus>::VALUE`]: ../trait.Modulus.html#associatedconstant.VALUE",
      "        #[inline(always)]",
      "        pub fn modulus() -> u64 {",
      "            M::VALUE",
      "        }",
      "        /// Creates a new `StaticModInt`.",
      "        /// Takes [any primitive integer].",
      "        /// Corresponds to the constructor of `atcoder::static_modint` in the original ACL.",
      "        /// [any primitive integer]:  ../trait.RemEuclidU32.html",
      "        #[inline]",
      "        pub fn new<T: RemEuclidU64>(val: T) -> Self {",
      "            Self::raw(val.rem_euclid_u64(M::VALUE))",
      "        }",
      "        /// Constructs a `StaticModInt` from a `val < Self::modulus()` without checking it.",
      "        /// Corresponds to `atcoder::static_modint::raw` in the original ACL.",
      "        /// # Constraints",
      "        /// - `val` is less than `Self::modulus()`",
      "        /// See [`ModIntBase::raw`] for more more details.",
      "        /// [`ModIntBase::raw`]: ./trait.ModIntBase.html#tymethod.raw",
      "        #[inline]",
      "        pub fn raw(val: u64) -> Self {",
      "            Self {",
      "                val,",
      "                phantom: PhantomData,",
      "            }",
      "        }",
      "        /// Retruns the representative.",
      "        /// Corresponds to `atcoder::static_modint::val` in the original ACL.",
      "        #[inline]",
      "        pub fn val(self) -> u64 {",
      "            self.val",
      "        }",
      "        /// Returns `self` to the power of `n`.",
      "        /// Corresponds to `atcoder::static_modint::pow` in the original ACL.",
      "        #[inline]",
      "        pub fn pow(self, n: u64) -> Self {",
      "            <Self as ModIntBase>::pow(self, n)",
      "        }",
      "        /// Retruns the multiplicative inverse of `self`.",
      "        /// Corresponds to `atcoder::static_modint::inv` in the original ACL.",
      "        /// # Panics",
      "        /// Panics if the multiplicative inverse does not exist.",
      "        #[inline]",
      "        pub fn inv(self) -> Self {",
      "            if self.val() == 0 {",
      "                panic!(\"attempt to divide by zero\");",
      "            }",
      "            self.pow(M::VALUE - 2)",
      "        }",
      "    }",
      "    /// These methods are implemented for the struct.",
      "    /// You don't need to `use` `ModIntBase` to call methods of `StaticModInt`.",
      "    impl<M: Modulus> ModIntBase for StaticModInt<M> {",
      "        #[inline(always)]",
      "        fn modulus() -> u64 {",
      "            Self::modulus()",
      "        }",
      "        #[inline]",
      "        fn raw(val: u64) -> Self {",
      "            Self::raw(val)",
      "        }",
      "        #[inline]",
      "        fn val(self) -> u64 {",
      "            self.val()",
      "        }",
      "        #[inline]",
      "        fn inv(self) -> Self {",
      "            self.inv()",
      "        }",
      "    }",
      "    /// Represents a modulus.",
      "    /// # Example",
      "    /// ```",
      "    /// macro_rules! modulus {",
      "    ///     (\\$(\\$name:ident(\\$value:expr, \\$is_prime:expr)),*) => {",
      "    ///         \\$(",
      "    ///             #[derive(Copy, Clone, Eq, PartialEq)]",
      "    ///             enum \\$name {}",
      "    ///             impl ac_library::modint::Modulus for \\$name {",
      "    ///                 const VALUE: u32 = \\$value;",
      "    ///                 const HINT_VALUE_IS_PRIME: bool = \\$is_prime;",
      "    ///                 fn butterfly_cache() -> &'static ::std::thread::LocalKey<::std::cell::RefCell<::std::option::Option<ac_library::modint::ButterflyCache<Self>>>> {",
      "    ///                     thread_local! {",
      "    ///                         static BUTTERFLY_CACHE: ::std::cell::RefCell<::std::option::Option<ac_library::modint::ButterflyCache<\\$name>>> = ::std::default::Default::default();",
      "    ///                     }",
      "    ///                     &BUTTERFLY_CACHE",
      "    ///                 }",
      "    ///             }",
      "    ///         )*",
      "    ///     };",
      "    /// }",
      "    /// use ac_library::StaticModInt;",
      "    /// modulus!(Mod101(101, true), Mod103(103, true));",
      "    /// type Z101 = StaticModInt<Mod101>;",
      "    /// type Z103 = StaticModInt<Mod103>;",
      "    /// assert_eq!(Z101::new(101), Z101::new(0));",
      "    /// assert_eq!(Z103::new(103), Z103::new(0));",
      "    /// ```",
      "    pub trait Modulus: 'static + Copy + Eq {",
      "        const VALUE: u64;",
      "        const HINT_VALUE_IS_PRIME: bool;",
      "    }",
      "    /// Represents \\$2^{61}-1 = 2305843009213693951\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod2305843009213693951 {}",
      "    impl Modulus for Mod2305843009213693951 {",
      "        const VALUE: u64 = 2_305_843_009_213_693_951;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// Represents \\$10^{18}+3 = 1000000000000000003\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod1000000000000000003 {}",
      "    impl Modulus for Mod1000000000000000003 {",
      "        const VALUE: u64 = 1_000_000_000_000_000_003;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// Represents \\$1000000007\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod1000000007 {}",
      "    impl Modulus for Mod1000000007 {",
      "        const VALUE: u64 = 1_000_000_007;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// Represents \\$998244353\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod998244353 {}",
      "    impl Modulus for Mod998244353 {",
      "        const VALUE: u64 = 998_244_353;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// A trait for [`StaticModInt`] and [`DynamicModInt`].",
      "    /// Corresponds to `atcoder::internal::modint_base` in the original ACL.",
      "    /// [`StaticModInt`]: ../struct.StaticModInt.html",
      "    /// [`DynamicModInt`]: ../struct.DynamicModInt.html",
      "    pub trait ModIntBase:",
      "        Default",
      "        + FromStr",
      "        + From<i8>",
      "        + From<i16>",
      "        + From<i32>",
      "        + From<i64>",
      "        + From<i128>",
      "        + From<isize>",
      "        + From<u8>",
      "        + From<u16>",
      "        + From<u32>",
      "        + From<u64>",
      "        + From<u128>",
      "        + From<usize>",
      "        + Copy",
      "        + Eq",
      "        + Hash",
      "        + fmt::Display",
      "        + fmt::Debug",
      "        + Neg<Output = Self>",
      "        + Add<Output = Self>",
      "        + Sub<Output = Self>",
      "        + Mul<Output = Self>",
      "        + Div<Output = Self>",
      "        + AddAssign",
      "        + SubAssign",
      "        + MulAssign",
      "        + DivAssign",
      "    {",
      "        /// Returns the modulus.",
      "        /// Corresponds to `atcoder::static_modint::mod` and `atcoder::dynamic_modint::mod` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() {",
      "        ///     let _: u32 = Z::modulus();",
      "        /// }",
      "        /// ```",
      "        fn modulus() -> u64;",
      "        /// Constructs a `Self` from a `val < Self::modulus()` without checking it.",
      "        /// Corresponds to `atcoder::static_modint::raw` and `atcoder::dynamic_modint::raw` in the original ACL.",
      "        /// # Constraints",
      "        /// - `val` is less than `Self::modulus()`",
      "        /// **Note that all operations assume that inner values are smaller than the modulus.**",
      "        /// If `val` is greater than or equal to `Self::modulus()`, the behaviors are not defined.",
      "        /// ```should_panic",
      "        /// use ac_library::ModInt1000000007 as Mint;",
      "        /// let x = Mint::raw(1_000_000_007);",
      "        /// let y = x + x;",
      "        /// assert_eq!(0, y.val());",
      "        /// ```",
      "        /// ```text",
      "        /// thread 'main' panicked at 'assertion failed: `(left == right)`",
      "        ///   left: `0`,",
      "        ///  right: `1000000007`', src/modint.rs:8:1",
      "        /// note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace",
      "        /// ```",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() -> Z {",
      "        ///     debug_assert!(Z::modulus() >= 100);",
      "        ///     let mut acc = Z::new(0);",
      "        ///     for i in 0..100 {",
      "        ///         if i % 3 == 0 {",
      "        ///             // I know `i` is smaller than the modulus!",
      "        ///             acc += Z::raw(i);",
      "        ///         }",
      "        ///     }",
      "        ///     acc",
      "        /// }",
      "        /// ```",
      "        fn raw(val: u64) -> Self;",
      "        /// Retruns the representative.",
      "        /// Corresponds to `atcoder::static_modint::val` and `atcoder::dynamic_modint::val` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>(x: Z) {",
      "        ///     let _: u32 = x.val();",
      "        /// }",
      "        /// ```",
      "        fn val(self) -> u64;",
      "        /// Retruns the multiplicative inverse of `self`.",
      "        /// Corresponds to `atcoder::static_modint::inv` and `atcoder::dynamic_modint::inv` in the original ACL.",
      "        /// # Panics",
      "        /// Panics if the multiplicative inverse does not exist.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>(x: Z) {",
      "        ///     let _: Z = x.inv();",
      "        /// }",
      "        /// ```",
      "        fn inv(self) -> Self;",
      "        /// Creates a new `Self`.",
      "        /// Takes [any primitive integer].",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() {",
      "        ///     let _ = Z::new(1u32);",
      "        ///     let _ = Z::new(1usize);",
      "        ///     let _ = Z::new(-1i64);",
      "        /// }",
      "        /// ```",
      "        /// [any primitive integer]:  ../trait.RemEuclidU32.html",
      "        #[inline]",
      "        fn new<T: RemEuclidU64>(val: T) -> Self {",
      "            Self::raw(val.rem_euclid_u64(Self::modulus()))",
      "        }",
      "        /// Returns `self` to the power of `n`.",
      "        /// Corresponds to `atcoder::static_modint::pow` and `atcoder::dynamic_modint::pow` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() {",
      "        ///     let _: Z = Z::new(2).pow(3);",
      "        /// }",
      "        /// ```",
      "        #[inline]",
      "        fn pow(self, mut n: u64) -> Self {",
      "            let mut x = self;",
      "            let mut r = Self::raw(1);",
      "            while n > 0 {",
      "                if n & 1 == 1 {",
      "                    r *= x;",
      "                }",
      "                x *= x;",
      "                n >>= 1;",
      "            }",
      "            r",
      "        }",
      "    }",
      "    /// A trait for `{StaticModInt, DynamicModInt, ModIntBase}::new`.",
      "    pub trait RemEuclidU64 {",
      "        /// Calculates `self` \\$\\bmod\\$ `modulus` losslessly.",
      "        fn rem_euclid_u64(self, modulus: u64) -> u64;",
      "    }",
      "    macro_rules ! impl_rem_euclid_u64_for_small_signed {(\\$ (\\$ ty : tt ) ,* ) => {\\$ (impl RemEuclidU64 for \\$ ty {# [inline ] fn rem_euclid_u64 (self , modulus : u64 ) -> u64 {(self as i128 ) . rem_euclid (i128 :: from (modulus ) ) as _ } } ) * } }",
      "    impl_rem_euclid_u64_for_small_signed!(i8, i16, i32, i64, isize);",
      "    impl RemEuclidU64 for i128 {",
      "        #[inline]",
      "        fn rem_euclid_u64(self, modulus: u64) -> u64 {",
      "            self.rem_euclid(i128::from(modulus)) as _",
      "        }",
      "    }",
      "    macro_rules ! impl_rem_euclid_u64_for_small_unsigned {(\\$ (\\$ ty : tt ) ,* ) => {\\$ (impl RemEuclidU64 for \\$ ty {# [inline ] fn rem_euclid_u64 (self , modulus : u64 ) -> u64 {self as u64 % modulus } } ) * } }",
      "    macro_rules ! impl_rem_euclid_u64_for_large_unsigned {(\\$ (\\$ ty : tt ) ,* ) => {\\$ (impl RemEuclidU64 for \\$ ty {# [inline ] fn rem_euclid_u64 (self , modulus : u64 ) -> u64 {(self % (modulus as \\$ ty ) ) as _ } } ) * } }",
      "    impl_rem_euclid_u64_for_small_unsigned!(u8, u16, u32, u64, usize);",
      "    impl_rem_euclid_u64_for_large_unsigned!(u128);",
      "    trait InternalImplementations: ModIntBase {",
      "        #[inline]",
      "        fn default_impl() -> Self {",
      "            Self::raw(0)",
      "        }",
      "        #[inline]",
      "        fn from_str_impl(s: &str) -> Result<Self, Infallible> {",
      "            Ok(s.parse::<i64>()",
      "                .map(Self::new)",
      "                .unwrap_or_else(|_| todo!(\"parsing as an arbitrary precision integer?\")))",
      "        }",
      "        #[inline]",
      "        fn hash_impl(this: &Self, state: &mut impl Hasher) {",
      "            this.val().hash(state)",
      "        }",
      "        #[inline]",
      "        fn display_impl(this: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "            fmt::Display::fmt(&this.val(), f)",
      "        }",
      "        #[inline]",
      "        fn debug_impl(this: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "            fmt::Debug::fmt(&this.val(), f)",
      "        }",
      "        #[inline]",
      "        fn neg_impl(this: Self) -> Self {",
      "            Self::sub_impl(Self::raw(0), this)",
      "        }",
      "        #[inline]",
      "        fn add_impl(lhs: Self, rhs: Self) -> Self {",
      "            let modulus = Self::modulus();",
      "            let mut val = lhs.val() + rhs.val();",
      "            if val >= modulus {",
      "                val -= modulus;",
      "            }",
      "            Self::raw(val)",
      "        }",
      "        #[inline]",
      "        fn sub_impl(lhs: Self, rhs: Self) -> Self {",
      "            let modulus = Self::modulus();",
      "            let mut val = lhs.val().wrapping_sub(rhs.val());",
      "            if val >= modulus {",
      "                val = val.wrapping_add(modulus)",
      "            }",
      "            Self::raw(val)",
      "        }",
      "        fn mul_impl(lhs: Self, rhs: Self) -> Self;",
      "        #[inline]",
      "        fn div_impl(lhs: Self, rhs: Self) -> Self {",
      "            Self::mul_impl(lhs, rhs.inv())",
      "        }",
      "    }",
      "    impl<M: Modulus> InternalImplementations for StaticModInt<M> {",
      "        #[inline]",
      "        fn mul_impl(lhs: Self, rhs: Self) -> Self {",
      "            Self::raw((u128::from(lhs.val()) * u128::from(rhs.val()) % u128::from(M::VALUE)) as u64)",
      "        }",
      "    }",
      "    macro_rules ! impl_basic_traits {() => {} ; (impl <\\$ generic_param : ident : \\$ generic_param_bound : tt > _ for \\$ self : ty ; \\$ (\\$ rest : tt ) * ) => {impl <\\$ generic_param : \\$ generic_param_bound > Default for \\$ self {# [inline ] fn default () -> Self {Self :: default_impl () } } impl <\\$ generic_param : \\$ generic_param_bound > FromStr for \\$ self {type Err = Infallible ; # [inline ] fn from_str (s : & str ) -> Result < Self , Infallible > {Self :: from_str_impl (s ) } } impl <\\$ generic_param : \\$ generic_param_bound , V : RemEuclidU64 > From < V > for \\$ self {# [inline ] fn from (from : V ) -> Self {Self :: new (from ) } } # [allow (clippy :: derive_hash_xor_eq ) ] impl <\\$ generic_param : \\$ generic_param_bound > Hash for \\$ self {# [inline ] fn hash < H : Hasher > (& self , state : & mut H ) {Self :: hash_impl (self , state ) } } impl <\\$ generic_param : \\$ generic_param_bound > fmt :: Display for \\$ self {# [inline ] fn fmt (& self , f : & mut fmt :: Formatter <'_ > ) -> fmt :: Result {Self :: display_impl (self , f ) } } impl <\\$ generic_param : \\$ generic_param_bound > fmt :: Debug for \\$ self {# [inline ] fn fmt (& self , f : & mut fmt :: Formatter <'_ > ) -> fmt :: Result {Self :: debug_impl (self , f ) } } impl <\\$ generic_param : \\$ generic_param_bound > Neg for \\$ self {type Output = \\$ self ; # [inline ] fn neg (self ) -> \\$ self {Self :: neg_impl (self ) } } impl <\\$ generic_param : \\$ generic_param_bound > Neg for &'_ \\$ self {type Output = \\$ self ; # [inline ] fn neg (self ) -> \\$ self {<\\$ self >:: neg_impl (* self ) } } impl_basic_traits ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    impl_basic_traits! {impl < M : Modulus > _ for StaticModInt < M > ; }",
      "    macro_rules ! impl_bin_ops {() => {} ; (for <\\$ (\\$ generic_param : ident : \\$ generic_param_bound : tt ) ,*> <\\$ lhs_ty : ty > ~ <\\$ rhs_ty : ty > -> \\$ output : ty {{\\$ lhs_body : expr } ~ {\\$ rhs_body : expr } } \\$ (\\$ rest : tt ) * ) => {impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Add <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn add (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: add_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Sub <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn sub (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: sub_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Mul <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn mul (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: mul_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Div <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn div (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: div_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl_bin_ops ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    macro_rules ! impl_assign_ops {() => {} ; (for <\\$ (\\$ generic_param : ident : \\$ generic_param_bound : tt ) ,*> <\\$ lhs_ty : ty > ~= <\\$ rhs_ty : ty > {_ ~= {\\$ rhs_body : expr } } \\$ (\\$ rest : tt ) * ) => {impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> AddAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn add_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self + apply (\\$ rhs_body , rhs ) ; } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> SubAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn sub_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self - apply (\\$ rhs_body , rhs ) ; } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> MulAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn mul_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self * apply (\\$ rhs_body , rhs ) ; } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> DivAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn div_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self / apply (\\$ rhs_body , rhs ) ; } } impl_assign_ops ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    #[inline]",
      "    fn apply<F: FnOnce(X) -> O, X, O>(f: F, x: X) -> O {",
      "        f(x)",
      "    }",
      "    impl_bin_ops! {for < M : Modulus > < StaticModInt < M > > ~ < StaticModInt < M > > -> StaticModInt < M > {{| x | x } ~ {| x | x } } for < M : Modulus > < StaticModInt < M > > ~ <&'_ StaticModInt < M > > -> StaticModInt < M > {{| x | x } ~ {|& x | x } } for < M : Modulus > <&'_ StaticModInt < M > > ~ < StaticModInt < M > > -> StaticModInt < M > {{|& x | x } ~ {| x | x } } for < M : Modulus > <&'_ StaticModInt < M > > ~ <&'_ StaticModInt < M > > -> StaticModInt < M > {{|& x | x } ~ {|& x | x } } for < M : Modulus , T : RemEuclidU64 > < StaticModInt < M > > ~ < T > -> StaticModInt < M > {{| x | x } ~ {StaticModInt ::< M >:: new } } }",
      "    impl_assign_ops! {for < M : Modulus > < StaticModInt < M > > ~= < StaticModInt < M > > {_ ~= {| x | x } } for < M : Modulus > < StaticModInt < M > > ~= <&'_ StaticModInt < M > > {_ ~= {|& x | x } } for < M : Modulus , T : RemEuclidU64 > < StaticModInt < M > > ~= < T > {_ ~= {StaticModInt ::< M >:: new } } }",
      "    macro_rules ! impl_folding {() => {} ; (impl <\\$ generic_param : ident : \\$ generic_param_bound : tt > \\$ trait : ident < _ > for \\$ self : ty {fn \\$ method : ident (_ ) -> _ {_ (\\$ unit : expr , \\$ op : expr ) } } \\$ (\\$ rest : tt ) * ) => {impl <\\$ generic_param : \\$ generic_param_bound > \\$ trait < Self > for \\$ self {# [inline ] fn \\$ method < S > (iter : S ) -> Self where S : Iterator < Item = Self >, {iter . fold (\\$ unit , \\$ op ) } } impl <'a , \\$ generic_param : \\$ generic_param_bound > \\$ trait <&'a Self > for \\$ self {# [inline ] fn \\$ method < S > (iter : S ) -> Self where S : Iterator < Item = &'a Self >, {iter . fold (\\$ unit , \\$ op ) } } impl_folding ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    impl_folding! {impl < M : Modulus > Sum < _ > for StaticModInt < M > {fn sum (_ ) -> _ {_ (Self :: raw (0 ) , Add :: add ) } } impl < M : Modulus > Product < _ > for StaticModInt < M > {fn product (_ ) -> _ {_ (Self :: raw (1 ) , Mul :: mul ) } } }",
      "}",
      "pub mod monoid_rolling_hash {",
      "    use ac_library::Monoid;",
      "    use std::convert::Infallible;",
      "    type Mint = super::ModInt2305843009213693951;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct RollingHash {",
      "        hash: Mint,",
      "        base: Mint,",
      "    }",
      "    impl RollingHash {",
      "        pub fn get_hash(&self) -> u64 {",
      "            self.hash.val()",
      "        }",
      "        pub fn unit(base: i64) -> impl (Fn(i64) -> RollingHash) {",
      "            move |x| RollingHash {",
      "                hash: Mint::new(x),",
      "                base: Mint::new(base),",
      "            }",
      "        }",
      "        pub fn new(hash: i64, base: i64) -> Self {",
      "            Self {",
      "                hash: Mint::new(hash),",
      "                base: Mint::new(base),",
      "            }",
      "        }",
      "    }",
      "    pub struct RollingHashConcat(Infallible);",
      "    impl Monoid for RollingHashConcat {",
      "        type S = RollingHash;",
      "        fn identity() -> Self::S {",
      "            RollingHash {",
      "                hash: Mint::new(0),",
      "                base: Mint::new(1),",
      "            }",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            RollingHash {",
      "                hash: a.hash * b.base + b.hash,",
      "                base: a.base * b.base,",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "monoid_template": {
    "scope": "rust",
    "prefix": "monoid_template",
    "body": [
      "use monoid_template::*;",
      "#[allow(unused_variables)]",
      "pub mod monoid_template {",
      "    use ac_library::segtree::Monoid;",
      "    use std::convert::Infallible;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct RangeXxx {",
      "        pub len: usize,",
      "    }",
      "    impl RangeXxx {",
      "        pub fn unit(x: i64) -> Self {",
      "            Self { len: 1 }",
      "        }",
      "    }",
      "    pub struct RangeXxxMonoid(Infallible);",
      "    impl Monoid for RangeXxxMonoid {",
      "        type S = RangeXxx;",
      "        fn identity() -> Self::S {",
      "            RangeXxx { len: 0 }",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            RangeXxx { len: a.len + b.len }",
      "        }",
      "    }",
      "}"
    ]
  },
  "monoid_transform": {
    "scope": "rust",
    "prefix": "monoid_transform",
    "body": [
      "use dynamic_monoid::*;",
      "use monoid_transform::*;",
      "pub mod dynamic_monoid {",
      "    pub trait DynamicMonoid {",
      "        type S: Clone;",
      "        fn identity(&self) -> Self::S;",
      "        fn binary_operation(&self, a: &Self::S, b: &Self::S) -> Self::S;",
      "        /// base^n を求める",
      "        fn pow(&self, base: &Self::S, n: usize) -> Self::S {",
      "            let mut base = base.clone();",
      "            let mut ans = self.identity();",
      "            let mut n = n;",
      "            while n > 0 {",
      "                if n & 1 == 1 {",
      "                    ans = self.binary_operation(&ans, &base);",
      "                }",
      "                base = self.binary_operation(&base, &base);",
      "                n >>= 1;",
      "            }",
      "            ans",
      "        }",
      "    }",
      "}",
      "pub mod monoid_transform {",
      "    use super::dynamic_monoid::DynamicMonoid;",
      "    use itertools::Itertools;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct Transform {",
      "        n: usize,",
      "    }",
      "    impl Transform {",
      "        pub fn new(n: usize) -> Self {",
      "            Self { n }",
      "        }",
      "    }",
      "    impl DynamicMonoid for Transform {",
      "        type S = Vec<usize>;",
      "        fn identity(&self) -> Self::S {",
      "            (0..self.n).collect_vec()",
      "        }",
      "        fn binary_operation(&self, a: &Self::S, b: &Self::S) -> Self::S {",
      "            (0..self.n).map(|i| a[b[i]]).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "monoid_union_find": {
    "scope": "rust",
    "prefix": "monoid_union_find",
    "body": [
      "use monoid_union_find::*;",
      "/// 可換モノイドをのっけた Union Find",
      "pub mod monoid_union_find {",
      "    use ac_library::Monoid;",
      "    use itertools::Itertools;",
      "    #[derive(Clone, Debug)]",
      "    struct RootInfo<S: Clone> {",
      "        count: usize,",
      "        prod: S,",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    struct NonRootInfo {",
      "        parent: usize,",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    enum Node<S: Clone> {",
      "        Root(RootInfo<S>),",
      "        NonRoot(NonRootInfo),",
      "    }",
      "    impl<S: Clone> Node<S> {",
      "        fn root(count: usize, prod: S) -> Node<S> {",
      "            Node::Root(RootInfo { count, prod })",
      "        }",
      "        fn non_root(parent: usize) -> Node<S> {",
      "            Node::NonRoot(NonRootInfo { parent })",
      "        }",
      "        fn as_root(&self) -> &RootInfo<S> {",
      "            match self {",
      "                Node::Root(info) => info,",
      "                Node::NonRoot(_) => panic!(),",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    pub struct MonoidUnionFind<M: Monoid> {",
      "        nodes: Vec<Node<M::S>>,",
      "        cnt_groups: usize,",
      "    }",
      "    impl<M: Monoid> MonoidUnionFind<M> {",
      "        pub fn new(data: &[M::S]) -> MonoidUnionFind<M> {",
      "            let nodes = data.iter().map(|d| Node::root(1, d.clone())).collect_vec();",
      "            MonoidUnionFind {",
      "                nodes,",
      "                cnt_groups: data.len(),",
      "            }",
      "        }",
      "        pub fn root(&mut self, index: usize) -> usize {",
      "            match &self.nodes[index] {",
      "                Node::Root(_) => index,",
      "                Node::NonRoot(info) => {",
      "                    let root = self.root(info.parent);",
      "                    self.nodes[index] = Node::non_root(root);",
      "                    root",
      "                }",
      "            }",
      "        }",
      "        pub fn same_count(&mut self, index: usize) -> usize {",
      "            let root_index = self.root(index);",
      "            self.nodes[root_index].as_root().count",
      "        }",
      "        pub fn same_prod(&mut self, index: usize) -> M::S {",
      "            let root_index = self.root(index);",
      "            self.nodes[root_index].as_root().prod.clone()",
      "        }",
      "        pub fn same_prod_ref(&mut self, index: usize) -> &M::S {",
      "            let root_index = self.root(index);",
      "            &self.nodes[root_index].as_root().prod",
      "        }",
      "        pub fn same(&mut self, x: usize, y: usize) -> bool {",
      "            self.root(x) == self.root(y)",
      "        }",
      "        pub fn num_groups(&self) -> usize {",
      "            self.cnt_groups",
      "        }",
      "        pub fn unite(&mut self, x: usize, y: usize) -> bool {",
      "            if self.same(x, y) {",
      "                return false;",
      "            }",
      "            self.cnt_groups -= 1;",
      "            let (smaller_root, larger_root) = {",
      "                let x_root = self.root(x);",
      "                let y_root = self.root(y);",
      "                let x_count = self.nodes[x_root].as_root().count;",
      "                let y_count = self.nodes[y_root].as_root().count;",
      "                if x_count < y_count {",
      "                    (x_root, y_root)",
      "                } else {",
      "                    (y_root, x_root)",
      "                }",
      "            };",
      "            let smaller_root_info = self.nodes[smaller_root].as_root();",
      "            let larger_root_info = self.nodes[larger_root].as_root();",
      "            let count = smaller_root_info.count + larger_root_info.count;",
      "            let prod = M::binary_operation(&smaller_root_info.prod, &larger_root_info.prod);",
      "            self.nodes[smaller_root] = Node::non_root(larger_root);",
      "            self.nodes[larger_root] = Node::root(count, prod);",
      "            true",
      "        }",
      "        pub fn groups(&mut self) -> Vec<Vec<usize>> {",
      "            let n = self.nodes.len();",
      "            let roots = (0..n).map(|i| self.root(i)).collect_vec();",
      "            let group_size = (0..n).map(|i| roots[i]).fold(vec![0; n], |mut acc, x| {",
      "                acc[x] += 1;",
      "                acc",
      "            });",
      "            let result = {",
      "                let mut result = vec![Vec::new(); n];",
      "                for i in 0..n {",
      "                    result[i].reserve(group_size[i]);",
      "                }",
      "                for i in 0..n {",
      "                    result[roots[i]].push(i);",
      "                }",
      "                result",
      "            };",
      "            result.into_iter().filter(|x| !x.is_empty()).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "pos": {
    "scope": "rust",
    "prefix": "pos",
    "body": [
      "use pos::*;",
      "pub mod pos {",
      "    use std::ops::{Add, AddAssign, Neg, Sub, SubAssign};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]",
      "    pub struct Pos {",
      "        pub x: i64,",
      "        pub y: i64,",
      "    }",
      "    impl Pos {",
      "        pub fn new(x: i64, y: i64) -> Pos {",
      "            Pos { x, y }",
      "        }",
      "    }",
      "    impl Pos {",
      "        pub fn scala_mul(self, rhs: i64) -> Pos {",
      "            Pos::new(self.x * rhs, self.y * rhs)",
      "        }",
      "    }",
      "    impl Pos {",
      "        pub fn inner_product(self, rhs: Self) -> i64 {",
      "            self.x * rhs.x + self.y * rhs.y",
      "        }",
      "        pub fn norm_square(self) -> i64 {",
      "            self.inner_product(self)",
      "        }",
      "    }",
      "    impl Add for Pos {",
      "        type Output = Pos;",
      "        fn add(self, rhs: Self) -> Self::Output {",
      "            Pos::new(self.x + rhs.x, self.y + rhs.y)",
      "        }",
      "    }",
      "    impl Sub for Pos {",
      "        type Output = Pos;",
      "        fn sub(self, rhs: Self) -> Self::Output {",
      "            Pos::new(self.x - rhs.x, self.y - rhs.y)",
      "        }",
      "    }",
      "    impl Neg for Pos {",
      "        type Output = Self;",
      "        fn neg(self) -> Self::Output {",
      "            Pos::new(-self.x, -self.y)",
      "        }",
      "    }",
      "    impl num_traits::Zero for Pos {",
      "        fn zero() -> Self {",
      "            Pos::new(0, 0)",
      "        }",
      "        fn is_zero(&self) -> bool {",
      "            self.x.is_zero() && self.y.is_zero()",
      "        }",
      "    }",
      "    impl AddAssign for Pos {",
      "        fn add_assign(&mut self, rhs: Self) {",
      "            *self = *self + rhs",
      "        }",
      "    }",
      "    impl SubAssign for Pos {",
      "        fn sub_assign(&mut self, rhs: Self) {",
      "            *self = *self - rhs",
      "        }",
      "    }",
      "    pub const DIR8_LIST: [Pos; 8] = [",
      "        Pos { x: 0, y: 1 },",
      "        Pos { x: 1, y: 1 },",
      "        Pos { x: 1, y: 0 },",
      "        Pos { x: 1, y: -1 },",
      "        Pos { x: 0, y: -1 },",
      "        Pos { x: -1, y: -1 },",
      "        Pos { x: -1, y: 0 },",
      "        Pos { x: -1, y: 1 },",
      "    ];",
      "    pub const DIR4_LIST: [Pos; 4] = [",
      "        Pos { x: 0, y: 1 },",
      "        Pos { x: 1, y: 0 },",
      "        Pos { x: 0, y: -1 },",
      "        Pos { x: -1, y: 0 },",
      "    ];",
      "    impl Pos {",
      "        pub fn around4_pos_iter(self) -> impl Iterator<Item = Pos> {",
      "            DIR4_LIST.iter().copied().map(move |d| self + d)",
      "        }",
      "        pub fn around8_pos_iter(self) -> impl Iterator<Item = Pos> {",
      "            DIR8_LIST.iter().copied().map(move |d| self + d)",
      "        }",
      "    }",
      "}"
    ]
  },
  "positional_notation": {
    "scope": "rust",
    "prefix": "positional_notation",
    "body": [
      "use positional_notation::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod positional_notation {",
      "    /// 配列 xs で表された base 進数の値を評価する",
      "    /// 例: `eval_base_n_value(&[1, 2, 3], 10) == 123`",
      "    pub fn eval_base_n_value(xs: &[i64], base: i64) -> i64 {",
      "        xs.iter().fold(0, |acc, &x| acc * base + x)",
      "    }",
      "    /// n の base 進数での表記を Vec で表す",
      "    /// 例: `to_base_n_value(123, 10) == vec![1, 2, 3]`",
      "    pub fn to_base_n_value(x: i64, base: i64) -> Vec<i64> {",
      "        let mut ret = vec![];",
      "        let mut x = x;",
      "        while x > 0 {",
      "            ret.push(x % base);",
      "            x /= base;",
      "        }",
      "        ret.reverse();",
      "        ret",
      "    }",
      "}"
    ]
  },
  "potentialized_union_find": {
    "scope": "rust",
    "prefix": "potentialized_union_find",
    "body": [
      "use potentialized_union_find::*;",
      "pub mod potentialized_union_find {",
      "    use itertools::Itertools;",
      "    #[derive(Clone, Debug)]",
      "    struct RootInfo {",
      "        count: usize,",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    struct NonRootInfo {",
      "        parent: usize,",
      "        /// 親のポテンシャル - 自分のポテンシャル",
      "        potential_diff: i64,",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    enum Node {",
      "        Root(RootInfo),",
      "        NonRoot(NonRootInfo),",
      "    }",
      "    impl Node {",
      "        fn root(count: usize) -> Node {",
      "            Node::Root(RootInfo { count })",
      "        }",
      "        fn non_root(parent: usize, potential_diff: i64) -> Node {",
      "            Node::NonRoot(NonRootInfo {",
      "                parent,",
      "                potential_diff,",
      "            })",
      "        }",
      "        fn as_root(&self) -> &RootInfo {",
      "            match self {",
      "                Node::Root(info) => info,",
      "                Node::NonRoot(_) => panic!(),",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    struct ToRoot {",
      "        root_index: usize,",
      "        /// root のポテンシャル - 自分のポテンシャル",
      "        potential_diff: i64,",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    pub struct PotentializedUnionFind {",
      "        nodes: Vec<Node>,",
      "        cnt_groups: usize,",
      "    }",
      "    pub enum UnionResult {",
      "        Consistent { updated: bool },",
      "        Inconsistent,",
      "    }",
      "    impl UnionResult {",
      "        pub fn updated(&self) -> bool {",
      "            match self {",
      "                UnionResult::Consistent { updated } => *updated,",
      "                UnionResult::Inconsistent => false,",
      "            }",
      "        }",
      "        pub fn is_consistent(&self) -> bool {",
      "            matches!(self, UnionResult::Consistent { .. })",
      "        }",
      "        pub fn is_inconsistent(&self) -> bool {",
      "            matches!(self, UnionResult::Inconsistent { .. })",
      "        }",
      "    }",
      "    impl PotentializedUnionFind {",
      "        pub fn new(n: usize) -> PotentializedUnionFind {",
      "            PotentializedUnionFind {",
      "                nodes: vec![Node::Root(RootInfo { count: 1 }); n],",
      "                cnt_groups: n,",
      "            }",
      "        }",
      "        fn root_node(&mut self, index: usize) -> ToRoot {",
      "            match &self.nodes[index] {",
      "                Node::Root(_) => ToRoot {",
      "                    root_index: index,",
      "                    potential_diff: 0,",
      "                },",
      "                Node::NonRoot(my_info) => {",
      "                    let to_parent_potential_diff = my_info.potential_diff;",
      "                    let parent_to_root = self.root_node(my_info.parent);",
      "                    let new_potential_diff =",
      "                        to_parent_potential_diff + parent_to_root.potential_diff;",
      "                    self.nodes[index] =",
      "                        Node::non_root(parent_to_root.root_index, new_potential_diff);",
      "                    ToRoot {",
      "                        root_index: parent_to_root.root_index,",
      "                        potential_diff: new_potential_diff,",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        pub fn root(&mut self, index: usize) -> usize {",
      "            self.root_node(index).root_index",
      "        }",
      "        pub fn same_count(&mut self, index: usize) -> usize {",
      "            let root_index = self.root(index);",
      "            self.nodes[root_index].as_root().count",
      "        }",
      "        pub fn same(&mut self, x: usize, y: usize) -> bool {",
      "            self.root(x) == self.root(y)",
      "        }",
      "        pub fn num_groups(&self) -> usize {",
      "            self.cnt_groups",
      "        }",
      "        /// diff = dst のポテンシャル - src のポテンシャル となるように統合する",
      "        pub fn unite(&mut self, src: usize, dst: usize, diff: i64) -> UnionResult {",
      "            if self.same(src, dst) {",
      "                if self.diff(src, dst) == Some(diff) {",
      "                    return UnionResult::Consistent { updated: false };",
      "                } else {",
      "                    return UnionResult::Inconsistent;",
      "                }",
      "            }",
      "            self.cnt_groups -= 1;",
      "            let src_root_node = self.root_node(src);",
      "            let dst_root_node = self.root_node(dst);",
      "            let root_diff = -src_root_node.potential_diff + diff + dst_root_node.potential_diff;",
      "            let (src_root_node, dst_root_node, root_diff) = {",
      "                let src_cnt = self.nodes[src_root_node.root_index].as_root().count;",
      "                let dst_cnt = self.nodes[dst_root_node.root_index].as_root().count;",
      "                if src_cnt <= dst_cnt {",
      "                    (src_root_node, dst_root_node, root_diff)",
      "                } else {",
      "                    (dst_root_node, src_root_node, -root_diff)",
      "                }",
      "            };",
      "            let count_sum = self.nodes[src_root_node.root_index].as_root().count",
      "                + self.nodes[dst_root_node.root_index].as_root().count;",
      "            self.nodes[src_root_node.root_index] =",
      "                Node::non_root(dst_root_node.root_index, root_diff);",
      "            self.nodes[dst_root_node.root_index] = Node::root(count_sum);",
      "            UnionResult::Consistent { updated: true }",
      "        }",
      "        /// dst のポテンシャル - src のポテンシャル を求める",
      "        pub fn diff(&mut self, src: usize, dst: usize) -> Option<i64> {",
      "            if self.same(src, dst) {",
      "                Some(self.root_node(src).potential_diff - self.root_node(dst).potential_diff)",
      "            } else {",
      "                None",
      "            }",
      "        }",
      "        pub fn groups(&mut self) -> Vec<Vec<usize>> {",
      "            let n = self.nodes.len();",
      "            let roots = (0..n).map(|i| self.root(i)).collect_vec();",
      "            let group_size = (0..n).map(|i| roots[i]).fold(vec![0; n], |mut acc, x| {",
      "                acc[x] += 1;",
      "                acc",
      "            });",
      "            let result = {",
      "                let mut result = vec![Vec::new(); n];",
      "                for i in 0..n {",
      "                    result[i].reserve(group_size[i]);",
      "                }",
      "                for i in 0..n {",
      "                    result[roots[i]].push(i);",
      "                }",
      "                result",
      "            };",
      "            result.into_iter().filter(|x| !x.is_empty()).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "prime_factorize": {
    "scope": "rust",
    "prefix": "prime_factorize",
    "body": [
      "/// 計算量: O(sqrt(n))",
      "pub fn prime_factorize(n: i64) -> HashMap<i64, i64> {",
      "    use num::Integer;",
      "    use num_integer::Roots;",
      "    assert!(n >= 1);",
      "    let mut cnt_table: HashMap<i64, i64> = HashMap::new();",
      "    let mut n = n;",
      "    for i in 2..=n.sqrt() {",
      "        if n.is_multiple_of(&i) {",
      "            let mut cnt = 0;",
      "            while n.is_multiple_of(&i) {",
      "                n /= i;",
      "                cnt += 1;",
      "            }",
      "            cnt_table.insert(i, cnt);",
      "        }",
      "    }",
      "    if n != 1 {",
      "        cnt_table.insert(n, 1);",
      "    }",
      "    cnt_table",
      "}"
    ]
  },
  "print_arr": {
    "scope": "rust",
    "prefix": "print_arr",
    "body": [
      "use print_arr::*;",
      "pub mod print_arr {",
      "    use ndarray::{Array2, Array3};",
      "    use proconio::fastout;",
      "    #[fastout]",
      "    pub fn print_arr<T: std::fmt::Debug>(arr: &[T]) {",
      "        for a in arr {",
      "            print!(\"{:?} \", a);",
      "        }",
      "        println!();",
      "    }",
      "    #[fastout]",
      "    pub fn print_arr2<T: std::fmt::Debug>(arr: &Array2<T>) {",
      "        for i in 0..arr.nrows() {",
      "            for j in 0..arr.ncols() {",
      "                print!(\"{:?} \", arr[[i, j]]);",
      "            }",
      "            println!();",
      "        }",
      "    }",
      "    #[fastout]",
      "    pub fn print_arr3<T: std::fmt::Debug>(arr: &Array3<T>) {",
      "        let shape = arr.shape();",
      "        for i in 0..shape[0] {",
      "            for j in 0..shape[1] {",
      "                for k in 0..shape[2] {",
      "                    print!(\"{:?} \", arr[[i, j, k]]);",
      "                }",
      "                println!();",
      "            }",
      "            println!();",
      "        }",
      "    }",
      "}"
    ]
  },
  "print_vec": {
    "scope": "rust",
    "prefix": "print_vec",
    "body": [
      "use print_vec::*;",
      "pub mod print_vec {",
      "    use itertools::Itertools;",
      "    use proconio::fastout;",
      "    #[fastout]",
      "    pub fn print_vec<T: std::fmt::Debug>(arr: &[T]) {",
      "        for a in arr {",
      "            println!(\"{:?}\", a);",
      "        }",
      "    }",
      "    #[fastout]",
      "    pub fn print_vec_1line<T: std::fmt::Debug>(arr: &[T]) {",
      "        let msg = arr.iter().map(|x| format!(\"{:?}\", x)).join(\" \");",
      "        println!(\"{}\", msg);",
      "    }",
      "    #[fastout]",
      "    pub fn print_vec2<T: std::fmt::Debug>(arr: &Vec<Vec<T>>) {",
      "        for row in arr {",
      "            let msg = row.iter().map(|x| format!(\"{:?}\", x)).join(\" \");",
      "            println!(\"{}\", msg);",
      "        }",
      "    }",
      "    pub fn print_bytes(bytes: &[u8]) {",
      "        let msg = String::from_utf8(bytes.to_vec()).unwrap();",
      "        println!(\"{}\", msg);",
      "    }",
      "    #[fastout]",
      "    pub fn print_vec_bytes(vec_bytes: &[Vec<u8>]) {",
      "        for row in vec_bytes {",
      "            let msg = String::from_utf8(row.to_vec()).unwrap();",
      "            println!(\"{}\", msg);",
      "        }",
      "    }",
      "}"
    ]
  },
  "random_test": {
    "scope": "rust",
    "prefix": "random_test",
    "body": [
      "use random_test::*;",
      "pub mod random_test {",
      "    use itertools::Itertools;",
      "    use num::Integer;",
      "    use num_integer::Roots;",
      "    use petgraph::unionfind::UnionFind;",
      "    use rand::Rng;",
      "    use std::{collections::HashSet, hash::Hash};",
      "    pub fn generate_random_uniq_sequence<T, F>(n: usize, mut gen: F) -> Vec<T>",
      "    where",
      "        T: Hash + PartialEq + Eq,",
      "        F: FnMut() -> T,",
      "    {",
      "        let mut set: HashSet<T> = HashSet::new();",
      "        while set.len() != n {",
      "            set.insert(gen());",
      "        }",
      "        set.into_iter().collect_vec()",
      "    }",
      "    pub fn generate_random_while<T, F, P>(mut gen: F, mut pred: P) -> T",
      "    where",
      "        F: FnMut() -> T,",
      "        P: FnMut(&T) -> bool,",
      "    {",
      "        loop {",
      "            let x = gen();",
      "            if pred(&x) {",
      "                return x;",
      "            }",
      "        }",
      "    }",
      "    pub fn generate_random_tree<R>(rng: &mut R, n_vertices: usize) -> Vec<(usize, usize)>",
      "    where",
      "        R: Rng,",
      "    {",
      "        let mut edges: Vec<(usize, usize)> = Vec::new();",
      "        let mut uf: UnionFind<usize> = UnionFind::new(n_vertices);",
      "        while edges.len() != n_vertices - 1 {",
      "            let x = rng.gen_range(0..n_vertices);",
      "            let y = rng.gen_range(0..n_vertices);",
      "            if uf.union(x, y) {",
      "                edges.push((x, y));",
      "            }",
      "        }",
      "        edges",
      "    }",
      "    fn is_prime(n: i64) -> bool {",
      "        if n <= 1 {",
      "            return false;",
      "        }",
      "        for i in 2..=n.sqrt() {",
      "            if n.is_multiple_of(&i) {",
      "                return false;",
      "            }",
      "        }",
      "        true",
      "    }",
      "    pub fn generate_random_prime<R>(rng: &mut R, begin: i64, end: i64) -> i64",
      "    where",
      "        R: Rng,",
      "    {",
      "        let gen = || rng.gen_range(begin..end);",
      "        generate_random_while(gen, |x| is_prime(*x))",
      "    }",
      "}"
    ]
  },
  "range_add": {
    "scope": "rust",
    "prefix": "range_add",
    "body": [
      "use range_add::*;",
      "pub mod range_add {",
      "    use super::dual_segtree::*;",
      "    use std::convert::Infallible;",
      "    pub struct AddMonoid(Infallible);",
      "    impl MapMonoid for AddMonoid {",
      "        type F = i32;",
      "        type S = i32;",
      "        fn identity_map() -> Self::F {",
      "            0",
      "        }",
      "        fn mapping(&f: &i32, &x: &i32) -> i32 {",
      "            f + x",
      "        }",
      "        fn composition(&f: &i32, &g: &i32) -> i32 {",
      "            f + g",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_affine": {
    "scope": "rust",
    "prefix": "range_affine",
    "body": [
      "use range_affine::*;",
      "pub mod range_affine {",
      "    use super::dual_segtree::*;",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    use std::ops::{Add, Mul};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct Affine<T> {",
      "        pub slope: T,",
      "        pub intercept: T,",
      "    }",
      "    impl<T> Affine<T> {",
      "        pub fn new(slope: T, intercept: T) -> Affine<T> {",
      "            Affine { slope, intercept }",
      "        }",
      "    }",
      "    impl<T> Affine<T>",
      "    where",
      "        T: From<i64>,",
      "    {",
      "        /// 区間変更用（定数関数）",
      "        pub fn constant_func(x: T) -> Affine<T> {",
      "            Affine {",
      "                slope: 0.into(),",
      "                intercept: x,",
      "            }",
      "        }",
      "        /// 区間加算用",
      "        pub fn addition_func(x: T) -> Affine<T> {",
      "            Affine {",
      "                slope: 1.into(),",
      "                intercept: x,",
      "            }",
      "        }",
      "    }",
      "    pub struct AffineMonoid<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> MapMonoid for AffineMonoid<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        type F = Affine<T>;",
      "        type S = T;",
      "        fn identity_map() -> Affine<T> {",
      "            Affine {",
      "                slope: 1.into(),",
      "                intercept: 0.into(),",
      "            }",
      "        }",
      "        fn composition(a: &Affine<T>, b: &Affine<T>) -> Affine<T> {",
      "            Affine {",
      "                slope: a.slope * b.slope,",
      "                intercept: a.slope * b.intercept + a.intercept,",
      "            }",
      "        }",
      "        fn mapping(f: &Affine<T>, x: &T) -> T {",
      "            f.slope * *x + f.intercept",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_affine_range_minmax": {
    "scope": "rust",
    "prefix": "range_affine_range_minmax",
    "body": [
      "use range_affine_range_minmax::*;",
      "pub mod range_affine_range_minmax {",
      "    use ac_library::{LazySegtree, MapMonoid, Monoid};",
      "    use itertools::Itertools;",
      "    use std::{cmp::Ordering, convert::Infallible, ops::RangeBounds};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeMinMax {",
      "        pub min: i64,",
      "        pub max: i64,",
      "        pub len: i64,",
      "    }",
      "    impl RangeMinMax {",
      "        pub fn unit(x: i64) -> RangeMinMax {",
      "            RangeMinMax {",
      "                min: x,",
      "                max: x,",
      "                len: 1,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct Affine {",
      "        pub slope: i64,",
      "        pub intercept: i64,",
      "    }",
      "    impl Affine {",
      "        /// 区間変更用（定数関数）",
      "        pub fn constant_func(x: i64) -> Affine {",
      "            Affine {",
      "                slope: 0,",
      "                intercept: x,",
      "            }",
      "        }",
      "        /// 区間加算用",
      "        pub fn addition_func(x: i64) -> Affine {",
      "            Affine {",
      "                slope: 1,",
      "                intercept: x,",
      "            }",
      "        }",
      "    }",
      "    pub struct RangeMinMaxMonoid(Infallible);",
      "    impl Monoid for RangeMinMaxMonoid {",
      "        type S = RangeMinMax;",
      "        fn identity() -> RangeMinMax {",
      "            RangeMinMax {",
      "                min: INF,",
      "                max: -INF,",
      "                len: 0,",
      "            }",
      "        }",
      "        fn binary_operation(a: &RangeMinMax, b: &RangeMinMax) -> RangeMinMax {",
      "            RangeMinMax {",
      "                min: Ord::min(a.min, b.min),",
      "                max: Ord::max(a.max, b.max),",
      "                len: a.len + b.len,",
      "            }",
      "        }",
      "    }",
      "    const INF: i64 = i64::MAX;",
      "    pub struct RangeAffineRangeMinMax(Infallible);",
      "    impl MapMonoid for RangeAffineRangeMinMax {",
      "        type M = RangeMinMaxMonoid;",
      "        type F = Affine;",
      "        fn identity_map() -> Affine {",
      "            Affine {",
      "                slope: 1,",
      "                intercept: 0,",
      "            }",
      "        }",
      "        fn composition(a: &Affine, b: &Affine) -> Affine {",
      "            Affine {",
      "                slope: a.slope * b.slope,",
      "                intercept: a.slope * b.intercept + a.intercept,",
      "            }",
      "        }",
      "        fn mapping(f: &Affine, x: &RangeMinMax) -> RangeMinMax {",
      "            if x.len == 0 {",
      "                return RangeMinMaxMonoid::identity();",
      "            }",
      "            match f.slope.cmp(&0) {",
      "                Ordering::Equal => RangeMinMax {",
      "                    min: f.intercept,",
      "                    max: f.intercept,",
      "                    len: x.len,",
      "                },",
      "                Ordering::Greater => RangeMinMax {",
      "                    min: f.intercept + f.slope * x.min,",
      "                    max: f.intercept + f.slope * x.max,",
      "                    len: x.len,",
      "                },",
      "                Ordering::Less => RangeMinMax {",
      "                    min: f.intercept + f.slope * x.max,",
      "                    max: f.intercept + f.slope * x.min,",
      "                    len: x.len,",
      "                },",
      "            }",
      "        }",
      "    }",
      "    pub struct RangeAffineRangeMinMaxSegtree {",
      "        segtree: LazySegtree<RangeAffineRangeMinMax>,",
      "        len: usize,",
      "    }",
      "    impl RangeAffineRangeMinMaxSegtree {",
      "        pub fn new(xs: &[i64]) -> RangeAffineRangeMinMaxSegtree {",
      "            let xs = xs.iter().copied().map(RangeMinMax::unit).collect_vec();",
      "            let len = xs.len();",
      "            RangeAffineRangeMinMaxSegtree {",
      "                segtree: LazySegtree::from(xs),",
      "                len,",
      "            }",
      "        }",
      "        pub fn set(&mut self, p: usize, x: i64) {",
      "            self.segtree.set(p, RangeMinMax::unit(x));",
      "        }",
      "        pub fn get(&mut self, p: usize) -> i64 {",
      "            self.segtree.get(p).min",
      "        }",
      "        pub fn range_min<R>(&mut self, range: R) -> i64",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range).min",
      "        }",
      "        pub fn range_max<R>(&mut self, range: R) -> i64",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range).max",
      "        }",
      "        pub fn all_min(&self) -> i64 {",
      "            self.segtree.all_prod().min",
      "        }",
      "        pub fn all_max(&self) -> i64 {",
      "            self.segtree.all_prod().max",
      "        }",
      "        pub fn apply_affine(&mut self, p: usize, slope: i64, intercept: i64) {",
      "            self.segtree.apply(p, Affine { slope, intercept })",
      "        }",
      "        pub fn apply_update(&mut self, p: usize, x: i64) {",
      "            self.segtree.apply(p, Affine::constant_func(x))",
      "        }",
      "        pub fn apply_add(&mut self, p: usize, x: i64) {",
      "            self.segtree.apply(p, Affine::addition_func(x))",
      "        }",
      "        pub fn apply_range_affine<R>(&mut self, range: R, slope: i64, intercept: i64)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, Affine { slope, intercept })",
      "        }",
      "        pub fn apply_range_update<R>(&mut self, range: R, x: i64)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, Affine::constant_func(x))",
      "        }",
      "        pub fn apply_range_add<R>(&mut self, range: R, x: i64)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, Affine::addition_func(x))",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<i64> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_affine_range_sum": {
    "scope": "rust",
    "prefix": "range_affine_range_sum",
    "body": [
      "use range_affine_range_sum::*;",
      "pub mod range_affine_range_sum {",
      "    use ac_library::{LazySegtree, MapMonoid, Monoid};",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    use std::ops::{Add, Mul, RangeBounds};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeSum<T> {",
      "        pub sum: T,",
      "        pub len: i64,",
      "    }",
      "    impl<T> RangeSum<T> {",
      "        pub fn unit(x: T) -> RangeSum<T> {",
      "            RangeSum { sum: x, len: 1 }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct Affine<T> {",
      "        pub slope: T,",
      "        pub intercept: T,",
      "    }",
      "    impl<T> Affine<T>",
      "    where",
      "        T: From<i64>,",
      "    {",
      "        /// 区間変更用（定数関数）",
      "        pub fn constant_func(x: T) -> Affine<T> {",
      "            Affine {",
      "                slope: 0.into(),",
      "                intercept: x,",
      "            }",
      "        }",
      "        /// 区間加算用",
      "        pub fn addition_func(x: T) -> Affine<T> {",
      "            Affine {",
      "                slope: 1.into(),",
      "                intercept: x,",
      "            }",
      "        }",
      "    }",
      "    pub struct ValueLenSum<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for ValueLenSum<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        type S = RangeSum<T>;",
      "        fn identity() -> RangeSum<T> {",
      "            RangeSum {",
      "                sum: 0.into(),",
      "                len: 0,",
      "            }",
      "        }",
      "        fn binary_operation(a: &RangeSum<T>, b: &RangeSum<T>) -> RangeSum<T> {",
      "            RangeSum {",
      "                sum: a.sum + b.sum,",
      "                len: a.len + b.len,",
      "            }",
      "        }",
      "    }",
      "    pub struct RangeAffineRangeSum<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> MapMonoid for RangeAffineRangeSum<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        type M = ValueLenSum<T>;",
      "        type F = Affine<T>;",
      "        fn identity_map() -> Affine<T> {",
      "            Affine {",
      "                slope: 1.into(),",
      "                intercept: 0.into(),",
      "            }",
      "        }",
      "        fn composition(a: &Affine<T>, b: &Affine<T>) -> Affine<T> {",
      "            Affine {",
      "                slope: a.slope * b.slope,",
      "                intercept: a.slope * b.intercept + a.intercept,",
      "            }",
      "        }",
      "        fn mapping(f: &Affine<T>, x: &RangeSum<T>) -> RangeSum<T> {",
      "            RangeSum {",
      "                sum: f.slope * x.sum + f.intercept * x.len.into(),",
      "                len: x.len,",
      "            }",
      "        }",
      "    }",
      "    pub struct RangeAffineRangeSumSegtree<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        segtree: LazySegtree<RangeAffineRangeSum<T>>,",
      "        len: usize,",
      "    }",
      "    impl<T> RangeAffineRangeSumSegtree<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        pub fn new(xs: &[T]) -> RangeAffineRangeSumSegtree<T> {",
      "            let xs = xs.iter().copied().map(RangeSum::unit).collect_vec();",
      "            let len = xs.len();",
      "            RangeAffineRangeSumSegtree {",
      "                segtree: LazySegtree::from(xs),",
      "                len,",
      "            }",
      "        }",
      "        pub fn set(&mut self, p: usize, x: T) {",
      "            self.segtree.set(p, RangeSum::unit(x));",
      "        }",
      "        pub fn get(&mut self, p: usize) -> T {",
      "            self.segtree.get(p).sum",
      "        }",
      "        pub fn range_sum<R>(&mut self, range: R) -> T",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range).sum",
      "        }",
      "        pub fn all_sum(&self) -> T {",
      "            self.segtree.all_prod().sum",
      "        }",
      "        pub fn apply_affine(&mut self, p: usize, slope: T, intercept: T) {",
      "            self.segtree.apply(p, Affine { slope, intercept })",
      "        }",
      "        pub fn apply_update(&mut self, p: usize, x: T) {",
      "            self.segtree.apply(p, Affine::constant_func(x))",
      "        }",
      "        pub fn apply_add(&mut self, p: usize, x: T) {",
      "            self.segtree.apply(p, Affine::addition_func(x))",
      "        }",
      "        pub fn apply_range_affine<R>(&mut self, range: R, slope: T, intercept: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, Affine { slope, intercept })",
      "        }",
      "        pub fn apply_range_update<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, Affine::constant_func(x))",
      "        }",
      "        pub fn apply_range_add<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, Affine::addition_func(x))",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<T> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_chmax_range_sum": {
    "scope": "rust",
    "prefix": "range_chmax_range_sum",
    "body": [
      "use abstract_segtree_beats::*;",
      "use range_chmax_range_sum::*;",
      "pub mod abstract_segtree_beats {",
      "    fn ceil_pow2(n: u32) -> u32 {",
      "        32 - n.saturating_sub(1).leading_zeros()",
      "    }",
      "    pub trait MonoidBeats {",
      "        type S: Clone;",
      "        fn identity() -> Self::S;",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S;",
      "        fn fails(a: &Self::S) -> bool;",
      "    }",
      "    pub trait MapMonoidBeats {",
      "        type M: MonoidBeats;",
      "        type F: Clone;",
      "        fn identity_element() -> <Self::M as MonoidBeats>::S {",
      "            Self::M::identity()",
      "        }",
      "        fn binary_operation(",
      "            a: &<Self::M as MonoidBeats>::S,",
      "            b: &<Self::M as MonoidBeats>::S,",
      "        ) -> <Self::M as MonoidBeats>::S {",
      "            Self::M::binary_operation(a, b)",
      "        }",
      "        fn fails(a: &<Self::M as MonoidBeats>::S) -> bool {",
      "            Self::M::fails(a)",
      "        }",
      "        fn identity_map() -> Self::F;",
      "        fn mapping(f: &Self::F, x: &<Self::M as MonoidBeats>::S) -> <Self::M as MonoidBeats>::S;",
      "        fn composition(f: &Self::F, g: &Self::F) -> Self::F;",
      "    }",
      "    impl<F: MapMonoidBeats> Default for SegtreeBeats<F> {",
      "        fn default() -> Self {",
      "            Self::new(0)",
      "        }",
      "    }",
      "    impl<F: MapMonoidBeats> SegtreeBeats<F> {",
      "        pub fn new(n: usize) -> Self {",
      "            vec![F::identity_element(); n].into()",
      "        }",
      "    }",
      "    impl<F: MapMonoidBeats> From<Vec<<F::M as MonoidBeats>::S>> for SegtreeBeats<F> {",
      "        fn from(v: Vec<<F::M as MonoidBeats>::S>) -> Self {",
      "            let n = v.len();",
      "            let log = ceil_pow2(n as u32) as usize;",
      "            let size = 1 << log;",
      "            let mut d = vec![F::identity_element(); 2 * size];",
      "            let lz = vec![F::identity_map(); size];",
      "            d[size..(size + n)].clone_from_slice(&v);",
      "            let mut ret = SegtreeBeats {",
      "                n,",
      "                size,",
      "                log,",
      "                d,",
      "                lz,",
      "            };",
      "            for i in (1..size).rev() {",
      "                ret.update(i);",
      "            }",
      "            ret",
      "        }",
      "    }",
      "    impl<F: MapMonoidBeats> SegtreeBeats<F> {",
      "        pub fn set(&mut self, mut p: usize, x: <F::M as MonoidBeats>::S) {",
      "            assert!(p < self.n);",
      "            p += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(p >> i);",
      "            }",
      "            self.d[p] = x;",
      "            for i in 1..=self.log {",
      "                self.update(p >> i);",
      "            }",
      "        }",
      "        pub fn get(&mut self, mut p: usize) -> <F::M as MonoidBeats>::S {",
      "            assert!(p < self.n);",
      "            p += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(p >> i);",
      "            }",
      "            self.d[p].clone()",
      "        }",
      "        pub fn prod<R>(&mut self, range: R) -> <F::M as MonoidBeats>::S",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            if range.start_bound() == Bound::Unbounded && range.end_bound() == Bound::Unbounded {",
      "                return self.all_prod();",
      "            }",
      "            let mut r = match range.end_bound() {",
      "                Bound::Included(r) => r + 1,",
      "                Bound::Excluded(r) => *r,",
      "                Bound::Unbounded => self.n,",
      "            };",
      "            let mut l = match range.start_bound() {",
      "                Bound::Included(l) => *l,",
      "                Bound::Excluded(l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            assert!(l <= r && r <= self.n);",
      "            if l == r {",
      "                return F::identity_element();",
      "            }",
      "            l += self.size;",
      "            r += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                if ((l >> i) << i) != l {",
      "                    self.push(l >> i);",
      "                }",
      "                if ((r >> i) << i) != r {",
      "                    self.push(r >> i);",
      "                }",
      "            }",
      "            let mut sml = F::identity_element();",
      "            let mut smr = F::identity_element();",
      "            while l < r {",
      "                if l & 1 != 0 {",
      "                    sml = F::binary_operation(&sml, &self.d[l]);",
      "                    l += 1;",
      "                }",
      "                if r & 1 != 0 {",
      "                    r -= 1;",
      "                    smr = F::binary_operation(&self.d[r], &smr);",
      "                }",
      "                l >>= 1;",
      "                r >>= 1;",
      "            }",
      "            F::binary_operation(&sml, &smr)",
      "        }",
      "        pub fn all_prod(&self) -> <F::M as MonoidBeats>::S {",
      "            self.d[1].clone()",
      "        }",
      "        pub fn apply(&mut self, mut p: usize, f: F::F) {",
      "            assert!(p < self.n);",
      "            p += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(p >> i);",
      "            }",
      "            self.d[p] = F::mapping(&f, &self.d[p]);",
      "            for i in 1..=self.log {",
      "                self.update(p >> i);",
      "            }",
      "        }",
      "        pub fn apply_range<R>(&mut self, range: R, f: F::F)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            let mut r = match range.end_bound() {",
      "                Bound::Included(r) => r + 1,",
      "                Bound::Excluded(r) => *r,",
      "                Bound::Unbounded => self.n,",
      "            };",
      "            let mut l = match range.start_bound() {",
      "                Bound::Included(l) => *l,",
      "                Bound::Excluded(l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            assert!(l <= r && r <= self.n);",
      "            if l == r {",
      "                return;",
      "            }",
      "            l += self.size;",
      "            r += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                if ((l >> i) << i) != l {",
      "                    self.push(l >> i);",
      "                }",
      "                if ((r >> i) << i) != r {",
      "                    self.push((r - 1) >> i);",
      "                }",
      "            }",
      "            {",
      "                let l2 = l;",
      "                let r2 = r;",
      "                while l < r {",
      "                    if l & 1 != 0 {",
      "                        self.all_apply(l, f.clone());",
      "                        l += 1;",
      "                    }",
      "                    if r & 1 != 0 {",
      "                        r -= 1;",
      "                        self.all_apply(r, f.clone());",
      "                    }",
      "                    l >>= 1;",
      "                    r >>= 1;",
      "                }",
      "                l = l2;",
      "                r = r2;",
      "            }",
      "            for i in 1..=self.log {",
      "                if ((l >> i) << i) != l {",
      "                    self.update(l >> i);",
      "                }",
      "                if ((r >> i) << i) != r {",
      "                    self.update((r - 1) >> i);",
      "                }",
      "            }",
      "        }",
      "        pub fn max_right<G>(&mut self, mut l: usize, g: G) -> usize",
      "        where",
      "            G: Fn(<F::M as MonoidBeats>::S) -> bool,",
      "        {",
      "            assert!(l <= self.n);",
      "            assert!(g(F::identity_element()));",
      "            if l == self.n {",
      "                return self.n;",
      "            }",
      "            l += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(l >> i);",
      "            }",
      "            let mut sm = F::identity_element();",
      "            while {",
      "                while l % 2 == 0 {",
      "                    l >>= 1;",
      "                }",
      "                if !g(F::binary_operation(&sm, &self.d[l])) {",
      "                    while l < self.size {",
      "                        self.push(l);",
      "                        l *= 2;",
      "                        let res = F::binary_operation(&sm, &self.d[l]);",
      "                        if g(res.clone()) {",
      "                            sm = res;",
      "                            l += 1;",
      "                        }",
      "                    }",
      "                    return l - self.size;",
      "                }",
      "                sm = F::binary_operation(&sm, &self.d[l]);",
      "                l += 1;",
      "                {",
      "                    let l = l as isize;",
      "                    (l & -l) != l",
      "                }",
      "            } {}",
      "            self.n",
      "        }",
      "        pub fn min_left<G>(&mut self, mut r: usize, g: G) -> usize",
      "        where",
      "            G: Fn(<F::M as MonoidBeats>::S) -> bool,",
      "        {",
      "            assert!(r <= self.n);",
      "            assert!(g(F::identity_element()));",
      "            if r == 0 {",
      "                return 0;",
      "            }",
      "            r += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push((r - 1) >> i);",
      "            }",
      "            let mut sm = F::identity_element();",
      "            while {",
      "                r -= 1;",
      "                while r > 1 && r % 2 != 0 {",
      "                    r >>= 1;",
      "                }",
      "                if !g(F::binary_operation(&self.d[r], &sm)) {",
      "                    while r < self.size {",
      "                        self.push(r);",
      "                        r = 2 * r + 1;",
      "                        let res = F::binary_operation(&self.d[r], &sm);",
      "                        if g(res.clone()) {",
      "                            sm = res;",
      "                            r -= 1;",
      "                        }",
      "                    }",
      "                    return r + 1 - self.size;",
      "                }",
      "                sm = F::binary_operation(&self.d[r], &sm);",
      "                {",
      "                    let r = r as isize;",
      "                    (r & -r) != r",
      "                }",
      "            } {}",
      "            0",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<<F::M as MonoidBeats>::S> {",
      "            (0..self.n).map(|i| self.get(i)).collect()",
      "        }",
      "    }",
      "    pub struct SegtreeBeats<F>",
      "    where",
      "        F: MapMonoidBeats,",
      "    {",
      "        n: usize,",
      "        size: usize,",
      "        log: usize,",
      "        d: Vec<<F::M as MonoidBeats>::S>,",
      "        lz: Vec<F::F>,",
      "    }",
      "    impl<F> SegtreeBeats<F>",
      "    where",
      "        F: MapMonoidBeats,",
      "    {",
      "        fn update(&mut self, k: usize) {",
      "            self.d[k] = F::binary_operation(&self.d[2 * k], &self.d[2 * k + 1]);",
      "        }",
      "        fn all_apply(&mut self, k: usize, f: F::F) {",
      "            self.d[k] = F::mapping(&f, &self.d[k]);",
      "            if k < self.size {",
      "                self.lz[k] = F::composition(&f, &self.lz[k]);",
      "                if F::fails(&self.d[k]) {",
      "                    self.push(k);",
      "                    self.update(k)",
      "                }",
      "            }",
      "        }",
      "        fn push(&mut self, k: usize) {",
      "            self.all_apply(2 * k, self.lz[k].clone());",
      "            self.all_apply(2 * k + 1, self.lz[k].clone());",
      "            self.lz[k] = F::identity_map();",
      "        }",
      "    }",
      "    use std::{",
      "        fmt::{Debug, Error, Formatter, Write},",
      "        ops::{Bound, RangeBounds},",
      "    };",
      "    impl<F> Debug for SegtreeBeats<F>",
      "    where",
      "        F: MapMonoidBeats,",
      "        F::F: Debug,",
      "        <F::M as MonoidBeats>::S: Debug,",
      "    {",
      "        fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {",
      "            for i in 0..self.log {",
      "                for j in 0..1 << i {",
      "                    f.write_fmt(format_args!(",
      "                        \"{:?}[{:?}]\\t\",",
      "                        self.d[(1 << i) + j],",
      "                        self.lz[(1 << i) + j]",
      "                    ))?;",
      "                }",
      "                f.write_char('\\n')?;",
      "            }",
      "            for i in 0..self.size {",
      "                f.write_fmt(format_args!(\"{:?}\\t\", self.d[self.size + i]))?;",
      "            }",
      "            Ok(())",
      "        }",
      "    }",
      "}",
      "pub mod range_chmax_range_sum {",
      "    use super::abstract_segtree_beats::{MapMonoidBeats, MonoidBeats};",
      "    use std::{",
      "        cmp::{max, min},",
      "        convert::Infallible,",
      "    };",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct RangeSum {",
      "        pub sum: i64,",
      "        pub len: usize,",
      "        pub min: i64,",
      "        pub min_cnt: usize,",
      "        pub min_2nd: i64,",
      "    }",
      "    impl RangeSum {",
      "        pub fn unit(x: i64) -> Option<RangeSum> {",
      "            Some(RangeSum {",
      "                sum: x,",
      "                len: 1,",
      "                min: x,",
      "                min_cnt: 1,",
      "                min_2nd: i64::MAX,",
      "            })",
      "        }",
      "    }",
      "    fn second_smallest(a0: i64, a1: i64, b0: i64, b1: i64) -> i64 {",
      "        if a0 == b0 {",
      "            min(a1, b1)",
      "        } else if a1 <= b0 {",
      "            a1",
      "        } else if b1 <= a0 {",
      "            b1",
      "        } else {",
      "            max(a0, b0)",
      "        }",
      "    }",
      "    pub struct RangeSumMonoid(Infallible);",
      "    impl MonoidBeats for RangeSumMonoid {",
      "        type S = Option<RangeSum>;",
      "        fn identity() -> Self::S {",
      "            Some(RangeSum {",
      "                sum: 0,",
      "                len: 0,",
      "                min: i64::MAX,",
      "                min_cnt: 0,",
      "                min_2nd: i64::MAX,",
      "            })",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            match (a, b) {",
      "                (None, None) => None,",
      "                (None, Some(_)) => None,",
      "                (Some(_), None) => None,",
      "                (Some(a), Some(b)) => Some(RangeSum {",
      "                    sum: a.sum + b.sum,",
      "                    len: a.len + b.len,",
      "                    min: min(a.min, b.min),",
      "                    min_cnt: a.min_cnt * (a.min <= b.min) as usize",
      "                        + b.min_cnt * (b.min <= a.min) as usize,",
      "                    min_2nd: second_smallest(a.min, a.min_2nd, b.min, b.min_2nd),",
      "                }),",
      "            }",
      "        }",
      "        fn fails(a: &Self::S) -> bool {",
      "            a.is_none()",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct ChmaxFunc {",
      "        pub chmax_val: i64,",
      "    }",
      "    impl ChmaxFunc {",
      "        pub fn new(x: i64) -> Self {",
      "            ChmaxFunc { chmax_val: x }",
      "        }",
      "    }",
      "    pub struct RangeChmaxRangeSum(Infallible);",
      "    impl MapMonoidBeats for RangeChmaxRangeSum {",
      "        type F = ChmaxFunc;",
      "        type M = RangeSumMonoid;",
      "        fn identity_map() -> Self::F {",
      "            ChmaxFunc {",
      "                chmax_val: i64::MIN,",
      "            }",
      "        }",
      "        #[allow(clippy::if_same_then_else)]",
      "        fn mapping(f: &Self::F, x: &<Self::M as MonoidBeats>::S) -> <Self::M as MonoidBeats>::S {",
      "            match x {",
      "                None => None,",
      "                Some(x) => {",
      "                    if x.len == 0 {",
      "                        Some(*x)",
      "                    } else if f.chmax_val <= x.min {",
      "                        Some(*x)",
      "                    } else if f.chmax_val < x.min_2nd {",
      "                        Some(RangeSum {",
      "                            sum: x.sum + (f.chmax_val - x.min) * x.min_cnt as i64,",
      "                            len: x.len,",
      "                            min: f.chmax_val,",
      "                            min_cnt: x.min_cnt,",
      "                            min_2nd: x.min_2nd,",
      "                        })",
      "                    } else {",
      "                        None",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        fn composition(f: &Self::F, g: &Self::F) -> Self::F {",
      "            ChmaxFunc {",
      "                chmax_val: max(f.chmax_val, g.chmax_val),",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_chmin_range_sum": {
    "scope": "rust",
    "prefix": "range_chmin_range_sum",
    "body": [
      "use abstract_segtree_beats::*;",
      "use range_chmin_range_sum::*;",
      "pub mod abstract_segtree_beats {",
      "    fn ceil_pow2(n: u32) -> u32 {",
      "        32 - n.saturating_sub(1).leading_zeros()",
      "    }",
      "    pub trait MonoidBeats {",
      "        type S: Clone;",
      "        fn identity() -> Self::S;",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S;",
      "        fn fails(a: &Self::S) -> bool;",
      "    }",
      "    pub trait MapMonoidBeats {",
      "        type M: MonoidBeats;",
      "        type F: Clone;",
      "        fn identity_element() -> <Self::M as MonoidBeats>::S {",
      "            Self::M::identity()",
      "        }",
      "        fn binary_operation(",
      "            a: &<Self::M as MonoidBeats>::S,",
      "            b: &<Self::M as MonoidBeats>::S,",
      "        ) -> <Self::M as MonoidBeats>::S {",
      "            Self::M::binary_operation(a, b)",
      "        }",
      "        fn fails(a: &<Self::M as MonoidBeats>::S) -> bool {",
      "            Self::M::fails(a)",
      "        }",
      "        fn identity_map() -> Self::F;",
      "        fn mapping(f: &Self::F, x: &<Self::M as MonoidBeats>::S) -> <Self::M as MonoidBeats>::S;",
      "        fn composition(f: &Self::F, g: &Self::F) -> Self::F;",
      "    }",
      "    impl<F: MapMonoidBeats> Default for SegtreeBeats<F> {",
      "        fn default() -> Self {",
      "            Self::new(0)",
      "        }",
      "    }",
      "    impl<F: MapMonoidBeats> SegtreeBeats<F> {",
      "        pub fn new(n: usize) -> Self {",
      "            vec![F::identity_element(); n].into()",
      "        }",
      "    }",
      "    impl<F: MapMonoidBeats> From<Vec<<F::M as MonoidBeats>::S>> for SegtreeBeats<F> {",
      "        fn from(v: Vec<<F::M as MonoidBeats>::S>) -> Self {",
      "            let n = v.len();",
      "            let log = ceil_pow2(n as u32) as usize;",
      "            let size = 1 << log;",
      "            let mut d = vec![F::identity_element(); 2 * size];",
      "            let lz = vec![F::identity_map(); size];",
      "            d[size..(size + n)].clone_from_slice(&v);",
      "            let mut ret = SegtreeBeats {",
      "                n,",
      "                size,",
      "                log,",
      "                d,",
      "                lz,",
      "            };",
      "            for i in (1..size).rev() {",
      "                ret.update(i);",
      "            }",
      "            ret",
      "        }",
      "    }",
      "    impl<F: MapMonoidBeats> SegtreeBeats<F> {",
      "        pub fn set(&mut self, mut p: usize, x: <F::M as MonoidBeats>::S) {",
      "            assert!(p < self.n);",
      "            p += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(p >> i);",
      "            }",
      "            self.d[p] = x;",
      "            for i in 1..=self.log {",
      "                self.update(p >> i);",
      "            }",
      "        }",
      "        pub fn get(&mut self, mut p: usize) -> <F::M as MonoidBeats>::S {",
      "            assert!(p < self.n);",
      "            p += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(p >> i);",
      "            }",
      "            self.d[p].clone()",
      "        }",
      "        pub fn prod<R>(&mut self, range: R) -> <F::M as MonoidBeats>::S",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            if range.start_bound() == Bound::Unbounded && range.end_bound() == Bound::Unbounded {",
      "                return self.all_prod();",
      "            }",
      "            let mut r = match range.end_bound() {",
      "                Bound::Included(r) => r + 1,",
      "                Bound::Excluded(r) => *r,",
      "                Bound::Unbounded => self.n,",
      "            };",
      "            let mut l = match range.start_bound() {",
      "                Bound::Included(l) => *l,",
      "                Bound::Excluded(l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            assert!(l <= r && r <= self.n);",
      "            if l == r {",
      "                return F::identity_element();",
      "            }",
      "            l += self.size;",
      "            r += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                if ((l >> i) << i) != l {",
      "                    self.push(l >> i);",
      "                }",
      "                if ((r >> i) << i) != r {",
      "                    self.push(r >> i);",
      "                }",
      "            }",
      "            let mut sml = F::identity_element();",
      "            let mut smr = F::identity_element();",
      "            while l < r {",
      "                if l & 1 != 0 {",
      "                    sml = F::binary_operation(&sml, &self.d[l]);",
      "                    l += 1;",
      "                }",
      "                if r & 1 != 0 {",
      "                    r -= 1;",
      "                    smr = F::binary_operation(&self.d[r], &smr);",
      "                }",
      "                l >>= 1;",
      "                r >>= 1;",
      "            }",
      "            F::binary_operation(&sml, &smr)",
      "        }",
      "        pub fn all_prod(&self) -> <F::M as MonoidBeats>::S {",
      "            self.d[1].clone()",
      "        }",
      "        pub fn apply(&mut self, mut p: usize, f: F::F) {",
      "            assert!(p < self.n);",
      "            p += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(p >> i);",
      "            }",
      "            self.d[p] = F::mapping(&f, &self.d[p]);",
      "            for i in 1..=self.log {",
      "                self.update(p >> i);",
      "            }",
      "        }",
      "        pub fn apply_range<R>(&mut self, range: R, f: F::F)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            let mut r = match range.end_bound() {",
      "                Bound::Included(r) => r + 1,",
      "                Bound::Excluded(r) => *r,",
      "                Bound::Unbounded => self.n,",
      "            };",
      "            let mut l = match range.start_bound() {",
      "                Bound::Included(l) => *l,",
      "                Bound::Excluded(l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            assert!(l <= r && r <= self.n);",
      "            if l == r {",
      "                return;",
      "            }",
      "            l += self.size;",
      "            r += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                if ((l >> i) << i) != l {",
      "                    self.push(l >> i);",
      "                }",
      "                if ((r >> i) << i) != r {",
      "                    self.push((r - 1) >> i);",
      "                }",
      "            }",
      "            {",
      "                let l2 = l;",
      "                let r2 = r;",
      "                while l < r {",
      "                    if l & 1 != 0 {",
      "                        self.all_apply(l, f.clone());",
      "                        l += 1;",
      "                    }",
      "                    if r & 1 != 0 {",
      "                        r -= 1;",
      "                        self.all_apply(r, f.clone());",
      "                    }",
      "                    l >>= 1;",
      "                    r >>= 1;",
      "                }",
      "                l = l2;",
      "                r = r2;",
      "            }",
      "            for i in 1..=self.log {",
      "                if ((l >> i) << i) != l {",
      "                    self.update(l >> i);",
      "                }",
      "                if ((r >> i) << i) != r {",
      "                    self.update((r - 1) >> i);",
      "                }",
      "            }",
      "        }",
      "        pub fn max_right<G>(&mut self, mut l: usize, g: G) -> usize",
      "        where",
      "            G: Fn(<F::M as MonoidBeats>::S) -> bool,",
      "        {",
      "            assert!(l <= self.n);",
      "            assert!(g(F::identity_element()));",
      "            if l == self.n {",
      "                return self.n;",
      "            }",
      "            l += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(l >> i);",
      "            }",
      "            let mut sm = F::identity_element();",
      "            while {",
      "                while l % 2 == 0 {",
      "                    l >>= 1;",
      "                }",
      "                if !g(F::binary_operation(&sm, &self.d[l])) {",
      "                    while l < self.size {",
      "                        self.push(l);",
      "                        l *= 2;",
      "                        let res = F::binary_operation(&sm, &self.d[l]);",
      "                        if g(res.clone()) {",
      "                            sm = res;",
      "                            l += 1;",
      "                        }",
      "                    }",
      "                    return l - self.size;",
      "                }",
      "                sm = F::binary_operation(&sm, &self.d[l]);",
      "                l += 1;",
      "                {",
      "                    let l = l as isize;",
      "                    (l & -l) != l",
      "                }",
      "            } {}",
      "            self.n",
      "        }",
      "        pub fn min_left<G>(&mut self, mut r: usize, g: G) -> usize",
      "        where",
      "            G: Fn(<F::M as MonoidBeats>::S) -> bool,",
      "        {",
      "            assert!(r <= self.n);",
      "            assert!(g(F::identity_element()));",
      "            if r == 0 {",
      "                return 0;",
      "            }",
      "            r += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push((r - 1) >> i);",
      "            }",
      "            let mut sm = F::identity_element();",
      "            while {",
      "                r -= 1;",
      "                while r > 1 && r % 2 != 0 {",
      "                    r >>= 1;",
      "                }",
      "                if !g(F::binary_operation(&self.d[r], &sm)) {",
      "                    while r < self.size {",
      "                        self.push(r);",
      "                        r = 2 * r + 1;",
      "                        let res = F::binary_operation(&self.d[r], &sm);",
      "                        if g(res.clone()) {",
      "                            sm = res;",
      "                            r -= 1;",
      "                        }",
      "                    }",
      "                    return r + 1 - self.size;",
      "                }",
      "                sm = F::binary_operation(&self.d[r], &sm);",
      "                {",
      "                    let r = r as isize;",
      "                    (r & -r) != r",
      "                }",
      "            } {}",
      "            0",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<<F::M as MonoidBeats>::S> {",
      "            (0..self.n).map(|i| self.get(i)).collect()",
      "        }",
      "    }",
      "    pub struct SegtreeBeats<F>",
      "    where",
      "        F: MapMonoidBeats,",
      "    {",
      "        n: usize,",
      "        size: usize,",
      "        log: usize,",
      "        d: Vec<<F::M as MonoidBeats>::S>,",
      "        lz: Vec<F::F>,",
      "    }",
      "    impl<F> SegtreeBeats<F>",
      "    where",
      "        F: MapMonoidBeats,",
      "    {",
      "        fn update(&mut self, k: usize) {",
      "            self.d[k] = F::binary_operation(&self.d[2 * k], &self.d[2 * k + 1]);",
      "        }",
      "        fn all_apply(&mut self, k: usize, f: F::F) {",
      "            self.d[k] = F::mapping(&f, &self.d[k]);",
      "            if k < self.size {",
      "                self.lz[k] = F::composition(&f, &self.lz[k]);",
      "                if F::fails(&self.d[k]) {",
      "                    self.push(k);",
      "                    self.update(k)",
      "                }",
      "            }",
      "        }",
      "        fn push(&mut self, k: usize) {",
      "            self.all_apply(2 * k, self.lz[k].clone());",
      "            self.all_apply(2 * k + 1, self.lz[k].clone());",
      "            self.lz[k] = F::identity_map();",
      "        }",
      "    }",
      "    use std::{",
      "        fmt::{Debug, Error, Formatter, Write},",
      "        ops::{Bound, RangeBounds},",
      "    };",
      "    impl<F> Debug for SegtreeBeats<F>",
      "    where",
      "        F: MapMonoidBeats,",
      "        F::F: Debug,",
      "        <F::M as MonoidBeats>::S: Debug,",
      "    {",
      "        fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {",
      "            for i in 0..self.log {",
      "                for j in 0..1 << i {",
      "                    f.write_fmt(format_args!(",
      "                        \"{:?}[{:?}]\\t\",",
      "                        self.d[(1 << i) + j],",
      "                        self.lz[(1 << i) + j]",
      "                    ))?;",
      "                }",
      "                f.write_char('\\n')?;",
      "            }",
      "            for i in 0..self.size {",
      "                f.write_fmt(format_args!(\"{:?}\\t\", self.d[self.size + i]))?;",
      "            }",
      "            Ok(())",
      "        }",
      "    }",
      "}",
      "pub mod range_chmin_range_sum {",
      "    use super::abstract_segtree_beats::{MapMonoidBeats, MonoidBeats};",
      "    use std::{",
      "        cmp::{max, min},",
      "        convert::Infallible,",
      "    };",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct RangeSum {",
      "        pub sum: i64,",
      "        pub len: usize,",
      "        pub max: i64,",
      "        pub max_cnt: usize,",
      "        pub max_2nd: i64,",
      "    }",
      "    impl RangeSum {",
      "        pub fn unit(x: i64) -> Option<RangeSum> {",
      "            Some(RangeSum {",
      "                sum: x,",
      "                len: 1,",
      "                max: x,",
      "                max_cnt: 1,",
      "                max_2nd: i64::MIN,",
      "            })",
      "        }",
      "    }",
      "    fn second_largest(a0: i64, a1: i64, b0: i64, b1: i64) -> i64 {",
      "        if a0 == b0 {",
      "            max(a1, b1)",
      "        } else if a1 >= b0 {",
      "            a1",
      "        } else if b1 >= a0 {",
      "            b1",
      "        } else {",
      "            min(a0, b0)",
      "        }",
      "    }",
      "    pub struct RangeSumMonoid(Infallible);",
      "    impl MonoidBeats for RangeSumMonoid {",
      "        type S = Option<RangeSum>;",
      "        fn identity() -> Self::S {",
      "            Some(RangeSum {",
      "                sum: 0,",
      "                len: 0,",
      "                max: i64::MIN,",
      "                max_cnt: 0,",
      "                max_2nd: i64::MIN,",
      "            })",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            match (a, b) {",
      "                (None, None) => None,",
      "                (None, Some(_)) => None,",
      "                (Some(_), None) => None,",
      "                (Some(a), Some(b)) => Some(RangeSum {",
      "                    sum: a.sum + b.sum,",
      "                    len: a.len + b.len,",
      "                    max: max(a.max, b.max),",
      "                    max_cnt: a.max_cnt * (a.max >= b.max) as usize",
      "                        + b.max_cnt * (b.max >= a.max) as usize,",
      "                    max_2nd: second_largest(a.max, a.max_2nd, b.max, b.max_2nd),",
      "                }),",
      "            }",
      "        }",
      "        fn fails(a: &Self::S) -> bool {",
      "            a.is_none()",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct ChminFunc {",
      "        pub chmin_val: i64,",
      "    }",
      "    impl ChminFunc {",
      "        pub fn new(x: i64) -> Self {",
      "            ChminFunc { chmin_val: x }",
      "        }",
      "    }",
      "    pub struct RangeChminRangeSum(Infallible);",
      "    impl MapMonoidBeats for RangeChminRangeSum {",
      "        type F = ChminFunc;",
      "        type M = RangeSumMonoid;",
      "        fn identity_map() -> Self::F {",
      "            ChminFunc {",
      "                chmin_val: i64::MAX,",
      "            }",
      "        }",
      "        #[allow(clippy::if_same_then_else)]",
      "        fn mapping(f: &Self::F, x: &<Self::M as MonoidBeats>::S) -> <Self::M as MonoidBeats>::S {",
      "            match x {",
      "                None => None,",
      "                Some(x) => {",
      "                    if x.len == 0 {",
      "                        Some(*x)",
      "                    } else if f.chmin_val >= x.max {",
      "                        Some(*x)",
      "                    } else if f.chmin_val > x.max_2nd {",
      "                        Some(RangeSum {",
      "                            sum: x.sum + (f.chmin_val - x.max) * x.max_cnt as i64,",
      "                            len: x.len,",
      "                            max: f.chmin_val,",
      "                            max_cnt: x.max_cnt,",
      "                            max_2nd: x.max_2nd,",
      "                        })",
      "                    } else {",
      "                        None",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        fn composition(f: &Self::F, g: &Self::F) -> Self::F {",
      "            ChminFunc {",
      "                chmin_val: min(f.chmin_val, g.chmin_val),",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_set": {
    "scope": "rust",
    "prefix": "range_set",
    "body": [
      "use range_set::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_set {",
      "    use std::collections::BTreeSet;",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct RangeSet {",
      "        set: BTreeSet<(i64, i64)>,",
      "        count: usize,",
      "    }",
      "    impl Default for RangeSet {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "    impl RangeSet {",
      "        pub fn new() -> RangeSet {",
      "            RangeSet {",
      "                set: vec![(i64::MIN, i64::MIN), (i64::MAX, i64::MAX)]",
      "                    .into_iter()",
      "                    .collect(),",
      "                count: 0,",
      "            }",
      "        }",
      "        pub fn iter(&self) -> impl Iterator<Item = i64> + '_ {",
      "            self.set",
      "                .iter()",
      "                .copied()",
      "                .filter(|&(l, r)| (l, r) != (i64::MIN, i64::MIN) && (l, r) != (i64::MAX, i64::MAX))",
      "                .flat_map(|(left, right)| left..=right)",
      "        }",
      "        pub fn insert(&mut self, x: i64) -> bool {",
      "            if self.contains(x) {",
      "                return false;",
      "            }",
      "            let &(prev_l, prev_r) = self.set.range(..(x + 1, x + 1)).max().unwrap();",
      "            let &(next_l, next_r) = self.set.range((x + 1, x + 1)..).min().unwrap();",
      "            if prev_r + 1 == x && x == next_l - 1 {",
      "                self.set.remove(&(prev_l, prev_r));",
      "                self.set.remove(&(next_l, next_r));",
      "                self.set.insert((prev_l, next_r));",
      "            } else if prev_r + 1 == x {",
      "                self.set.remove(&(prev_l, prev_r));",
      "                self.set.insert((prev_l, x));",
      "            } else if x == next_l - 1 {",
      "                self.set.remove(&(next_l, next_r));",
      "                self.set.insert((x, next_r));",
      "            } else {",
      "                self.set.insert((x, x));",
      "            }",
      "            self.count += 1;",
      "            true",
      "        }",
      "        pub fn remove(&mut self, x: i64) -> bool {",
      "            if !self.contains(x) {",
      "                return false;",
      "            }",
      "            let &(current_l, current_r) = self.set.range(..(x + 1, x + 1)).max().unwrap();",
      "            if current_l == x && x == current_r {",
      "                self.set.remove(&(current_l, current_r));",
      "            } else if current_l == x {",
      "                self.set.remove(&(current_l, current_r));",
      "                self.set.insert((x + 1, current_r));",
      "            } else if x == current_r {",
      "                self.set.remove(&(current_l, current_r));",
      "                self.set.insert((current_l, x - 1));",
      "            } else {",
      "                self.set.remove(&(current_l, current_r));",
      "                self.set.insert((current_l, x - 1));",
      "                self.set.insert((x + 1, current_r));",
      "            }",
      "            self.count -= 1;",
      "            true",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.count",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.count == 0",
      "        }",
      "        pub fn contains(&self, x: i64) -> bool {",
      "            let &(l, r) = self.set.range(..(x + 1, x + 1)).max().unwrap();",
      "            (l..=r).contains(&x)",
      "        }",
      "        /// x 以上で self に入っていない値の最小値を返す (いわゆる mex)",
      "        pub fn min_exclusive_geq(&self, x: i64) -> i64 {",
      "            let &(l, r) = self.set.range(..(x + 1, x + 1)).max().unwrap();",
      "            if (l..=r).contains(&x) {",
      "                r + 1",
      "            } else {",
      "                x",
      "            }",
      "        }",
      "        /// x 以下で self に入っていない値の最大値を返す",
      "        pub fn max_exclusive_leq(&self, x: i64) -> i64 {",
      "            let &(l, r) = self.set.range(..(x + 1, x + 1)).max().unwrap();",
      "            if (l..=r).contains(&x) {",
      "                l - 1",
      "            } else {",
      "                x",
      "            }",
      "        }",
      "    }",
      "    impl FromIterator<i64> for RangeSet {",
      "        fn from_iter<I: IntoIterator<Item = i64>>(iter: I) -> RangeSet {",
      "            let mut set = RangeSet::new();",
      "            for x in iter {",
      "                set.insert(x);",
      "            }",
      "            set",
      "        }",
      "    }",
      "}"
    ]
  },
  "rolling_hash": {
    "scope": "rust",
    "prefix": "rolling_hash",
    "body": [
      "use modint_u64::*;",
      "use rolling_hash::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod modint_u64 {",
      "    use std::{",
      "        convert::Infallible,",
      "        fmt,",
      "        hash::{Hash, Hasher},",
      "        iter::{Product, Sum},",
      "        marker::PhantomData,",
      "        ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign},",
      "        str::FromStr,",
      "    };",
      "    /// 2^61 -1",
      "    pub type ModInt2305843009213693951 = StaticModInt<Mod2305843009213693951>;",
      "    /// 10^18 + 3",
      "    pub type ModInt1000000000000000003 = StaticModInt<Mod1000000000000000003>;",
      "    pub type ModInt1000000007 = StaticModInt<Mod1000000007>;",
      "    pub type ModInt998244353 = StaticModInt<Mod998244353>;",
      "    /// Represents \\$\\mathbb{Z}/m\\mathbb{Z}\\$ where \\$m\\$ is a constant value.",
      "    /// Corresponds to `atcoder::static_modint` in the original ACL.",
      "    /// # Example",
      "    /// ```",
      "    /// use ac_library::ModInt1000000007 as Mint;",
      "    /// use proconio::{input, source::once::OnceSource};",
      "    /// input! {",
      "    ///     from OnceSource::from(\"1000000006 2\\n\"),",
      "    ///     a: Mint,",
      "    ///     b: Mint,",
      "    /// }",
      "    /// println!(\"{}\", a + b); // `1`",
      "    /// ```",
      "    #[derive(Copy, Clone, Eq, PartialEq)]",
      "    #[repr(transparent)]",
      "    pub struct StaticModInt<M> {",
      "        val: u64,",
      "        phantom: PhantomData<fn() -> M>,",
      "    }",
      "    impl<M: Modulus> StaticModInt<M> {",
      "        /// Returns the modulus, which is [`<M as Modulus>::VALUE`].",
      "        /// Corresponds to `atcoder::static_modint::mod` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::ModInt1000000007 as Mint;",
      "        /// assert_eq!(1_000_000_007, Mint::modulus());",
      "        /// ```",
      "        /// [`<M as Modulus>::VALUE`]: ../trait.Modulus.html#associatedconstant.VALUE",
      "        #[inline(always)]",
      "        pub fn modulus() -> u64 {",
      "            M::VALUE",
      "        }",
      "        /// Creates a new `StaticModInt`.",
      "        /// Takes [any primitive integer].",
      "        /// Corresponds to the constructor of `atcoder::static_modint` in the original ACL.",
      "        /// [any primitive integer]:  ../trait.RemEuclidU32.html",
      "        #[inline]",
      "        pub fn new<T: RemEuclidU64>(val: T) -> Self {",
      "            Self::raw(val.rem_euclid_u64(M::VALUE))",
      "        }",
      "        /// Constructs a `StaticModInt` from a `val < Self::modulus()` without checking it.",
      "        /// Corresponds to `atcoder::static_modint::raw` in the original ACL.",
      "        /// # Constraints",
      "        /// - `val` is less than `Self::modulus()`",
      "        /// See [`ModIntBase::raw`] for more more details.",
      "        /// [`ModIntBase::raw`]: ./trait.ModIntBase.html#tymethod.raw",
      "        #[inline]",
      "        pub fn raw(val: u64) -> Self {",
      "            Self {",
      "                val,",
      "                phantom: PhantomData,",
      "            }",
      "        }",
      "        /// Retruns the representative.",
      "        /// Corresponds to `atcoder::static_modint::val` in the original ACL.",
      "        #[inline]",
      "        pub fn val(self) -> u64 {",
      "            self.val",
      "        }",
      "        /// Returns `self` to the power of `n`.",
      "        /// Corresponds to `atcoder::static_modint::pow` in the original ACL.",
      "        #[inline]",
      "        pub fn pow(self, n: u64) -> Self {",
      "            <Self as ModIntBase>::pow(self, n)",
      "        }",
      "        /// Retruns the multiplicative inverse of `self`.",
      "        /// Corresponds to `atcoder::static_modint::inv` in the original ACL.",
      "        /// # Panics",
      "        /// Panics if the multiplicative inverse does not exist.",
      "        #[inline]",
      "        pub fn inv(self) -> Self {",
      "            if self.val() == 0 {",
      "                panic!(\"attempt to divide by zero\");",
      "            }",
      "            self.pow(M::VALUE - 2)",
      "        }",
      "    }",
      "    /// These methods are implemented for the struct.",
      "    /// You don't need to `use` `ModIntBase` to call methods of `StaticModInt`.",
      "    impl<M: Modulus> ModIntBase for StaticModInt<M> {",
      "        #[inline(always)]",
      "        fn modulus() -> u64 {",
      "            Self::modulus()",
      "        }",
      "        #[inline]",
      "        fn raw(val: u64) -> Self {",
      "            Self::raw(val)",
      "        }",
      "        #[inline]",
      "        fn val(self) -> u64 {",
      "            self.val()",
      "        }",
      "        #[inline]",
      "        fn inv(self) -> Self {",
      "            self.inv()",
      "        }",
      "    }",
      "    /// Represents a modulus.",
      "    /// # Example",
      "    /// ```",
      "    /// macro_rules! modulus {",
      "    ///     (\\$(\\$name:ident(\\$value:expr, \\$is_prime:expr)),*) => {",
      "    ///         \\$(",
      "    ///             #[derive(Copy, Clone, Eq, PartialEq)]",
      "    ///             enum \\$name {}",
      "    ///             impl ac_library::modint::Modulus for \\$name {",
      "    ///                 const VALUE: u32 = \\$value;",
      "    ///                 const HINT_VALUE_IS_PRIME: bool = \\$is_prime;",
      "    ///                 fn butterfly_cache() -> &'static ::std::thread::LocalKey<::std::cell::RefCell<::std::option::Option<ac_library::modint::ButterflyCache<Self>>>> {",
      "    ///                     thread_local! {",
      "    ///                         static BUTTERFLY_CACHE: ::std::cell::RefCell<::std::option::Option<ac_library::modint::ButterflyCache<\\$name>>> = ::std::default::Default::default();",
      "    ///                     }",
      "    ///                     &BUTTERFLY_CACHE",
      "    ///                 }",
      "    ///             }",
      "    ///         )*",
      "    ///     };",
      "    /// }",
      "    /// use ac_library::StaticModInt;",
      "    /// modulus!(Mod101(101, true), Mod103(103, true));",
      "    /// type Z101 = StaticModInt<Mod101>;",
      "    /// type Z103 = StaticModInt<Mod103>;",
      "    /// assert_eq!(Z101::new(101), Z101::new(0));",
      "    /// assert_eq!(Z103::new(103), Z103::new(0));",
      "    /// ```",
      "    pub trait Modulus: 'static + Copy + Eq {",
      "        const VALUE: u64;",
      "        const HINT_VALUE_IS_PRIME: bool;",
      "    }",
      "    /// Represents \\$2^{61}-1 = 2305843009213693951\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod2305843009213693951 {}",
      "    impl Modulus for Mod2305843009213693951 {",
      "        const VALUE: u64 = 2_305_843_009_213_693_951;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// Represents \\$10^{18}+3 = 1000000000000000003\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod1000000000000000003 {}",
      "    impl Modulus for Mod1000000000000000003 {",
      "        const VALUE: u64 = 1_000_000_000_000_000_003;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// Represents \\$1000000007\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod1000000007 {}",
      "    impl Modulus for Mod1000000007 {",
      "        const VALUE: u64 = 1_000_000_007;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// Represents \\$998244353\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod998244353 {}",
      "    impl Modulus for Mod998244353 {",
      "        const VALUE: u64 = 998_244_353;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// A trait for [`StaticModInt`] and [`DynamicModInt`].",
      "    /// Corresponds to `atcoder::internal::modint_base` in the original ACL.",
      "    /// [`StaticModInt`]: ../struct.StaticModInt.html",
      "    /// [`DynamicModInt`]: ../struct.DynamicModInt.html",
      "    pub trait ModIntBase:",
      "        Default",
      "        + FromStr",
      "        + From<i8>",
      "        + From<i16>",
      "        + From<i32>",
      "        + From<i64>",
      "        + From<i128>",
      "        + From<isize>",
      "        + From<u8>",
      "        + From<u16>",
      "        + From<u32>",
      "        + From<u64>",
      "        + From<u128>",
      "        + From<usize>",
      "        + Copy",
      "        + Eq",
      "        + Hash",
      "        + fmt::Display",
      "        + fmt::Debug",
      "        + Neg<Output = Self>",
      "        + Add<Output = Self>",
      "        + Sub<Output = Self>",
      "        + Mul<Output = Self>",
      "        + Div<Output = Self>",
      "        + AddAssign",
      "        + SubAssign",
      "        + MulAssign",
      "        + DivAssign",
      "    {",
      "        /// Returns the modulus.",
      "        /// Corresponds to `atcoder::static_modint::mod` and `atcoder::dynamic_modint::mod` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() {",
      "        ///     let _: u32 = Z::modulus();",
      "        /// }",
      "        /// ```",
      "        fn modulus() -> u64;",
      "        /// Constructs a `Self` from a `val < Self::modulus()` without checking it.",
      "        /// Corresponds to `atcoder::static_modint::raw` and `atcoder::dynamic_modint::raw` in the original ACL.",
      "        /// # Constraints",
      "        /// - `val` is less than `Self::modulus()`",
      "        /// **Note that all operations assume that inner values are smaller than the modulus.**",
      "        /// If `val` is greater than or equal to `Self::modulus()`, the behaviors are not defined.",
      "        /// ```should_panic",
      "        /// use ac_library::ModInt1000000007 as Mint;",
      "        /// let x = Mint::raw(1_000_000_007);",
      "        /// let y = x + x;",
      "        /// assert_eq!(0, y.val());",
      "        /// ```",
      "        /// ```text",
      "        /// thread 'main' panicked at 'assertion failed: `(left == right)`",
      "        ///   left: `0`,",
      "        ///  right: `1000000007`', src/modint.rs:8:1",
      "        /// note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace",
      "        /// ```",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() -> Z {",
      "        ///     debug_assert!(Z::modulus() >= 100);",
      "        ///     let mut acc = Z::new(0);",
      "        ///     for i in 0..100 {",
      "        ///         if i % 3 == 0 {",
      "        ///             // I know `i` is smaller than the modulus!",
      "        ///             acc += Z::raw(i);",
      "        ///         }",
      "        ///     }",
      "        ///     acc",
      "        /// }",
      "        /// ```",
      "        fn raw(val: u64) -> Self;",
      "        /// Retruns the representative.",
      "        /// Corresponds to `atcoder::static_modint::val` and `atcoder::dynamic_modint::val` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>(x: Z) {",
      "        ///     let _: u32 = x.val();",
      "        /// }",
      "        /// ```",
      "        fn val(self) -> u64;",
      "        /// Retruns the multiplicative inverse of `self`.",
      "        /// Corresponds to `atcoder::static_modint::inv` and `atcoder::dynamic_modint::inv` in the original ACL.",
      "        /// # Panics",
      "        /// Panics if the multiplicative inverse does not exist.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>(x: Z) {",
      "        ///     let _: Z = x.inv();",
      "        /// }",
      "        /// ```",
      "        fn inv(self) -> Self;",
      "        /// Creates a new `Self`.",
      "        /// Takes [any primitive integer].",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() {",
      "        ///     let _ = Z::new(1u32);",
      "        ///     let _ = Z::new(1usize);",
      "        ///     let _ = Z::new(-1i64);",
      "        /// }",
      "        /// ```",
      "        /// [any primitive integer]:  ../trait.RemEuclidU32.html",
      "        #[inline]",
      "        fn new<T: RemEuclidU64>(val: T) -> Self {",
      "            Self::raw(val.rem_euclid_u64(Self::modulus()))",
      "        }",
      "        /// Returns `self` to the power of `n`.",
      "        /// Corresponds to `atcoder::static_modint::pow` and `atcoder::dynamic_modint::pow` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() {",
      "        ///     let _: Z = Z::new(2).pow(3);",
      "        /// }",
      "        /// ```",
      "        #[inline]",
      "        fn pow(self, mut n: u64) -> Self {",
      "            let mut x = self;",
      "            let mut r = Self::raw(1);",
      "            while n > 0 {",
      "                if n & 1 == 1 {",
      "                    r *= x;",
      "                }",
      "                x *= x;",
      "                n >>= 1;",
      "            }",
      "            r",
      "        }",
      "    }",
      "    /// A trait for `{StaticModInt, DynamicModInt, ModIntBase}::new`.",
      "    pub trait RemEuclidU64 {",
      "        /// Calculates `self` \\$\\bmod\\$ `modulus` losslessly.",
      "        fn rem_euclid_u64(self, modulus: u64) -> u64;",
      "    }",
      "    macro_rules ! impl_rem_euclid_u64_for_small_signed {(\\$ (\\$ ty : tt ) ,* ) => {\\$ (impl RemEuclidU64 for \\$ ty {# [inline ] fn rem_euclid_u64 (self , modulus : u64 ) -> u64 {(self as i128 ) . rem_euclid (i128 :: from (modulus ) ) as _ } } ) * } }",
      "    impl_rem_euclid_u64_for_small_signed!(i8, i16, i32, i64, isize);",
      "    impl RemEuclidU64 for i128 {",
      "        #[inline]",
      "        fn rem_euclid_u64(self, modulus: u64) -> u64 {",
      "            self.rem_euclid(i128::from(modulus)) as _",
      "        }",
      "    }",
      "    macro_rules ! impl_rem_euclid_u64_for_small_unsigned {(\\$ (\\$ ty : tt ) ,* ) => {\\$ (impl RemEuclidU64 for \\$ ty {# [inline ] fn rem_euclid_u64 (self , modulus : u64 ) -> u64 {self as u64 % modulus } } ) * } }",
      "    macro_rules ! impl_rem_euclid_u64_for_large_unsigned {(\\$ (\\$ ty : tt ) ,* ) => {\\$ (impl RemEuclidU64 for \\$ ty {# [inline ] fn rem_euclid_u64 (self , modulus : u64 ) -> u64 {(self % (modulus as \\$ ty ) ) as _ } } ) * } }",
      "    impl_rem_euclid_u64_for_small_unsigned!(u8, u16, u32, u64, usize);",
      "    impl_rem_euclid_u64_for_large_unsigned!(u128);",
      "    trait InternalImplementations: ModIntBase {",
      "        #[inline]",
      "        fn default_impl() -> Self {",
      "            Self::raw(0)",
      "        }",
      "        #[inline]",
      "        fn from_str_impl(s: &str) -> Result<Self, Infallible> {",
      "            Ok(s.parse::<i64>()",
      "                .map(Self::new)",
      "                .unwrap_or_else(|_| todo!(\"parsing as an arbitrary precision integer?\")))",
      "        }",
      "        #[inline]",
      "        fn hash_impl(this: &Self, state: &mut impl Hasher) {",
      "            this.val().hash(state)",
      "        }",
      "        #[inline]",
      "        fn display_impl(this: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "            fmt::Display::fmt(&this.val(), f)",
      "        }",
      "        #[inline]",
      "        fn debug_impl(this: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "            fmt::Debug::fmt(&this.val(), f)",
      "        }",
      "        #[inline]",
      "        fn neg_impl(this: Self) -> Self {",
      "            Self::sub_impl(Self::raw(0), this)",
      "        }",
      "        #[inline]",
      "        fn add_impl(lhs: Self, rhs: Self) -> Self {",
      "            let modulus = Self::modulus();",
      "            let mut val = lhs.val() + rhs.val();",
      "            if val >= modulus {",
      "                val -= modulus;",
      "            }",
      "            Self::raw(val)",
      "        }",
      "        #[inline]",
      "        fn sub_impl(lhs: Self, rhs: Self) -> Self {",
      "            let modulus = Self::modulus();",
      "            let mut val = lhs.val().wrapping_sub(rhs.val());",
      "            if val >= modulus {",
      "                val = val.wrapping_add(modulus)",
      "            }",
      "            Self::raw(val)",
      "        }",
      "        fn mul_impl(lhs: Self, rhs: Self) -> Self;",
      "        #[inline]",
      "        fn div_impl(lhs: Self, rhs: Self) -> Self {",
      "            Self::mul_impl(lhs, rhs.inv())",
      "        }",
      "    }",
      "    impl<M: Modulus> InternalImplementations for StaticModInt<M> {",
      "        #[inline]",
      "        fn mul_impl(lhs: Self, rhs: Self) -> Self {",
      "            Self::raw((u128::from(lhs.val()) * u128::from(rhs.val()) % u128::from(M::VALUE)) as u64)",
      "        }",
      "    }",
      "    macro_rules ! impl_basic_traits {() => {} ; (impl <\\$ generic_param : ident : \\$ generic_param_bound : tt > _ for \\$ self : ty ; \\$ (\\$ rest : tt ) * ) => {impl <\\$ generic_param : \\$ generic_param_bound > Default for \\$ self {# [inline ] fn default () -> Self {Self :: default_impl () } } impl <\\$ generic_param : \\$ generic_param_bound > FromStr for \\$ self {type Err = Infallible ; # [inline ] fn from_str (s : & str ) -> Result < Self , Infallible > {Self :: from_str_impl (s ) } } impl <\\$ generic_param : \\$ generic_param_bound , V : RemEuclidU64 > From < V > for \\$ self {# [inline ] fn from (from : V ) -> Self {Self :: new (from ) } } # [allow (clippy :: derive_hash_xor_eq ) ] impl <\\$ generic_param : \\$ generic_param_bound > Hash for \\$ self {# [inline ] fn hash < H : Hasher > (& self , state : & mut H ) {Self :: hash_impl (self , state ) } } impl <\\$ generic_param : \\$ generic_param_bound > fmt :: Display for \\$ self {# [inline ] fn fmt (& self , f : & mut fmt :: Formatter <'_ > ) -> fmt :: Result {Self :: display_impl (self , f ) } } impl <\\$ generic_param : \\$ generic_param_bound > fmt :: Debug for \\$ self {# [inline ] fn fmt (& self , f : & mut fmt :: Formatter <'_ > ) -> fmt :: Result {Self :: debug_impl (self , f ) } } impl <\\$ generic_param : \\$ generic_param_bound > Neg for \\$ self {type Output = \\$ self ; # [inline ] fn neg (self ) -> \\$ self {Self :: neg_impl (self ) } } impl <\\$ generic_param : \\$ generic_param_bound > Neg for &'_ \\$ self {type Output = \\$ self ; # [inline ] fn neg (self ) -> \\$ self {<\\$ self >:: neg_impl (* self ) } } impl_basic_traits ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    impl_basic_traits! {impl < M : Modulus > _ for StaticModInt < M > ; }",
      "    macro_rules ! impl_bin_ops {() => {} ; (for <\\$ (\\$ generic_param : ident : \\$ generic_param_bound : tt ) ,*> <\\$ lhs_ty : ty > ~ <\\$ rhs_ty : ty > -> \\$ output : ty {{\\$ lhs_body : expr } ~ {\\$ rhs_body : expr } } \\$ (\\$ rest : tt ) * ) => {impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Add <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn add (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: add_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Sub <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn sub (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: sub_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Mul <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn mul (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: mul_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Div <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn div (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: div_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl_bin_ops ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    macro_rules ! impl_assign_ops {() => {} ; (for <\\$ (\\$ generic_param : ident : \\$ generic_param_bound : tt ) ,*> <\\$ lhs_ty : ty > ~= <\\$ rhs_ty : ty > {_ ~= {\\$ rhs_body : expr } } \\$ (\\$ rest : tt ) * ) => {impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> AddAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn add_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self + apply (\\$ rhs_body , rhs ) ; } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> SubAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn sub_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self - apply (\\$ rhs_body , rhs ) ; } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> MulAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn mul_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self * apply (\\$ rhs_body , rhs ) ; } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> DivAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn div_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self / apply (\\$ rhs_body , rhs ) ; } } impl_assign_ops ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    #[inline]",
      "    fn apply<F: FnOnce(X) -> O, X, O>(f: F, x: X) -> O {",
      "        f(x)",
      "    }",
      "    impl_bin_ops! {for < M : Modulus > < StaticModInt < M > > ~ < StaticModInt < M > > -> StaticModInt < M > {{| x | x } ~ {| x | x } } for < M : Modulus > < StaticModInt < M > > ~ <&'_ StaticModInt < M > > -> StaticModInt < M > {{| x | x } ~ {|& x | x } } for < M : Modulus > <&'_ StaticModInt < M > > ~ < StaticModInt < M > > -> StaticModInt < M > {{|& x | x } ~ {| x | x } } for < M : Modulus > <&'_ StaticModInt < M > > ~ <&'_ StaticModInt < M > > -> StaticModInt < M > {{|& x | x } ~ {|& x | x } } for < M : Modulus , T : RemEuclidU64 > < StaticModInt < M > > ~ < T > -> StaticModInt < M > {{| x | x } ~ {StaticModInt ::< M >:: new } } }",
      "    impl_assign_ops! {for < M : Modulus > < StaticModInt < M > > ~= < StaticModInt < M > > {_ ~= {| x | x } } for < M : Modulus > < StaticModInt < M > > ~= <&'_ StaticModInt < M > > {_ ~= {|& x | x } } for < M : Modulus , T : RemEuclidU64 > < StaticModInt < M > > ~= < T > {_ ~= {StaticModInt ::< M >:: new } } }",
      "    macro_rules ! impl_folding {() => {} ; (impl <\\$ generic_param : ident : \\$ generic_param_bound : tt > \\$ trait : ident < _ > for \\$ self : ty {fn \\$ method : ident (_ ) -> _ {_ (\\$ unit : expr , \\$ op : expr ) } } \\$ (\\$ rest : tt ) * ) => {impl <\\$ generic_param : \\$ generic_param_bound > \\$ trait < Self > for \\$ self {# [inline ] fn \\$ method < S > (iter : S ) -> Self where S : Iterator < Item = Self >, {iter . fold (\\$ unit , \\$ op ) } } impl <'a , \\$ generic_param : \\$ generic_param_bound > \\$ trait <&'a Self > for \\$ self {# [inline ] fn \\$ method < S > (iter : S ) -> Self where S : Iterator < Item = &'a Self >, {iter . fold (\\$ unit , \\$ op ) } } impl_folding ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    impl_folding! {impl < M : Modulus > Sum < _ > for StaticModInt < M > {fn sum (_ ) -> _ {_ (Self :: raw (0 ) , Add :: add ) } } impl < M : Modulus > Product < _ > for StaticModInt < M > {fn product (_ ) -> _ {_ (Self :: raw (1 ) , Mul :: mul ) } } }",
      "}",
      "pub mod rolling_hash {",
      "    type Mint = super::ModInt2305843009213693951;",
      "    #[derive(Clone, Debug)]",
      "    pub struct RollingHash {",
      "        hash_list: Vec<Mint>,",
      "        pow_list: Vec<Mint>,",
      "        length: usize,",
      "    }",
      "    impl RollingHash {",
      "        pub fn new(xs: &[i64], base: i64) -> Self {",
      "            let base = Mint::new(base);",
      "            let mut hash_list = vec![Mint::new(0); xs.len() + 1];",
      "            let mut pow_list = vec![Mint::new(1); xs.len() + 1];",
      "            for i in 0..xs.len() {",
      "                hash_list[i + 1] = hash_list[i] * base + Mint::new(xs[i]);",
      "                pow_list[i + 1] = pow_list[i] * base;",
      "            }",
      "            let length = xs.len();",
      "            Self {",
      "                hash_list,",
      "                pow_list,",
      "                length,",
      "            }",
      "        }",
      "        pub fn hash(&self, begin: usize, end: usize) -> u64 {",
      "            let x = self.hash_list[end] - self.hash_list[begin] * self.pow_list[end - begin];",
      "            x.val()",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.length",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.length == 0",
      "        }",
      "    }",
      "}"
    ]
  },
  "scan_iter": {
    "scope": "rust",
    "prefix": "scan_iter",
    "body": [
      "use scan_iter::*;",
      "pub mod scan_iter {",
      "    #[derive(Clone)]",
      "    pub struct Scanl<I, B, F> {",
      "        iter: I,",
      "        state: Option<B>,",
      "        f: F,",
      "    }",
      "    impl<I, B, F> Scanl<I, B, F> {",
      "        fn new(iter: I, init: B, f: F) -> Scanl<I, B, F> {",
      "            Scanl {",
      "                iter,",
      "                state: Some(init),",
      "                f,",
      "            }",
      "        }",
      "    }",
      "    impl<I, B, F> Iterator for Scanl<I, B, F>",
      "    where",
      "        B: Copy,",
      "        I: Iterator,",
      "        F: FnMut(&mut B, I::Item) -> B,",
      "    {",
      "        type Item = B;",
      "        #[inline]",
      "        fn next(&mut self) -> Option<B> {",
      "            let retval = self.state?;",
      "            let a_opt = self.iter.next();",
      "            self.state = self",
      "                .state",
      "                .and_then(|mut s| a_opt.map(|a| (self.f)(&mut s, a)));",
      "            Some(retval)",
      "        }",
      "    }",
      "    pub trait IteratorExtScanLeft: Iterator + Sized {",
      "        fn scanl<B, F>(self, init: B, f: F) -> Scanl<Self, B, F>",
      "        where",
      "            Self: Sized,",
      "            F: FnMut(&mut B, Self::Item) -> B,",
      "        {",
      "            Scanl::new(self, init, f)",
      "        }",
      "    }",
      "    impl<T: Iterator> IteratorExtScanLeft for T {}",
      "}"
    ]
  },
  "segtree_to_vec": {
    "scope": "rust",
    "prefix": "segtree_to_vec",
    "body": [
      "pub fn segtree_to_vec<M: ac_library::Monoid>(",
      "    seg: &ac_library::Segtree<M>,",
      "    len: usize,",
      ") -> Vec<M::S> {",
      "    (0..len).map(|i| seg.get(i)).collect()",
      "}"
    ]
  },
  "simple_union_find": {
    "scope": "rust",
    "prefix": "simple_union_find",
    "body": [
      "use simple_union_find::*;",
      "pub mod simple_union_find {",
      "    use itertools::Itertools;",
      "    #[derive(Clone, Debug)]",
      "    struct RootInfo {",
      "        count: usize,",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    struct NonRootInfo {",
      "        parent: usize,",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    enum Node {",
      "        Root(RootInfo),",
      "        NonRoot(NonRootInfo),",
      "    }",
      "    impl Node {",
      "        fn root(count: usize) -> Node {",
      "            Node::Root(RootInfo { count })",
      "        }",
      "        fn non_root(parent: usize) -> Node {",
      "            Node::NonRoot(NonRootInfo { parent })",
      "        }",
      "        fn as_root(&self) -> &RootInfo {",
      "            match self {",
      "                Node::Root(info) => info,",
      "                Node::NonRoot(_) => panic!(),",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    pub struct UnionFind {",
      "        nodes: Vec<Node>,",
      "        cnt_groups: usize,",
      "    }",
      "    impl UnionFind {",
      "        pub fn new(n: usize) -> UnionFind {",
      "            let nodes = (0..n).map(|_| Node::root(1)).collect_vec();",
      "            UnionFind {",
      "                nodes,",
      "                cnt_groups: n,",
      "            }",
      "        }",
      "        pub fn root(&mut self, index: usize) -> usize {",
      "            match &self.nodes[index] {",
      "                Node::Root(_) => index,",
      "                Node::NonRoot(info) => {",
      "                    let root = self.root(info.parent);",
      "                    self.nodes[index] = Node::non_root(root);",
      "                    root",
      "                }",
      "            }",
      "        }",
      "        pub fn same_count(&mut self, index: usize) -> usize {",
      "            let root_index = self.root(index);",
      "            self.nodes[root_index].as_root().count",
      "        }",
      "        pub fn same(&mut self, x: usize, y: usize) -> bool {",
      "            self.root(x) == self.root(y)",
      "        }",
      "        pub fn num_groups(&self) -> usize {",
      "            self.cnt_groups",
      "        }",
      "        pub fn unite(&mut self, x: usize, y: usize) -> bool {",
      "            if self.same(x, y) {",
      "                return false;",
      "            }",
      "            self.cnt_groups -= 1;",
      "            let (smaller_root, larger_root) = {",
      "                let x_root = self.root(x);",
      "                let y_root = self.root(y);",
      "                let x_count = self.nodes[x_root].as_root().count;",
      "                let y_count = self.nodes[y_root].as_root().count;",
      "                if x_count < y_count {",
      "                    (x_root, y_root)",
      "                } else {",
      "                    (y_root, x_root)",
      "                }",
      "            };",
      "            let count_sum =",
      "                self.nodes[smaller_root].as_root().count + self.nodes[larger_root].as_root().count;",
      "            self.nodes[smaller_root] = Node::non_root(larger_root);",
      "            self.nodes[larger_root] = Node::root(count_sum);",
      "            true",
      "        }",
      "        pub fn groups(&mut self) -> Vec<Vec<usize>> {",
      "            let n = self.nodes.len();",
      "            let roots = (0..n).map(|i| self.root(i)).collect_vec();",
      "            let group_size = (0..n).map(|i| roots[i]).fold(vec![0; n], |mut acc, x| {",
      "                acc[x] += 1;",
      "                acc",
      "            });",
      "            let result = {",
      "                let mut result = vec![Vec::new(); n];",
      "                for i in 0..n {",
      "                    result[i].reserve(group_size[i]);",
      "                }",
      "                for i in 0..n {",
      "                    result[roots[i]].push(i);",
      "                }",
      "                result",
      "            };",
      "            result.into_iter().filter(|x| !x.is_empty()).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "static_mod_int": {
    "scope": "rust",
    "prefix": "static_mod_int",
    "body": [
      "use static_mod_int::*;",
      "pub mod static_mod_int {",
      "    use ac_library::{ButterflyCache, Modulus, StaticModInt};",
      "    use std::{cell::RefCell, thread::LocalKey};",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod2 {}",
      "    impl Modulus for Mod2 {",
      "        const VALUE: u32 = 2;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "        fn butterfly_cache() -> &'static LocalKey<RefCell<Option<ButterflyCache<Self>>>> {",
      "            thread_local! {static BUTTERFLY_CACHE : RefCell < Option < ButterflyCache < Mod2 >>> = RefCell :: default () ; }",
      "            &BUTTERFLY_CACHE",
      "        }",
      "    }",
      "    pub type ModInt2 = StaticModInt<Mod2>;",
      "}"
    ]
  },
  "subtraction_game": {
    "scope": "rust",
    "prefix": "subtraction_game",
    "body": [
      "use subtraction_game::*;",
      "pub mod subtraction_game {",
      "    use itertools::Itertools;",
      "    fn mex(xs: &[usize]) -> usize {",
      "        let contains = xs",
      "            .iter()",
      "            .copied()",
      "            .fold(vec![false; xs.len()], |mut acc, x| {",
      "                if x < xs.len() {",
      "                    acc[x] |= true;",
      "                }",
      "                acc",
      "            });",
      "        contains",
      "            .iter()",
      "            .copied()",
      "            .position(|p| !p)",
      "            .unwrap_or(xs.len())",
      "    }",
      "    /// subtraction_game の 0 から n - 1 までの grundy 数を求める",
      "    pub fn subtraction_game_grundy(subtractions: &[usize], n: usize) -> Vec<usize> {",
      "        let mut grundy = vec![usize::MAX; n];",
      "        for x in 0..n {",
      "            let next_grundy_list = subtractions",
      "                .iter()",
      "                .copied()",
      "                .filter(|sub| x >= *sub)",
      "                .map(|sub| grundy[x - sub])",
      "                .collect_vec();",
      "            grundy[x] = mex(&next_grundy_list)",
      "        }",
      "        grundy",
      "    }",
      "}"
    ]
  },
  "time_keeper": {
    "scope": "rust",
    "prefix": "time_keeper",
    "body": [
      "use time_keeper::*;",
      "pub mod time_keeper {",
      "    #[derive(Debug, Clone)]",
      "    pub struct TimeKeeper {",
      "        start_time: std::time::Instant,",
      "        time_threshold_sec: f64,",
      "    }",
      "    impl TimeKeeper {",
      "        /// time_threshold_sec: 制限時間(秒数)",
      "        pub fn new(time_threshold_sec: f64) -> Self {",
      "            TimeKeeper {",
      "                start_time: std::time::Instant::now(),",
      "                time_threshold_sec,",
      "            }",
      "        }",
      "        #[inline]",
      "        pub fn is_time_over(&self) -> bool {",
      "            let elapsed_time = self.start_time.elapsed().as_nanos() as f64 * 1e-9;",
      "            elapsed_time >= self.time_threshold_sec",
      "        }",
      "    }",
      "}"
    ]
  },
  "topo_sort": {
    "scope": "rust",
    "prefix": "topo_sort",
    "body": [
      "use mod_queue::*;",
      "pub mod mod_queue {",
      "    use std::collections::VecDeque;",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Queue<T> {",
      "        raw: VecDeque<T>,",
      "    }",
      "    impl<T> Queue<T> {",
      "        pub fn new() -> Self {",
      "            Queue {",
      "                raw: VecDeque::new(),",
      "            }",
      "        }",
      "        pub fn push(&mut self, value: T) {",
      "            self.raw.push_back(value)",
      "        }",
      "        pub fn pop(&mut self) -> Option<T> {",
      "            self.raw.pop_front()",
      "        }",
      "        pub fn peek(&self) -> Option<&T> {",
      "            self.raw.front()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.raw.len()",
      "        }",
      "    }",
      "    impl<T> Default for Queue<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "}",
      "pub fn topo_sort(adj: &Vec<Vec<usize>>) -> Vec<usize> {",
      "    let n_vertex = adj.len();",
      "    let mut in_deg = vec![0; n_vertex];",
      "    for current in 0..n_vertex {",
      "        for &next in &adj[current] {",
      "            in_deg[next] += 1;",
      "        }",
      "    }",
      "    let mut open: Queue<usize> = Queue::new();",
      "    for v in 0..n_vertex {",
      "        if in_deg[v] == 0 {",
      "            open.push(v);",
      "        }",
      "    }",
      "    let mut ans = vec![];",
      "    while let Some(current) = open.pop() {",
      "        ans.push(current);",
      "        for &next in &adj[current] {",
      "            in_deg[next] -= 1;",
      "            if in_deg[next] == 0 {",
      "                open.push(next);",
      "            }",
      "        }",
      "    }",
      "    ans",
      "}"
    ]
  },
  "tree_diameter": {
    "scope": "rust",
    "prefix": "tree_diameter",
    "body": [
      "use mod_queue::*;",
      "pub mod mod_queue {",
      "    use std::collections::VecDeque;",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Queue<T> {",
      "        raw: VecDeque<T>,",
      "    }",
      "    impl<T> Queue<T> {",
      "        pub fn new() -> Self {",
      "            Queue {",
      "                raw: VecDeque::new(),",
      "            }",
      "        }",
      "        pub fn push(&mut self, value: T) {",
      "            self.raw.push_back(value)",
      "        }",
      "        pub fn pop(&mut self) -> Option<T> {",
      "            self.raw.pop_front()",
      "        }",
      "        pub fn peek(&self) -> Option<&T> {",
      "            self.raw.front()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.raw.len()",
      "        }",
      "    }",
      "    impl<T> Default for Queue<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "}",
      "/// 木の直径を求める(直径の長さと直径を構成する頂点のリストを返す)",
      "/// edges: 辺の情報 (頂点, 頂点, コスト) のリスト",
      "/// 計算量: O(n) (n が頂点の数のとき)",
      "pub fn tree_diameter(edges: &[(usize, usize, i64)]) -> (i64, Vec<usize>) {",
      "    let nv = edges.len() + 1;",
      "    let adj = edges",
      "        .iter()",
      "        .copied()",
      "        .fold(vec![vec![]; nv], |mut acc, (u, v, cost)| {",
      "            acc[u].push((v, cost));",
      "            acc[v].push((u, cost));",
      "            acc",
      "        });",
      "    fn bfs(adj: &[Vec<(usize, i64)>], init: usize) -> (i64, Vec<usize>) {",
      "        let n = adj.len();",
      "        let mut dist = vec![0; n];",
      "        let mut prev = vec![None; n];",
      "        let mut visited = vec![false; n];",
      "        let mut open = Queue::new();",
      "        open.push(init);",
      "        visited[init] = true;",
      "        while let Some(current) = open.pop() {",
      "            for &(next, cost) in &adj[current] {",
      "                if !visited[next] {",
      "                    dist[next] = dist[current] + cost;",
      "                    prev[next] = Some(current);",
      "                    visited[next] = true;",
      "                    open.push(next);",
      "                }",
      "            }",
      "        }",
      "        let (furthest, max_dist) = dist",
      "            .iter()",
      "            .copied()",
      "            .enumerate()",
      "            .max_by_key(|(_, d)| *d)",
      "            .unwrap();",
      "        let path: Vec<usize> = {",
      "            let mut path: Vec<usize> =",
      "                std::iter::successors(Some(furthest), |&i| prev[i]).collect();",
      "            path.reverse();",
      "            path",
      "        };",
      "        (max_dist, path)",
      "    }",
      "    let x = *bfs(&adj, 0).1.last().unwrap();",
      "    bfs(&adj, x)",
      "}"
    ]
  },
  "tree_diameter_no_weight": {
    "scope": "rust",
    "prefix": "tree_diameter_no_weight",
    "body": [
      "use mod_queue::*;",
      "/// 木の直径を求める(直径の長さと直径を構成する頂点のリストを返す)",
      "/// edges: 辺の情報 (頂点, 頂点, コスト) のリスト",
      "/// 計算量: O(n) (n が頂点の数のとき)",
      "pub fn tree_diameter(edges: &[(usize, usize, i64)]) -> (i64, Vec<usize>) {",
      "    let nv = edges.len() + 1;",
      "    let adj = edges",
      "        .iter()",
      "        .copied()",
      "        .fold(vec![vec![]; nv], |mut acc, (u, v, cost)| {",
      "            acc[u].push((v, cost));",
      "            acc[v].push((u, cost));",
      "            acc",
      "        });",
      "    fn bfs(adj: &[Vec<(usize, i64)>], init: usize) -> (i64, Vec<usize>) {",
      "        let n = adj.len();",
      "        let mut dist = vec![0; n];",
      "        let mut prev = vec![None; n];",
      "        let mut visited = vec![false; n];",
      "        let mut open = Queue::new();",
      "        open.push(init);",
      "        visited[init] = true;",
      "        while let Some(current) = open.pop() {",
      "            for &(next, cost) in &adj[current] {",
      "                if !visited[next] {",
      "                    dist[next] = dist[current] + cost;",
      "                    prev[next] = Some(current);",
      "                    visited[next] = true;",
      "                    open.push(next);",
      "                }",
      "            }",
      "        }",
      "        let (furthest, max_dist) = dist",
      "            .iter()",
      "            .copied()",
      "            .enumerate()",
      "            .max_by_key(|(_, d)| *d)",
      "            .unwrap();",
      "        let path: Vec<usize> = {",
      "            let mut path: Vec<usize> =",
      "                std::iter::successors(Some(furthest), |&i| prev[i]).collect();",
      "            path.reverse();",
      "            path",
      "        };",
      "        (max_dist, path)",
      "    }",
      "    let x = *bfs(&adj, 0).1.last().unwrap();",
      "    bfs(&adj, x)",
      "}",
      "pub mod mod_queue {",
      "    use std::collections::VecDeque;",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Queue<T> {",
      "        raw: VecDeque<T>,",
      "    }",
      "    impl<T> Queue<T> {",
      "        pub fn new() -> Self {",
      "            Queue {",
      "                raw: VecDeque::new(),",
      "            }",
      "        }",
      "        pub fn push(&mut self, value: T) {",
      "            self.raw.push_back(value)",
      "        }",
      "        pub fn pop(&mut self) -> Option<T> {",
      "            self.raw.pop_front()",
      "        }",
      "        pub fn peek(&self) -> Option<&T> {",
      "            self.raw.front()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.raw.len()",
      "        }",
      "    }",
      "    impl<T> Default for Queue<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "}",
      "pub fn tree_diameter_no_weight(edges: &[(usize, usize)]) -> (i64, Vec<usize>) {",
      "    let edges: Vec<(usize, usize, i64)> = edges.iter().copied().map(|(u, v)| (u, v, 1)).collect();",
      "    tree_diameter(&edges)",
      "}"
    ]
  },
  "upper_bound": {
    "scope": "rust",
    "prefix": "upper_bound",
    "body": [
      "/// 二分探索をする",
      "/// ```text",
      "/// ng ng ng ok ok ok",
      "///          ↑ここの引数の値を返す",
      "/// ```",
      "/// 計算量: O(log(|ok - ng|))",
      "/// ## Arguments",
      "/// * ok != ng",
      "/// * |ok - ng| <= 2^63 - 1, |ok + ng| <= 2^63 - 1",
      "/// * p の定義域について",
      "///     * ng < ok の場合、p は区間 ng..ok で定義されている。",
      "///     * ok < ng の場合、p は区間 ok..ng で定義されている。",
      "/// * p の単調性について",
      "///     * ng < ok の場合、p は単調増加",
      "///     * ok < ng の場合、p は単調減少",
      "/// ## Return",
      "/// * ng < ok の場合: I = { i in ng..ok | p(i) == true } としたとき",
      "///     * I が空でなければ、min I を返す。",
      "///     * I が空ならば、ok を返す。",
      "/// * ok < ng の場合: I = { i in ok..ng | p(i) == true } としたとき",
      "///     * I が空でなければ、max I を返す。",
      "///     * I が空ならば、ok を返す。",
      "pub fn bin_search<F>(mut ok: i64, mut ng: i64, mut p: F) -> i64",
      "where",
      "    F: FnMut(i64) -> bool,",
      "{",
      "    debug_assert!(ok != ng);",
      "    debug_assert!(ok.checked_sub(ng).is_some());",
      "    debug_assert!(ok.checked_add(ng).is_some());",
      "    while num::abs(ok - ng) > 1 {",
      "        let mid = (ok + ng) / 2;",
      "        debug_assert!(mid != ok);",
      "        debug_assert!(mid != ng);",
      "        if p(mid) {",
      "            ok = mid;",
      "        } else {",
      "            ng = mid;",
      "        }",
      "    }",
      "    ok",
      "}",
      "/// 指定された要素より大きい値が現れる最初の位置を返す。",
      "/// 計算量: O(log(|xs|))",
      "/// ## Arguments",
      "/// * xs: 単調増加",
      "///     * 単調増加でなくても、 `|i| xs[i] > key` が単調ならOK",
      "/// ## Return",
      "/// `I = {i in 0..xs.len() | xs[i] > key}` としたとき、`min I` を返す。",
      "/// ただし、`I` が空の場合は `xs.len()` を返す",
      "/// 戻り値は、区間 `0..=xs.len()` の間で返る。",
      "pub fn upper_bound<T: PartialOrd>(xs: &[T], key: T) -> usize {",
      "    let pred = |i: i64| xs[i as usize] > key;",
      "    bin_search(xs.len() as i64, -1_i64, pred) as usize",
      "}"
    ]
  },
  "upper_bound_dec": {
    "scope": "rust",
    "prefix": "upper_bound_dec",
    "body": [
      "/// 二分探索をする",
      "/// ```text",
      "/// ng ng ng ok ok ok",
      "///          ↑ここの引数の値を返す",
      "/// ```",
      "/// 計算量: O(log(|ok - ng|))",
      "/// ## Arguments",
      "/// * ok != ng",
      "/// * |ok - ng| <= 2^63 - 1, |ok + ng| <= 2^63 - 1",
      "/// * p の定義域について",
      "///     * ng < ok の場合、p は区間 ng..ok で定義されている。",
      "///     * ok < ng の場合、p は区間 ok..ng で定義されている。",
      "/// * p の単調性について",
      "///     * ng < ok の場合、p は単調増加",
      "///     * ok < ng の場合、p は単調減少",
      "/// ## Return",
      "/// * ng < ok の場合: I = { i in ng..ok | p(i) == true } としたとき",
      "///     * I が空でなければ、min I を返す。",
      "///     * I が空ならば、ok を返す。",
      "/// * ok < ng の場合: I = { i in ok..ng | p(i) == true } としたとき",
      "///     * I が空でなければ、max I を返す。",
      "///     * I が空ならば、ok を返す。",
      "pub fn bin_search<F>(mut ok: i64, mut ng: i64, mut p: F) -> i64",
      "where",
      "    F: FnMut(i64) -> bool,",
      "{",
      "    debug_assert!(ok != ng);",
      "    debug_assert!(ok.checked_sub(ng).is_some());",
      "    debug_assert!(ok.checked_add(ng).is_some());",
      "    while num::abs(ok - ng) > 1 {",
      "        let mid = (ok + ng) / 2;",
      "        debug_assert!(mid != ok);",
      "        debug_assert!(mid != ng);",
      "        if p(mid) {",
      "            ok = mid;",
      "        } else {",
      "            ng = mid;",
      "        }",
      "    }",
      "    ok",
      "}",
      "/// 指定された要素より小さい値が現れる最初の位置を返す。",
      "/// 計算量: O(log(|xs|))",
      "/// ## Arguments",
      "/// * xs: 単勝減少",
      "///     * 単調減少でなくても、 `|i| xs[i] < key` が単調ならOK",
      "/// ## Return",
      "/// `I = {i in 0..xs.len() | xs[i] < key}` としたとき、`min I` を返す。",
      "/// ただし、`I` が空の場合は `xs.len()` を返す",
      "/// 戻り値は、区間 `0..=xs.len()` の間で返る。",
      "pub fn upper_bound_dec<T: PartialOrd>(xs: &[T], key: T) -> usize {",
      "    let pred = |i: i64| xs[i as usize] < key;",
      "    bin_search(xs.len() as i64, -1_i64, pred) as usize",
      "}"
    ]
  },
  "vec_at": {
    "scope": "rust",
    "prefix": "vec_at",
    "body": [
      "use vec_at::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod vec_at {",
      "    use easy_ext::ext;",
      "    #[ext(VecAt)]",
      "    impl<T> Vec<T> {",
      "        pub fn at(&self, index: i64) -> &T {",
      "            &self[index as usize]",
      "        }",
      "        pub fn at_mut(&mut self, index: i64) -> &mut T {",
      "            &mut self[index as usize]",
      "        }",
      "    }",
      "}"
    ]
  },
  "vec_to_fenwick_tree": {
    "scope": "rust",
    "prefix": "vec_to_fenwick_tree",
    "body": [
      "pub fn vec_to_fenwick_tree<T>(xs: &[T], e: T) -> FenwickTree<T>",
      "where",
      "    T: Clone + std::ops::AddAssign<T>,",
      "{",
      "    let mut fenwick_tree = FenwickTree::new(xs.len(), e);",
      "    for (i, x) in xs.iter().enumerate() {",
      "        fenwick_tree.add(i, x.clone());",
      "    }",
      "    fenwick_tree",
      "}"
    ]
  },
  "vec_vec_at": {
    "scope": "rust",
    "prefix": "vec_vec_at",
    "body": [
      "use vec_vec_at::*;",
      "pub mod vec_vec_at {",
      "    use super::pos::*;",
      "    use easy_ext::ext;",
      "    use std::ops::{Index, IndexMut};",
      "    #[ext(ExtVecVec)]",
      "    impl<T> Vec<Vec<T>> {",
      "        pub fn width(&self) -> usize {",
      "            if self.is_empty() {",
      "                0",
      "            } else {",
      "                self[0].len()",
      "            }",
      "        }",
      "        pub fn height(&self) -> usize {",
      "            self.len()",
      "        }",
      "        pub fn is_within(&self, pos: Pos) -> bool {",
      "            (0..self.width() as i64).contains(&pos.x) && (0..self.height() as i64).contains(&pos.y)",
      "        }",
      "    }",
      "    impl<T> Index<Pos> for Vec<Vec<T>> {",
      "        type Output = T;",
      "        fn index(&self, index: Pos) -> &Self::Output {",
      "            if cfg!(debug_assertions) && !self.is_within(index) {",
      "                panic ! (\"index out of bounds: the size (w, h) is ({}, {}) but the index (x, y) is ({}, {})\" , self . width () , self . height () , index . x , index . y );",
      "            }",
      "            &self[index.y as usize][index.x as usize]",
      "        }",
      "    }",
      "    impl<T> IndexMut<Pos> for Vec<Vec<T>> {",
      "        fn index_mut(&mut self, index: Pos) -> &mut Self::Output {",
      "            if cfg!(debug_assertions) && !self.is_within(index) {",
      "                panic ! (\"index out of bounds: the size (w, h) is ({}, {}) but the index (x, y) is ({}, {})\" , self . width () , self . height () , index . x , index . y );",
      "            }",
      "            &mut self[index.y as usize][index.x as usize]",
      "        }",
      "    }",
      "}"
    ]
  }
}
