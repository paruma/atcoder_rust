{
  "bin_search": {
    "scope": "rust",
    "prefix": "bin_search",
    "body": [
      "/// 二分探索をする",
      "/// ```text",
      "/// ng ng ng ok ok ok",
      "///          ↑ここの引数の値を返す",
      "/// ```",
      "/// 計算量: O(log(|ok - ng|))",
      "/// ## Arguments",
      "/// * ok != ng",
      "/// * |ok - ng| <= 2^63 - 1, |ok + ng| <= 2^63 - 1",
      "/// * p の定義域について",
      "///     * ng < ok の場合、p は区間 ng..ok で定義されている。",
      "///     * ok < ng の場合、p は区間 ok..ng で定義されている。",
      "/// * p の単調性について",
      "///     * ng < ok の場合、p は単調増加",
      "///     * ok < ng の場合、p は単調減少",
      "/// ## Return",
      "/// * ng < ok の場合: I = { i in ng..ok | p(i) == true } としたとき",
      "///     * I が空でなければ、min I を返す。",
      "///     * I が空ならば、ok を返す。",
      "/// * ok < ng の場合: I = { i in ok..ng | p(i) == true } としたとき",
      "///     * I が空でなければ、max I を返す。",
      "///     * I が空ならば、ok を返す。",
      "pub fn bin_search<F>(mut ok: i64, mut ng: i64, p: F) -> i64",
      "where",
      "    F: Fn(i64) -> bool,",
      "{",
      "    assert!(ok != ng);",
      "    assert!(ok.checked_sub(ng).is_some());",
      "    assert!(ok.checked_add(ng).is_some());",
      "    while num::abs(ok - ng) > 1 {",
      "        let mid = (ok + ng) / 2;",
      "        assert!(mid != ok);",
      "        assert!(mid != ng);",
      "        if p(mid) {",
      "            ok = mid;",
      "        } else {",
      "            ng = mid;",
      "        }",
      "    }",
      "    ok",
      "}"
    ]
  },
  "chminmax": {
    "scope": "rust",
    "prefix": "chminmax",
    "body": [
      "#[allow(clippy::module_inception)]",
      "#[macro_use]",
      "pub mod chminmax {",
      "    #[allow(unused_macros)]",
      "    #[macro_export]",
      "    macro_rules! chmin {",
      "        (\\$ a : expr , \\$ b : expr ) => {",
      "            if \\$a > \\$b {",
      "                \\$a = \\$b;",
      "                true",
      "            } else {",
      "                false",
      "            }",
      "        };",
      "    }",
      "    #[allow(unused_macros)]",
      "    #[macro_export]",
      "    macro_rules! chmax {",
      "        (\\$ a : expr , \\$ b : expr ) => {",
      "            if \\$a < \\$b {",
      "                \\$a = \\$b;",
      "                true",
      "            } else {",
      "                false",
      "            }",
      "        };",
      "    }",
      "}"
    ]
  },
  "coordinate_compression": {
    "scope": "rust",
    "prefix": "coordinate_compression",
    "body": [
      "use coordinate_compression::*;",
      "pub mod coordinate_compression {",
      "    use itertools::Itertools;",
      "    pub struct CoordinateCompression {",
      "        space: Vec<i64>,",
      "    }",
      "    impl CoordinateCompression {",
      "        /// 計算量: O(|space|log(|space|))",
      "        pub fn new(space: &[i64]) -> Self {",
      "            let space = space.iter().copied().sorted().dedup().collect_vec();",
      "            Self { space }",
      "        }",
      "        /// 計算量: O(log(|space|))",
      "        pub fn compress(&self, x: i64) -> usize {",
      "            self.space.binary_search(&x).unwrap()",
      "        }",
      "        /// 計算量: O(|xs|log(|space|))",
      "        pub fn compress_vec(&self, xs: &[i64]) -> Vec<usize> {",
      "            xs.iter().copied().map(|x| self.compress(x)).collect_vec()",
      "        }",
      "        /// 計算量: O(1)",
      "        pub fn decompress(&self, i: usize) -> i64 {",
      "            self.space[i]",
      "        }",
      "    }",
      "}"
    ]
  },
  "cum_monoid": {
    "scope": "rust",
    "prefix": "cum_monoid",
    "body": [
      "use cum_monoid::*;",
      "pub mod cum_monoid {",
      "    use ac_library::Monoid;",
      "    pub struct CumMonoid<M>",
      "    where",
      "        M: Monoid,",
      "    {",
      "        prefix_prod: Vec<M::S>,",
      "        suffix_prod: Vec<M::S>,",
      "    }",
      "    impl<M> CumMonoid<M>",
      "    where",
      "        M: Monoid,",
      "    {",
      "        pub fn new(xs: &[M::S]) -> CumMonoid<M> {",
      "            let mut prefix_prod = vec![M::identity(); xs.len() + 1];",
      "            let mut suffix_prod = vec![M::identity(); xs.len() + 1];",
      "            for i in 0..xs.len() {",
      "                prefix_prod[i + 1] = M::binary_operation(&prefix_prod[i], &xs[i]);",
      "            }",
      "            for i in (0..xs.len()).rev() {",
      "                suffix_prod[i] = M::binary_operation(&xs[i], &suffix_prod[i + 1]);",
      "            }",
      "            CumMonoid {",
      "                prefix_prod,",
      "                suffix_prod,",
      "            }",
      "        }",
      "        /// [0, i) の総積 (前から累積)",
      "        pub fn prefix_prod(&self, i: usize) -> M::S {",
      "            self.prefix_prod[i].clone()",
      "        }",
      "        /// [i, n) の総積 (後ろから累積)",
      "        pub fn suffix_prod(&self, i: usize) -> M::S {",
      "            self.suffix_prod[i].clone()",
      "        }",
      "        /// [0, i), [i + 1, n) の区間で総積を取る",
      "        pub fn prod_without1(&self, i: usize) -> M::S {",
      "            M::binary_operation(&self.prefix_prod[i], &self.suffix_prod[i + 1])",
      "        }",
      "        pub fn prod_without_range(&self, l: usize, r: usize) -> M::S {",
      "            M::binary_operation(&self.prefix_prod[l], &self.suffix_prod[r])",
      "        }",
      "    }",
      "}"
    ]
  },
  "cumsum": {
    "scope": "rust",
    "prefix": "cumsum",
    "body": [
      "use cumsum::*;",
      "pub mod cumsum {",
      "    pub struct CumSum {",
      "        pub cumsum: Vec<i64>,",
      "    }",
      "    impl CumSum {",
      "        /// 計算量: O(|xs|)",
      "        pub fn new(xs: &[i64]) -> CumSum {",
      "            let mut cumsum = vec![0; xs.len() + 1];",
      "            for i in 1..xs.len() + 1 {",
      "                cumsum[i] = cumsum[i - 1] + xs[i - 1];",
      "            }",
      "            CumSum { cumsum }",
      "        }",
      "        /// 計算量: O(1)",
      "        pub fn get_interval_sum(&self, begin: usize, end: usize) -> i64 {",
      "            self.cumsum[end] - self.cumsum[begin]",
      "        }",
      "    }",
      "}"
    ]
  },
  "cumsum_2d": {
    "scope": "rust",
    "prefix": "cumsum_2d",
    "body": [
      "use cumsum_2d::*;",
      "pub mod cumsum_2d {",
      "    pub struct CumSum2D {",
      "        pub cumsum: Vec<Vec<i64>>,",
      "    }",
      "    impl CumSum2D {",
      "        pub fn new(xss: &[Vec<i64>]) -> CumSum2D {",
      "            if xss.is_empty() {",
      "                return CumSum2D {",
      "                    cumsum: vec![vec![0]],",
      "                };",
      "            }",
      "            let height = xss.len();",
      "            let width = xss[0].len();",
      "            let mut cumsum = vec![vec![0; width + 1]; height + 1];",
      "            for y in 1..height + 1 {",
      "                for x in 1..width + 1 {",
      "                    cumsum[y][x] = cumsum[y - 1][x] + cumsum[y][x - 1] - cumsum[y - 1][x - 1]",
      "                        + xss[y - 1][x - 1];",
      "                }",
      "            }",
      "            CumSum2D { cumsum }",
      "        }",
      "        pub fn get_rect_sum(&self, (x1, y1): (usize, usize), (x2, y2): (usize, usize)) -> i64 {",
      "            self.cumsum[y2][x2] - self.cumsum[y2][x1] - self.cumsum[y1][x2] + self.cumsum[y1][x1]",
      "        }",
      "    }",
      "}"
    ]
  },
  "dynamic_monoid": {
    "scope": "rust",
    "prefix": "dynamic_monoid",
    "body": [
      "use dynamic_monoid::*;",
      "pub mod dynamic_monoid {",
      "    pub trait DynamicMonoid {",
      "        type S: Clone;",
      "        fn identity(&self) -> Self::S;",
      "        fn binary_operation(&self, a: &Self::S, b: &Self::S) -> Self::S;",
      "        /// base^n を求める",
      "        fn pow(&self, base: &Self::S, n: usize) -> Self::S {",
      "            let mut base = base.clone();",
      "            let mut ans = self.identity();",
      "            let mut n = n;",
      "            while n > 0 {",
      "                if n & 1 == 1 {",
      "                    ans = self.binary_operation(&ans, &base);",
      "                }",
      "                base = self.binary_operation(&base, &base);",
      "                n >>= 1;",
      "            }",
      "            ans",
      "        }",
      "    }",
      "}"
    ]
  },
  "edge": {
    "scope": "rust",
    "prefix": "edge",
    "body": [
      "#[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "pub struct Edge {",
      "    from: usize,",
      "    to: usize,",
      "}",
      "impl Edge {",
      "    pub fn new(from: usize, to: usize) -> Self {",
      "        Self { from, to }",
      "    }",
      "}",
      "pub fn make_adj(n_vertex: usize, edges: &[Edge]) -> Vec<Vec<Edge>> {",
      "    let mut adj = vec![vec![]; n_vertex];",
      "    for &e in edges {",
      "        adj[e.from].push(e);",
      "    }",
      "    adj",
      "}"
    ]
  },
  "extend_acl_monoid": {
    "scope": "rust",
    "prefix": "extend_acl_monoid",
    "body": [
      "use extend_acl_monoid::*;",
      "pub mod extend_acl_monoid {",
      "    use ac_library::Monoid;",
      "    pub trait MonoidExtPow: Monoid {",
      "        /// base^n を求める",
      "        fn pow(base: &Self::S, n: usize) -> Self::S {",
      "            let mut base = base.clone();",
      "            let mut ans = Self::identity();",
      "            let mut n = n;",
      "            while n > 0 {",
      "                if n & 1 == 1 {",
      "                    ans = Self::binary_operation(&ans, &base);",
      "                }",
      "                base = Self::binary_operation(&base, &base);",
      "                n >>= 1;",
      "            }",
      "            ans",
      "        }",
      "    }",
      "    impl<T> MonoidExtPow for T where T: Monoid {}",
      "}"
    ]
  },
  "fn_guard": {
    "scope": "rust",
    "prefix": "fn_guard",
    "body": [
      "pub fn guard(p: bool) -> Option<()> {",
      "    if p {",
      "        Some(())",
      "    } else {",
      "        None",
      "    }",
      "}"
    ]
  },
  "has_cycle_directed": {
    "scope": "rust",
    "prefix": "has_cycle_directed",
    "body": [
      "pub fn topo_sort(adj: &Vec<Vec<Edge>>) -> Vec<usize> {",
      "    let n_vertex = adj.len();",
      "    let mut in_deg = vec![0; n_vertex];",
      "    for v in 0..n_vertex {",
      "        for &e in &adj[v] {",
      "            in_deg[e.to] += 1;",
      "        }",
      "    }",
      "    let mut open: Queue<usize> = Queue::new();",
      "    for v in 0..n_vertex {",
      "        if in_deg[v] == 0 {",
      "            open.push(v);",
      "        }",
      "    }",
      "    let mut ans = vec![];",
      "    while let Some(current) = open.pop() {",
      "        ans.push(current);",
      "        for &e in &adj[current] {",
      "            in_deg[e.to] -= 1;",
      "            if in_deg[e.to] == 0 {",
      "                open.push(e.to);",
      "            }",
      "        }",
      "    }",
      "    ans",
      "}",
      "pub fn has_cycle_directed(adj: &Vec<Vec<Edge>>) -> bool {",
      "    let topo_sorted = topo_sort(adj);",
      "    topo_sorted.len() != adj.len()",
      "}"
    ]
  },
  "has_cycle_undirected": {
    "scope": "rust",
    "prefix": "has_cycle_undirected",
    "body": [
      "pub fn has_cycle_undirected(n_vertex: usize, edges: &[Edge]) -> bool {",
      "    let mut uf = UnionFind::new(n_vertex);",
      "    for &e in edges {",
      "        if uf.equiv(e.from, e.to) {",
      "            return true;",
      "        }",
      "        uf.union(e.from, e.to);",
      "    }",
      "    false",
      "}"
    ]
  },
  "imos_1d": {
    "scope": "rust",
    "prefix": "imos_1d",
    "body": [
      "use imos_1d::*;",
      "pub mod imos_1d {",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct RangeFunc {",
      "        begin: usize,",
      "        end: usize,",
      "        value: i64,",
      "    }",
      "    impl RangeFunc {",
      "        pub fn new(begin: usize, end: usize, value: i64) -> Self {",
      "            Self { begin, end, value }",
      "        }",
      "    }",
      "    /// sum value * 1_{[begin, end)} を Vec<i64> として計算する",
      "    /// [0, space) の範囲で考える",
      "    /// 各 begin, end は [0, space) に入っていてほしい",
      "    pub fn calc_imos_1d(range_func_list: &[RangeFunc], space: usize) -> Vec<i64> {",
      "        let mut imos = vec![0; space];",
      "        for &range_func in range_func_list {",
      "            imos[range_func.begin] += range_func.value;",
      "            imos[range_func.end] -= range_func.value;",
      "        }",
      "        for i in 1..space {",
      "            imos[i] += imos[i - 1];",
      "        }",
      "        imos",
      "    }",
      "}"
    ]
  },
  "imos_2d": {
    "scope": "rust",
    "prefix": "imos_2d",
    "body": [
      "use imos_2d::*;",
      "pub mod imos_2d {",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct RectFunc {",
      "        x_begin: usize,",
      "        x_end: usize,",
      "        y_begin: usize,",
      "        y_end: usize,",
      "        value: i64,",
      "    }",
      "    impl RectFunc {",
      "        pub fn new(x_begin: usize, x_end: usize, y_begin: usize, y_end: usize, value: i64) -> Self {",
      "            Self {",
      "                x_begin,",
      "                x_end,",
      "                y_begin,",
      "                y_end,",
      "                value,",
      "            }",
      "        }",
      "    }",
      "    #[allow(clippy::needless_range_loop)]",
      "    pub fn calc_imos_2d(",
      "        rect_func_list: &[RectFunc],",
      "        x_space: usize,",
      "        y_space: usize,",
      "    ) -> Vec<Vec<i64>> {",
      "        let mut imos = vec![vec![0; x_space]; y_space];",
      "        for &rect_func in rect_func_list {",
      "            imos[rect_func.y_begin][rect_func.x_begin] += rect_func.value;",
      "            imos[rect_func.y_begin][rect_func.x_end] -= rect_func.value;",
      "            imos[rect_func.y_end][rect_func.x_begin] -= rect_func.value;",
      "            imos[rect_func.y_end][rect_func.x_end] += rect_func.value;",
      "        }",
      "        for x in 1..x_space {",
      "            for y in 0..y_space {",
      "                imos[y][x] += imos[y][x - 1];",
      "            }",
      "        }",
      "        for y in 1..y_space {",
      "            for x in 0..x_space {",
      "                imos[y][x] += imos[y - 1][x];",
      "            }",
      "        }",
      "        imos",
      "    }",
      "}"
    ]
  },
  "inversion_number": {
    "scope": "rust",
    "prefix": "inversion_number",
    "body": [
      "/// 転倒数 #{(i, j) | i < j and xs[i] > xs[j]} を求める",
      "/// 計算量: O(n log n)",
      "pub fn inversion_number(xs: &[usize]) -> i64 {",
      "    use ac_library::{Additive, Segtree};",
      "    if xs.is_empty() {",
      "        return 0;",
      "    }",
      "    let max_val = xs.iter().copied().max().unwrap();",
      "    let mut segtree = Segtree::<Additive<i64>>::new(max_val + 1);",
      "    let mut cnt = 0;",
      "    for &x in xs {",
      "        cnt += segtree.prod(x + 1..);",
      "        segtree.set(x, segtree.get(x) + 1)",
      "    }",
      "    cnt",
      "}"
    ]
  },
  "is_bipartite_graph": {
    "scope": "rust",
    "prefix": "is_bipartite_graph",
    "body": [
      "#[allow(clippy::collapsible_else_if)]",
      "pub fn is_bipartite_graph(adj: &Vec<Vec<Edge>>) -> bool {",
      "    let n_vertex = adj.len();",
      "    let mut visited = vec![false; n_vertex];",
      "    let mut odd_even_list = vec![-1; n_vertex];",
      "    for init in 0..n_vertex {",
      "        if visited[init] {",
      "            continue;",
      "        }",
      "        let mut open: Queue<usize> = Queue::new();",
      "        open.push(init);",
      "        visited[init] = true;",
      "        odd_even_list[init] = 0;",
      "        while let Some(current) = open.pop() {",
      "            for &e in &adj[current] {",
      "                if !visited[e.to] {",
      "                    visited[e.to] = true;",
      "                    open.push(e.to);",
      "                    odd_even_list[e.to] = (odd_even_list[e.from] + 1) % 2;",
      "                } else {",
      "                    if odd_even_list[e.from] == odd_even_list[e.to] {",
      "                        return false;",
      "                    }",
      "                }",
      "            }",
      "        }",
      "    }",
      "    true",
      "}"
    ]
  },
  "is_bipartite_graph_by_uf": {
    "scope": "rust",
    "prefix": "is_bipartite_graph_by_uf",
    "body": [
      "pub fn is_bipartite_graph_by_uf(n_vertex: usize, edges: &[Edge]) -> bool {",
      "    let mut uf = UnionFind::new(2 * n_vertex);",
      "    for &e in edges {",
      "        uf.union(e.from, e.to + n_vertex);",
      "        uf.union(e.from + n_vertex, e.to);",
      "    }",
      "    (0..n_vertex).all(|i| !uf.equiv(i, i + n_vertex))",
      "}"
    ]
  },
  "iter_product": {
    "scope": "rust",
    "prefix": "iter_product",
    "body": [
      "use iter_product::*;",
      "mod iter_product {",
      "    pub trait Product2<A>: Sized {",
      "        fn product2<I: Iterator<Item = A>>(iter: I) -> Self;",
      "    }",
      "    impl<'a, T: num::One + std::ops::Mul<T, Output = T> + Copy> Product2<&'a T> for T {",
      "        fn product2<I: Iterator<Item = &'a T>>(iter: I) -> Self {",
      "            iter.fold(Self::one(), |acc, x| acc * (*x))",
      "        }",
      "    }",
      "    impl<T: num::One + std::ops::Mul<T, Output = T> + Copy> Product2<T> for T {",
      "        fn product2<I: Iterator<Item = T>>(iter: I) -> Self {",
      "            iter.fold(Self::one(), |acc, x| acc * x)",
      "        }",
      "    }",
      "    pub trait IteratorExtProduct2: Iterator + Sized {",
      "        fn product2<S>(self) -> S",
      "        where",
      "            Self: Sized,",
      "            S: Product2<Self::Item>,",
      "        {",
      "            Product2::product2(self)",
      "        }",
      "    }",
      "    impl<T: Iterator> IteratorExtProduct2 for T {}",
      "}"
    ]
  },
  "iter_sum": {
    "scope": "rust",
    "prefix": "iter_sum",
    "body": [
      "use iter_sum::*;",
      "pub mod iter_sum {",
      "    pub trait Sum2<A>: Sized {",
      "        fn sum2<I: Iterator<Item = A>>(iter: I) -> Self;",
      "    }",
      "    impl<'a, T: num::Zero + std::ops::Add<T, Output = T> + Copy> Sum2<&'a T> for T {",
      "        fn sum2<I: Iterator<Item = &'a T>>(iter: I) -> Self {",
      "            iter.fold(Self::zero(), |acc, x| acc + *x)",
      "        }",
      "    }",
      "    impl<T: num::Zero + std::ops::Add<T, Output = T> + Copy> Sum2<T> for T {",
      "        fn sum2<I: Iterator<Item = T>>(iter: I) -> Self {",
      "            iter.fold(Self::zero(), |acc, x| acc + x)",
      "        }",
      "    }",
      "    pub trait IteratorExtSum2: Iterator + Sized {",
      "        fn sum2<S>(self) -> S",
      "        where",
      "            Self: Sized,",
      "            S: Sum2<Self::Item>,",
      "        {",
      "            Sum2::sum2(self)",
      "        }",
      "    }",
      "    impl<T: Iterator> IteratorExtSum2 for T {}",
      "}"
    ]
  },
  "lg": {
    "scope": "rust",
    "prefix": "lg",
    "body": [
      "use lg::*;",
      "pub mod lg {",
      "    use std::borrow::Borrow;",
      "    use std::fmt;",
      "    use std::iter::once;",
      "    /// Print the values with the line number.",
      "    /// # Examples",
      "    /// ```rust",
      "    /// # use lg::*;",
      "    /// let x = 42;",
      "    /// let y = 43;",
      "    /// lg!(x);",
      "    /// lg!(x, y);",
      "    /// lg!(42, x, 43, y);",
      "    /// ```",
      "    #[macro_export]",
      "    macro_rules ! lg {(@ contents \\$ head : expr \\$ (, \\$ tail : expr ) * ) => {{\\$ crate :: __lg_internal ! (\\$ head ) ; \\$ (eprint ! (\",\" ) ; \\$ crate :: __lg_internal ! (\\$ tail ) ; ) * eprintln ! () ; } } ; (\\$ (\\$ expr : expr ) ,* \\$ (, ) ? ) => {{eprint ! (\"{}\\u{276f}\" , line ! () ) ; \\$ crate :: lg ! (@ contents \\$ (\\$ expr ) ,* ) } } ; }",
      "    #[doc(hidden)]",
      "    #[macro_export]",
      "    macro_rules! __lg_internal {",
      "        (\\$ value : expr ) => {{",
      "            match \\$value {",
      "                head => {",
      "                    eprint!(",
      "                        \" {} = {}\",",
      "                        stringify!(\\$value),",
      "                        \\$crate::__quiet(format!(\"{:?}\", &head))",
      "                    );",
      "                }",
      "            }",
      "        }};",
      "    }",
      "    /// Print many 1D arrays side-by-side with the line number.",
      "    /// # Examples",
      "    /// ```rust",
      "    /// # use lg::*;",
      "    /// let a = [1, 2, 3];",
      "    /// let b = [4, 5, 6];",
      "    /// let c = [7, 8, 9];",
      "    /// rows! {",
      "    ///   \"id\", // the name of the index",
      "    ///   @\"a\" => a,",
      "    ///   b,",
      "    ///   @\"c\" => c,",
      "    /// }",
      "    /// ```",
      "    #[macro_export]",
      "    macro_rules ! rows {{\\$ index_label : literal , \\$ (@ offset \\$ offset : expr , ) ? \\$ (@ verticalbar \\$ verticalbar : expr , ) * \\$ (\\$ (@\\$ label : literal => ) ? \\$ values : expr ) ,* \\$ (, ) ? } => {{#! [allow (unused_assignments ) ] let mut rows = \\$ crate :: Rows :: default () ; rows . line_number (line ! () ) ; \\$ (rows . offset (\\$ offset ) ; ) ? \\$ (rows . verticalbar (\\$ verticalbar ) ; ) * rows . index_label (\\$ index_label ) ; \\$ ({let mut label = stringify ! (\\$ values ) . to_string () ; if label . starts_with (\"&\" ) {label = label [1 .. ] . to_string () ; } \\$ ({let label_ : &'static str = \\$ label ; label = label_ . to_string () ; } ) ? rows . row (label , \\$ values ) ; } ) * eprintln ! (\"{}\" , rows . to_string_table () ) ; } } ; }",
      "    /// Print the 2D array with the line number.",
      "    /// # Examples",
      "    /// ```rust",
      "    /// # use lg::*;",
      "    /// let a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];",
      "    /// table! {",
      "    ///    @\"a\" => a,",
      "    /// }",
      "    /// table! {",
      "    ///   a,",
      "    /// }",
      "    /// ```",
      "    #[macro_export]",
      "    macro_rules ! table {{\\$ (@\\$ name : literal => ) ? \\$ values : expr \\$ (, ) ? } => {{#! [allow (unused_assignments ) ] let mut name = stringify ! (\\$ values ) . to_string () ; if name . starts_with (\"&\" ) {name = name [1 .. ] . to_string () ; } \\$ ({let name_ : &'static str = \\$ name ; name = name_ . to_string () ; } ) ? let mut rows = \\$ crate :: Rows :: default () ; rows . line_number (line ! () ) ; rows . table_name (name ) ; # [allow (array_into_iter ) ] for (i , row ) in \\$ values . into_iter () . enumerate () {rows . row (i . to_string () , row ) ; } eprintln ! (\"{}\" , rows . to_string_table () ) ; } } ; }",
      "    #[doc(hidden)]",
      "    pub fn __quiet(s: impl AsRef<str>) -> String {",
      "        s.as_ref()",
      "            .replace(\"340282366920938463463374607431768211455\", \"*\")",
      "            .replace(\"170141183460469231731687303715884105727\", \"*\")",
      "            .replace(\"18446744073709551615\", \"*\")",
      "            .replace(\"9223372036854775807\", \"*\")",
      "            .replace(\"-9223372036854775808\", \"*\")",
      "            .replace(\"4294967295\", \"*\")",
      "            .replace(\"2147483647\", \"*\")",
      "            .replace(\"-2147483648\", \"*\")",
      "            .replace(\"None\", \"*\")",
      "            .replace(\"Some\", \"\")",
      "            .replace(\"true\", \"#\")",
      "            .replace(\"false\", \".\")",
      "            .replace(['\"', '\\''], \"\")",
      "    }",
      "    #[doc(hidden)]",
      "    #[derive(Default)]",
      "    pub struct Rows {",
      "        line_number: String,",
      "        index_label: String,",
      "        offset: usize,",
      "        verticalbars: Vec<usize>,",
      "        table_name: String,",
      "        rows: Vec<Row>,",
      "    }",
      "    impl Rows {",
      "        pub fn line_number(&mut self, line_number: u32) -> &mut Self {",
      "            self.line_number = format!(\"{}\", line_number);",
      "            self",
      "        }",
      "        pub fn index_label(&mut self, index_label: impl Into<String>) -> &mut Self {",
      "            self.index_label = index_label.into();",
      "            self",
      "        }",
      "        pub fn offset(&mut self, offset: usize) -> &mut Self {",
      "            self.offset = offset;",
      "            self",
      "        }",
      "        pub fn verticalbar(&mut self, verticalbar: impl IntoIterator<Item = usize>) -> &mut Self {",
      "            self.verticalbars.extend(verticalbar);",
      "            self",
      "        }",
      "        pub fn table_name(&mut self, table_name: impl Into<String>) -> &mut Self {",
      "            self.table_name = table_name.into();",
      "            self",
      "        }",
      "        pub fn row(",
      "            &mut self,",
      "            label: impl Into<String>,",
      "            values: impl IntoIterator<Item = impl fmt::Debug>,",
      "        ) -> &mut Self {",
      "            self.rows.push(Row {",
      "                label: label.into(),",
      "                values: values",
      "                    .into_iter()",
      "                    .map(|value| __quiet(format!(\"{:?}\", value)))",
      "                    .collect(),",
      "            });",
      "            self",
      "        }",
      "        pub fn to_string_table(self) -> StringTable {",
      "            let Self {",
      "                line_number,",
      "                index_label,",
      "                offset,",
      "                verticalbars,",
      "                table_name,",
      "                rows,",
      "            } = self;",
      "            let w = rows",
      "                .iter()",
      "                .map(|row| row.values.len())",
      "                .max()",
      "                .unwrap_or_default();",
      "            let mut verticalbar_count = vec![0; w + 1];",
      "            for &v in &verticalbars {",
      "                if (offset..=offset + w).contains(&v) {",
      "                    verticalbar_count[v - offset] += 1;",
      "                }",
      "            }",
      "            StringTable {",
      "                head: StringRow {",
      "                    label: format!(",
      "                        \"{line_number}❯ {table_name}{index_label}\",",
      "                        index_label = if index_label.is_empty() {",
      "                            String::new()",
      "                        } else {",
      "                            format!(\"[{}]\", index_label)",
      "                        }",
      "                    ),",
      "                    values: (offset..offset + w)",
      "                        .map(|index| index.to_string())",
      "                        .collect(),",
      "                },",
      "                body: rows",
      "                    .iter()",
      "                    .map(|row| StringRow {",
      "                        label: row.label.clone(),",
      "                        values: row.values.clone(),",
      "                    })",
      "                    .collect(),",
      "                verticalbar_count,",
      "            }",
      "        }",
      "    }",
      "    struct Row {",
      "        label: String,",
      "        values: Vec<String>,",
      "    }",
      "    #[doc(hidden)]",
      "    pub struct StringTable {",
      "        head: StringRow,",
      "        body: Vec<StringRow>,",
      "        verticalbar_count: Vec<usize>,",
      "    }",
      "    impl fmt::Display for StringTable {",
      "        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "            let Self {",
      "                head,",
      "                body,",
      "                verticalbar_count,",
      "            } = self;",
      "            let w = body",
      "                .iter()",
      "                .map(|row| row.values.len())",
      "                .max()",
      "                .unwrap_or_default();",
      "            let label_width = once(head.label.chars().count())",
      "                .chain(body.iter().map(|row| row.label.chars().count()))",
      "                .max()",
      "                .unwrap();",
      "            let value_width = (0..w)",
      "                .map(|j| {",
      "                    once(j.to_string().len())",
      "                        .chain(",
      "                            body.iter()",
      "                                .map(|row| row.values.get(j).map_or(0, |s| s.chars().count())),",
      "                        )",
      "                        .max()",
      "                        .unwrap()",
      "                })",
      "                .collect::<Vec<_>>();",
      "            gray(f)?;",
      "            write!(",
      "                f,",
      "                \"{}\",",
      "                head.to_string(label_width, &value_width, verticalbar_count, true)",
      "            )?;",
      "            resetln(f)?;",
      "            for row in body {",
      "                write!(",
      "                    f,",
      "                    \"{}\",",
      "                    row.to_string(label_width, &value_width, verticalbar_count, false)",
      "                )?;",
      "                writeln!(f)?;",
      "            }",
      "            Ok(())",
      "        }",
      "    }",
      "    struct StringRow {",
      "        label: String,",
      "        values: Vec<String>,",
      "    }",
      "    impl StringRow {",
      "        fn to_string(",
      "            &self,",
      "            label_width: usize,",
      "            value_width: &[usize],",
      "            varticalbars_count: &[usize],",
      "            label_align_left: bool,",
      "        ) -> String {",
      "            let Self { label, values } = self;",
      "            let w = value_width.len();",
      "            let mut s = String::new();",
      "            s.push_str(&if label_align_left {",
      "                format!(\"{label:<label_width\\$} |\")",
      "            } else {",
      "                format!(\"{label:^label_width\\$} |\")",
      "            });",
      "            for j in 0..w {",
      "                let value_width = value_width[j];",
      "                s.push_str(\"|\".repeat(varticalbars_count[j]).as_str());",
      "                if varticalbars_count[j] == 0 && j != 0 && value_width <= 1 {",
      "                    s.push(' ');",
      "                }",
      "                match values.get(j) {",
      "                    Some(value) => {",
      "                        s.push_str(&format!(\" {value:>value_width\\$}\",));",
      "                    }",
      "                    None => {",
      "                        s.push_str(\" \".repeat(value_width + 1).as_str());",
      "                    }",
      "                }",
      "            }",
      "            s",
      "        }",
      "    }",
      "    const GRAY: &str = \"\\x1b[48;2;127;127;127;37m\";",
      "    const RESET: &str = \"\\x1b[0m\";",
      "    fn gray(f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "        write!(f, \"{GRAY}\")",
      "    }",
      "    fn resetln(f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "        writeln!(f, \"{RESET}\")",
      "    }",
      "    /// Format a iterator of [`bool`]s.",
      "    pub fn bools<B, I>(iter: I) -> String",
      "    where",
      "        B: Borrow<bool>,",
      "        I: IntoIterator<Item = B>,",
      "    {",
      "        format!(",
      "            \"[{}]\",",
      "            iter.into_iter()",
      "                .map(|b| ['.', '#'][usize::from(*(b.borrow()))])",
      "                .collect::<String>(),",
      "        )",
      "    }",
      "}"
    ]
  },
  "lower_bound": {
    "scope": "rust",
    "prefix": "lower_bound",
    "body": [
      "/// 二分探索をする",
      "/// ```text",
      "/// ng ng ng ok ok ok",
      "///          ↑ここの引数の値を返す",
      "/// ```",
      "/// 計算量: O(log(|ok - ng|))",
      "/// ## Arguments",
      "/// * ok != ng",
      "/// * |ok - ng| <= 2^63 - 1, |ok + ng| <= 2^63 - 1",
      "/// * p の定義域について",
      "///     * ng < ok の場合、p は区間 ng..ok で定義されている。",
      "///     * ok < ng の場合、p は区間 ok..ng で定義されている。",
      "/// * p の単調性について",
      "///     * ng < ok の場合、p は単調増加",
      "///     * ok < ng の場合、p は単調減少",
      "/// ## Return",
      "/// * ng < ok の場合: I = { i in ng..ok | p(i) == true } としたとき",
      "///     * I が空でなければ、min I を返す。",
      "///     * I が空ならば、ok を返す。",
      "/// * ok < ng の場合: I = { i in ok..ng | p(i) == true } としたとき",
      "///     * I が空でなければ、max I を返す。",
      "///     * I が空ならば、ok を返す。",
      "pub fn bin_search<F>(mut ok: i64, mut ng: i64, p: F) -> i64",
      "where",
      "    F: Fn(i64) -> bool,",
      "{",
      "    assert!(ok != ng);",
      "    assert!(ok.checked_sub(ng).is_some());",
      "    assert!(ok.checked_add(ng).is_some());",
      "    while num::abs(ok - ng) > 1 {",
      "        let mid = (ok + ng) / 2;",
      "        assert!(mid != ok);",
      "        assert!(mid != ng);",
      "        if p(mid) {",
      "            ok = mid;",
      "        } else {",
      "            ng = mid;",
      "        }",
      "    }",
      "    ok",
      "}",
      "/// 指定された要素以上の値が現れる最初の位置を返す。",
      "/// 計算量: O(log(|xs|))",
      "/// ## Arguments",
      "/// * xs: 単調増加",
      "///     * 単調増加でなくても、 `|i| xs[i] >= key` が単調ならOK",
      "/// ## Return",
      "/// `I = {i in 0..xs.len() | xs[i] >= key}` としたとき、`min I` を返す。",
      "/// ただし、`I` が空の場合は `xs.len()` を返す",
      "/// 戻り値は、区間 `0..=xs.len()` の間で返る。",
      "pub fn lower_bound<T: PartialOrd>(xs: &[T], key: T) -> usize {",
      "    let pred = |i: i64| xs[i as usize] >= key;",
      "    bin_search(xs.len() as i64, -1_i64, pred) as usize",
      "}"
    ]
  },
  "lower_bound_dec": {
    "scope": "rust",
    "prefix": "lower_bound_dec",
    "body": [
      "/// 二分探索をする",
      "/// ```text",
      "/// ng ng ng ok ok ok",
      "///          ↑ここの引数の値を返す",
      "/// ```",
      "/// 計算量: O(log(|ok - ng|))",
      "/// ## Arguments",
      "/// * ok != ng",
      "/// * |ok - ng| <= 2^63 - 1, |ok + ng| <= 2^63 - 1",
      "/// * p の定義域について",
      "///     * ng < ok の場合、p は区間 ng..ok で定義されている。",
      "///     * ok < ng の場合、p は区間 ok..ng で定義されている。",
      "/// * p の単調性について",
      "///     * ng < ok の場合、p は単調増加",
      "///     * ok < ng の場合、p は単調減少",
      "/// ## Return",
      "/// * ng < ok の場合: I = { i in ng..ok | p(i) == true } としたとき",
      "///     * I が空でなければ、min I を返す。",
      "///     * I が空ならば、ok を返す。",
      "/// * ok < ng の場合: I = { i in ok..ng | p(i) == true } としたとき",
      "///     * I が空でなければ、max I を返す。",
      "///     * I が空ならば、ok を返す。",
      "pub fn bin_search<F>(mut ok: i64, mut ng: i64, p: F) -> i64",
      "where",
      "    F: Fn(i64) -> bool,",
      "{",
      "    assert!(ok != ng);",
      "    assert!(ok.checked_sub(ng).is_some());",
      "    assert!(ok.checked_add(ng).is_some());",
      "    while num::abs(ok - ng) > 1 {",
      "        let mid = (ok + ng) / 2;",
      "        assert!(mid != ok);",
      "        assert!(mid != ng);",
      "        if p(mid) {",
      "            ok = mid;",
      "        } else {",
      "            ng = mid;",
      "        }",
      "    }",
      "    ok",
      "}",
      "/// 指定された要素以下の値が現れる最初の位置を返す。",
      "/// 計算量: O(log(|xs|))",
      "/// ## Arguments",
      "/// * xs: 単調減少",
      "///     * 単調減少でなくても、 `|i| xs[i] <= key` が単調ならOK",
      "/// ## Return",
      "/// `I = {i in 0..xs.len() | xs[i] <= key}` としたとき、`min I` を返す。",
      "/// ただし、`I` が空の場合は `xs.len()` を返す",
      "/// 戻り値は、区間 `0..=xs.len()` の間で返る。",
      "pub fn lower_bound_dec<T: PartialOrd>(xs: &[T], key: T) -> usize {",
      "    let pred = |i: i64| xs[i as usize] <= key;",
      "    bin_search(xs.len() as i64, -1_i64, pred) as usize",
      "}"
    ]
  },
  "mod_combinatorics": {
    "scope": "rust",
    "prefix": "mod_combinatorics",
    "body": [
      "use mod_combinatorics::*;",
      "pub mod mod_combinatorics {",
      "    use ac_library::ModInt998244353 as Mint;",
      "    pub struct Comb {",
      "        fac: Vec<Mint>,",
      "        invfac: Vec<Mint>,",
      "    }",
      "    impl Comb {",
      "        pub fn new(max_val: usize) -> Self {",
      "            let mut inv = vec![Mint::new(0); max_val + 1];",
      "            let mut fac = vec![Mint::new(0); max_val + 1];",
      "            let mut invfac = vec![Mint::new(0); max_val + 1];",
      "            fac[0] = 1.into();",
      "            fac[1] = 1.into();",
      "            invfac[0] = 1.into();",
      "            invfac[1] = 1.into();",
      "            inv[1] = 1.into();",
      "            let modulus = Mint::modulus() as usize;",
      "            for i in 2..=max_val {",
      "                inv[i] = -inv[modulus % i] * Mint::new(modulus / i);",
      "                fac[i] = fac[i - 1] * Mint::new(i);",
      "                invfac[i] = invfac[i - 1] * inv[i];",
      "            }",
      "            Self { fac, invfac }",
      "        }",
      "        pub fn comb(&self, n: usize, k: usize) -> Mint {",
      "            if n < k {",
      "                0.into()",
      "            } else {",
      "                self.fac[n] * self.invfac[k] * self.invfac[n - k]",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "mod_ext_int": {
    "scope": "rust",
    "prefix": "mod_ext_int",
    "body": [
      "use mod_ext_int::ExtInt::{self, *};",
      "pub mod mod_ext_int {",
      "    use ac_library::Monoid;",
      "    use std::{",
      "        cmp::Ordering,",
      "        convert::Infallible,",
      "        iter::Sum,",
      "        ops::{Add, AddAssign},",
      "    };",
      "    use ExtInt::*;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub enum ExtInt {",
      "        Inf,",
      "        Fin(i64),",
      "    }",
      "    impl ExtInt {",
      "        pub fn get_fin(self) -> i64 {",
      "            match self {",
      "                Fin(val) => val,",
      "                Inf => panic!(\"called `ExtInt::get_fin()` on a `Fin` value\"),",
      "            }",
      "        }",
      "        pub fn get_fin_or(self, default: i64) -> i64 {",
      "            match self {",
      "                Fin(val) => val,",
      "                Inf => default,",
      "            }",
      "        }",
      "        pub fn is_fin(self) -> bool {",
      "            matches!(self, Fin(_))",
      "        }",
      "        pub fn is_inf(self) -> bool {",
      "            matches!(self, Inf)",
      "        }",
      "        pub fn to_option(self) -> Option<i64> {",
      "            match self {",
      "                Inf => None,",
      "                Fin(a) => Some(a),",
      "            }",
      "        }",
      "        pub fn from_option(opt: Option<i64>) -> ExtInt {",
      "            match opt {",
      "                Some(a) => Fin(a),",
      "                None => Inf,",
      "            }",
      "        }",
      "        pub fn times(self, t: i64) -> Self {",
      "            match t.cmp(&0) {",
      "                Ordering::Less => panic!(\"t must be non-negative.\"),",
      "                Ordering::Equal => Fin(0),",
      "                Ordering::Greater => match self {",
      "                    Inf => Inf,",
      "                    Fin(a) => Fin(a * t),",
      "                },",
      "            }",
      "        }",
      "    }",
      "    impl Add for ExtInt {",
      "        type Output = ExtInt;",
      "        fn add(self, rhs: Self) -> Self::Output {",
      "            match (self, rhs) {",
      "                (Inf, Inf) => Inf,",
      "                (Inf, Fin(_)) => Inf,",
      "                (Fin(_), Inf) => Inf,",
      "                (Fin(a), Fin(b)) => Fin(a + b),",
      "            }",
      "        }",
      "    }",
      "    impl AddAssign for ExtInt {",
      "        fn add_assign(&mut self, rhs: Self) {",
      "            *self = *self + rhs;",
      "        }",
      "    }",
      "    impl Add<i64> for ExtInt {",
      "        type Output = ExtInt;",
      "        fn add(self, rhs: i64) -> Self::Output {",
      "            match self {",
      "                Inf => Inf,",
      "                Fin(a) => Fin(a + rhs),",
      "            }",
      "        }",
      "    }",
      "    impl AddAssign<i64> for ExtInt {",
      "        fn add_assign(&mut self, rhs: i64) {",
      "            *self = *self + rhs;",
      "        }",
      "    }",
      "    impl Sum for ExtInt {",
      "        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {",
      "            let mut s = 0;",
      "            for x in iter {",
      "                match x {",
      "                    Inf => return Inf,",
      "                    Fin(x) => s += x,",
      "                }",
      "            }",
      "            Fin(s)",
      "        }",
      "    }",
      "    impl PartialOrd for ExtInt {",
      "        fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {",
      "            match (self, other) {",
      "                (Inf, Inf) => Some(Ordering::Equal),",
      "                (Inf, Fin(_)) => Some(Ordering::Greater),",
      "                (Fin(_), Inf) => Some(Ordering::Less),",
      "                (Fin(a), Fin(b)) => PartialOrd::partial_cmp(a, b),",
      "            }",
      "        }",
      "    }",
      "    impl Ord for ExtInt {",
      "        fn cmp(&self, other: &Self) -> Ordering {",
      "            self.partial_cmp(other).unwrap()",
      "        }",
      "    }",
      "    pub struct ExtIntAdditive(Infallible);",
      "    impl Monoid for ExtIntAdditive {",
      "        type S = ExtInt;",
      "        fn identity() -> Self::S {",
      "            Fin(0)",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a + *b",
      "        }",
      "    }",
      "    pub struct ExtIntMin(Infallible);",
      "    impl Monoid for ExtIntMin {",
      "        type S = ExtInt;",
      "        fn identity() -> Self::S {",
      "            Inf",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a.min(b)",
      "        }",
      "    }",
      "}"
    ]
  },
  "mod_neg_ext_int": {
    "scope": "rust",
    "prefix": "mod_neg_ext_int",
    "body": [
      "use mod_neg_ext_int::NegExtInt::{self, *};",
      "pub mod mod_neg_ext_int {",
      "    use ac_library::Monoid;",
      "    use std::{",
      "        cmp::Ordering,",
      "        convert::Infallible,",
      "        ops::{Add, AddAssign},",
      "    };",
      "    use NegExtInt::*;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub enum NegExtInt {",
      "        NegInf,",
      "        Fin(i64),",
      "    }",
      "    impl NegExtInt {",
      "        pub fn get_fin(self) -> i64 {",
      "            match self {",
      "                Fin(val) => val,",
      "                NegInf => panic!(\"called `NegExtInt::get_fin()` on a `Fin` value\"),",
      "            }",
      "        }",
      "        pub fn get_fin_or(self, default: i64) -> i64 {",
      "            match self {",
      "                Fin(val) => val,",
      "                NegInf => default,",
      "            }",
      "        }",
      "        pub fn is_fin(self) -> bool {",
      "            matches!(self, Fin(_))",
      "        }",
      "        pub fn is_neginf(self) -> bool {",
      "            matches!(self, NegInf)",
      "        }",
      "        pub fn to_option(self) -> Option<i64> {",
      "            match self {",
      "                NegInf => None,",
      "                Fin(a) => Some(a),",
      "            }",
      "        }",
      "        pub fn from_option(opt: Option<i64>) -> NegExtInt {",
      "            match opt {",
      "                Some(a) => Fin(a),",
      "                None => NegInf,",
      "            }",
      "        }",
      "        pub fn times(self, t: i64) -> Self {",
      "            match t.cmp(&0) {",
      "                Ordering::Less => panic!(\"t must be non-negative.\"),",
      "                Ordering::Equal => Fin(0),",
      "                Ordering::Greater => match self {",
      "                    NegInf => NegInf,",
      "                    Fin(a) => Fin(a * t),",
      "                },",
      "            }",
      "        }",
      "    }",
      "    impl Add for NegExtInt {",
      "        type Output = NegExtInt;",
      "        fn add(self, rhs: Self) -> Self::Output {",
      "            match (self, rhs) {",
      "                (NegInf, NegInf) => NegInf,",
      "                (NegInf, Fin(_)) => NegInf,",
      "                (Fin(_), NegInf) => NegInf,",
      "                (Fin(a), Fin(b)) => Fin(a + b),",
      "            }",
      "        }",
      "    }",
      "    impl AddAssign for NegExtInt {",
      "        fn add_assign(&mut self, rhs: Self) {",
      "            *self = *self + rhs;",
      "        }",
      "    }",
      "    impl Add<i64> for NegExtInt {",
      "        type Output = NegExtInt;",
      "        fn add(self, rhs: i64) -> Self::Output {",
      "            match self {",
      "                NegInf => NegInf,",
      "                Fin(a) => Fin(a + rhs),",
      "            }",
      "        }",
      "    }",
      "    impl AddAssign<i64> for NegExtInt {",
      "        fn add_assign(&mut self, rhs: i64) {",
      "            *self = *self + rhs;",
      "        }",
      "    }",
      "    impl std::iter::Sum for NegExtInt {",
      "        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {",
      "            let mut s = 0;",
      "            for x in iter {",
      "                match x {",
      "                    NegInf => return NegInf,",
      "                    Fin(x) => s += x,",
      "                }",
      "            }",
      "            Fin(s)",
      "        }",
      "    }",
      "    impl PartialOrd for NegExtInt {",
      "        fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {",
      "            match (self, other) {",
      "                (NegInf, NegInf) => Some(Ordering::Equal),",
      "                (NegInf, Fin(_)) => Some(Ordering::Less),",
      "                (Fin(_), NegInf) => Some(Ordering::Greater),",
      "                (Fin(a), Fin(b)) => PartialOrd::partial_cmp(a, b),",
      "            }",
      "        }",
      "    }",
      "    impl Ord for NegExtInt {",
      "        fn cmp(&self, other: &Self) -> Ordering {",
      "            self.partial_cmp(other).unwrap()",
      "        }",
      "    }",
      "    pub struct NegExtIntAdditive(Infallible);",
      "    impl Monoid for NegExtIntAdditive {",
      "        type S = NegExtInt;",
      "        fn identity() -> Self::S {",
      "            Fin(0)",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a + *b",
      "        }",
      "    }",
      "    pub struct NegExtIntMax(Infallible);",
      "    impl Monoid for NegExtIntMax {",
      "        type S = NegExtInt;",
      "        fn identity() -> Self::S {",
      "            NegInf",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a.max(b)",
      "        }",
      "    }",
      "}"
    ]
  },
  "mod_number_thm": {
    "scope": "rust",
    "prefix": "mod_number_thm",
    "body": [
      "use mod_number_thm::*;",
      "pub mod mod_number_thm {",
      "    use num::Integer;",
      "    use num_integer::Roots;",
      "    use std::collections::HashMap;",
      "    /// O(sqrt(n))",
      "    pub fn divisors(n: i64) -> Vec<i64> {",
      "        assert!(n >= 1);",
      "        let mut retval: Vec<i64> = Vec::new();",
      "        for i in 1..=n.sqrt() {",
      "            if n.is_multiple_of(&i) {",
      "                retval.push(i);",
      "                if i * i != n {",
      "                    retval.push(n / i);",
      "                }",
      "            }",
      "        }",
      "        retval",
      "    }",
      "    /// 計算量: O(sqrt(n))",
      "    pub fn is_prime(n: i64) -> bool {",
      "        if n <= 1 {",
      "            return false;",
      "        }",
      "        for i in 2..=n.sqrt() {",
      "            if n.is_multiple_of(&i) {",
      "                return false;",
      "            }",
      "        }",
      "        true",
      "    }",
      "    /// 計算量: O(sqrt(n))",
      "    pub fn prime_factorize(n: i64) -> HashMap<i64, i64> {",
      "        assert!(n >= 1);",
      "        let mut cnt_table: HashMap<i64, i64> = HashMap::new();",
      "        let mut n = n;",
      "        for i in 2..=n.sqrt() {",
      "            if n.is_multiple_of(&i) {",
      "                let mut cnt = 0;",
      "                while n.is_multiple_of(&i) {",
      "                    n /= i;",
      "                    cnt += 1;",
      "                }",
      "                cnt_table.insert(i, cnt);",
      "            }",
      "        }",
      "        if n != 1 {",
      "            cnt_table.insert(n, 1);",
      "        }",
      "        cnt_table",
      "    }",
      "    /// 計算量: O(sqrt(n))",
      "    pub fn euler_phi(n: i64) -> i64 {",
      "        assert!(n >= 1);",
      "        let pf = prime_factorize(n);",
      "        let mut res = n;",
      "        for p in pf.keys() {",
      "            res = res / p * (p - 1);",
      "        }",
      "        res",
      "    }",
      "    pub struct Eratosthenes {",
      "        is_prime_list: Vec<bool>,",
      "        min_factor_list: Vec<Option<usize>>,",
      "    }",
      "    impl Eratosthenes {",
      "        pub fn new(n: usize) -> Self {",
      "            let mut is_prime_list = vec![true; n + 1];",
      "            let mut min_factor_list = vec![None; n + 1];",
      "            is_prime_list[0] = false;",
      "            is_prime_list[1] = false;",
      "            for p in 2..=n {",
      "                if !is_prime_list[p] {",
      "                    continue;",
      "                }",
      "                min_factor_list[p] = Some(p);",
      "                for q in (p * 2..=n).step_by(p) {",
      "                    is_prime_list[q] = false;",
      "                    if min_factor_list[q].is_none() {",
      "                        min_factor_list[q] = Some(p);",
      "                    }",
      "                }",
      "            }",
      "            Self {",
      "                is_prime_list,",
      "                min_factor_list,",
      "            }",
      "        }",
      "        pub fn is_prime(&self, n: usize) -> bool {",
      "            self.is_prime_list[n]",
      "        }",
      "        pub fn prime_factorize(&self, n: usize) -> HashMap<usize, usize> {",
      "            let mut n = n;",
      "            let mut cnt_table: HashMap<usize, usize> = HashMap::new();",
      "            while n > 1 {",
      "                let p = self.min_factor_list[n].unwrap();",
      "                let mut exp = 0;",
      "                while self.min_factor_list[n] == Some(p) {",
      "                    n /= p;",
      "                    exp += 1;",
      "                }",
      "                cnt_table.insert(p, exp);",
      "            }",
      "            cnt_table",
      "        }",
      "        pub fn divisors(&self, n: usize) -> Vec<usize> {",
      "            let mut res = vec![1];",
      "            let pf = self.prime_factorize(n);",
      "            for (p, e) in pf {",
      "                for i in 0..res.len() {",
      "                    let mut tmp = 1;",
      "                    for _ in 0..e {",
      "                        tmp *= p;",
      "                        res.push(res[i] * tmp);",
      "                    }",
      "                }",
      "            }",
      "            res",
      "        }",
      "    }",
      "}"
    ]
  },
  "mod_queue": {
    "scope": "rust",
    "prefix": "mod_queue",
    "body": [
      "use mod_queue::*;",
      "pub mod mod_queue {",
      "    use std::collections::VecDeque;",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Queue<T> {",
      "        raw: VecDeque<T>,",
      "    }",
      "    impl<T> Queue<T> {",
      "        pub fn new() -> Self {",
      "            Queue {",
      "                raw: VecDeque::new(),",
      "            }",
      "        }",
      "        pub fn push(&mut self, value: T) {",
      "            self.raw.push_front(value)",
      "        }",
      "        pub fn pop(&mut self) -> Option<T> {",
      "            self.raw.pop_back()",
      "        }",
      "        pub fn peek(&self) -> Option<&T> {",
      "            self.raw.back()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "    }",
      "    impl<T> Default for Queue<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "}"
    ]
  },
  "mod_stack": {
    "scope": "rust",
    "prefix": "mod_stack",
    "body": [
      "use mod_stack::*;",
      "pub mod mod_stack {",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Stack<T> {",
      "        raw: Vec<T>,",
      "    }",
      "    impl<T> Stack<T> {",
      "        pub fn new() -> Self {",
      "            Stack { raw: Vec::new() }",
      "        }",
      "        pub fn push(&mut self, value: T) {",
      "            self.raw.push(value)",
      "        }",
      "        pub fn pop(&mut self) -> Option<T> {",
      "            self.raw.pop()",
      "        }",
      "        pub fn peek(&self) -> Option<&T> {",
      "            self.raw.last()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "    }",
      "    impl<T> Default for Stack<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "}"
    ]
  },
  "modint_to_rational": {
    "scope": "rust",
    "prefix": "modint_to_rational",
    "body": [
      "use modint_to_rational::*;",
      "pub mod modint_to_rational {",
      "    use num_rational::Rational64;",
      "    pub trait ToRational {",
      "        fn to_rational(&self) -> Option<Rational64>;",
      "        fn to_rational_str(&self) -> String {",
      "            self.to_rational()",
      "                .map(|x| x.to_string())",
      "                .unwrap_or(\"cannot reconstruct\".to_string())",
      "        }",
      "    }",
      "    impl ToRational for ac_library::ModInt998244353 {",
      "        /// 注意: 1000 * 2000 = 2*10^6 の計算をしている",
      "        fn to_rational(&self) -> Option<Rational64> {",
      "            if self.val() == 0 {",
      "                return Some(Rational64::new(0, 1));",
      "            }",
      "            for denom in 1..1000 {",
      "                let denom_inv = Self::new(denom).inv();",
      "                for numer in -1000..1000 {",
      "                    if *self == denom_inv * Self::new(numer) {",
      "                        return Some(Rational64::new(numer, denom));",
      "                    }",
      "                }",
      "            }",
      "            None",
      "        }",
      "    }",
      "}"
    ]
  },
  "monoid_affine": {
    "scope": "rust",
    "prefix": "monoid_affine",
    "body": [
      "use monoid_affine::*;",
      "pub mod monoid_affine {",
      "    use ac_library::Monoid;",
      "    use std::{",
      "        convert::Infallible,",
      "        marker::PhantomData,",
      "        ops::{Add, Mul},",
      "    };",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct AffineTransform<T> {",
      "        slope: T,",
      "        intercept: T,",
      "    }",
      "    impl<T> AffineTransform<T> {",
      "        pub fn new(slope: T, intercept: T) -> Self {",
      "            Self { slope, intercept }",
      "        }",
      "        pub fn apply(&self, x: T) -> T",
      "        where",
      "            T: Copy + Mul<Output = T> + Add<Output = T>,",
      "        {",
      "            self.slope * x + self.intercept",
      "        }",
      "        pub fn identity() -> Self",
      "        where",
      "            T: From<i64>,",
      "        {",
      "            Self {",
      "                slope: 1.into(),",
      "                intercept: 0.into(),",
      "            }",
      "        }",
      "        pub fn composite(&self, rhs: &Self) -> Self",
      "        where",
      "            T: Copy + Mul<Output = T> + Add<Output = T>,",
      "        {",
      "            Self {",
      "                slope: self.slope * rhs.slope,",
      "                intercept: self.slope * rhs.intercept + self.intercept,",
      "            }",
      "        }",
      "    }",
      "    pub struct AffineComposition<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for AffineComposition<T>",
      "    where",
      "        T: Copy + From<i64> + Add<Output = T> + Mul<Output = T>,",
      "    {",
      "        type S = AffineTransform<T>;",
      "        fn identity() -> Self::S {",
      "            AffineTransform::identity()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            a.composite(b)",
      "        }",
      "    }",
      "}"
    ]
  },
  "monoid_bitwise": {
    "scope": "rust",
    "prefix": "monoid_bitwise",
    "body": [
      "use monoid_bitwise::*;",
      "pub mod monoid_bitwise {",
      "    use ac_library::Monoid;",
      "    use num_traits::Zero;",
      "    use std::{",
      "        convert::Infallible,",
      "        marker::PhantomData,",
      "        ops::{BitAnd, BitOr, BitXor, Not},",
      "    };",
      "    pub struct BitwiseOr<S>(Infallible, PhantomData<fn() -> S>);",
      "    impl<S> Monoid for BitwiseOr<S>",
      "    where",
      "        S: Copy + BitOr<Output = S> + Zero,",
      "    {",
      "        type S = S;",
      "        fn identity() -> Self::S {",
      "            S::zero()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a | *b",
      "        }",
      "    }",
      "    pub struct BitwiseAnd<S>(Infallible, PhantomData<fn() -> S>);",
      "    impl<S> Monoid for BitwiseAnd<S>",
      "    where",
      "        S: Copy + BitAnd<Output = S> + Not<Output = S> + Zero,",
      "    {",
      "        type S = S;",
      "        fn identity() -> Self::S {",
      "            !S::zero()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a & *b",
      "        }",
      "    }",
      "    pub struct BitwiseXor<S>(Infallible, PhantomData<fn() -> S>);",
      "    impl<S> Monoid for BitwiseXor<S>",
      "    where",
      "        S: Copy + BitXor<Output = S> + Zero,",
      "    {",
      "        type S = S;",
      "        fn identity() -> Self::S {",
      "            S::zero()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "    }",
      "}"
    ]
  },
  "monoid_gcd_lcm": {
    "scope": "rust",
    "prefix": "monoid_gcd_lcm",
    "body": [
      "use monoid_gcd_lcm::*;",
      "pub mod monoid_gcd_lcm {",
      "    use ac_library::Monoid;",
      "    use num_integer::Integer;",
      "    use std::{convert::Infallible, marker::PhantomData};",
      "    pub struct Gcd<S>(Infallible, PhantomData<fn() -> S>);",
      "    impl<S> Monoid for Gcd<S>",
      "    where",
      "        S: Integer + Clone,",
      "    {",
      "        type S = S;",
      "        fn identity() -> Self::S {",
      "            S::zero()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            a.gcd(b)",
      "        }",
      "    }",
      "    pub struct Lcm<S>(Infallible, PhantomData<fn() -> S>);",
      "    impl<S> Monoid for Lcm<S>",
      "    where",
      "        S: Integer + Clone,",
      "    {",
      "        type S = S;",
      "        fn identity() -> Self::S {",
      "            S::one()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            a.lcm(b)",
      "        }",
      "    }",
      "}"
    ]
  },
  "monoid_modint": {
    "scope": "rust",
    "prefix": "monoid_modint",
    "body": [
      "use monoid_modint::*;",
      "pub mod monoid_modint {",
      "    use ac_library::{Modulus, Monoid, StaticModInt};",
      "    use std::{convert::Infallible, marker::PhantomData};",
      "    pub struct MintAdditive<Mod>(Infallible, PhantomData<fn() -> Mod>);",
      "    impl<Mod> Monoid for MintAdditive<Mod>",
      "    where",
      "        Mod: Modulus,",
      "    {",
      "        type S = StaticModInt<Mod>;",
      "        fn identity() -> Self::S {",
      "            StaticModInt::raw(0)",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            a + b",
      "        }",
      "    }",
      "    pub struct MintMultiplicative<Mod>(Infallible, PhantomData<fn() -> Mod>);",
      "    impl<Mod> Monoid for MintMultiplicative<Mod>",
      "    where",
      "        Mod: Modulus,",
      "    {",
      "        type S = StaticModInt<Mod>;",
      "        fn identity() -> Self::S {",
      "            StaticModInt::raw(1)",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            a * b",
      "        }",
      "    }",
      "}"
    ]
  },
  "monoid_rolling_hash": {
    "scope": "rust",
    "prefix": "monoid_rolling_hash",
    "body": [
      "use monoid_rolling_hash::*;",
      "pub mod monoid_rolling_hash {",
      "    use std::convert::Infallible;",
      "    const MOD: i128 = (1 << 61) - 1;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    struct ModIntPow261M1 {",
      "        val: i128,",
      "    }",
      "    impl ModIntPow261M1 {",
      "        #[inline]",
      "        pub fn new(val: i128) -> Self {",
      "            let val = (val + MOD) % MOD;",
      "            Self {",
      "                val: val.rem_euclid(MOD),",
      "            }",
      "        }",
      "    }",
      "    impl std::ops::Add for ModIntPow261M1 {",
      "        type Output = Self;",
      "        #[inline]",
      "        fn add(self, rhs: Self) -> Self::Output {",
      "            Self::new(self.val + rhs.val)",
      "        }",
      "    }",
      "    impl std::ops::Sub for ModIntPow261M1 {",
      "        type Output = Self;",
      "        #[inline]",
      "        fn sub(self, rhs: Self) -> Self::Output {",
      "            Self::new(self.val - rhs.val)",
      "        }",
      "    }",
      "    impl std::ops::Mul for ModIntPow261M1 {",
      "        type Output = Self;",
      "        #[inline]",
      "        fn mul(self, rhs: Self) -> Self::Output {",
      "            Self::new(self.val * rhs.val)",
      "        }",
      "    }",
      "    use ac_library::Monoid;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct RollingHash {",
      "        hash: ModIntPow261M1,",
      "        base: ModIntPow261M1,",
      "    }",
      "    impl RollingHash {",
      "        pub fn get_hash(&self) -> i64 {",
      "            self.hash.val as i64",
      "        }",
      "        pub fn unit(base: i64) -> impl (Fn(i64) -> RollingHash) {",
      "            move |x| RollingHash {",
      "                hash: ModIntPow261M1::new(x as i128),",
      "                base: ModIntPow261M1::new(base as i128),",
      "            }",
      "        }",
      "    }",
      "    pub struct RollingHashConcat(Infallible);",
      "    impl Monoid for RollingHashConcat {",
      "        type S = RollingHash;",
      "        fn identity() -> Self::S {",
      "            RollingHash {",
      "                hash: ModIntPow261M1::new(0),",
      "                base: ModIntPow261M1::new(1),",
      "            }",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            RollingHash {",
      "                hash: a.hash * b.base + b.hash,",
      "                base: a.base * b.base,",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "monoid_rolling_hash_old": {
    "scope": "rust",
    "prefix": "monoid_rolling_hash_old",
    "body": [
      "use monoid_rolling_hash_old::*;",
      "pub mod monoid_rolling_hash_old {",
      "    use ac_library::Monoid;",
      "    use std::{",
      "        convert::Infallible,",
      "        marker::PhantomData,",
      "        ops::{Add, Mul},",
      "    };",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RollingHash<T> {",
      "        hash: T,",
      "        base: T,",
      "    }",
      "    impl<T> RollingHash<T> {",
      "        pub fn new(hash: T, base: T) -> Self {",
      "            Self { hash, base }",
      "        }",
      "        pub fn identity() -> Self",
      "        where",
      "            T: From<i64>,",
      "        {",
      "            Self {",
      "                hash: 0.into(),",
      "                base: 1.into(),",
      "            }",
      "        }",
      "        pub fn concat(&self, rhs: &Self) -> Self",
      "        where",
      "            T: Copy + Mul<Output = T> + Add<Output = T>,",
      "        {",
      "            Self {",
      "                hash: self.hash * rhs.base + rhs.hash,",
      "                base: self.base * rhs.base,",
      "            }",
      "        }",
      "    }",
      "    pub struct RollingHashConcat<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for RollingHashConcat<T>",
      "    where",
      "        T: Copy + From<i64> + Add<Output = T> + Mul<Output = T>,",
      "    {",
      "        type S = RollingHash<T>;",
      "        fn identity() -> Self::S {",
      "            RollingHash::identity()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            a.concat(b)",
      "        }",
      "    }",
      "}"
    ]
  },
  "monoid_transform": {
    "scope": "rust",
    "prefix": "monoid_transform",
    "body": [
      "use dynamic_monoid::*;",
      "use monoid_transform::*;",
      "pub mod dynamic_monoid {",
      "    pub trait DynamicMonoid {",
      "        type S: Clone;",
      "        fn identity(&self) -> Self::S;",
      "        fn binary_operation(&self, a: &Self::S, b: &Self::S) -> Self::S;",
      "        /// base^n を求める",
      "        fn pow(&self, base: &Self::S, n: usize) -> Self::S {",
      "            let mut base = base.clone();",
      "            let mut ans = self.identity();",
      "            let mut n = n;",
      "            while n > 0 {",
      "                if n & 1 == 1 {",
      "                    ans = self.binary_operation(&ans, &base);",
      "                }",
      "                base = self.binary_operation(&base, &base);",
      "                n >>= 1;",
      "            }",
      "            ans",
      "        }",
      "    }",
      "}",
      "pub mod monoid_transform {",
      "    use super::dynamic_monoid::DynamicMonoid;",
      "    use itertools::Itertools;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct Transform {",
      "        n: usize,",
      "    }",
      "    impl Transform {",
      "        pub fn new(n: usize) -> Self {",
      "            Self { n }",
      "        }",
      "    }",
      "    impl DynamicMonoid for Transform {",
      "        type S = Vec<usize>;",
      "        fn identity(&self) -> Self::S {",
      "            (0..self.n).collect_vec()",
      "        }",
      "        fn binary_operation(&self, a: &Self::S, b: &Self::S) -> Self::S {",
      "            (0..self.n).map(|i| a[b[i]]).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "pos": {
    "scope": "rust",
    "prefix": "pos",
    "body": [
      "use pos::*;",
      "pub mod pos {",
      "    use std::ops::{Add, AddAssign, Mul, Neg, Sub, SubAssign};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct Pos<T> {",
      "        pub x: T,",
      "        pub y: T,",
      "    }",
      "    impl<T> Pos<T> {",
      "        pub fn new(x: T, y: T) -> Pos<T> {",
      "            Pos { x, y }",
      "        }",
      "    }",
      "    impl<T: Mul<Output = T> + Copy> Pos<T> {",
      "        pub fn scala_mul(self, rhs: T) -> Pos<T> {",
      "            Pos::new(self.x * rhs, self.y * rhs)",
      "        }",
      "    }",
      "    impl<T: Add<Output = T> + Mul<Output = T> + Copy> Pos<T> {",
      "        pub fn norm_square(self) -> T {",
      "            self.x * self.x + self.y * self.y",
      "        }",
      "    }",
      "    impl<T: Add<Output = T> + Copy> Add for Pos<T> {",
      "        type Output = Pos<T>;",
      "        fn add(self, rhs: Self) -> Self::Output {",
      "            Pos::new(self.x + rhs.x, self.y + rhs.y)",
      "        }",
      "    }",
      "    impl<T: Sub<Output = T> + Copy> Sub for Pos<T> {",
      "        type Output = Pos<T>;",
      "        fn sub(self, rhs: Self) -> Self::Output {",
      "            Pos::new(self.x - rhs.x, self.y - rhs.y)",
      "        }",
      "    }",
      "    impl<T: Neg<Output = T>> Neg for Pos<T> {",
      "        type Output = Self;",
      "        fn neg(self) -> Self::Output {",
      "            Pos::new(-self.x, -self.y)",
      "        }",
      "    }",
      "    impl<T: num_traits::Zero + Copy> num_traits::Zero for Pos<T> {",
      "        fn zero() -> Self {",
      "            Pos::new(T::zero(), T::zero())",
      "        }",
      "        fn is_zero(&self) -> bool {",
      "            self.x.is_zero() && self.y.is_zero()",
      "        }",
      "    }",
      "    impl<T: Add<Output = T> + Copy> AddAssign for Pos<T> {",
      "        fn add_assign(&mut self, rhs: Self) {",
      "            *self = *self + rhs",
      "        }",
      "    }",
      "    impl<T: Sub<Output = T> + Copy> SubAssign for Pos<T> {",
      "        fn sub_assign(&mut self, rhs: Self) {",
      "            *self = *self - rhs",
      "        }",
      "    }",
      "    pub const DIR8_LIST: [Pos<i64>; 8] = [",
      "        Pos { x: 0, y: 1 },",
      "        Pos { x: 1, y: 1 },",
      "        Pos { x: 1, y: 0 },",
      "        Pos { x: 1, y: -1 },",
      "        Pos { x: 0, y: -1 },",
      "        Pos { x: -1, y: -1 },",
      "        Pos { x: -1, y: 0 },",
      "        Pos { x: -1, y: 1 },",
      "    ];",
      "    pub const DIR4_LIST: [Pos<i64>; 4] = [",
      "        Pos { x: 0, y: 1 },",
      "        Pos { x: 1, y: 0 },",
      "        Pos { x: 0, y: -1 },",
      "        Pos { x: -1, y: 0 },",
      "    ];",
      "}"
    ]
  },
  "print_arr": {
    "scope": "rust",
    "prefix": "print_arr",
    "body": [
      "use print_arr::*;",
      "pub mod print_arr {",
      "    use ndarray::{Array2, Array3};",
      "    use proconio::fastout;",
      "    #[fastout]",
      "    pub fn print_arr<T: std::fmt::Debug>(arr: &[T]) {",
      "        for a in arr {",
      "            print!(\"{:?} \", a);",
      "        }",
      "        println!();",
      "    }",
      "    #[fastout]",
      "    pub fn print_arr2<T: std::fmt::Debug>(arr: &Array2<T>) {",
      "        for i in 0..arr.nrows() {",
      "            for j in 0..arr.ncols() {",
      "                print!(\"{:?} \", arr[[i, j]]);",
      "            }",
      "            println!();",
      "        }",
      "    }",
      "    #[fastout]",
      "    pub fn print_arr3<T: std::fmt::Debug>(arr: &Array3<T>) {",
      "        let shape = arr.shape();",
      "        for i in 0..shape[0] {",
      "            for j in 0..shape[1] {",
      "                for k in 0..shape[2] {",
      "                    print!(\"{:?} \", arr[[i, j, k]]);",
      "                }",
      "                println!();",
      "            }",
      "            println!();",
      "        }",
      "    }",
      "}"
    ]
  },
  "print_vec": {
    "scope": "rust",
    "prefix": "print_vec",
    "body": [
      "use print_vec::*;",
      "pub mod print_vec {",
      "    use itertools::Itertools;",
      "    use proconio::fastout;",
      "    #[fastout]",
      "    pub fn print_vec<T: std::fmt::Debug>(arr: &[T]) {",
      "        for a in arr {",
      "            println!(\"{:?}\", a);",
      "        }",
      "    }",
      "    #[fastout]",
      "    pub fn print_vec_1line<T: std::fmt::Debug>(arr: &[T]) {",
      "        let msg = arr.iter().map(|x| format!(\"{:?}\", x)).join(\" \");",
      "        println!(\"{}\", msg);",
      "    }",
      "    #[fastout]",
      "    pub fn print_vec2<T: std::fmt::Debug>(arr: &Vec<Vec<T>>) {",
      "        for row in arr {",
      "            let msg = row.iter().map(|x| format!(\"{:?}\", x)).join(\" \");",
      "            println!(\"{}\", msg);",
      "        }",
      "    }",
      "    pub fn print_bytes(bytes: &[u8]) {",
      "        let msg = String::from_utf8(bytes.to_vec()).unwrap();",
      "        println!(\"{}\", msg);",
      "    }",
      "    #[fastout]",
      "    pub fn print_vec_bytes(vec_bytes: &[Vec<u8>]) {",
      "        for row in vec_bytes {",
      "            let msg = String::from_utf8(row.to_vec()).unwrap();",
      "            println!(\"{}\", msg);",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_affine_range_minmax": {
    "scope": "rust",
    "prefix": "range_affine_range_minmax",
    "body": [
      "use range_affine_range_minmax::*;",
      "pub mod range_affine_range_minmax {",
      "    use ac_library::{MapMonoid, Monoid};",
      "    use std::{cmp::Ordering, convert::Infallible};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct MinMaxLen {",
      "        pub min: i64,",
      "        pub max: i64,",
      "        pub len: i64,",
      "    }",
      "    impl MinMaxLen {",
      "        pub fn unit(x: i64) -> MinMaxLen {",
      "            MinMaxLen {",
      "                min: x,",
      "                max: x,",
      "                len: 1,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct Affine {",
      "        pub slope: i64,",
      "        pub intercept: i64,",
      "    }",
      "    impl Affine {",
      "        /// 区間変更用（定数関数）",
      "        pub fn constant_func(x: i64) -> Affine {",
      "            Affine {",
      "                slope: 0,",
      "                intercept: x,",
      "            }",
      "        }",
      "        /// 区間加算用",
      "        pub fn addition_func(x: i64) -> Affine {",
      "            Affine {",
      "                slope: 1,",
      "                intercept: x,",
      "            }",
      "        }",
      "    }",
      "    pub struct MinMaxLenMonoid(Infallible);",
      "    impl Monoid for MinMaxLenMonoid {",
      "        type S = MinMaxLen;",
      "        fn identity() -> MinMaxLen {",
      "            MinMaxLen {",
      "                min: INF,",
      "                max: -INF,",
      "                len: 0,",
      "            }",
      "        }",
      "        fn binary_operation(a: &MinMaxLen, b: &MinMaxLen) -> MinMaxLen {",
      "            MinMaxLen {",
      "                min: Ord::min(a.min, b.min),",
      "                max: Ord::max(a.max, b.max),",
      "                len: a.len + b.len,",
      "            }",
      "        }",
      "    }",
      "    const INF: i64 = i64::MAX;",
      "    pub struct AffineMinMax(Infallible);",
      "    impl MapMonoid for AffineMinMax {",
      "        type M = MinMaxLenMonoid;",
      "        type F = Affine;",
      "        fn identity_map() -> Affine {",
      "            Affine {",
      "                slope: 1,",
      "                intercept: 0,",
      "            }",
      "        }",
      "        fn composition(a: &Affine, b: &Affine) -> Affine {",
      "            Affine {",
      "                slope: a.slope * b.slope,",
      "                intercept: a.slope * b.intercept + a.intercept,",
      "            }",
      "        }",
      "        fn mapping(f: &Affine, x: &MinMaxLen) -> MinMaxLen {",
      "            if x.len == 0 {",
      "                return MinMaxLenMonoid::identity();",
      "            }",
      "            match f.slope.cmp(&0) {",
      "                Ordering::Equal => MinMaxLen {",
      "                    min: f.intercept,",
      "                    max: f.intercept,",
      "                    len: x.len,",
      "                },",
      "                Ordering::Greater => MinMaxLen {",
      "                    min: f.intercept + f.slope * x.min,",
      "                    max: f.intercept + f.slope * x.max,",
      "                    len: x.len,",
      "                },",
      "                Ordering::Less => MinMaxLen {",
      "                    min: f.intercept + f.slope * x.max,",
      "                    max: f.intercept + f.slope * x.min,",
      "                    len: x.len,",
      "                },",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_affine_range_sum": {
    "scope": "rust",
    "prefix": "range_affine_range_sum",
    "body": [
      "use range_affine_range_sum::*;",
      "pub mod range_affine_range_sum {",
      "    use ac_library::{MapMonoid, Monoid};",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    use std::ops::{Add, Mul};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct ValueLen<T> {",
      "        pub value: T,",
      "        pub len: i64,",
      "    }",
      "    impl<T> ValueLen<T> {",
      "        pub fn unit(x: T) -> ValueLen<T> {",
      "            ValueLen { value: x, len: 1 }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct Affine<T> {",
      "        pub slope: T,",
      "        pub intercept: T,",
      "    }",
      "    impl<T> Affine<T>",
      "    where",
      "        T: From<i64>,",
      "    {",
      "        /// 区間変更用（定数関数）",
      "        pub fn constant_func(x: T) -> Affine<T> {",
      "            Affine {",
      "                slope: 0.into(),",
      "                intercept: x,",
      "            }",
      "        }",
      "        /// 区間加算用",
      "        pub fn addition_func(x: T) -> Affine<T> {",
      "            Affine {",
      "                slope: 1.into(),",
      "                intercept: x,",
      "            }",
      "        }",
      "    }",
      "    pub struct ValueLenSum<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for ValueLenSum<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        type S = ValueLen<T>;",
      "        fn identity() -> ValueLen<T> {",
      "            ValueLen {",
      "                value: 0.into(),",
      "                len: 0,",
      "            }",
      "        }",
      "        fn binary_operation(a: &ValueLen<T>, b: &ValueLen<T>) -> ValueLen<T> {",
      "            ValueLen {",
      "                value: a.value + b.value,",
      "                len: a.len + b.len,",
      "            }",
      "        }",
      "    }",
      "    pub struct AffineSum<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> MapMonoid for AffineSum<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        type M = ValueLenSum<T>;",
      "        type F = Affine<T>;",
      "        fn identity_map() -> Affine<T> {",
      "            Affine {",
      "                slope: 1.into(),",
      "                intercept: 0.into(),",
      "            }",
      "        }",
      "        fn composition(a: &Affine<T>, b: &Affine<T>) -> Affine<T> {",
      "            Affine {",
      "                slope: a.slope * b.slope,",
      "                intercept: a.slope * b.intercept + a.intercept,",
      "            }",
      "        }",
      "        fn mapping(f: &Affine<T>, x: &ValueLen<T>) -> ValueLen<T> {",
      "            ValueLen {",
      "                value: f.slope * x.value + f.intercept * x.len.into(),",
      "                len: x.len,",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "rf": {
    "scope": "rust",
    "prefix": "rf",
    "body": [
      "use num::{One, Zero};",
      "use rf::*;",
      "pub mod rf {",
      "    pub const MOD: i64 = 998_244_353;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Default)]",
      "    pub struct RF {",
      "        rep: i64,",
      "    }",
      "    impl RF {",
      "        pub fn new(x: i64) -> RF {",
      "            RF {",
      "                rep: x.rem_euclid(MOD),",
      "            }",
      "        }",
      "        pub fn rep(self) -> i64 {",
      "            self.rep",
      "        }",
      "    }",
      "    impl RF {",
      "        pub fn inv(self) -> Self {",
      "            num::pow(self, (MOD - 2) as usize)",
      "        }",
      "    }",
      "    impl num_traits::Zero for RF {",
      "        fn zero() -> Self {",
      "            RF::new(0)",
      "        }",
      "        fn is_zero(&self) -> bool {",
      "            self.rep == 0",
      "        }",
      "    }",
      "    impl num_traits::One for RF {",
      "        fn one() -> Self {",
      "            RF::new(1)",
      "        }",
      "    }",
      "    macro_rules ! bi_ops_impl {(\\$ std_ops : ident , \\$ fn : ident , \\$ op : tt ) => {impl std :: ops ::\\$ std_ops for RF {type Output = Self ; fn \\$ fn (self , rhs : Self ) -> Self :: Output {RF :: new (self . rep \\$ op rhs . rep ) } } } ; }",
      "    bi_ops_impl ! (Add , add , + );",
      "    bi_ops_impl ! (Sub , sub , - );",
      "    bi_ops_impl ! (Mul , mul , * );",
      "    impl std::ops::Div for RF {",
      "        type Output = Self;",
      "        fn div(self, rhs: Self) -> Self::Output {",
      "            std::ops::Mul::mul(self, rhs.inv())",
      "        }",
      "    }",
      "    macro_rules ! bi_ops_assign_impl {(\\$ std_ops_assign : ident , \\$ fn_assign : ident , \\$ op : tt ) => {impl std :: ops ::\\$ std_ops_assign for RF {fn \\$ fn_assign (& mut self , rhs : Self ) {* self = * self \\$ op rhs } } } ; }",
      "    bi_ops_assign_impl ! (AddAssign , add_assign , + );",
      "    bi_ops_assign_impl ! (SubAssign , sub_assign , - );",
      "    bi_ops_assign_impl ! (MulAssign , mul_assign , * );",
      "    bi_ops_assign_impl ! (DivAssign , div_assign , / );",
      "    impl std::ops::Neg for RF {",
      "        type Output = Self;",
      "        fn neg(self) -> Self::Output {",
      "            RF::new(-self.rep)",
      "        }",
      "    }",
      "}"
    ]
  },
  "rf_fake": {
    "scope": "rust",
    "prefix": "rf_fake",
    "body": [
      "use num::{One, Zero};",
      "use rf_fake::*;",
      "pub mod rf_fake {",
      "    #[derive(Clone, Copy, Debug, PartialEq, Default)]",
      "    pub struct RF {",
      "        rep: f64,",
      "    }",
      "    impl RF {",
      "        pub fn new(x: f64) -> RF {",
      "            RF { rep: x }",
      "        }",
      "        pub fn rep(self) -> f64 {",
      "            self.rep",
      "        }",
      "    }",
      "    impl RF {",
      "        pub fn inv(self) -> Self {",
      "            RF::new(1.0 / self.rep)",
      "        }",
      "    }",
      "    impl num_traits::Zero for RF {",
      "        fn zero() -> Self {",
      "            RF::new(0.0)",
      "        }",
      "        fn is_zero(&self) -> bool {",
      "            f64::is_zero(&self.rep)",
      "        }",
      "    }",
      "    impl num_traits::One for RF {",
      "        fn one() -> Self {",
      "            RF::new(1.0)",
      "        }",
      "    }",
      "    macro_rules ! bi_ops_impl {(\\$ std_ops : ident , \\$ fn : ident , \\$ op : tt ) => {impl std :: ops ::\\$ std_ops for RF {type Output = Self ; fn \\$ fn (self , rhs : Self ) -> Self :: Output {RF :: new (self . rep \\$ op rhs . rep ) } } } ; }",
      "    bi_ops_impl ! (Add , add , + );",
      "    bi_ops_impl ! (Sub , sub , - );",
      "    bi_ops_impl ! (Mul , mul , * );",
      "    bi_ops_impl ! (Div , div , / );",
      "    macro_rules ! bi_ops_assign_impl {(\\$ std_ops_assign : ident , \\$ fn_assign : ident , \\$ op : tt ) => {impl std :: ops ::\\$ std_ops_assign for RF {fn \\$ fn_assign (& mut self , rhs : Self ) {* self = * self \\$ op rhs } } } ; }",
      "    bi_ops_assign_impl ! (AddAssign , add_assign , + );",
      "    bi_ops_assign_impl ! (SubAssign , sub_assign , - );",
      "    bi_ops_assign_impl ! (MulAssign , mul_assign , * );",
      "    bi_ops_assign_impl ! (DivAssign , div_assign , / );",
      "    impl std::ops::Neg for RF {",
      "        type Output = Self;",
      "        fn neg(self) -> Self::Output {",
      "            RF::new(-self.rep)",
      "        }",
      "    }",
      "}"
    ]
  },
  "rolling_hash": {
    "scope": "rust",
    "prefix": "rolling_hash",
    "body": [
      "use rolling_hash::*;",
      "pub mod rolling_hash {",
      "    const MOD: i128 = (1 << 61) - 1;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    struct ModIntPow261M1 {",
      "        val: i128,",
      "    }",
      "    impl ModIntPow261M1 {",
      "        #[inline]",
      "        pub fn new(val: i128) -> Self {",
      "            let val = (val + MOD) % MOD;",
      "            Self {",
      "                val: val.rem_euclid(MOD),",
      "            }",
      "        }",
      "    }",
      "    impl std::ops::Add for ModIntPow261M1 {",
      "        type Output = Self;",
      "        #[inline]",
      "        fn add(self, rhs: Self) -> Self::Output {",
      "            Self::new(self.val + rhs.val)",
      "        }",
      "    }",
      "    impl std::ops::Sub for ModIntPow261M1 {",
      "        type Output = Self;",
      "        #[inline]",
      "        fn sub(self, rhs: Self) -> Self::Output {",
      "            Self::new(self.val - rhs.val)",
      "        }",
      "    }",
      "    impl std::ops::Mul for ModIntPow261M1 {",
      "        type Output = Self;",
      "        #[inline]",
      "        fn mul(self, rhs: Self) -> Self::Output {",
      "            Self::new(self.val * rhs.val)",
      "        }",
      "    }",
      "    pub struct RollingHash {",
      "        hash_list: Vec<ModIntPow261M1>,",
      "        pow_list: Vec<ModIntPow261M1>,",
      "    }",
      "    impl RollingHash {",
      "        pub fn new(xs: &[i64], base: i64) -> Self {",
      "            let base = ModIntPow261M1::new(base as i128);",
      "            let mut hash_list = vec![ModIntPow261M1::new(0); xs.len() + 1];",
      "            let mut pow_list = vec![ModIntPow261M1::new(1); xs.len() + 1];",
      "            for i in 0..xs.len() {",
      "                hash_list[i + 1] = hash_list[i] * base + ModIntPow261M1::new(xs[i] as i128);",
      "                pow_list[i + 1] = pow_list[i] * base;",
      "            }",
      "            Self {",
      "                hash_list,",
      "                pow_list,",
      "            }",
      "        }",
      "        pub fn hash(&self, begin: usize, end: usize) -> i64 {",
      "            let x = self.hash_list[end] - self.hash_list[begin] * self.pow_list[end - begin];",
      "            x.val as i64",
      "        }",
      "    }",
      "}"
    ]
  },
  "rr": {
    "scope": "rust",
    "prefix": "rr",
    "body": [
      "use num::{One, Zero};",
      "use rr::*;",
      "pub mod rr {",
      "    pub const MOD: i64 = 998_244_353;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Default)]",
      "    pub struct RR {",
      "        rep: i64,",
      "    }",
      "    impl RR {",
      "        pub fn new(x: i64) -> RR {",
      "            RR {",
      "                rep: x.rem_euclid(MOD),",
      "            }",
      "        }",
      "        pub fn rep(self) -> i64 {",
      "            self.rep",
      "        }",
      "    }",
      "    impl num_traits::Zero for RR {",
      "        fn zero() -> Self {",
      "            RR::new(0)",
      "        }",
      "        fn is_zero(&self) -> bool {",
      "            self.rep == 0",
      "        }",
      "    }",
      "    impl num_traits::One for RR {",
      "        fn one() -> Self {",
      "            RR::new(1)",
      "        }",
      "    }",
      "    macro_rules ! bi_ops_impl {(\\$ std_ops : ident , \\$ fn : ident , \\$ op : tt ) => {impl std :: ops ::\\$ std_ops for RR {type Output = Self ; fn \\$ fn (self , rhs : Self ) -> Self :: Output {RR :: new (self . rep \\$ op rhs . rep ) } } } ; }",
      "    bi_ops_impl ! (Add , add , + );",
      "    bi_ops_impl ! (Sub , sub , - );",
      "    bi_ops_impl ! (Mul , mul , * );",
      "    macro_rules ! bi_ops_assign_impl {(\\$ std_ops_assign : ident , \\$ fn_assign : ident , \\$ op : tt ) => {impl std :: ops ::\\$ std_ops_assign for RR {fn \\$ fn_assign (& mut self , rhs : Self ) {* self = * self \\$ op rhs } } } ; }",
      "    bi_ops_assign_impl ! (AddAssign , add_assign , + );",
      "    bi_ops_assign_impl ! (SubAssign , sub_assign , - );",
      "    bi_ops_assign_impl ! (MulAssign , mul_assign , * );",
      "    impl std::ops::Neg for RR {",
      "        type Output = Self;",
      "        fn neg(self) -> Self::Output {",
      "            RR::new(-self.rep)",
      "        }",
      "    }",
      "}"
    ]
  },
  "scan_iter": {
    "scope": "rust",
    "prefix": "scan_iter",
    "body": [
      "use scan_iter::*;",
      "pub mod scan_iter {",
      "    #[derive(Clone)]",
      "    pub struct Scanl<I, B, F> {",
      "        iter: I,",
      "        state: Option<B>,",
      "        f: F,",
      "    }",
      "    impl<I, B, F> Scanl<I, B, F> {",
      "        fn new(iter: I, init: B, f: F) -> Scanl<I, B, F> {",
      "            Scanl {",
      "                iter,",
      "                state: Some(init),",
      "                f,",
      "            }",
      "        }",
      "    }",
      "    impl<I, B, F> Iterator for Scanl<I, B, F>",
      "    where",
      "        B: Copy,",
      "        I: Iterator,",
      "        F: FnMut(&mut B, I::Item) -> B,",
      "    {",
      "        type Item = B;",
      "        #[inline]",
      "        fn next(&mut self) -> Option<B> {",
      "            let retval = self.state?;",
      "            let a_opt = self.iter.next();",
      "            self.state = self",
      "                .state",
      "                .and_then(|mut s| a_opt.map(|a| (self.f)(&mut s, a)));",
      "            Some(retval)",
      "        }",
      "    }",
      "    pub trait IteratorExtScanLeft: Iterator + Sized {",
      "        fn scanl<B, F>(self, init: B, f: F) -> Scanl<Self, B, F>",
      "        where",
      "            Self: Sized,",
      "            F: FnMut(&mut B, Self::Item) -> B,",
      "        {",
      "            Scanl::new(self, init, f)",
      "        }",
      "    }",
      "    impl<T: Iterator> IteratorExtScanLeft for T {}",
      "}"
    ]
  },
  "scan_vec": {
    "scope": "rust",
    "prefix": "scan_vec",
    "body": [
      "use scan_vec::*;",
      "pub mod scan_vec {",
      "    pub fn scanl<A, B, F>(vec: &[A], init: B, mut f: F) -> Vec<B>",
      "    where",
      "        F: FnMut(&mut B, &A) -> B,",
      "        B: Copy,",
      "    {",
      "        let mut ret: Vec<B> = Vec::new();",
      "        let mut acc = init;",
      "        ret.push(acc);",
      "        for x in vec {",
      "            acc = f(&mut acc, x);",
      "            ret.push(acc);",
      "        }",
      "        ret",
      "    }",
      "    pub fn scanr<A, B, F>(vec: &[A], init: B, f: F) -> Vec<B>",
      "    where",
      "        F: FnMut(&mut B, &A) -> B,",
      "        A: Clone,",
      "        B: Copy,",
      "    {",
      "        let vec2 = vec.iter().cloned().rev().collect::<Vec<A>>();",
      "        let vec3 = scanl(&vec2, init, f);",
      "        vec3.iter().copied().rev().collect::<Vec<B>>()",
      "    }",
      "    pub fn cumsum<T>(vec: &[T]) -> Vec<T>",
      "    where",
      "        T: std::ops::Add + num::Zero + Copy,",
      "    {",
      "        scanl(vec, T::zero(), |acc, x| *acc + *x)",
      "    }",
      "}"
    ]
  },
  "static_mod_int": {
    "scope": "rust",
    "prefix": "static_mod_int",
    "body": [
      "use static_mod_int::*;",
      "pub mod static_mod_int {",
      "    use ac_library::{ButterflyCache, Modulus, StaticModInt};",
      "    use std::{cell::RefCell, thread::LocalKey};",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod2 {}",
      "    impl Modulus for Mod2 {",
      "        const VALUE: u32 = 2;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "        fn butterfly_cache() -> &'static LocalKey<RefCell<Option<ButterflyCache<Self>>>> {",
      "            thread_local! {static BUTTERFLY_CACHE : RefCell < Option < ButterflyCache < Mod2 >>> = RefCell :: default () ; }",
      "            &BUTTERFLY_CACHE",
      "        }",
      "    }",
      "    pub type ModInt2 = StaticModInt<Mod2>;",
      "}"
    ]
  },
  "topo_sort": {
    "scope": "rust",
    "prefix": "topo_sort",
    "body": [
      "pub fn topo_sort(adj: &Vec<Vec<Edge>>) -> Vec<usize> {",
      "    let n_vertex = adj.len();",
      "    let mut in_deg = vec![0; n_vertex];",
      "    for v in 0..n_vertex {",
      "        for &e in &adj[v] {",
      "            in_deg[e.to] += 1;",
      "        }",
      "    }",
      "    let mut open: Queue<usize> = Queue::new();",
      "    for v in 0..n_vertex {",
      "        if in_deg[v] == 0 {",
      "            open.push(v);",
      "        }",
      "    }",
      "    let mut ans = vec![];",
      "    while let Some(current) = open.pop() {",
      "        ans.push(current);",
      "        for &e in &adj[current] {",
      "            in_deg[e.to] -= 1;",
      "            if in_deg[e.to] == 0 {",
      "                open.push(e.to);",
      "            }",
      "        }",
      "    }",
      "    ans",
      "}"
    ]
  },
  "union_find": {
    "scope": "rust",
    "prefix": "union_find",
    "body": [
      "use union_find::*;",
      "pub mod union_find {",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    struct Root {",
      "        count: i32,",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    enum Node {",
      "        Root { root: Root },",
      "        NonRoot { parent_index: usize },",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    struct RootAndIndex {",
      "        root: Root,",
      "        index: usize,",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    pub struct UnionFind {",
      "        nodes: Vec<Node>,",
      "    }",
      "    impl UnionFind {",
      "        pub fn new(n: usize) -> UnionFind {",
      "            UnionFind {",
      "                nodes: vec![",
      "                    Node::Root {",
      "                        root: Root { count: 1 }",
      "                    };",
      "                    n",
      "                ],",
      "            }",
      "        }",
      "        fn root_node(&mut self, index: usize) -> RootAndIndex {",
      "            match self.nodes[index] {",
      "                Node::Root { root } => RootAndIndex { root, index },",
      "                Node::NonRoot { parent_index } => {",
      "                    let root_and_index = self.root_node(parent_index);",
      "                    self.nodes[index] = Node::NonRoot {",
      "                        parent_index: root_and_index.index,",
      "                    };",
      "                    root_and_index",
      "                }",
      "            }",
      "        }",
      "        pub fn root(&mut self, index: usize) -> usize {",
      "            self.root_node(index).index",
      "        }",
      "        pub fn same_count(&mut self, index: usize) -> i32 {",
      "            self.root_node(index).root.count",
      "        }",
      "        pub fn same(&mut self, x: usize, y: usize) -> bool {",
      "            self.root(x) == self.root(y)",
      "        }",
      "        pub fn num_groups(&self) -> usize {",
      "            self.nodes",
      "                .iter()",
      "                .filter(|&node| matches!(node, Node::Root { .. }))",
      "                .count()",
      "        }",
      "        pub fn unite(&mut self, x: usize, y: usize) {",
      "            if self.same(x, y) {",
      "                return;",
      "            }",
      "            let x_root_node = self.root_node(x);",
      "            let y_root_node = self.root_node(y);",
      "            let x_count = x_root_node.root.count;",
      "            let y_count = y_root_node.root.count;",
      "            let x_root_index = x_root_node.index;",
      "            let y_root_index = y_root_node.index;",
      "            if x_count < y_count {",
      "                self.nodes[x_root_index] = Node::NonRoot {",
      "                    parent_index: y_root_index,",
      "                };",
      "                self.nodes[y_root_index] = Node::Root {",
      "                    root: Root {",
      "                        count: x_count + y_count,",
      "                    },",
      "                }",
      "            } else {",
      "                self.nodes[y_root_index] = Node::NonRoot {",
      "                    parent_index: x_root_index,",
      "                };",
      "                self.nodes[x_root_index] = Node::Root {",
      "                    root: Root {",
      "                        count: x_count + y_count,",
      "                    },",
      "                }",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "upper_bound": {
    "scope": "rust",
    "prefix": "upper_bound",
    "body": [
      "/// 二分探索をする",
      "/// ```text",
      "/// ng ng ng ok ok ok",
      "///          ↑ここの引数の値を返す",
      "/// ```",
      "/// 計算量: O(log(|ok - ng|))",
      "/// ## Arguments",
      "/// * ok != ng",
      "/// * |ok - ng| <= 2^63 - 1, |ok + ng| <= 2^63 - 1",
      "/// * p の定義域について",
      "///     * ng < ok の場合、p は区間 ng..ok で定義されている。",
      "///     * ok < ng の場合、p は区間 ok..ng で定義されている。",
      "/// * p の単調性について",
      "///     * ng < ok の場合、p は単調増加",
      "///     * ok < ng の場合、p は単調減少",
      "/// ## Return",
      "/// * ng < ok の場合: I = { i in ng..ok | p(i) == true } としたとき",
      "///     * I が空でなければ、min I を返す。",
      "///     * I が空ならば、ok を返す。",
      "/// * ok < ng の場合: I = { i in ok..ng | p(i) == true } としたとき",
      "///     * I が空でなければ、max I を返す。",
      "///     * I が空ならば、ok を返す。",
      "pub fn bin_search<F>(mut ok: i64, mut ng: i64, p: F) -> i64",
      "where",
      "    F: Fn(i64) -> bool,",
      "{",
      "    assert!(ok != ng);",
      "    assert!(ok.checked_sub(ng).is_some());",
      "    assert!(ok.checked_add(ng).is_some());",
      "    while num::abs(ok - ng) > 1 {",
      "        let mid = (ok + ng) / 2;",
      "        assert!(mid != ok);",
      "        assert!(mid != ng);",
      "        if p(mid) {",
      "            ok = mid;",
      "        } else {",
      "            ng = mid;",
      "        }",
      "    }",
      "    ok",
      "}",
      "/// 指定された要素より大きい値が現れる最初の位置を返す。",
      "/// 計算量: O(log(|xs|))",
      "/// ## Arguments",
      "/// * xs: 単調増加",
      "///     * 単調増加でなくても、 `|i| xs[i] > key` が単調ならOK",
      "/// ## Return",
      "/// `I = {i in 0..xs.len() | xs[i] > key}` としたとき、`min I` を返す。",
      "/// ただし、`I` が空の場合は `xs.len()` を返す",
      "/// 戻り値は、区間 `0..=xs.len()` の間で返る。",
      "pub fn upper_bound<T: PartialOrd>(xs: &[T], key: T) -> usize {",
      "    let pred = |i: i64| xs[i as usize] > key;",
      "    bin_search(xs.len() as i64, -1_i64, pred) as usize",
      "}"
    ]
  },
  "upper_bound_dec": {
    "scope": "rust",
    "prefix": "upper_bound_dec",
    "body": [
      "/// 二分探索をする",
      "/// ```text",
      "/// ng ng ng ok ok ok",
      "///          ↑ここの引数の値を返す",
      "/// ```",
      "/// 計算量: O(log(|ok - ng|))",
      "/// ## Arguments",
      "/// * ok != ng",
      "/// * |ok - ng| <= 2^63 - 1, |ok + ng| <= 2^63 - 1",
      "/// * p の定義域について",
      "///     * ng < ok の場合、p は区間 ng..ok で定義されている。",
      "///     * ok < ng の場合、p は区間 ok..ng で定義されている。",
      "/// * p の単調性について",
      "///     * ng < ok の場合、p は単調増加",
      "///     * ok < ng の場合、p は単調減少",
      "/// ## Return",
      "/// * ng < ok の場合: I = { i in ng..ok | p(i) == true } としたとき",
      "///     * I が空でなければ、min I を返す。",
      "///     * I が空ならば、ok を返す。",
      "/// * ok < ng の場合: I = { i in ok..ng | p(i) == true } としたとき",
      "///     * I が空でなければ、max I を返す。",
      "///     * I が空ならば、ok を返す。",
      "pub fn bin_search<F>(mut ok: i64, mut ng: i64, p: F) -> i64",
      "where",
      "    F: Fn(i64) -> bool,",
      "{",
      "    assert!(ok != ng);",
      "    assert!(ok.checked_sub(ng).is_some());",
      "    assert!(ok.checked_add(ng).is_some());",
      "    while num::abs(ok - ng) > 1 {",
      "        let mid = (ok + ng) / 2;",
      "        assert!(mid != ok);",
      "        assert!(mid != ng);",
      "        if p(mid) {",
      "            ok = mid;",
      "        } else {",
      "            ng = mid;",
      "        }",
      "    }",
      "    ok",
      "}",
      "/// 指定された要素より小さい値が現れる最初の位置を返す。",
      "/// 計算量: O(log(|xs|))",
      "/// ## Arguments",
      "/// * xs: 単勝減少",
      "///     * 単調減少でなくても、 `|i| xs[i] < key` が単調ならOK",
      "/// ## Return",
      "/// `I = {i in 0..xs.len() | xs[i] < key}` としたとき、`min I` を返す。",
      "/// ただし、`I` が空の場合は `xs.len()` を返す",
      "/// 戻り値は、区間 `0..=xs.len()` の間で返る。",
      "pub fn upper_bound_dec<T: PartialOrd>(xs: &[T], key: T) -> usize {",
      "    let pred = |i: i64| xs[i as usize] < key;",
      "    bin_search(xs.len() as i64, -1_i64, pred) as usize",
      "}"
    ]
  },
  "vec_vec_at": {
    "scope": "rust",
    "prefix": "vec_vec_at",
    "body": [
      "use vec_vec_at::*;",
      "pub mod vec_vec_at {",
      "    use super::pos::*;",
      "    use easy_ext::ext;",
      "    #[ext]",
      "    impl<T> Vec<Vec<T>> {",
      "        pub fn at(&self, pos: Pos<i64>) -> &T {",
      "            &self[pos.y as usize][pos.x as usize]",
      "        }",
      "        pub fn at_mut(&mut self, pos: Pos<i64>) -> &mut T {",
      "            &mut self[pos.y as usize][pos.x as usize]",
      "        }",
      "    }",
      "}"
    ]
  }
}
