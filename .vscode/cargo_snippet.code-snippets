{
  "Grid": {
    "scope": "rust",
    "prefix": "Grid",
    "body": [
      "use std::ops::{Index, IndexMut};",
      "#[derive(Clone, Debug)]",
      "pub struct Grid {",
      "    pub grid: Vec<Vec<char>>,",
      "    pub h: usize,",
      "    pub w: usize,",
      "}",
      "impl Index<Pos> for Grid {",
      "    type Output = char;",
      "    fn index(&self, index: Pos) -> &Self::Output {",
      "        if self.is_within(index) {",
      "            self.grid.index(index)",
      "        } else {",
      "            &'#'",
      "        }",
      "    }",
      "}",
      "impl IndexMut<Pos> for Grid {",
      "    fn index_mut(&mut self, index: Pos) -> &mut Self::Output {",
      "        self.grid.index_mut(index)",
      "    }",
      "}",
      "impl Grid {",
      "    pub fn new(grid: Vec<Vec<char>>) -> Grid {",
      "        let h = grid.len();",
      "        let w = grid[0].len();",
      "        Grid { grid, h, w }",
      "    }",
      "    pub fn is_within(&self, pos: Pos) -> bool {",
      "        let h = self.h as i64;",
      "        let w = self.w as i64;",
      "        0 <= pos.y && pos.y < h && 0 <= pos.x && pos.x < w",
      "    }",
      "    pub fn can_move(&self, pos: Pos) -> bool {",
      "        ['.'].contains(&self[pos])",
      "    }",
      "    pub fn all_pos_iter(&self) -> impl Iterator<Item = Pos> {",
      "        iproduct!(0..self.h, 0..self.w).map(|(y, x)| Pos::new(x as i64, y as i64))",
      "    }",
      "    pub fn find_pos_of(&self, ch: char) -> Option<Pos> {",
      "        self.all_pos_iter().find(|pos| self[*pos] == ch)",
      "    }",
      "    pub fn encode(&self, pos: Pos) -> usize {",
      "        (pos.y * self.w as i64 + pos.x) as usize",
      "    }",
      "    pub fn decode(&self, i: usize) -> Pos {",
      "        let y = (i / self.w) as i64;",
      "        let x = (i % self.w) as i64;",
      "        Pos::new(x, y)",
      "    }",
      "    pub fn debug(&self) {",
      "        for row in &self.grid {",
      "            eprintln!(\"{}\", row.iter().collect::<String>());",
      "        }",
      "        eprintln!();",
      "    }",
      "    /// pos の部分は背景を灰色にして出力する",
      "    pub fn debug_with_pos(&self, pos: Pos) {",
      "        const GRAY: &str = \"\\x1b[48;2;127;127;127;37m\";",
      "        const RESET: &str = \"\\x1b[0m\";",
      "        for y in 0..self.h {",
      "            let row = (0..self.w)",
      "                .map(|x| {",
      "                    if pos == Pos::new(x as i64, y as i64) {",
      "                        format!(\"{}{}{}\", GRAY, self.grid[y][x], RESET)",
      "                    } else {",
      "                        self.grid[y][x].to_string()",
      "                    }",
      "                })",
      "                .join(\"\");",
      "            eprintln!(\"{}\", row);",
      "        }",
      "        eprintln!();",
      "    }",
      "}"
    ]
  },
  "GridUnionFind": {
    "scope": "rust",
    "prefix": "GridUnionFind",
    "body": [
      "#[derive(Clone, Debug)]",
      "pub struct GridUnionFind {",
      "    pub uf: UnionFind,",
      "    pub h: usize,",
      "    pub w: usize,",
      "}",
      "impl GridUnionFind {",
      "    pub fn new(h: usize, w: usize) -> GridUnionFind {",
      "        GridUnionFind {",
      "            uf: UnionFind::new(h * w),",
      "            h,",
      "            w,",
      "        }",
      "    }",
      "    pub fn encode(&self, pos: Pos) -> usize {",
      "        (pos.y * self.w as i64 + pos.x) as usize",
      "    }",
      "    pub fn decode(&self, i: usize) -> Pos {",
      "        let y = (i / self.w) as i64;",
      "        let x = (i % self.w) as i64;",
      "        Pos::new(x, y)",
      "    }",
      "    pub fn same_count(&mut self, pos: Pos) -> usize {",
      "        self.uf.same_count(self.encode(pos))",
      "    }",
      "    pub fn same(&mut self, pos1: Pos, pos2: Pos) -> bool {",
      "        self.uf.same(self.encode(pos1), self.encode(pos2))",
      "    }",
      "    pub fn num_groups(&self) -> usize {",
      "        self.uf.num_groups()",
      "    }",
      "    pub fn unite(&mut self, pos1: Pos, pos2: Pos) {",
      "        self.uf.unite(self.encode(pos1), self.encode(pos2));",
      "    }",
      "    pub fn groups(&mut self) -> Vec<Vec<Pos>> {",
      "        self.uf",
      "            .groups()",
      "            .into_iter()",
      "            .map(|group| group.iter().copied().map(|i| self.decode(i)).collect_vec())",
      "            .collect_vec()",
      "    }",
      "}"
    ]
  },
  "ab_group": {
    "scope": "rust",
    "prefix": "ab_group",
    "body": [
      "use ab_group::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod ab_group {",
      "    use std::{",
      "        convert::Infallible,",
      "        iter::Sum,",
      "        marker::PhantomData,",
      "        ops::{Add, Neg, Sub},",
      "    };",
      "    /// 可換群 (Abelian Group)",
      "    pub trait AbGroup {",
      "        type S: Clone;",
      "        fn zero() -> Self::S;",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S;",
      "        fn neg(a: &Self::S) -> Self::S;",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            Self::add(a, &Self::neg(b))",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct AdditiveAbGroup<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T: Sum + Add<Output = T> + Sub<Output = T> + Neg<Output = T> + Copy> AbGroup",
      "        for AdditiveAbGroup<T>",
      "    {",
      "        type S = T;",
      "        fn zero() -> Self::S {",
      "            std::iter::empty().sum()",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a + *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            -(*a)",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a - *b",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct XorAbGroup(Infallible);",
      "    impl AbGroup for XorAbGroup {",
      "        type S = u64;",
      "        fn zero() -> Self::S {",
      "            0",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            *a",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "    }",
      "}"
    ]
  },
  "abstract_segtree_beats": {
    "scope": "rust",
    "prefix": "abstract_segtree_beats",
    "body": [
      "use abstract_segtree_beats::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod abstract_segtree_beats {",
      "    fn ceil_pow2(n: u32) -> u32 {",
      "        32 - n.saturating_sub(1).leading_zeros()",
      "    }",
      "    pub trait MonoidBeats {",
      "        type S: Clone;",
      "        fn identity() -> Self::S;",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S;",
      "        fn fails(a: &Self::S) -> bool;",
      "    }",
      "    pub trait MapMonoidBeats {",
      "        type M: MonoidBeats;",
      "        type F: Clone;",
      "        fn identity_element() -> <Self::M as MonoidBeats>::S {",
      "            Self::M::identity()",
      "        }",
      "        fn binary_operation(",
      "            a: &<Self::M as MonoidBeats>::S,",
      "            b: &<Self::M as MonoidBeats>::S,",
      "        ) -> <Self::M as MonoidBeats>::S {",
      "            Self::M::binary_operation(a, b)",
      "        }",
      "        fn fails(a: &<Self::M as MonoidBeats>::S) -> bool {",
      "            Self::M::fails(a)",
      "        }",
      "        fn identity_map() -> Self::F;",
      "        fn mapping(f: &Self::F, x: &<Self::M as MonoidBeats>::S) -> <Self::M as MonoidBeats>::S;",
      "        fn composition(f: &Self::F, g: &Self::F) -> Self::F;",
      "    }",
      "    impl<F: MapMonoidBeats> Default for SegtreeBeats<F> {",
      "        fn default() -> Self {",
      "            Self::new(0)",
      "        }",
      "    }",
      "    impl<F: MapMonoidBeats> SegtreeBeats<F> {",
      "        pub fn new(n: usize) -> Self {",
      "            vec![F::identity_element(); n].into()",
      "        }",
      "    }",
      "    impl<F: MapMonoidBeats> From<Vec<<F::M as MonoidBeats>::S>> for SegtreeBeats<F> {",
      "        fn from(v: Vec<<F::M as MonoidBeats>::S>) -> Self {",
      "            let n = v.len();",
      "            let log = ceil_pow2(n as u32) as usize;",
      "            let size = 1 << log;",
      "            let mut d = vec![F::identity_element(); 2 * size];",
      "            let lz = vec![F::identity_map(); size];",
      "            d[size..(size + n)].clone_from_slice(&v);",
      "            let mut ret = SegtreeBeats {",
      "                n,",
      "                size,",
      "                log,",
      "                d,",
      "                lz,",
      "            };",
      "            for i in (1..size).rev() {",
      "                ret.update(i);",
      "            }",
      "            ret",
      "        }",
      "    }",
      "    impl<F: MapMonoidBeats> SegtreeBeats<F> {",
      "        pub fn set(&mut self, mut p: usize, x: <F::M as MonoidBeats>::S) {",
      "            assert!(p < self.n);",
      "            p += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(p >> i);",
      "            }",
      "            self.d[p] = x;",
      "            for i in 1..=self.log {",
      "                self.update(p >> i);",
      "            }",
      "        }",
      "        pub fn get(&mut self, mut p: usize) -> <F::M as MonoidBeats>::S {",
      "            assert!(p < self.n);",
      "            p += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(p >> i);",
      "            }",
      "            self.d[p].clone()",
      "        }",
      "        pub fn prod<R>(&mut self, range: R) -> <F::M as MonoidBeats>::S",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            if range.start_bound() == Bound::Unbounded && range.end_bound() == Bound::Unbounded {",
      "                return self.all_prod();",
      "            }",
      "            let mut r = match range.end_bound() {",
      "                Bound::Included(r) => r + 1,",
      "                Bound::Excluded(r) => *r,",
      "                Bound::Unbounded => self.n,",
      "            };",
      "            let mut l = match range.start_bound() {",
      "                Bound::Included(l) => *l,",
      "                Bound::Excluded(l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            assert!(l <= r && r <= self.n);",
      "            if l == r {",
      "                return F::identity_element();",
      "            }",
      "            l += self.size;",
      "            r += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                if ((l >> i) << i) != l {",
      "                    self.push(l >> i);",
      "                }",
      "                if ((r >> i) << i) != r {",
      "                    self.push(r >> i);",
      "                }",
      "            }",
      "            let mut sml = F::identity_element();",
      "            let mut smr = F::identity_element();",
      "            while l < r {",
      "                if l & 1 != 0 {",
      "                    sml = F::binary_operation(&sml, &self.d[l]);",
      "                    l += 1;",
      "                }",
      "                if r & 1 != 0 {",
      "                    r -= 1;",
      "                    smr = F::binary_operation(&self.d[r], &smr);",
      "                }",
      "                l >>= 1;",
      "                r >>= 1;",
      "            }",
      "            F::binary_operation(&sml, &smr)",
      "        }",
      "        pub fn all_prod(&self) -> <F::M as MonoidBeats>::S {",
      "            self.d[1].clone()",
      "        }",
      "        pub fn apply(&mut self, mut p: usize, f: F::F) {",
      "            assert!(p < self.n);",
      "            p += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(p >> i);",
      "            }",
      "            self.d[p] = F::mapping(&f, &self.d[p]);",
      "            for i in 1..=self.log {",
      "                self.update(p >> i);",
      "            }",
      "        }",
      "        pub fn apply_range<R>(&mut self, range: R, f: F::F)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            let mut r = match range.end_bound() {",
      "                Bound::Included(r) => r + 1,",
      "                Bound::Excluded(r) => *r,",
      "                Bound::Unbounded => self.n,",
      "            };",
      "            let mut l = match range.start_bound() {",
      "                Bound::Included(l) => *l,",
      "                Bound::Excluded(l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            assert!(l <= r && r <= self.n);",
      "            if l == r {",
      "                return;",
      "            }",
      "            l += self.size;",
      "            r += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                if ((l >> i) << i) != l {",
      "                    self.push(l >> i);",
      "                }",
      "                if ((r >> i) << i) != r {",
      "                    self.push((r - 1) >> i);",
      "                }",
      "            }",
      "            {",
      "                let l2 = l;",
      "                let r2 = r;",
      "                while l < r {",
      "                    if l & 1 != 0 {",
      "                        self.all_apply(l, f.clone());",
      "                        l += 1;",
      "                    }",
      "                    if r & 1 != 0 {",
      "                        r -= 1;",
      "                        self.all_apply(r, f.clone());",
      "                    }",
      "                    l >>= 1;",
      "                    r >>= 1;",
      "                }",
      "                l = l2;",
      "                r = r2;",
      "            }",
      "            for i in 1..=self.log {",
      "                if ((l >> i) << i) != l {",
      "                    self.update(l >> i);",
      "                }",
      "                if ((r >> i) << i) != r {",
      "                    self.update((r - 1) >> i);",
      "                }",
      "            }",
      "        }",
      "        pub fn max_right<G>(&mut self, mut l: usize, g: G) -> usize",
      "        where",
      "            G: Fn(<F::M as MonoidBeats>::S) -> bool,",
      "        {",
      "            assert!(l <= self.n);",
      "            assert!(g(F::identity_element()));",
      "            if l == self.n {",
      "                return self.n;",
      "            }",
      "            l += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(l >> i);",
      "            }",
      "            let mut sm = F::identity_element();",
      "            while {",
      "                while l % 2 == 0 {",
      "                    l >>= 1;",
      "                }",
      "                if !g(F::binary_operation(&sm, &self.d[l])) {",
      "                    while l < self.size {",
      "                        self.push(l);",
      "                        l *= 2;",
      "                        let res = F::binary_operation(&sm, &self.d[l]);",
      "                        if g(res.clone()) {",
      "                            sm = res;",
      "                            l += 1;",
      "                        }",
      "                    }",
      "                    return l - self.size;",
      "                }",
      "                sm = F::binary_operation(&sm, &self.d[l]);",
      "                l += 1;",
      "                {",
      "                    let l = l as isize;",
      "                    (l & -l) != l",
      "                }",
      "            } {}",
      "            self.n",
      "        }",
      "        pub fn min_left<G>(&mut self, mut r: usize, g: G) -> usize",
      "        where",
      "            G: Fn(<F::M as MonoidBeats>::S) -> bool,",
      "        {",
      "            assert!(r <= self.n);",
      "            assert!(g(F::identity_element()));",
      "            if r == 0 {",
      "                return 0;",
      "            }",
      "            r += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push((r - 1) >> i);",
      "            }",
      "            let mut sm = F::identity_element();",
      "            while {",
      "                r -= 1;",
      "                while r > 1 && r % 2 != 0 {",
      "                    r >>= 1;",
      "                }",
      "                if !g(F::binary_operation(&self.d[r], &sm)) {",
      "                    while r < self.size {",
      "                        self.push(r);",
      "                        r = 2 * r + 1;",
      "                        let res = F::binary_operation(&self.d[r], &sm);",
      "                        if g(res.clone()) {",
      "                            sm = res;",
      "                            r -= 1;",
      "                        }",
      "                    }",
      "                    return r + 1 - self.size;",
      "                }",
      "                sm = F::binary_operation(&self.d[r], &sm);",
      "                {",
      "                    let r = r as isize;",
      "                    (r & -r) != r",
      "                }",
      "            } {}",
      "            0",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<<F::M as MonoidBeats>::S> {",
      "            (0..self.n).map(|i| self.get(i)).collect()",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct SegtreeBeats<F>",
      "    where",
      "        F: MapMonoidBeats,",
      "    {",
      "        n: usize,",
      "        size: usize,",
      "        log: usize,",
      "        d: Vec<<F::M as MonoidBeats>::S>,",
      "        lz: Vec<F::F>,",
      "    }",
      "    impl<F> SegtreeBeats<F>",
      "    where",
      "        F: MapMonoidBeats,",
      "    {",
      "        fn update(&mut self, k: usize) {",
      "            self.d[k] = F::binary_operation(&self.d[2 * k], &self.d[2 * k + 1]);",
      "        }",
      "        fn all_apply(&mut self, k: usize, f: F::F) {",
      "            self.d[k] = F::mapping(&f, &self.d[k]);",
      "            if k < self.size {",
      "                self.lz[k] = F::composition(&f, &self.lz[k]);",
      "                if F::fails(&self.d[k]) {",
      "                    self.push(k);",
      "                    self.update(k)",
      "                }",
      "            }",
      "        }",
      "        fn push(&mut self, k: usize) {",
      "            self.all_apply(2 * k, self.lz[k].clone());",
      "            self.all_apply(2 * k + 1, self.lz[k].clone());",
      "            self.lz[k] = F::identity_map();",
      "        }",
      "    }",
      "    use std::{",
      "        fmt::{Debug, Error, Formatter, Write},",
      "        ops::{Bound, RangeBounds},",
      "    };",
      "    impl<F> Debug for SegtreeBeats<F>",
      "    where",
      "        F: MapMonoidBeats,",
      "        F::F: Debug,",
      "        <F::M as MonoidBeats>::S: Debug,",
      "    {",
      "        fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {",
      "            for i in 0..self.log {",
      "                for j in 0..1 << i {",
      "                    f.write_fmt(format_args!(",
      "                        \"{:?}[{:?}]\\t\",",
      "                        self.d[(1 << i) + j],",
      "                        self.lz[(1 << i) + j]",
      "                    ))?;",
      "                }",
      "                f.write_char('\\n')?;",
      "            }",
      "            for i in 0..self.size {",
      "                f.write_fmt(format_args!(\"{:?}\\t\", self.d[self.size + i]))?;",
      "            }",
      "            Ok(())",
      "        }",
      "    }",
      "}"
    ]
  },
  "acl_lcp_array": {
    "scope": "rust",
    "prefix": "acl_lcp_array",
    "body": [
      "use acl_lcp_array::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod acl_lcp_array {",
      "    use ac_library::{lcp_array_arbitrary, suffix_array_arbitrary, Min, Segtree};",
      "    use std::cmp::Ordering;",
      "    /// 文字列内の部分文字列の LCP および辞書順比較を効率的に処理する。",
      "    pub struct SubstringLcpQuery {",
      "        rank: Vec<usize>,",
      "        lcp_rmq: Segtree<Min<usize>>,",
      "        n: usize,",
      "    }",
      "    impl SubstringLcpQuery {",
      "        /// 部分文字列の LCP 計算や辞書順比較を行うためのデータ構造を構築する。",
      "        /// # 計算量",
      "        /// O(N log N)",
      "        pub fn new<T: Ord + Clone>(s: &[T]) -> Self {",
      "            let n = s.len();",
      "            assert!(n >= 1, \"文字列の長さは 1 以上である必要があります。\");",
      "            let sa = suffix_array_arbitrary(s);",
      "            let lcp = lcp_array_arbitrary(s, &sa);",
      "            let mut rank = vec![0; n];",
      "            for (i, &x) in sa.iter().enumerate() {",
      "                rank[x] = i;",
      "            }",
      "            let lcp_rmq = Segtree::<Min<usize>>::from(lcp);",
      "            Self { rank, lcp_rmq, n }",
      "        }",
      "        /// s[i..] と s[j..] の LCP を返す",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn lcp_suffix(&self, i: usize, j: usize) -> usize {",
      "            assert!(i <= self.n && j <= self.n);",
      "            if i == self.n || j == self.n {",
      "                return 0;",
      "            }",
      "            if i == j {",
      "                return self.n - i;",
      "            }",
      "            let r1 = self.rank[i];",
      "            let r2 = self.rank[j];",
      "            let (min_r, max_r) = if r1 < r2 { (r1, r2) } else { (r2, r1) };",
      "            self.lcp_rmq.prod(min_r..max_r)",
      "        }",
      "        /// s[begin1..end1] と s[begin2..end2] の LCP を返す",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn lcp_substring(",
      "            &self,",
      "            begin1: usize,",
      "            end1: usize,",
      "            begin2: usize,",
      "            end2: usize,",
      "        ) -> usize {",
      "            let l = self.lcp_suffix(begin1, begin2);",
      "            l.min(end1 - begin1).min(end2 - begin2)",
      "        }",
      "        /// s[begin1..end1] と s[begin2..end2] の辞書順比較を行う",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn compare_substring(",
      "            &self,",
      "            begin1: usize,",
      "            end1: usize,",
      "            begin2: usize,",
      "            end2: usize,",
      "        ) -> Ordering {",
      "            let len1 = end1 - begin1;",
      "            let len2 = end2 - begin2;",
      "            let l = self.lcp_substring(begin1, end1, begin2, end2);",
      "            if l == len1 && l == len2 {",
      "                return Ordering::Equal;",
      "            }",
      "            if l == len1 {",
      "                return Ordering::Less;",
      "            }",
      "            if l == len2 {",
      "                return Ordering::Greater;",
      "            }",
      "            self.rank[begin1 + l].cmp(&self.rank[begin2 + l])",
      "        }",
      "    }",
      "}"
    ]
  },
  "acl_scc": {
    "scope": "rust",
    "prefix": "acl_scc",
    "body": [
      "use acl_scc::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod acl_scc {",
      "    /// 強連結成分分解 (SCC) を行い、縮約グラフ (DAG) を構築するための構造体",
      "    #[derive(Clone, Debug)]",
      "    pub struct SccGraphWrapper {",
      "        nv: usize,",
      "        edges: Vec<(usize, usize)>,",
      "    }",
      "    impl SccGraphWrapper {",
      "        /// 頂点数 `nv` でグラフを作成する",
      "        /// # Arguments",
      "        /// * `nv` - 頂点数",
      "        pub fn new(nv: usize) -> Self {",
      "            Self { nv, edges: vec![] }",
      "        }",
      "        /// 辺 `from -> to` を追加する",
      "        /// # Arguments",
      "        /// * `from` - 始点",
      "        /// * `to` - 終点",
      "        pub fn add_edge(&mut self, from: usize, to: usize) {",
      "            self.edges.push((from, to));",
      "        }",
      "        /// SCC を実行し、結果を保持する `CondensationGraph` を返す",
      "        /// # Returns",
      "        /// SCC の結果を含む `CondensationGraph`",
      "        /// # 計算量",
      "        /// O(V + E)",
      "        pub fn scc(self) -> CondensationGraph {",
      "            let mut scc_graph = ac_library::SccGraph::new(self.nv);",
      "            for &(u, v) in &self.edges {",
      "                scc_graph.add_edge(u, v);",
      "            }",
      "            let groups = scc_graph.scc();",
      "            CondensationGraph {",
      "                groups,",
      "                original_edges: self.edges,",
      "                original_nv: self.nv,",
      "            }",
      "        }",
      "    }",
      "    /// SCC の結果を保持し、必要に応じて縮約グラフなどを提供する構造体",
      "    #[derive(Debug, Clone)]",
      "    pub struct CondensationGraph {",
      "        /// 強連結成分のリスト (トポロジカル順)",
      "        groups: Vec<Vec<usize>>,",
      "        original_edges: Vec<(usize, usize)>,",
      "        original_nv: usize,",
      "    }",
      "    impl CondensationGraph {",
      "        /// 強連結成分のリストを返す (トポロジカル順)",
      "        pub fn groups(&self) -> &[Vec<usize>] {",
      "            &self.groups",
      "        }",
      "        /// 強連結成分の個数 (縮約グラフの頂点数) を返す",
      "        pub fn group_count(&self) -> usize {",
      "            self.groups.len()",
      "        }",
      "        /// 各頂点が属するグループ番号 (0-indexed) への対応表を返す",
      "        /// # Returns",
      "        /// 戻り値を `v_to_g` としたとき、`v_to_g[v]` は頂点 `v` が属するグループのインデックス",
      "        /// # 計算量",
      "        /// O(V)",
      "        pub fn vertex_to_group(&self) -> Vec<usize> {",
      "            let mut v_to_g = vec![0; self.original_nv];",
      "            for (i, group) in self.groups.iter().enumerate() {",
      "                for &v in group {",
      "                    v_to_g[v] = i;",
      "                }",
      "            }",
      "            v_to_g",
      "        }",
      "        /// 縮約グラフの辺のリストを返す (重複辺と自己ループは除去される)",
      "        /// # Returns",
      "        /// 縮約後の頂点 (グループID) 間の辺のリスト",
      "        /// # 計算量",
      "        /// O(V + E log E)",
      "        pub fn condensation_edges(&self) -> Vec<(usize, usize)> {",
      "            let v_to_g = self.vertex_to_group();",
      "            let mut edges = vec![];",
      "            for &(u, v) in &self.original_edges {",
      "                let u_group = v_to_g[u];",
      "                let v_group = v_to_g[v];",
      "                if u_group != v_group {",
      "                    edges.push((u_group, v_group));",
      "                }",
      "            }",
      "            edges.sort_unstable();",
      "            edges.dedup();",
      "            edges",
      "        }",
      "        /// 縮約グラフの隣接リストを返す (重複辺は除去される)",
      "        /// # Returns",
      "        /// 縮約後の頂点 (グループID) をインデックスとする隣接リスト",
      "        /// # 計算量",
      "        /// O(V + E log E)",
      "        pub fn condensation_adj(&self) -> Vec<Vec<usize>> {",
      "            let mut adj = vec![vec![]; self.group_count()];",
      "            for (u_g, v_group) in self.condensation_edges() {",
      "                adj[u_g].push(v_group);",
      "            }",
      "            adj",
      "        }",
      "    }",
      "}"
    ]
  },
  "acl_scc_ix": {
    "scope": "rust",
    "prefix": "acl_scc_ix",
    "body": [
      "use acl_scc_ix::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod acl_scc_ix {",
      "    use super::{Bounds, Ix, IxVec};",
      "    /// 強連結成分分解 (SCC) を行い、縮約グラフ (DAG) を構築するための構造体 (Ix版)",
      "    #[derive(Clone, Debug)]",
      "    pub struct SccGraphIxWrapper<I: Ix> {",
      "        bounds: Bounds<I>,",
      "        edges: Vec<(usize, usize)>,",
      "    }",
      "    impl<I: Ix> SccGraphIxWrapper<I> {",
      "        /// 指定された範囲の頂点を持つグラフを作成する",
      "        /// # Arguments",
      "        /// * `bounds` - 頂点のインデックス範囲",
      "        pub fn new(bounds: Bounds<I>) -> Self {",
      "            Self {",
      "                bounds,",
      "                edges: vec![],",
      "            }",
      "        }",
      "        /// 辺 `from -> to` を追加する",
      "        /// # Arguments",
      "        /// * `from` - 始点",
      "        /// * `to` - 終点",
      "        pub fn add_edge(&mut self, from: I, to: I) {",
      "            let from_idx = self.bounds.to_index(from);",
      "            let to_idx = self.bounds.to_index(to);",
      "            self.edges.push((from_idx, to_idx));",
      "        }",
      "        /// SCC を実行し、結果を保持する `CondensationGraphIx` を返す",
      "        /// # Returns",
      "        /// SCC の結果を含む `CondensationGraphIx`",
      "        /// # 計算量",
      "        /// O(V + E)",
      "        pub fn scc(self) -> CondensationGraphIx<I> {",
      "            let n = self.bounds.range_size();",
      "            let mut scc_graph = ac_library::SccGraph::new(n);",
      "            for &(u, v) in &self.edges {",
      "                scc_graph.add_edge(u, v);",
      "            }",
      "            let groups_indices = scc_graph.scc();",
      "            let groups: Vec<Vec<I>> = groups_indices",
      "                .into_iter()",
      "                .map(|group| {",
      "                    group",
      "                        .into_iter()",
      "                        .map(|idx| self.bounds.from_index(idx))",
      "                        .collect()",
      "                })",
      "                .collect();",
      "            CondensationGraphIx {",
      "                groups,",
      "                bounds: self.bounds,",
      "                original_edges: self.edges,",
      "            }",
      "        }",
      "    }",
      "    /// SCC の結果を保持し、必要に応じて縮約グラフなどを提供する構造体 (Ix版)",
      "    #[derive(Debug, Clone)]",
      "    pub struct CondensationGraphIx<I: Ix> {",
      "        /// 強連結成分のリスト (トポロジカル順)",
      "        groups: Vec<Vec<I>>,",
      "        bounds: Bounds<I>,",
      "        original_edges: Vec<(usize, usize)>,",
      "    }",
      "    impl<I: Ix> CondensationGraphIx<I> {",
      "        /// 強連結成分のリストを返す (トポロジカル順)",
      "        pub fn groups(&self) -> &[Vec<I>] {",
      "            &self.groups",
      "        }",
      "        /// グループ数 (縮約グラフの頂点数) を返す",
      "        /// # Returns",
      "        /// 強連結成分の個数",
      "        pub fn group_count(&self) -> usize {",
      "            self.groups.len()",
      "        }",
      "        /// 各頂点が属するグループ番号 (0-indexed) へのマッピングを返す",
      "        /// # Returns",
      "        /// `mapping[v]` は頂点 `v` が属するグループのインデックス",
      "        /// # 計算量",
      "        /// O(V)",
      "        pub fn mapping(&self) -> IxVec<I, usize> {",
      "            let mut mapping_vec = vec![0; self.bounds.range_size()];",
      "            for (i, group) in self.groups.iter().enumerate() {",
      "                for &v in group {",
      "                    mapping_vec[self.bounds.to_index(v)] = i;",
      "                }",
      "            }",
      "            IxVec::from_vec(self.bounds, mapping_vec)",
      "        }",
      "        /// 縮約グラフの辺のリストを返す (重複辺と自己ループは除去される)",
      "        /// # Returns",
      "        /// 縮約後の頂点 (グループID) 間の辺のリスト",
      "        /// # 計算量",
      "        /// O(V + E log E)",
      "        pub fn condensation_edges(&self) -> Vec<(usize, usize)> {",
      "            let mut mapping_vec = vec![0; self.bounds.range_size()];",
      "            for (i, group) in self.groups.iter().enumerate() {",
      "                for &v in group {",
      "                    mapping_vec[self.bounds.to_index(v)] = i;",
      "                }",
      "            }",
      "            let mut edges = vec![];",
      "            for &(u_idx, v_idx) in &self.original_edges {",
      "                let u_group = mapping_vec[u_idx];",
      "                let v_group = mapping_vec[v_idx];",
      "                if u_group != v_group {",
      "                    edges.push((u_group, v_group));",
      "                }",
      "            }",
      "            edges.sort_unstable();",
      "            edges.dedup();",
      "            edges",
      "        }",
      "        /// 縮約グラフの隣接リストを返す (重複辺は除去される)",
      "        /// # Returns",
      "        /// 縮約後の頂点 (グループID) をインデックスとする隣接リスト",
      "        /// # 計算量",
      "        /// O(V + E log E)",
      "        pub fn condensation_adj(&self) -> Vec<Vec<usize>> {",
      "            let mut adj = vec![vec![]; self.group_count()];",
      "            for (u_g, v_group) in self.condensation_edges() {",
      "                adj[u_g].push(v_group);",
      "            }",
      "            adj",
      "        }",
      "    }",
      "}"
    ]
  },
  "acl_suffix_array_finder": {
    "scope": "rust",
    "prefix": "acl_suffix_array_finder",
    "body": [
      "use acl_suffix_array_finder::*;",
      "pub mod acl_suffix_array_finder {",
      "    use ac_library::suffix_array_arbitrary;",
      "    use superslice::Ext;",
      "    /// Suffix Array を用いた文字列検索を行う構造体",
      "    #[derive(Clone, Debug)]",
      "    pub struct SuffixArrayFinder<'a, T: Ord> {",
      "        target: &'a [T],",
      "        sa: Vec<usize>,",
      "    }",
      "    impl<'a, T: Ord> SuffixArrayFinder<'a, T> {",
      "        /// 指定された `target` に対して SuffixArray を構築し、検索の準備を行う。",
      "        /// 計算量は O(|T| log |T|)",
      "        pub fn new(target: &'a [T]) -> Self {",
      "            let sa = suffix_array_arbitrary(target);",
      "            SuffixArrayFinder { target, sa }",
      "        }",
      "        /// `target` に出現する `pattern` の開始位置をすべて返す。",
      "        /// 結果はソートされているとは限らない。",
      "        /// 計算量は O(|P| log |T|)",
      "        pub fn find_all(&self, pattern: &[T]) -> &[usize] {",
      "            let range = self.sa.equal_range_by_key(&pattern, |&begin| {",
      "                let suffix = &self.target[begin..];",
      "                &suffix[..pattern.len().min(suffix.len())]",
      "            });",
      "            &self.sa[range]",
      "        }",
      "    }",
      "}"
    ]
  },
  "argcmp": {
    "scope": "rust",
    "prefix": "argcmp",
    "body": [
      "/// x軸正の向きを0度として、反時計回りを正とする偏角で順序を決める。",
      "/// (0, 0) は未考慮。",
      "/// オーバーフローには注意: 座標の絶対値が 3×10^9 を超える場合はオーバーフローする可能性がある",
      "pub fn argcmp((x0, y0): (i64, i64), (x1, y1): (i64, i64)) -> std::cmp::Ordering {",
      "    ((y0, x0) < (0, 0))",
      "        .cmp(&((y1, x1) < (0, 0)))",
      "        .then_with(|| (x1 * y0).cmp(&(x0 * y1)))",
      "}"
    ]
  },
  "array_2d_transformation": {
    "scope": "rust",
    "prefix": "array_2d_transformation",
    "body": [
      "use array_2d_transformation::*;",
      "#[allow(clippy::module_inception)]",
      "/// 2次元配列 (`Vec<Vec<T>>`) を変換するためのモジュールです。",
      "/// このモジュールは、2次元配列に対する回転、転置、反転といった幾何学的変換を行う関数を提供します。",
      "/// すべての関数は `&[Vec<T>]` を受け取り、新しい `Vec<Vec<T>>` を返します。",
      "/// 要素型 `T` は `Default`、`Clone`、`Copy` を実装している必要があります。",
      "/// 注: これらの関数は、空の行や列 (例: 0xH または Wx0 の行列) を持つ配列には対応していません。",
      "pub mod array_2d_transformation {",
      "    pub fn rotate_right<T>(table: &[Vec<T>]) -> Vec<Vec<T>>",
      "    where",
      "        T: Default + Clone + Copy,",
      "    {",
      "        let h = table.len();",
      "        let w = table[0].len();",
      "        let mut table_after = vec![vec![T::default(); h]; w];",
      "        for (y, row) in table.iter().enumerate() {",
      "            for (x, v) in row.iter().enumerate() {",
      "                table_after[x][h - 1 - y] = *v;",
      "            }",
      "        }",
      "        table_after",
      "    }",
      "    pub fn rotate_left<T>(table: &[Vec<T>]) -> Vec<Vec<T>>",
      "    where",
      "        T: Default + Clone + Copy,",
      "    {",
      "        let h = table.len();",
      "        let w = table[0].len();",
      "        let mut table_after = vec![vec![T::default(); h]; w];",
      "        for (y, row) in table.iter().enumerate() {",
      "            for (x, v) in row.iter().enumerate() {",
      "                table_after[w - 1 - x][y] = *v;",
      "            }",
      "        }",
      "        table_after",
      "    }",
      "    pub fn rotate_180_deg<T>(table: &[Vec<T>]) -> Vec<Vec<T>>",
      "    where",
      "        T: Default + Clone + Copy,",
      "    {",
      "        let h = table.len();",
      "        let w = table[0].len();",
      "        let mut table_after = vec![vec![T::default(); w]; h];",
      "        for (y, row) in table.iter().enumerate() {",
      "            for (x, v) in row.iter().enumerate() {",
      "                table_after[h - 1 - y][w - 1 - x] = *v;",
      "            }",
      "        }",
      "        table_after",
      "    }",
      "    pub fn transpose<T>(table: &[Vec<T>]) -> Vec<Vec<T>>",
      "    where",
      "        T: Default + Clone + Copy,",
      "    {",
      "        let h = table.len();",
      "        let w = table[0].len();",
      "        let mut table_after = vec![vec![T::default(); h]; w];",
      "        for (y, row) in table.iter().enumerate() {",
      "            for (x, v) in row.iter().enumerate() {",
      "                table_after[x][y] = *v;",
      "            }",
      "        }",
      "        table_after",
      "    }",
      "    pub fn reflect_x_axis<T>(table: &[Vec<T>]) -> Vec<Vec<T>>",
      "    where",
      "        T: Default + Clone + Copy,",
      "    {",
      "        let h = table.len();",
      "        let w = table[0].len();",
      "        let mut table_after = vec![vec![T::default(); w]; h];",
      "        for (y, row) in table.iter().enumerate() {",
      "            for (x, v) in row.iter().enumerate() {",
      "                table_after[h - 1 - y][x] = *v;",
      "            }",
      "        }",
      "        table_after",
      "    }",
      "    pub fn reflect_y_axis<T>(table: &[Vec<T>]) -> Vec<Vec<T>>",
      "    where",
      "        T: Default + Clone + Copy,",
      "    {",
      "        let h = table.len();",
      "        let w = table[0].len();",
      "        let mut table_after = vec![vec![T::default(); w]; h];",
      "        for (y, row) in table.iter().enumerate() {",
      "            for (x, v) in row.iter().enumerate() {",
      "                table_after[y][w - 1 - x] = *v;",
      "            }",
      "        }",
      "        table_after",
      "    }",
      "}"
    ]
  },
  "bellman_ford": {
    "scope": "rust",
    "prefix": "bellman_ford",
    "body": [
      "use mod_ext_int::*;",
      "pub mod mod_ext_int {",
      "    use ac_library::Monoid;",
      "    use std::{",
      "        cmp::Ordering,",
      "        convert::Infallible,",
      "        fmt,",
      "        ops::{Add, AddAssign, Mul, Sub, SubAssign},",
      "    };",
      "    pub const INF: ExtInt = ExtInt::INF;",
      "    pub fn fin(x: i64) -> ExtInt {",
      "        ExtInt::fin(x)",
      "    }",
      "    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]",
      "    pub struct ExtInt(i64);",
      "    impl ExtInt {",
      "        pub const INF: Self = Self(i64::MAX);",
      "        pub fn fin(x: i64) -> Self {",
      "            Self(x)",
      "        }",
      "        pub fn get_fin(self) -> i64 {",
      "            if self.is_fin() {",
      "                self.0",
      "            } else {",
      "                panic!(\"called `ExtInt::get_fin()` on a infinity\")",
      "            }",
      "        }",
      "        pub fn get_fin_or(self, default: i64) -> i64 {",
      "            if self.is_fin() {",
      "                self.0",
      "            } else {",
      "                default",
      "            }",
      "        }",
      "        #[inline]",
      "        pub fn is_fin(self) -> bool {",
      "            self.0 != i64::MAX",
      "        }",
      "        pub fn is_inf(self) -> bool {",
      "            self.0 == i64::MAX",
      "        }",
      "        pub fn to_option(self) -> Option<i64> {",
      "            if self.is_fin() {",
      "                Some(self.0)",
      "            } else {",
      "                None",
      "            }",
      "        }",
      "        pub fn from_option(opt: Option<i64>) -> ExtInt {",
      "            match opt {",
      "                Some(a) => Self(a),",
      "                None => Self::INF,",
      "            }",
      "        }",
      "        pub fn times(self, t: i64) -> Self {",
      "            self * t",
      "        }",
      "    }",
      "    impl Add for ExtInt {",
      "        type Output = ExtInt;",
      "        fn add(self, rhs: Self) -> Self::Output {",
      "            if self.is_inf() || rhs.is_inf() {",
      "                Self::INF",
      "            } else {",
      "                Self::fin(self.0 + rhs.0)",
      "            }",
      "        }",
      "    }",
      "    impl AddAssign for ExtInt {",
      "        fn add_assign(&mut self, rhs: Self) {",
      "            *self = *self + rhs;",
      "        }",
      "    }",
      "    impl Add<i64> for ExtInt {",
      "        type Output = ExtInt;",
      "        fn add(self, rhs: i64) -> Self::Output {",
      "            if self.is_inf() {",
      "                Self::INF",
      "            } else {",
      "                Self::fin(self.0 + rhs)",
      "            }",
      "        }",
      "    }",
      "    impl AddAssign<i64> for ExtInt {",
      "        fn add_assign(&mut self, rhs: i64) {",
      "            *self = *self + rhs;",
      "        }",
      "    }",
      "    impl Sub<i64> for ExtInt {",
      "        type Output = ExtInt;",
      "        fn sub(self, rhs: i64) -> Self::Output {",
      "            if self.is_inf() {",
      "                Self::INF",
      "            } else {",
      "                Self::fin(self.0 - rhs)",
      "            }",
      "        }",
      "    }",
      "    impl SubAssign<i64> for ExtInt {",
      "        fn sub_assign(&mut self, rhs: i64) {",
      "            *self = *self - rhs;",
      "        }",
      "    }",
      "    impl Mul<i64> for ExtInt {",
      "        type Output = ExtInt;",
      "        fn mul(self, rhs: i64) -> Self::Output {",
      "            match rhs.cmp(&0) {",
      "                Ordering::Less => panic!(\"multiplier must be non-negative.\"),",
      "                Ordering::Equal => Self::fin(0),",
      "                Ordering::Greater => {",
      "                    if self.is_fin() {",
      "                        Self::fin(self.0 * rhs)",
      "                    } else {",
      "                        Self::INF",
      "                    }",
      "                }",
      "            }",
      "        }",
      "    }",
      "    impl std::iter::Sum for ExtInt {",
      "        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {",
      "            let mut s = 0;",
      "            for x in iter {",
      "                if x.is_inf() {",
      "                    return Self::INF;",
      "                }",
      "                s += x.0;",
      "            }",
      "            Self::fin(s)",
      "        }",
      "    }",
      "    impl fmt::Display for ExtInt {",
      "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
      "            if self.is_inf() {",
      "                write!(f, \"+∞\")",
      "            } else {",
      "                write!(f, \"{}\", self.0)",
      "            }",
      "        }",
      "    }",
      "    impl fmt::Debug for ExtInt {",
      "        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "            if self.is_inf() {",
      "                write!(f, \"+∞\")",
      "            } else {",
      "                write!(f, \"{}\", self.0)",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct ExtIntAdditive(Infallible);",
      "    impl Monoid for ExtIntAdditive {",
      "        type S = ExtInt;",
      "        fn identity() -> Self::S {",
      "            ExtInt::fin(0)",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a + *b",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct ExtIntMin(Infallible);",
      "    impl Monoid for ExtIntMin {",
      "        type S = ExtInt;",
      "        fn identity() -> Self::S {",
      "            ExtInt::INF",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a.min(b)",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::module_inception)]",
      "pub mod bellman_ford {",
      "    macro_rules! chmin {",
      "        (\\$ a : expr_2021 , \\$ b : expr_2021 ) => {",
      "            if \\$a > \\$b {",
      "                \\$a = \\$b;",
      "                true",
      "            } else {",
      "                false",
      "            }",
      "        };",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    /// 最短路問題の解。双対問題を考える場合は非有界と非許容が逆になるので注意",
      "    pub enum Solution {",
      "        /// 非有界 (負閉路を経由することでいくらでもパスを短くできる。-∞ 扱い)",
      "        Unbounded,",
      "        /// 有界",
      "        Bounded(i64),",
      "        /// 非許容 (連結でなくて到達不可能。 +∞ 扱い)",
      "        Infeasible,",
      "    }",
      "    impl Solution {",
      "        /// 双対問題の解に変換する (非有界と非許容が入れ替わる)",
      "        pub fn dual(&self) -> Self {",
      "            match self {",
      "                Solution::Unbounded => Solution::Infeasible,",
      "                Solution::Bounded(x) => Solution::Bounded(*x),",
      "                Solution::Infeasible => Solution::Unbounded,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct Edge {",
      "        from: usize,",
      "        to: usize,",
      "        cost: i64,",
      "    }",
      "    impl Edge {",
      "        pub fn new(from: usize, to: usize, cost: i64) -> Self {",
      "            Self { from, to, cost }",
      "        }",
      "    }",
      "    /// ベルマンフォード法を用いて、指定した始点から全頂点への最短距離を求めます。",
      "    /// 負閉路の影響を受ける頂点を適切に判定します。",
      "    /// # 計算量",
      "    /// O(V * E)",
      "    pub fn bellman_ford(edges: &[Edge], n_vertex: usize, start: usize) -> Vec<Solution> {",
      "        let mut dist = vec![INF; n_vertex];",
      "        dist[start] = fin(0);",
      "        for _ in 0..n_vertex {",
      "            for edge in edges {",
      "                chmin!(dist[edge.to], dist[edge.from] + fin(edge.cost));",
      "            }",
      "        }",
      "        let mut adj = vec![vec![]; n_vertex];",
      "        for edge in edges {",
      "            adj[edge.from].push(edge.to);",
      "        }",
      "        use std::collections::VecDeque;",
      "        let mut queue = VecDeque::new();",
      "        let mut is_unbounded = vec![false; n_vertex];",
      "        let mut visited = vec![false; n_vertex];",
      "        for edge in edges {",
      "            if dist[edge.to] > dist[edge.from] + fin(edge.cost) && !visited[edge.to] {",
      "                visited[edge.to] = true;",
      "                queue.push_back(edge.to);",
      "            }",
      "        }",
      "        while let Some(u) = queue.pop_front() {",
      "            is_unbounded[u] = true;",
      "            for &v in &adj[u] {",
      "                if !visited[v] {",
      "                    visited[v] = true;",
      "                    queue.push_back(v);",
      "                }",
      "            }",
      "        }",
      "        dist.into_iter()",
      "            .zip(is_unbounded)",
      "            .map(|(d, unbounded)| {",
      "                if unbounded {",
      "                    Solution::Unbounded",
      "                } else if d.is_inf() {",
      "                    Solution::Infeasible",
      "                } else {",
      "                    Solution::Bounded(d.get_fin())",
      "                }",
      "            })",
      "            .collect()",
      "    }",
      "    use mod_ext_int::*;",
      "    #[allow(dead_code)]",
      "    mod mod_ext_int {",
      "        use ac_library::Monoid;",
      "        use std::{",
      "            cmp::Ordering,",
      "            convert::Infallible,",
      "            fmt,",
      "            ops::{Add, AddAssign, Sub, SubAssign},",
      "        };",
      "        pub const INF: ExtInt = ExtInt::INF;",
      "        pub fn fin(x: i64) -> ExtInt {",
      "            ExtInt::fin(x)",
      "        }",
      "        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]",
      "        pub struct ExtInt(i64);",
      "        impl ExtInt {",
      "            pub const INF: Self = Self(i64::MAX);",
      "            pub fn fin(x: i64) -> Self {",
      "                Self(x)",
      "            }",
      "            pub fn get_fin(self) -> i64 {",
      "                if self.is_fin() {",
      "                    self.0",
      "                } else {",
      "                    panic!(\"called `ExtInt::get_fin()` on a infinity\")",
      "                }",
      "            }",
      "            pub fn get_fin_or(self, default: i64) -> i64 {",
      "                if self.is_fin() {",
      "                    self.0",
      "                } else {",
      "                    default",
      "                }",
      "            }",
      "            #[inline]",
      "            pub fn is_fin(self) -> bool {",
      "                self.0 != i64::MAX",
      "            }",
      "            pub fn is_inf(self) -> bool {",
      "                self.0 == i64::MAX",
      "            }",
      "            pub fn to_option(self) -> Option<i64> {",
      "                if self.is_fin() {",
      "                    Some(self.0)",
      "                } else {",
      "                    None",
      "                }",
      "            }",
      "            pub fn from_option(opt: Option<i64>) -> ExtInt {",
      "                match opt {",
      "                    Some(a) => Self(a),",
      "                    None => Self::INF,",
      "                }",
      "            }",
      "            pub fn times(self, t: i64) -> Self {",
      "                match t.cmp(&0) {",
      "                    Ordering::Less => panic!(\"t must be non-negative.\"),",
      "                    Ordering::Equal => Self(0),",
      "                    Ordering::Greater => {",
      "                        if self.is_fin() {",
      "                            Self(self.0 * t)",
      "                        } else {",
      "                            Self::INF",
      "                        }",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        impl Add for ExtInt {",
      "            type Output = ExtInt;",
      "            fn add(self, rhs: Self) -> Self::Output {",
      "                if self.is_inf() || rhs.is_inf() {",
      "                    Self::INF",
      "                } else {",
      "                    Self::fin(self.0 + rhs.0)",
      "                }",
      "            }",
      "        }",
      "        impl AddAssign for ExtInt {",
      "            fn add_assign(&mut self, rhs: Self) {",
      "                *self = *self + rhs;",
      "            }",
      "        }",
      "        impl Add<i64> for ExtInt {",
      "            type Output = ExtInt;",
      "            fn add(self, rhs: i64) -> Self::Output {",
      "                if self.is_inf() {",
      "                    Self::INF",
      "                } else {",
      "                    Self::fin(self.0 + rhs)",
      "                }",
      "            }",
      "        }",
      "        impl AddAssign<i64> for ExtInt {",
      "            fn add_assign(&mut self, rhs: i64) {",
      "                *self = *self + rhs;",
      "            }",
      "        }",
      "        impl Sub<i64> for ExtInt {",
      "            type Output = ExtInt;",
      "            fn sub(self, rhs: i64) -> Self::Output {",
      "                if self.is_inf() {",
      "                    Self::INF",
      "                } else {",
      "                    Self::fin(self.0 - rhs)",
      "                }",
      "            }",
      "        }",
      "        impl SubAssign<i64> for ExtInt {",
      "            fn sub_assign(&mut self, rhs: i64) {",
      "                *self = *self - rhs;",
      "            }",
      "        }",
      "        impl std::iter::Sum for ExtInt {",
      "            fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {",
      "                let mut s = 0;",
      "                for x in iter {",
      "                    if x.is_inf() {",
      "                        return Self::INF;",
      "                    }",
      "                    s += x.0;",
      "                }",
      "                Self::fin(s)",
      "            }",
      "        }",
      "        impl fmt::Display for ExtInt {",
      "            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
      "                if self.is_inf() {",
      "                    write!(f, \"+∞\")",
      "                } else {",
      "                    write!(f, \"{}\", self.0)",
      "                }",
      "            }",
      "        }",
      "        impl fmt::Debug for ExtInt {",
      "            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "                if self.is_inf() {",
      "                    write!(f, \"+∞\")",
      "                } else {",
      "                    write!(f, \"{}\", self.0)",
      "                }",
      "            }",
      "        }",
      "        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "        pub struct ExtIntAdditive(Infallible);",
      "        impl Monoid for ExtIntAdditive {",
      "            type S = ExtInt;",
      "            fn identity() -> Self::S {",
      "                ExtInt::fin(0)",
      "            }",
      "            fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "                *a + *b",
      "            }",
      "        }",
      "        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "        pub struct ExtIntMin(Infallible);",
      "        impl Monoid for ExtIntMin {",
      "            type S = ExtInt;",
      "            fn identity() -> Self::S {",
      "                ExtInt::INF",
      "            }",
      "            fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "                *a.min(b)",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "bfs": {
    "scope": "rust",
    "prefix": "bfs",
    "body": [
      "use bfs::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod bfs {",
      "    use std::collections::VecDeque;",
      "    /// BFS の結果（距離と復元情報）",
      "    #[derive(Clone, Debug)]",
      "    pub struct BfsResult {",
      "        pub dist: Vec<Option<i64>>,",
      "        pub prev: Vec<Option<usize>>,",
      "    }",
      "    impl BfsResult {",
      "        /// 頂点 `t` への最短経路を復元する（始点 -> ... -> t）",
      "        /// # Returns",
      "        /// 始点から `t` までの頂点列。`t` に到達不可能な場合は `None`。",
      "        /// # 計算量",
      "        /// O(経路の長さ)",
      "        pub fn restore(&self, t: usize) -> Option<Vec<usize>> {",
      "            self.dist[t]?;",
      "            let mut path: Vec<_> =",
      "                std::iter::successors(Some(t), |&curr| self.prev[curr]).collect();",
      "            path.reverse();",
      "            Some(path)",
      "        }",
      "    }",
      "    /// 標準的な usize インデックスを用いた幅優先探索 (BFS)",
      "    /// # Arguments",
      "    /// * `nv` - 頂点数",
      "    /// * `adj` - 頂点を受け取り、隣接する頂点のイテレータを返すクロージャー",
      "    /// * `init` - 始点となる頂点集合のイテレータ",
      "    /// # Returns",
      "    /// 始点集合 `init` からの最短距離を格納した `Vec<Option<i64>>`。到達不可能な頂点は `None`。",
      "    /// # 計算量",
      "    /// O(V + E)",
      "    pub fn bfs<F, It>(",
      "        nv: usize,",
      "        mut adj: F,",
      "        init: impl IntoIterator<Item = usize>,",
      "    ) -> Vec<Option<i64>>",
      "    where",
      "        F: FnMut(usize) -> It,",
      "        It: IntoIterator<Item = usize>,",
      "    {",
      "        let mut dist = vec![None; nv];",
      "        let mut q = VecDeque::new();",
      "        for s in init {",
      "            if dist[s].is_none() {",
      "                dist[s] = Some(0);",
      "                q.push_back(s);",
      "            }",
      "        }",
      "        while let Some(u) = q.pop_front() {",
      "            let d = dist[u].unwrap();",
      "            for v in adj(u) {",
      "                if dist[v].is_none() {",
      "                    dist[v] = Some(d + 1);",
      "                    q.push_back(v);",
      "                }",
      "            }",
      "        }",
      "        dist",
      "    }",
      "    /// 経路復元可能な BFS",
      "    /// # Arguments",
      "    /// * `nv` - 頂点数",
      "    /// * `adj` - 頂点を受け取り、隣接する頂点のイテレータを返すクロージャー",
      "    /// * `init` - 始点となる頂点集合のイテレータ",
      "    /// # Returns",
      "    /// 最短距離 `dist` と、復元用配列 `prev` を含む `BfsResult`。",
      "    /// # 計算量",
      "    /// O(V + E)",
      "    pub fn bfs_with_restore<F, It>(",
      "        nv: usize,",
      "        mut adj: F,",
      "        init: impl IntoIterator<Item = usize>,",
      "    ) -> BfsResult",
      "    where",
      "        F: FnMut(usize) -> It,",
      "        It: IntoIterator<Item = usize>,",
      "    {",
      "        let mut dist = vec![None; nv];",
      "        let mut prev = vec![None; nv];",
      "        let mut q = VecDeque::new();",
      "        for s in init {",
      "            if dist[s].is_none() {",
      "                dist[s] = Some(0);",
      "                q.push_back(s);",
      "            }",
      "        }",
      "        while let Some(u) = q.pop_front() {",
      "            let d = dist[u].unwrap();",
      "            for v in adj(u) {",
      "                if dist[v].is_none() {",
      "                    dist[v] = Some(d + 1);",
      "                    prev[v] = Some(u);",
      "                    q.push_back(v);",
      "                }",
      "            }",
      "        }",
      "        BfsResult { dist, prev }",
      "    }",
      "    /// BFS での訪問順序（キューに入れた順）を返す",
      "    /// # Arguments",
      "    /// * `nv` - 頂点数",
      "    /// * `adj` - 頂点を受け取り、隣接する頂点のイテレータを返すクロージャー",
      "    /// * `init` - 始点となる頂点集合のイテレータ",
      "    /// # Returns",
      "    /// 到達可能な頂点を訪問順に格納した `Vec<usize>`",
      "    /// # 計算量",
      "    /// O(V + E)",
      "    pub fn bfs_order<F, It>(",
      "        nv: usize,",
      "        mut adj: F,",
      "        init: impl IntoIterator<Item = usize>,",
      "    ) -> Vec<usize>",
      "    where",
      "        F: FnMut(usize) -> It,",
      "        It: IntoIterator<Item = usize>,",
      "    {",
      "        let mut visited = vec![false; nv];",
      "        let mut order = Vec::new();",
      "        let mut q = VecDeque::new();",
      "        for s in init {",
      "            if !visited[s] {",
      "                visited[s] = true;",
      "                order.push(s);",
      "                q.push_back(s);",
      "            }",
      "        }",
      "        while let Some(u) = q.pop_front() {",
      "            for v in adj(u) {",
      "                if !visited[v] {",
      "                    visited[v] = true;",
      "                    order.push(v);",
      "                    q.push_back(v);",
      "                }",
      "            }",
      "        }",
      "        order",
      "    }",
      "    /// 始点集合から各頂点への到達可能性を判定する",
      "    /// # Arguments",
      "    /// * `nv` - 頂点数",
      "    /// * `adj` - 頂点を受け取り、隣接する頂点のイテレータを返すクロージャー",
      "    /// * `init` - 始点となる頂点集合のイテレータ",
      "    /// # Returns",
      "    /// 各頂点への到達可能性を格納した `Vec<bool>`",
      "    /// # 計算量",
      "    /// O(V + E)",
      "    pub fn bfs_reachable<F, It>(",
      "        nv: usize,",
      "        mut adj: F,",
      "        init: impl IntoIterator<Item = usize>,",
      "    ) -> Vec<bool>",
      "    where",
      "        F: FnMut(usize) -> It,",
      "        It: IntoIterator<Item = usize>,",
      "    {",
      "        let mut visited = vec![false; nv];",
      "        let mut q = VecDeque::new();",
      "        for s in init {",
      "            if !visited[s] {",
      "                visited[s] = true;",
      "                q.push_back(s);",
      "            }",
      "        }",
      "        while let Some(u) = q.pop_front() {",
      "            for v in adj(u) {",
      "                if !visited[v] {",
      "                    visited[v] = true;",
      "                    q.push_back(v);",
      "                }",
      "            }",
      "        }",
      "        visited",
      "    }",
      "}"
    ]
  },
  "bfs01": {
    "scope": "rust",
    "prefix": "bfs01",
    "body": [
      "use bfs01::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod bfs01 {",
      "    use std::collections::VecDeque;",
      "    /// 01-BFS の結果（距離と復元情報）",
      "    #[derive(Clone, Debug)]",
      "    pub struct Bfs01Result {",
      "        pub dist: Vec<Option<i64>>,",
      "        pub prev: Vec<Option<usize>>,",
      "    }",
      "    impl Bfs01Result {",
      "        /// 頂点 `t` への最短経路を復元する（始点 -> ... -> t）",
      "        /// # Returns",
      "        /// 始点から `t` までの頂点列。`t` に到達不可能な場合は `None`。",
      "        /// # 計算量",
      "        /// O(経路の長さ)",
      "        pub fn restore(&self, t: usize) -> Option<Vec<usize>> {",
      "            self.dist[t]?;",
      "            let mut path: Vec<_> =",
      "                std::iter::successors(Some(t), |&curr| self.prev[curr]).collect();",
      "            path.reverse();",
      "            Some(path)",
      "        }",
      "    }",
      "    /// 標準的な 01-BFS",
      "    /// # Arguments",
      "    /// * `nv` - 頂点数",
      "    /// * `adj` - 頂点を受け取り、隣接する頂点とそのコストのペアのイテレータを返すクロージャー",
      "    /// * `init` - 始点となる頂点集合のイテレータ",
      "    /// # Returns",
      "    /// 始点集合 `init` からの最短距離を格納した `Vec<Option<i64>>`。到達不可能な頂点は `None`。",
      "    /// # 計算量",
      "    /// O(V + E)",
      "    pub fn bfs01<F, It>(",
      "        nv: usize,",
      "        mut adj: F,",
      "        init: impl IntoIterator<Item = usize>,",
      "    ) -> Vec<Option<i64>>",
      "    where",
      "        F: FnMut(usize) -> It,",
      "        It: IntoIterator<Item = (usize, i64)>,",
      "    {",
      "        let mut dist = vec![None; nv];",
      "        let mut q = VecDeque::new();",
      "        for s in init {",
      "            if dist[s].is_none() {",
      "                dist[s] = Some(0);",
      "                q.push_back((s, 0));",
      "            }",
      "        }",
      "        while let Some((u, d)) = q.pop_front() {",
      "            if dist[u].is_some_and(|cur| cur < d) {",
      "                continue;",
      "            }",
      "            for (v, cost) in adj(u) {",
      "                assert!(cost == 0 || cost == 1, \"cost must be 0 or 1\");",
      "                let next_d = d + cost;",
      "                if dist[v].is_none_or(|cur| cur > next_d) {",
      "                    dist[v] = Some(next_d);",
      "                    if cost == 0 {",
      "                        q.push_front((v, next_d));",
      "                    } else {",
      "                        q.push_back((v, next_d));",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        dist",
      "    }",
      "    /// 経路復元可能な 01-BFS",
      "    /// # Arguments",
      "    /// * `nv` - 頂点数",
      "    /// * `adj` - 頂点を受け取り、隣接する頂点とそのコストのペアのイテレータを返すクロージャー",
      "    /// * `init` - 始点となる頂点集合のイテレータ",
      "    /// # Returns",
      "    /// 最短距離 `dist` と、復元用配列 `prev` を含む `Bfs01Result`。",
      "    /// # 計算量",
      "    /// O(V + E)",
      "    pub fn bfs01_with_restore<F, It>(",
      "        nv: usize,",
      "        mut adj: F,",
      "        init: impl IntoIterator<Item = usize>,",
      "    ) -> Bfs01Result",
      "    where",
      "        F: FnMut(usize) -> It,",
      "        It: IntoIterator<Item = (usize, i64)>,",
      "    {",
      "        let mut dist = vec![None; nv];",
      "        let mut prev = vec![None; nv];",
      "        let mut q = VecDeque::new();",
      "        for s in init {",
      "            if dist[s].is_none() {",
      "                dist[s] = Some(0);",
      "                q.push_back((s, 0));",
      "            }",
      "        }",
      "        while let Some((u, d)) = q.pop_front() {",
      "            if dist[u].is_some_and(|cur| cur < d) {",
      "                continue;",
      "            }",
      "            for (v, cost) in adj(u) {",
      "                assert!(cost == 0 || cost == 1, \"cost must be 0 or 1\");",
      "                let next_d = d + cost;",
      "                if dist[v].is_none_or(|cur| cur > next_d) {",
      "                    dist[v] = Some(next_d);",
      "                    prev[v] = Some(u);",
      "                    if cost == 0 {",
      "                        q.push_front((v, next_d));",
      "                    } else {",
      "                        q.push_back((v, next_d));",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        Bfs01Result { dist, prev }",
      "    }",
      "}"
    ]
  },
  "bfs01_ix": {
    "scope": "rust",
    "prefix": "bfs01_ix",
    "body": [
      "use bfs01_ix::*;",
      "pub mod bfs01_ix {",
      "    use super::bfs01::{bfs01, bfs01_with_restore};",
      "    use super::{Bounds, Ix, IxVec};",
      "    /// 01-BFS の結果（Ix版）",
      "    #[derive(Clone, Debug)]",
      "    pub struct Bfs01IxResult<I: Ix> {",
      "        pub dist: IxVec<I, Option<i64>>,",
      "        pub prev: IxVec<I, Option<I>>,",
      "    }",
      "    impl<I: Ix> Bfs01IxResult<I> {",
      "        /// 頂点 `t` への最短経路を復元する（始点 -> ... -> t）",
      "        /// # Returns",
      "        /// 始点から `t` までの頂点列。`t` に到達不可能な場合は `None`。",
      "        /// # 計算量",
      "        /// O(経路の長さ)",
      "        pub fn restore(&self, t: I) -> Option<Vec<I>> {",
      "            self.dist[t]?;",
      "            let mut path: Vec<_> =",
      "                std::iter::successors(Some(t), |&curr| self.prev[curr]).collect();",
      "            path.reverse();",
      "            Some(path)",
      "        }",
      "    }",
      "    /// Bounds を用いた任意の型 I に対する 01-BFS",
      "    /// # Arguments",
      "    /// * `bounds` - 頂点のインデックス範囲",
      "    /// * `adj` - 頂点を受け取り、隣接する頂点とそのコストのペアのイテレータを返すクロージャー",
      "    /// * `init` - 始点となる頂点集合のイテレータ",
      "    /// # Returns",
      "    /// 始点集合 `init` からの最短距離を格納した `IxVec<I, Option<i64>>`。",
      "    /// # 計算量",
      "    /// O(V + E)",
      "    pub fn bfs01_arbitrary<I, F, It>(",
      "        bounds: Bounds<I>,",
      "        mut adj: F,",
      "        init: impl IntoIterator<Item = I>,",
      "    ) -> IxVec<I, Option<i64>>",
      "    where",
      "        I: Ix,",
      "        F: FnMut(I) -> It,",
      "        It: IntoIterator<Item = (I, i64)>,",
      "    {",
      "        let nv = bounds.range_size();",
      "        let mut adj_usize = |u_idx: usize| {",
      "            let u = bounds.from_index(u_idx);",
      "            adj(u)",
      "                .into_iter()",
      "                .map(move |(v, cost)| (bounds.to_index(v), cost))",
      "        };",
      "        let init_usize = init.into_iter().map(|s| bounds.to_index(s));",
      "        let res_vec = bfs01(nv, &mut adj_usize, init_usize);",
      "        IxVec::from_vec(bounds, res_vec)",
      "    }",
      "    /// Bounds を用いた任意の型 I に対する 01-BFS (経路復元付き)",
      "    /// # Arguments",
      "    /// * `bounds` - 頂点のインデックス範囲",
      "    /// * `adj` - 頂点を受け取り、隣接する頂点とそのコストのペアのイテレータを返すクロージャー",
      "    /// * `init` - 始点となる頂点集合のイテレータ",
      "    /// # Returns",
      "    /// 最短距離 `dist` と、復元用配列 `prev` を含む `Bfs01IxResult`。",
      "    /// # 計算量",
      "    /// O(V + E)",
      "    pub fn bfs01_with_restore_arbitrary<I, F, It>(",
      "        bounds: Bounds<I>,",
      "        mut adj: F,",
      "        init: impl IntoIterator<Item = I>,",
      "    ) -> Bfs01IxResult<I>",
      "    where",
      "        I: Ix,",
      "        F: FnMut(I) -> It,",
      "        It: IntoIterator<Item = (I, i64)>,",
      "    {",
      "        let nv = bounds.range_size();",
      "        let mut adj_usize = |u_idx: usize| {",
      "            let u = bounds.from_index(u_idx);",
      "            adj(u)",
      "                .into_iter()",
      "                .map(move |(v, cost)| (bounds.to_index(v), cost))",
      "        };",
      "        let init_usize = init.into_iter().map(|s| bounds.to_index(s));",
      "        let res = bfs01_with_restore(nv, &mut adj_usize, init_usize);",
      "        Bfs01IxResult {",
      "            dist: IxVec::from_vec(bounds, res.dist),",
      "            prev: IxVec::from_vec(",
      "                bounds,",
      "                res.prev",
      "                    .into_iter()",
      "                    .map(|p| p.map(|idx| bounds.from_index(idx)))",
      "                    .collect(),",
      "            ),",
      "        }",
      "    }",
      "}"
    ]
  },
  "bfs_ix": {
    "scope": "rust",
    "prefix": "bfs_ix",
    "body": [
      "use bfs_ix::*;",
      "pub mod bfs_ix {",
      "    use super::bfs::{bfs, bfs_order, bfs_reachable, bfs_with_restore};",
      "    use super::{Bounds, Ix, IxVec};",
      "    /// BFS の結果（Ix版）",
      "    #[derive(Clone, Debug)]",
      "    pub struct BfsIxResult<I: Ix> {",
      "        pub dist: IxVec<I, Option<i64>>,",
      "        pub prev: IxVec<I, Option<I>>,",
      "    }",
      "    impl<I: Ix> BfsIxResult<I> {",
      "        /// 頂点 `t` への最短経路を復元する（始点 -> ... -> t）",
      "        /// # Returns",
      "        /// 始点から `t` までの頂点列。`t` に到達不可能な場合は `None`。",
      "        /// # 計算量",
      "        /// O(経路の長さ)",
      "        pub fn restore(&self, t: I) -> Option<Vec<I>> {",
      "            self.dist[t]?;",
      "            let mut path: Vec<_> =",
      "                std::iter::successors(Some(t), |&curr| self.prev[curr]).collect();",
      "            path.reverse();",
      "            Some(path)",
      "        }",
      "    }",
      "    /// Bounds を用いた任意の型 I に対する BFS",
      "    /// # Arguments",
      "    /// * `bounds` - 頂点のインデックス範囲",
      "    /// * `adj` - 頂点を受け取り、隣接する頂点のイテレータを返すクロージャー",
      "    /// * `init` - 始点となる頂点集合のイテレータ",
      "    /// # Returns",
      "    /// 始点集合 `init` からの最短距離を格納した `IxVec<I, Option<i64>>`。",
      "    /// # 計算量",
      "    /// O(V + E)",
      "    pub fn bfs_arbitrary<I, F, It>(",
      "        bounds: Bounds<I>,",
      "        mut adj: F,",
      "        init: impl IntoIterator<Item = I>,",
      "    ) -> IxVec<I, Option<i64>>",
      "    where",
      "        I: Ix,",
      "        F: FnMut(I) -> It,",
      "        It: IntoIterator<Item = I>,",
      "    {",
      "        let nv = bounds.range_size();",
      "        let mut adj_usize = |u_idx: usize| {",
      "            let u = bounds.from_index(u_idx);",
      "            adj(u).into_iter().map(move |v| bounds.to_index(v))",
      "        };",
      "        let init_usize = init.into_iter().map(|s| bounds.to_index(s));",
      "        let res_vec = bfs(nv, &mut adj_usize, init_usize);",
      "        IxVec::from_vec(bounds, res_vec)",
      "    }",
      "    /// Bounds を用いた任意の型 I に対する BFS (経路復元付き)",
      "    /// # Arguments",
      "    /// * `bounds` - 頂点のインデックス範囲",
      "    /// * `adj` - 頂点を受け取り、隣接する頂点のイテレータを返すクロージャー",
      "    /// * `init` - 始点となる頂点集合のイテレータ",
      "    /// # Returns",
      "    /// 最短距離 `dist` と、復元用配列 `prev` を含む `BfsIxResult`。",
      "    /// # 計算量",
      "    /// O(V + E)",
      "    pub fn bfs_with_restore_arbitrary<I, F, It>(",
      "        bounds: Bounds<I>,",
      "        mut adj: F,",
      "        init: impl IntoIterator<Item = I>,",
      "    ) -> BfsIxResult<I>",
      "    where",
      "        I: Ix,",
      "        F: FnMut(I) -> It,",
      "        It: IntoIterator<Item = I>,",
      "    {",
      "        let nv = bounds.range_size();",
      "        let mut adj_usize = |u_idx: usize| {",
      "            let u = bounds.from_index(u_idx);",
      "            adj(u).into_iter().map(move |v| bounds.to_index(v))",
      "        };",
      "        let init_usize = init.into_iter().map(|s| bounds.to_index(s));",
      "        let res = bfs_with_restore(nv, &mut adj_usize, init_usize);",
      "        BfsIxResult {",
      "            dist: IxVec::from_vec(bounds, res.dist),",
      "            prev: IxVec::from_vec(",
      "                bounds,",
      "                res.prev",
      "                    .into_iter()",
      "                    .map(|p| p.map(|idx| bounds.from_index(idx)))",
      "                    .collect(),",
      "            ),",
      "        }",
      "    }",
      "    /// Bounds を用いた任意の型 I に対する BFS 訪問順序",
      "    /// # Arguments",
      "    /// * `bounds` - 頂点のインデックス範囲",
      "    /// * `adj` - 頂点を受け取り、隣接する頂点のイテレータを返すクロージャー",
      "    /// * `init` - 始点となる頂点集合のイテレータ",
      "    /// # Returns",
      "    /// 到達可能な頂点を訪問順に格納した `Vec<I>`",
      "    /// # 計算量",
      "    /// O(V + E)",
      "    pub fn bfs_order_arbitrary<I, F, It>(",
      "        bounds: Bounds<I>,",
      "        mut adj: F,",
      "        init: impl IntoIterator<Item = I>,",
      "    ) -> Vec<I>",
      "    where",
      "        I: Ix,",
      "        F: FnMut(I) -> It,",
      "        It: IntoIterator<Item = I>,",
      "    {",
      "        let nv = bounds.range_size();",
      "        let mut adj_usize = |u_idx: usize| {",
      "            let u = bounds.from_index(u_idx);",
      "            adj(u).into_iter().map(move |v| bounds.to_index(v))",
      "        };",
      "        let init_usize = init.into_iter().map(|s| bounds.to_index(s));",
      "        let order_usize = bfs_order(nv, &mut adj_usize, init_usize);",
      "        order_usize",
      "            .into_iter()",
      "            .map(|idx| bounds.from_index(idx))",
      "            .collect()",
      "    }",
      "    /// Bounds を用いた任意の型 I に対する到達可能性判定",
      "    /// # Arguments",
      "    /// * `bounds` - 頂点のインデックス範囲",
      "    /// * `adj` - 頂点を受け取り、隣接する頂点のイテレータを返すクロージャー",
      "    /// * `init` - 始点となる頂点集合のイテレータ",
      "    /// # Returns",
      "    /// 各頂点への到達可能性を格納した `IxVec<I, bool>`",
      "    /// # 計算量",
      "    /// O(V + E)",
      "    pub fn bfs_reachable_arbitrary<I, F, It>(",
      "        bounds: Bounds<I>,",
      "        mut adj: F,",
      "        init: impl IntoIterator<Item = I>,",
      "    ) -> IxVec<I, bool>",
      "    where",
      "        I: Ix,",
      "        F: FnMut(I) -> It,",
      "        It: IntoIterator<Item = I>,",
      "    {",
      "        let nv = bounds.range_size();",
      "        let mut adj_usize = |u_idx: usize| {",
      "            let u = bounds.from_index(u_idx);",
      "            adj(u).into_iter().map(move |v| bounds.to_index(v))",
      "        };",
      "        let init_usize = init.into_iter().map(|s| bounds.to_index(s));",
      "        let res_vec = bfs_reachable(nv, &mut adj_usize, init_usize);",
      "        IxVec::from_vec(bounds, res_vec)",
      "    }",
      "}"
    ]
  },
  "bfs_order": {
    "scope": "rust",
    "prefix": "bfs_order",
    "body": [
      "use mod_queue::*;",
      "pub mod mod_queue {",
      "    use std::collections::VecDeque;",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Queue<T> {",
      "        raw: VecDeque<T>,",
      "    }",
      "    impl<T> Queue<T> {",
      "        pub fn new() -> Self {",
      "            Queue {",
      "                raw: VecDeque::new(),",
      "            }",
      "        }",
      "        pub fn push(&mut self, value: T) {",
      "            self.raw.push_back(value)",
      "        }",
      "        pub fn pop(&mut self) -> Option<T> {",
      "            self.raw.pop_front()",
      "        }",
      "        pub fn peek(&self) -> Option<&T> {",
      "            self.raw.front()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.raw.len()",
      "        }",
      "    }",
      "    impl<T> Default for Queue<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "}",
      "/// 幅優先探索 (BFS) を行い、頂点の訪問順序を返します。",
      "/// # 計算量",
      "/// O(V + E)",
      "pub fn bfs_order(adj: &[Vec<usize>], init: usize) -> Vec<usize> {",
      "    let nv = adj.len();",
      "    let mut order = vec![];",
      "    let mut visited = vec![false; nv];",
      "    let mut open = Queue::new();",
      "    open.push(init);",
      "    order.push(init);",
      "    visited[init] = true;",
      "    while let Some(current) = open.pop() {",
      "        for &next in &adj[current] {",
      "            if !visited[next] {",
      "                order.push(next);",
      "                visited[next] = true;",
      "                open.push(next);",
      "            }",
      "        }",
      "    }",
      "    order",
      "}"
    ]
  },
  "bin_search": {
    "scope": "rust",
    "prefix": "bin_search",
    "body": [
      "/// 二分探索をする。",
      "/// ```text",
      "/// ng ng ng ok ok ok",
      "///          ↑ここの引数の値を返す",
      "/// ```",
      "/// # 計算量",
      "/// O(log(|ok - ng|))",
      "/// ## Arguments",
      "/// * ok != ng",
      "/// * |ok - ng| <= 2^63 - 1, |ok + ng| <= 2^63 - 1",
      "/// * p の定義域について",
      "///     * ng < ok の場合、p は区間 ng..ok で定義されている。",
      "///     * ok < ng の場合、p は区間 ok..ng で定義されている。",
      "/// * p の単調性について",
      "///     * ng < ok の場合、p は単調増加",
      "///     * ok < ng の場合、p は単調減少",
      "/// ## Return",
      "/// * ng < ok の場合: I = { i in ng..ok | p(i) == true } としたとき",
      "///     * I が空でなければ、min I を返す。",
      "///     * I が空ならば、ok を返す。",
      "/// * ok < ng の場合: I = { i in ok..ng | p(i) == true } としたとき",
      "///     * I が空でなければ、max I を返す。",
      "///     * I が空ならば、ok を返す。",
      "pub fn bin_search<F>(mut ok: i64, mut ng: i64, mut p: F) -> i64",
      "where",
      "    F: FnMut(i64) -> bool,",
      "{",
      "    debug_assert!(ok != ng);",
      "    debug_assert!(ok.checked_sub(ng).is_some());",
      "    debug_assert!(ok.checked_add(ng).is_some());",
      "    while num::abs(ok - ng) > 1 {",
      "        let mid = (ok + ng) / 2;",
      "        debug_assert!(mid != ok);",
      "        debug_assert!(mid != ng);",
      "        if p(mid) {",
      "            ok = mid;",
      "        } else {",
      "            ng = mid;",
      "        }",
      "    }",
      "    ok",
      "}"
    ]
  },
  "bin_search_f64": {
    "scope": "rust",
    "prefix": "bin_search_f64",
    "body": [
      "/// 実数領域における二分探索を行い、判定関数 `p` の結果が切り替わる境界値を返す。",
      "/// 100回の反復を行うことで、元の区間幅の 2^-100 倍の精度で境界値を求める。",
      "/// ## 単調性の前提",
      "/// `ok` と `ng` の間において、判定関数 `p` は単調（一箇所でのみ真偽が切り替わる）である必要がある。",
      "/// ## Arguments",
      "/// * `ok`: 判定関数 `p` が `true` を返す値",
      "/// * `ng`: 判定関数 `p` が `false` を返す値",
      "/// * `p`: 判定関数",
      "/// ## Return",
      "/// 判定関数 `p` の結果が切り替わる境界値を返す。",
      "pub fn bin_search_f64<F>(mut ok: f64, mut ng: f64, mut p: F) -> f64",
      "where",
      "    F: FnMut(f64) -> bool,",
      "{",
      "    for _ in 0..100 {",
      "        let mid = (ok + ng) / 2.0;",
      "        if p(mid) {",
      "            ok = mid;",
      "        } else {",
      "            ng = mid;",
      "        }",
      "    }",
      "    ok",
      "}"
    ]
  },
  "bitset": {
    "scope": "rust",
    "prefix": "bitset",
    "body": [
      "use bitset::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod bitset {",
      "    use itertools::Itertools;",
      "    use std::{",
      "        fmt::{Error, Formatter},",
      "        ops::{BitAnd, BitOr, BitXor, Index, IndexMut},",
      "    };",
      "    /// `usize` をビットフラグとして用い、要素数 64 までの集合を管理する構造体です。",
      "    #[derive(Clone, Copy, PartialEq, Eq, Hash)]",
      "    pub struct BitSet {",
      "        bit: usize,",
      "    }",
      "    impl BitSet {",
      "        /// 指定されたビット値を持つ `BitSet` を作成します。",
      "        /// 下から i ビット目 (2^i の位) が 1 であるとき、要素 i が集合に含まれることに対応します。",
      "        #[inline]",
      "        pub fn new(bit: usize) -> BitSet {",
      "            BitSet { bit }",
      "        }",
      "        /// 内部のビット表現を整数として返します。",
      "        pub fn to_bit(self) -> usize {",
      "            self.bit",
      "        }",
      "        /// 範囲 [0, size) で集合に含まれている要素を `Vec<usize>` で返します。",
      "        pub fn to_vec(self, size: usize) -> Vec<usize> {",
      "            (0..size).filter(|i| (self.bit >> i) & 1 == 1).collect_vec()",
      "        }",
      "        /// 範囲 [0, size) で集合に含まれている要素を列挙するイテレータを返します。",
      "        pub fn to_iter(self, size: usize) -> impl Iterator<Item = usize> {",
      "            (0..size).filter(move |i| (self.bit >> i) & 1 == 1)",
      "        }",
      "        /// 指定された要素 `x` が集合に含まれているかを判定します。",
      "        pub fn contains(self, x: usize) -> bool {",
      "            (self.bit >> x) & 1 == 1",
      "        }",
      "        /// 集合に含まれる要素の数を返します。",
      "        pub fn len(self) -> usize {",
      "            self.bit.count_ones() as usize",
      "        }",
      "        /// 集合に含まれる最小の要素を返します。集合が空の場合は `None` を返します。",
      "        pub fn min_element(self) -> Option<usize> {",
      "            if self.is_empty() {",
      "                None",
      "            } else {",
      "                Some(self.bit.trailing_zeros() as usize)",
      "            }",
      "        }",
      "        /// 集合に含まれる最大の要素を返します。集合が空の場合は `None` を返します。",
      "        pub fn max_element(self) -> Option<usize> {",
      "            if self.is_empty() {",
      "                None",
      "            } else {",
      "                Some(usize::BITS as usize - 1 - self.bit.leading_zeros() as usize)",
      "            }",
      "        }",
      "        /// 集合に含まれない最小の非負整数 (MEX) を返します。",
      "        pub fn mex_element(self) -> usize {",
      "            self.bit.trailing_ones() as usize",
      "        }",
      "        /// 要素 `x` を追加した新しい `BitSet` を返します。",
      "        pub fn inserted(self, x: usize) -> BitSet {",
      "            BitSet::new(self.bit | (1 << x))",
      "        }",
      "        /// 要素 `x` を削除した新しい `BitSet` を返します。",
      "        pub fn removed(self, x: usize) -> BitSet {",
      "            BitSet::new(self.bit & !(1 << x))",
      "        }",
      "        /// 空集合を作成します。",
      "        pub fn empty() -> BitSet {",
      "            BitSet::new(0)",
      "        }",
      "        /// 全体集合 [0, size) を作成します。",
      "        pub fn universal_set(size: usize) -> BitSet {",
      "            BitSet::new((1 << size) - 1)",
      "        }",
      "        /// 全体集合を [0, size) としたときの補集合を返します。",
      "        pub fn complement(self, size: usize) -> BitSet {",
      "            BitSet::new(self.bit ^ ((1 << size) - 1))",
      "        }",
      "        /// 差集合 `self \\ other` を返します。",
      "        pub fn set_minus(self, other: BitSet) -> BitSet {",
      "            BitSet::new(self.bit & !other.bit)",
      "        }",
      "        /// 集合が空であるかを判定します。",
      "        pub fn is_empty(self) -> bool {",
      "            self.bit == 0",
      "        }",
      "        /// `self` が `other` の部分集合であるかを判定します。",
      "        pub fn is_subset(self, other: BitSet) -> bool {",
      "            self | other == other",
      "        }",
      "        /// 2つの集合が共通部分を持たない（互いに素である）かを判定します。",
      "        pub fn is_disjoint(self, other: BitSet) -> bool {",
      "            (self.bit & other.bit) == 0",
      "        }",
      "        /// 全体集合 [0, size) のすべての部分集合を列挙するイテレータを返します。",
      "        pub fn all_subset(size: usize) -> impl Iterator<Item = BitSet> {",
      "            (0..(1 << size)).map(BitSet::new)",
      "        }",
      "        /// `self` のすべての部分集合を降順に列挙するイテレータを返します。",
      "        pub fn subsets(self) -> impl Iterator<Item = BitSet> {",
      "            std::iter::successors(Some(self.bit), move |x| {",
      "                if *x == 0 {",
      "                    None",
      "                } else {",
      "                    Some((x - 1) & self.bit)",
      "                }",
      "            })",
      "            .map(BitSet::new)",
      "        }",
      "        /// 全体集合 [0, size) の範囲で、self を部分集合として含むすべての集合を降順に列挙するイテレータを返します。",
      "        pub fn supersets(self, size: usize) -> impl Iterator<Item = BitSet> {",
      "            let complement = Self::universal_set(size).set_minus(self);",
      "            complement.subsets().map(move |s| self | s)",
      "        }",
      "    }",
      "    impl BitAnd for BitSet {",
      "        type Output = BitSet;",
      "        fn bitand(self, rhs: BitSet) -> BitSet {",
      "            BitSet::new(self.bit & rhs.bit)",
      "        }",
      "    }",
      "    impl BitOr for BitSet {",
      "        type Output = BitSet;",
      "        fn bitor(self, rhs: BitSet) -> BitSet {",
      "            BitSet::new(self.bit | rhs.bit)",
      "        }",
      "    }",
      "    impl BitXor for BitSet {",
      "        type Output = BitSet;",
      "        fn bitxor(self, rhs: BitSet) -> BitSet {",
      "            BitSet::new(self.bit ^ rhs.bit)",
      "        }",
      "    }",
      "    use std::fmt::Debug;",
      "    impl Debug for BitSet {",
      "        fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {",
      "            f.write_fmt(format_args!(\"{:#b}\", self.bit))?;",
      "            Ok(())",
      "        }",
      "    }",
      "    impl<T> Index<BitSet> for [T] {",
      "        type Output = T;",
      "        fn index(&self, s: BitSet) -> &Self::Output {",
      "            &self[s.to_bit()]",
      "        }",
      "    }",
      "    impl<T> IndexMut<BitSet> for [T] {",
      "        fn index_mut(&mut self, s: BitSet) -> &mut Self::Output {",
      "            &mut self[s.to_bit()]",
      "        }",
      "    }",
      "    impl<T> Index<BitSet> for Vec<T> {",
      "        type Output = T;",
      "        fn index(&self, s: BitSet) -> &Self::Output {",
      "            &self[..][s]",
      "        }",
      "    }",
      "    impl<T> IndexMut<BitSet> for Vec<T> {",
      "        fn index_mut(&mut self, s: BitSet) -> &mut Self::Output {",
      "            &mut self[..][s]",
      "        }",
      "    }",
      "}"
    ]
  },
  "btree_multiset": {
    "scope": "rust",
    "prefix": "btree_multiset",
    "body": [
      "use btree_multiset::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod btree_multiset {",
      "    use std::{",
      "        borrow::Borrow,",
      "        collections::{btree_map::Range, BTreeMap},",
      "        ops::RangeBounds,",
      "    };",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct BTreeMultiSet<T> {",
      "        map: BTreeMap<T, usize>,",
      "        length: usize,",
      "    }",
      "    impl<T> Default for BTreeMultiSet<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "    impl<T> BTreeMultiSet<T> {",
      "        pub const fn new() -> BTreeMultiSet<T> {",
      "            BTreeMultiSet {",
      "                map: BTreeMap::new(),",
      "                length: 0,",
      "            }",
      "        }",
      "        pub fn range<R>(&self, range: R) -> Range<'_, T, usize>",
      "        where",
      "            T: Ord,",
      "            R: RangeBounds<T>,",
      "        {",
      "            self.map.range(range)",
      "        }",
      "        pub fn iter(&self) -> impl Iterator<Item = &T> {",
      "            self.map",
      "                .iter()",
      "                .flat_map(|(e, cnt)| std::iter::repeat_n(e, *cnt))",
      "        }",
      "        pub fn set_iter(&self) -> impl Iterator<Item = (&T, usize)> {",
      "            self.map.iter().map(|(e, cnt)| (e, *cnt))",
      "        }",
      "        pub fn insert(&mut self, value: T)",
      "        where",
      "            T: Ord,",
      "        {",
      "            *self.map.entry(value).or_insert(0) += 1;",
      "            self.length += 1;",
      "        }",
      "        pub fn remove1<Q>(&mut self, value: &Q) -> bool",
      "        where",
      "            T: Borrow<Q> + Ord,",
      "            Q: ?Sized + Ord,",
      "        {",
      "            if let Some(cnt) = self.map.get_mut(value) {",
      "                *cnt -= 1;",
      "                if *cnt == 0 {",
      "                    self.map.remove(value);",
      "                }",
      "                self.length -= 1;",
      "                return true;",
      "            }",
      "            false",
      "        }",
      "        pub fn remove_all<Q>(&mut self, value: &Q) -> bool",
      "        where",
      "            T: Borrow<Q> + Ord,",
      "            Q: ?Sized + Ord,",
      "        {",
      "            if let Some(cnt) = self.map.get(value) {",
      "                self.length -= cnt;",
      "                self.map.remove(value);",
      "                return true;",
      "            }",
      "            false",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.length",
      "        }",
      "        pub fn set_len(&self) -> usize {",
      "            self.map.len()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.length == 0",
      "        }",
      "        pub fn count<Q>(&self, value: &Q) -> usize",
      "        where",
      "            T: Borrow<Q> + Ord,",
      "            Q: ?Sized + Ord,",
      "        {",
      "            self.map.get(value).copied().unwrap_or(0)",
      "        }",
      "        pub fn contains<Q>(&self, value: &Q) -> bool",
      "        where",
      "            T: Borrow<Q> + Ord,",
      "            Q: ?Sized + Ord,",
      "        {",
      "            self.map.contains_key(value)",
      "        }",
      "    }",
      "    impl<T: Ord> FromIterator<T> for BTreeMultiSet<T> {",
      "        fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> BTreeMultiSet<T> {",
      "            let mut set = BTreeMultiSet::new();",
      "            for x in iter {",
      "                set.insert(x);",
      "            }",
      "            set",
      "        }",
      "    }",
      "}"
    ]
  },
  "calc_dist": {
    "scope": "rust",
    "prefix": "calc_dist",
    "body": [
      "use mod_queue::*;",
      "pub mod mod_queue {",
      "    use std::collections::VecDeque;",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Queue<T> {",
      "        raw: VecDeque<T>,",
      "    }",
      "    impl<T> Queue<T> {",
      "        pub fn new() -> Self {",
      "            Queue {",
      "                raw: VecDeque::new(),",
      "            }",
      "        }",
      "        pub fn push(&mut self, value: T) {",
      "            self.raw.push_back(value)",
      "        }",
      "        pub fn pop(&mut self) -> Option<T> {",
      "            self.raw.pop_front()",
      "        }",
      "        pub fn peek(&self) -> Option<&T> {",
      "            self.raw.front()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.raw.len()",
      "        }",
      "    }",
      "    impl<T> Default for Queue<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "}",
      "/// 指定した始点から各頂点への最短距離（枝数）を求めます。",
      "/// # 計算量",
      "/// O(V + E)",
      "pub fn calc_dist(adj: &[Vec<usize>], init: usize) -> Vec<usize> {",
      "    let nv = adj.len();",
      "    let mut visited = vec![false; nv];",
      "    let mut dist = vec![usize::MAX; nv];",
      "    let mut open = Queue::new();",
      "    visited[init] = true;",
      "    dist[init] = 0;",
      "    open.push(init);",
      "    while let Some(current) = open.pop() {",
      "        for &next in &adj[current] {",
      "            if !visited[next] {",
      "                visited[next] = true;",
      "                dist[next] = dist[current] + 1;",
      "                open.push(next);",
      "            }",
      "        }",
      "    }",
      "    dist",
      "}"
    ]
  },
  "chminmax": {
    "scope": "rust",
    "prefix": "chminmax",
    "body": [
      "#[allow(clippy::module_inception)]",
      "#[macro_use]",
      "pub mod chminmax {",
      "    #[allow(unused_macros)]",
      "    #[macro_export]",
      "    macro_rules! chmin {",
      "        (\\$ a : expr_2021 , \\$ b : expr_2021 ) => {",
      "            if \\$a > \\$b {",
      "                \\$a = \\$b;",
      "                true",
      "            } else {",
      "                false",
      "            }",
      "        };",
      "    }",
      "    #[allow(unused_macros)]",
      "    #[macro_export]",
      "    macro_rules! chmax {",
      "        (\\$ a : expr_2021 , \\$ b : expr_2021 ) => {",
      "            if \\$a < \\$b {",
      "                \\$a = \\$b;",
      "                true",
      "            } else {",
      "                false",
      "            }",
      "        };",
      "    }",
      "}"
    ]
  },
  "coordinate_compression": {
    "scope": "rust",
    "prefix": "coordinate_compression",
    "body": [
      "use coordinate_compression::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod coordinate_compression {",
      "    use itertools::Itertools;",
      "    use superslice::Ext;",
      "    #[derive(Debug, Clone)]",
      "    pub struct CoordinateCompression<T> {",
      "        space: Vec<T>,",
      "    }",
      "    impl<T: Ord + Copy> CoordinateCompression<T> {",
      "        /// # 計算量",
      "        /// O(|space|log(|space|))",
      "        pub fn new(space: &[T]) -> Self {",
      "            let space = space.iter().copied().sorted().dedup().collect_vec();",
      "            Self { space }",
      "        }",
      "        /// # 計算量",
      "        /// O(log(|space|))",
      "        pub fn compress(&self, x: T) -> usize {",
      "            self.space.binary_search(&x).unwrap()",
      "        }",
      "        /// 座標圧縮前の空間のうち x 以下である最大の値を座標圧縮したものを返す",
      "        /// # 計算量",
      "        /// O(log(|space|))",
      "        pub fn compress_floor(&self, x: T) -> usize {",
      "            self.space.upper_bound(&x) - 1",
      "        }",
      "        /// 座標圧縮前の空間のうち x 以上である最小の値を座標圧縮したものを返す",
      "        /// # 計算量",
      "        /// O(log(|space|))",
      "        pub fn compress_ceil(&self, x: T) -> usize {",
      "            self.space.lower_bound(&x)",
      "        }",
      "        /// # 計算量",
      "        /// O(|xs|log(|space|))",
      "        pub fn compress_vec(&self, xs: &[T]) -> Vec<usize> {",
      "            xs.iter().map(|&x| self.compress(x)).collect_vec()",
      "        }",
      "        /// # 計算量",
      "        /// O(1)",
      "        pub fn decompress(&self, i: usize) -> T {",
      "            self.space[i]",
      "        }",
      "        pub fn space_size(&self) -> usize {",
      "            self.space.len()",
      "        }",
      "    }",
      "}"
    ]
  },
  "counts_fx": {
    "scope": "rust",
    "prefix": "counts_fx",
    "body": [
      "use counts_fx::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod counts_fx {",
      "    use rustc_hash::FxHashMap;",
      "    pub trait IteratorCountsFx: Iterator + Sized {",
      "        fn counts_fx(self) -> FxHashMap<Self::Item, usize>",
      "        where",
      "            Self: Sized,",
      "            Self::Item: Eq + std::hash::Hash,",
      "        {",
      "            let mut counts = FxHashMap::default();",
      "            self.for_each(|item| *counts.entry(item).or_default() += 1);",
      "            counts",
      "        }",
      "    }",
      "    impl<T: Iterator> IteratorCountsFx for T {}",
      "}"
    ]
  },
  "counts_vec": {
    "scope": "rust",
    "prefix": "counts_vec",
    "body": [
      "use counts_vec::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod counts_vec {",
      "    pub trait IteratorCountsVec: Iterator<Item = usize> + Sized {",
      "        fn counts_vec(self, size: usize) -> Vec<i64> {",
      "            let mut counts = vec![0; size];",
      "            self.for_each(|item| counts[item] += 1);",
      "            counts",
      "        }",
      "    }",
      "    impl<T: Iterator<Item = usize>> IteratorCountsVec for T {}",
      "}"
    ]
  },
  "cum_monoid": {
    "scope": "rust",
    "prefix": "cum_monoid",
    "body": [
      "use cum_monoid::*;",
      "pub mod cum_monoid {",
      "    use ac_library::{Max, Min, Monoid};",
      "    pub struct CumMonoid<M>",
      "    where",
      "        M: Monoid,",
      "    {",
      "        prefix_prod: Vec<M::S>,",
      "        suffix_prod: Vec<M::S>,",
      "    }",
      "    impl<M> CumMonoid<M>",
      "    where",
      "        M: Monoid,",
      "    {",
      "        pub fn new(xs: &[M::S]) -> CumMonoid<M> {",
      "            let mut prefix_prod = vec![M::identity(); xs.len() + 1];",
      "            let mut suffix_prod = vec![M::identity(); xs.len() + 1];",
      "            for i in 0..xs.len() {",
      "                prefix_prod[i + 1] = M::binary_operation(&prefix_prod[i], &xs[i]);",
      "            }",
      "            for i in (0..xs.len()).rev() {",
      "                suffix_prod[i] = M::binary_operation(&xs[i], &suffix_prod[i + 1]);",
      "            }",
      "            CumMonoid {",
      "                prefix_prod,",
      "                suffix_prod,",
      "            }",
      "        }",
      "        /// [0, i) の総積 (前から累積)",
      "        pub fn prefix_prod(&self, i: usize) -> M::S {",
      "            self.prefix_prod[i].clone()",
      "        }",
      "        /// [i, n) の総積 (後ろから累積)",
      "        pub fn suffix_prod(&self, i: usize) -> M::S {",
      "            self.suffix_prod[i].clone()",
      "        }",
      "        /// [0, i), [i + 1, n) の区間で総積を取る",
      "        pub fn prod_without1(&self, i: usize) -> M::S {",
      "            M::binary_operation(&self.prefix_prod[i], &self.suffix_prod[i + 1])",
      "        }",
      "        pub fn prod_without_range(&self, l: usize, r: usize) -> M::S {",
      "            M::binary_operation(&self.prefix_prod[l], &self.suffix_prod[r])",
      "        }",
      "    }",
      "    pub struct CumMin {",
      "        cum: CumMonoid<Min<i64>>,",
      "    }",
      "    impl CumMin {",
      "        pub fn new(xs: &[i64]) -> CumMin {",
      "            CumMin {",
      "                cum: CumMonoid::new(xs),",
      "            }",
      "        }",
      "        /// [0, i) の総積 (前から累積)",
      "        pub fn prefix_min(&self, i: usize) -> i64 {",
      "            self.cum.prefix_prod(i)",
      "        }",
      "        /// [i, n) の総積 (後ろから累積)",
      "        pub fn suffix_min(&self, i: usize) -> i64 {",
      "            self.cum.suffix_prod(i)",
      "        }",
      "        /// [0, i), [i + 1, n) の区間で総積を取る",
      "        pub fn min_without1(&self, i: usize) -> i64 {",
      "            self.cum.prod_without1(i)",
      "        }",
      "        pub fn min_without_range(&self, l: usize, r: usize) -> i64 {",
      "            self.cum.prod_without_range(l, r)",
      "        }",
      "    }",
      "    pub struct CumMax {",
      "        cum: CumMonoid<Max<i64>>,",
      "    }",
      "    impl CumMax {",
      "        pub fn new(xs: &[i64]) -> CumMax {",
      "            CumMax {",
      "                cum: CumMonoid::new(xs),",
      "            }",
      "        }",
      "        /// [0, i) の総積 (前から累積)",
      "        pub fn prefix_max(&self, i: usize) -> i64 {",
      "            self.cum.prefix_prod(i)",
      "        }",
      "        /// [i, n) の総積 (後ろから累積)",
      "        pub fn suffix_max(&self, i: usize) -> i64 {",
      "            self.cum.suffix_prod(i)",
      "        }",
      "        /// [0, i), [i + 1, n) の区間で総積を取る",
      "        pub fn max_without1(&self, i: usize) -> i64 {",
      "            self.cum.prod_without1(i)",
      "        }",
      "        pub fn max_without_range(&self, l: usize, r: usize) -> i64 {",
      "            self.cum.prod_without_range(l, r)",
      "        }",
      "    }",
      "}"
    ]
  },
  "cumsum": {
    "scope": "rust",
    "prefix": "cumsum",
    "body": [
      "use cumsum::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod cumsum {",
      "    pub fn prefix_sum(xs: &[i64]) -> Vec<i64> {",
      "        let mut prefix_sum = vec![0; xs.len() + 1];",
      "        for i in 1..xs.len() + 1 {",
      "            prefix_sum[i] = prefix_sum[i - 1] + xs[i - 1];",
      "        }",
      "        prefix_sum",
      "    }",
      "    use std::ops::{Bound, Range, RangeBounds};",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct CumSum {",
      "        pub cumsum: Vec<i64>,",
      "    }",
      "    impl CumSum {",
      "        /// # 計算量",
      "        /// O(|xs|)",
      "        pub fn new(xs: &[i64]) -> CumSum {",
      "            let mut cumsum = vec![0; xs.len() + 1];",
      "            for i in 1..xs.len() + 1 {",
      "                cumsum[i] = cumsum[i - 1] + xs[i - 1];",
      "            }",
      "            CumSum { cumsum }",
      "        }",
      "        fn open(&self, range: impl RangeBounds<usize>) -> Range<usize> {",
      "            use Bound::Excluded;",
      "            use Bound::Included;",
      "            use Bound::Unbounded;",
      "            let begin = match range.start_bound() {",
      "                Unbounded => 0,",
      "                Included(&x) => x,",
      "                Excluded(&x) => x + 1,",
      "            };",
      "            let end = match range.end_bound() {",
      "                Excluded(&x) => x,",
      "                Included(&x) => x + 1,",
      "                Unbounded => self.cumsum.len() - 1,",
      "            };",
      "            begin..end",
      "        }",
      "        /// 区間 `[begin, end)` の要素の和を計算します。",
      "        /// # 計算量",
      "        /// O(1)",
      "        pub fn range_sum(&self, range: impl RangeBounds<usize>) -> i64 {",
      "            let range = self.open(range);",
      "            self.cumsum[range.end] - self.cumsum[range.start]",
      "        }",
      "        /// 区間 `[0, end)` での和を計算します。",
      "        /// # 計算量",
      "        /// O(1)",
      "        pub fn prefix_sum(&self, end: usize) -> i64 {",
      "            self.cumsum[end]",
      "        }",
      "        /// 区間 `[begin, n)` の要素の和を計算します。（`n` は元の配列の長さ）",
      "        /// # 計算量",
      "        /// O(1)",
      "        pub fn suffix_sum(&self, begin: usize) -> i64 {",
      "            self.cumsum[self.cumsum.len() - 1] - self.cumsum[begin]",
      "        }",
      "        /// `f(sum(l..r))` が `true` となる最大の `r in [l, n]` を見つける。",
      "        /// `n` は元の配列の長さ。",
      "        /// `f` は単調でなければならない。",
      "        /// `f(sum(l..i))` が `true` => `f(sum(l..j))` が `true` for all `l <= j <= i`.",
      "        /// # Panics",
      "        /// `l > n` の場合にパニックする。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn max_right<F>(&self, l: usize, mut f: F) -> usize",
      "        where",
      "            F: FnMut(i64) -> bool,",
      "        {",
      "            let n = self.cumsum.len() - 1;",
      "            assert!(l <= n);",
      "            assert!(f(0), \"f(0) must be true\");",
      "            if f(self.range_sum(l..n)) {",
      "                return n;",
      "            }",
      "            let mut ok = l;",
      "            let mut ng = n + 1;",
      "            while ng - ok > 1 {",
      "                let mid = ok + (ng - ok) / 2;",
      "                if f(self.range_sum(l..mid)) {",
      "                    ok = mid;",
      "                } else {",
      "                    ng = mid;",
      "                }",
      "            }",
      "            ok",
      "        }",
      "        /// `f(sum(l..r))` が `true` となる最小の `l in [0, r]` を見つける。",
      "        /// `f` は単調でなければならない。",
      "        /// `f(sum(i..r))` が `true` => `f(sum(j..r))` が `true` for all `i <= j <= r`.",
      "        /// `r > n` の場合にパニックする。",
      "        /// # 計算量",
      "        /// O(log r)",
      "        pub fn min_left<F>(&self, r: usize, mut f: F) -> usize",
      "        where",
      "            F: FnMut(i64) -> bool,",
      "        {",
      "            let n = self.cumsum.len() - 1;",
      "            assert!(r <= n);",
      "            assert!(f(0), \"f(0) must be true\");",
      "            if f(self.range_sum(0..r)) {",
      "                return 0;",
      "            }",
      "            let mut ok = r;",
      "            let mut ng = 0;",
      "            while ok - ng > 1 {",
      "                let mid = ng + (ok - ng) / 2;",
      "                if f(self.range_sum(mid..r)) {",
      "                    ok = mid;",
      "                } else {",
      "                    ng = mid;",
      "                }",
      "            }",
      "            ok",
      "        }",
      "    }",
      "}"
    ]
  },
  "cumsum_2d": {
    "scope": "rust",
    "prefix": "cumsum_2d",
    "body": [
      "use cumsum_2d::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod cumsum_2d {",
      "    use std::ops::{Bound, Range, RangeBounds};",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct CumSum2D {",
      "        pub cumsum: Vec<Vec<i64>>,",
      "    }",
      "    impl CumSum2D {",
      "        pub fn new(xss: &[Vec<i64>]) -> CumSum2D {",
      "            if xss.is_empty() {",
      "                return CumSum2D {",
      "                    cumsum: vec![vec![0]],",
      "                };",
      "            }",
      "            let height = xss.len();",
      "            let width = xss[0].len();",
      "            let mut cumsum = vec![vec![0; width + 1]; height + 1];",
      "            for y in 1..height + 1 {",
      "                for x in 1..width + 1 {",
      "                    cumsum[y][x] = cumsum[y - 1][x] + cumsum[y][x - 1] - cumsum[y - 1][x - 1]",
      "                        + xss[y - 1][x - 1];",
      "                }",
      "            }",
      "            CumSum2D { cumsum }",
      "        }",
      "        pub fn rect_sum(",
      "            &self,",
      "            y_range: impl RangeBounds<usize>,",
      "            x_range: impl RangeBounds<usize>,",
      "        ) -> i64 {",
      "            let y_len = self.cumsum.len() - 1;",
      "            let x_len = self.cumsum[0].len() - 1;",
      "            let y_range = open(y_range, y_len);",
      "            let x_range = open(x_range, x_len);",
      "            let y1 = y_range.start;",
      "            let y2 = y_range.end;",
      "            let x1 = x_range.start;",
      "            let x2 = x_range.end;",
      "            self.cumsum[y2][x2] - self.cumsum[y2][x1] - self.cumsum[y1][x2] + self.cumsum[y1][x1]",
      "        }",
      "    }",
      "    fn open(range: impl RangeBounds<usize>, len: usize) -> Range<usize> {",
      "        let begin = match range.start_bound() {",
      "            Bound::Unbounded => 0,",
      "            Bound::Included(&x) => x,",
      "            Bound::Excluded(&x) => x + 1,",
      "        };",
      "        let end = match range.end_bound() {",
      "            Bound::Excluded(&x) => x,",
      "            Bound::Included(&x) => x + 1,",
      "            Bound::Unbounded => len,",
      "        };",
      "        begin..end",
      "    }",
      "}"
    ]
  },
  "cumsum_2d_arbitrary": {
    "scope": "rust",
    "prefix": "cumsum_2d_arbitrary",
    "body": [
      "use ab_group::*;",
      "use cumsum_2d_arbitrary::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod ab_group {",
      "    use std::{",
      "        convert::Infallible,",
      "        iter::Sum,",
      "        marker::PhantomData,",
      "        ops::{Add, Neg, Sub},",
      "    };",
      "    /// 可換群 (Abelian Group)",
      "    pub trait AbGroup {",
      "        type S: Clone;",
      "        fn zero() -> Self::S;",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S;",
      "        fn neg(a: &Self::S) -> Self::S;",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            Self::add(a, &Self::neg(b))",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct AdditiveAbGroup<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T: Sum + Add<Output = T> + Sub<Output = T> + Neg<Output = T> + Copy> AbGroup",
      "        for AdditiveAbGroup<T>",
      "    {",
      "        type S = T;",
      "        fn zero() -> Self::S {",
      "            std::iter::empty().sum()",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a + *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            -(*a)",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a - *b",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct XorAbGroup(Infallible);",
      "    impl AbGroup for XorAbGroup {",
      "        type S = u64;",
      "        fn zero() -> Self::S {",
      "            0",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            *a",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::module_inception)]",
      "pub mod cumsum_2d_arbitrary {",
      "    use super::AbGroup;",
      "    use std::ops::{Bound, Range, RangeBounds};",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct CumSum2dArbitrary<G: AbGroup> {",
      "        pub cumsum: Vec<Vec<G::S>>,",
      "    }",
      "    impl<G: AbGroup> CumSum2dArbitrary<G> {",
      "        pub fn new(xss: &[Vec<G::S>]) -> CumSum2dArbitrary<G> {",
      "            if xss.is_empty() {",
      "                return CumSum2dArbitrary {",
      "                    cumsum: vec![vec![G::zero()]],",
      "                };",
      "            }",
      "            let height = xss.len();",
      "            let width = xss[0].len();",
      "            let mut cumsum = vec![vec![G::zero(); width + 1]; height + 1];",
      "            for y in 1..height + 1 {",
      "                for x in 1..width + 1 {",
      "                    let top = &cumsum[y - 1][x];",
      "                    let left = &cumsum[y][x - 1];",
      "                    let top_left = &cumsum[y - 1][x - 1];",
      "                    let val = &xss[y - 1][x - 1];",
      "                    let term1 = G::add(top, left);",
      "                    let term2 = G::sub(&term1, top_left);",
      "                    cumsum[y][x] = G::add(&term2, val);",
      "                }",
      "            }",
      "            CumSum2dArbitrary { cumsum }",
      "        }",
      "        pub fn rect_sum(",
      "            &self,",
      "            y_range: impl RangeBounds<usize>,",
      "            x_range: impl RangeBounds<usize>,",
      "        ) -> G::S {",
      "            let y_len = self.cumsum.len() - 1;",
      "            let x_len = self.cumsum[0].len() - 1;",
      "            let y_range = open(y_range, y_len);",
      "            let x_range = open(x_range, x_len);",
      "            let y1 = y_range.start;",
      "            let y2 = y_range.end;",
      "            let x1 = x_range.start;",
      "            let x2 = x_range.end;",
      "            let bottom_right = &self.cumsum[y2][x2];",
      "            let bottom_left = &self.cumsum[y2][x1];",
      "            let top_right = &self.cumsum[y1][x2];",
      "            let top_left = &self.cumsum[y1][x1];",
      "            let term1 = G::sub(bottom_right, bottom_left);",
      "            let term2 = G::sub(top_right, top_left);",
      "            G::sub(&term1, &term2)",
      "        }",
      "    }",
      "    fn open(range: impl RangeBounds<usize>, len: usize) -> Range<usize> {",
      "        let begin = match range.start_bound() {",
      "            Bound::Unbounded => 0,",
      "            Bound::Included(&x) => x,",
      "            Bound::Excluded(&x) => x + 1,",
      "        };",
      "        let end = match range.end_bound() {",
      "            Bound::Excluded(&x) => x,",
      "            Bound::Included(&x) => x + 1,",
      "            Bound::Unbounded => len,",
      "        };",
      "        begin..end",
      "    }",
      "}"
    ]
  },
  "cumsum_arbitrary": {
    "scope": "rust",
    "prefix": "cumsum_arbitrary",
    "body": [
      "use ab_group::*;",
      "use cumsum_arbitrary::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod ab_group {",
      "    use std::{",
      "        convert::Infallible,",
      "        iter::Sum,",
      "        marker::PhantomData,",
      "        ops::{Add, Neg, Sub},",
      "    };",
      "    /// 可換群 (Abelian Group)",
      "    pub trait AbGroup {",
      "        type S: Clone;",
      "        fn zero() -> Self::S;",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S;",
      "        fn neg(a: &Self::S) -> Self::S;",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            Self::add(a, &Self::neg(b))",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct AdditiveAbGroup<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T: Sum + Add<Output = T> + Sub<Output = T> + Neg<Output = T> + Copy> AbGroup",
      "        for AdditiveAbGroup<T>",
      "    {",
      "        type S = T;",
      "        fn zero() -> Self::S {",
      "            std::iter::empty().sum()",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a + *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            -(*a)",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a - *b",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct XorAbGroup(Infallible);",
      "    impl AbGroup for XorAbGroup {",
      "        type S = u64;",
      "        fn zero() -> Self::S {",
      "            0",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            *a",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::module_inception)]",
      "pub mod cumsum_arbitrary {",
      "    use super::AbGroup;",
      "    use std::ops::{Bound, Range, RangeBounds};",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct CumSumArbitrary<G: AbGroup> {",
      "        pub cumsum: Vec<G::S>,",
      "    }",
      "    impl<G: AbGroup> CumSumArbitrary<G> {",
      "        /// # 計算量",
      "        /// O(|xs|)",
      "        pub fn new(xs: &[G::S]) -> CumSumArbitrary<G> {",
      "            let mut cumsum = Vec::with_capacity(xs.len() + 1);",
      "            cumsum.push(G::zero());",
      "            for x in xs {",
      "                let last = cumsum.last().unwrap();",
      "                cumsum.push(G::add(last, x));",
      "            }",
      "            CumSumArbitrary { cumsum }",
      "        }",
      "        fn open(&self, range: impl RangeBounds<usize>) -> Range<usize> {",
      "            use Bound::Excluded;",
      "            use Bound::Included;",
      "            use Bound::Unbounded;",
      "            let begin = match range.start_bound() {",
      "                Unbounded => 0,",
      "                Included(&x) => x,",
      "                Excluded(&x) => x + 1,",
      "            };",
      "            let end = match range.end_bound() {",
      "                Excluded(&x) => x,",
      "                Included(&x) => x + 1,",
      "                Unbounded => self.cumsum.len() - 1,",
      "            };",
      "            begin..end",
      "        }",
      "        /// 区間 `[begin, end)` の要素の和を計算します。",
      "        /// # 計算量",
      "        /// O(1)",
      "        pub fn range_sum(&self, range: impl RangeBounds<usize>) -> G::S {",
      "            let range = self.open(range);",
      "            G::sub(&self.cumsum[range.end], &self.cumsum[range.start])",
      "        }",
      "        /// 区間 `[0, end)` での和を計算します。",
      "        /// # 計算量",
      "        /// O(1)",
      "        pub fn prefix_sum(&self, end: usize) -> G::S {",
      "            self.cumsum[end].clone()",
      "        }",
      "        /// 区間 `[begin, n)` の要素の和を計算します。（`n` は元の配列の長さ）",
      "        /// # 計算量",
      "        /// O(1)",
      "        pub fn suffix_sum(&self, begin: usize) -> G::S {",
      "            G::sub(&self.cumsum[self.cumsum.len() - 1], &self.cumsum[begin])",
      "        }",
      "        /// `f(sum(l..r))` が `true` となる最大の `r in [l, n]` を見つける。",
      "        /// `n` は元の配列の長さ。",
      "        /// `f` は単調でなければならない。",
      "        /// `f(sum(l..i))` が `true` => `f(sum(l..j))` が `true` for all `l <= j <= i`.",
      "        /// # Panics",
      "        /// `l > n` の場合にパニックする。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn max_right<F>(&self, l: usize, mut f: F) -> usize",
      "        where",
      "            F: FnMut(G::S) -> bool,",
      "        {",
      "            let n = self.cumsum.len() - 1;",
      "            assert!(l <= n);",
      "            assert!(f(G::zero()), \"f(0) must be true\");",
      "            if f(self.range_sum(l..n)) {",
      "                return n;",
      "            }",
      "            let mut ok = l;",
      "            let mut ng = n + 1;",
      "            while ng - ok > 1 {",
      "                let mid = ok + (ng - ok) / 2;",
      "                if f(self.range_sum(l..mid)) {",
      "                    ok = mid;",
      "                } else {",
      "                    ng = mid;",
      "                }",
      "            }",
      "            ok",
      "        }",
      "        /// `f(sum(l..r))` が `true` となる最小の `l in [0, r]` を見つける。",
      "        /// `f` は単調でなければならない。",
      "        /// `f(sum(i..r))` が `true` => `f(sum(j..r))` が `true` for all `i <= j <= r`.",
      "        /// `r > n` の場合にパニックする。",
      "        /// # 計算量",
      "        /// O(log r)",
      "        pub fn min_left<F>(&self, r: usize, mut f: F) -> usize",
      "        where",
      "            F: FnMut(G::S) -> bool,",
      "        {",
      "            let n = self.cumsum.len() - 1;",
      "            assert!(r <= n);",
      "            assert!(f(G::zero()), \"f(0) must be true\");",
      "            if f(self.range_sum(0..r)) {",
      "                return 0;",
      "            }",
      "            let mut ok = r;",
      "            let mut ng = 0;",
      "            while ok - ng > 1 {",
      "                let mid = ng + (ok - ng) / 2;",
      "                if f(self.range_sum(mid..r)) {",
      "                    ok = mid;",
      "                } else {",
      "                    ng = mid;",
      "                }",
      "            }",
      "            ok",
      "        }",
      "    }",
      "}"
    ]
  },
  "cycle_detection": {
    "scope": "rust",
    "prefix": "cycle_detection",
    "body": [
      "pub mod cycle_detection {",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    struct EdgeIndex {",
      "        src: usize,",
      "        dst: usize,",
      "        idx: usize,",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    struct CycleDetectionSolver {",
      "        nv: usize,",
      "        adj: Vec<Vec<EdgeIndex>>,",
      "    }",
      "    impl CycleDetectionSolver {",
      "        fn new(nv: usize, edges: &[(usize, usize)]) -> CycleDetectionSolver {",
      "            let edges = edges",
      "                .iter()",
      "                .copied()",
      "                .enumerate()",
      "                .map(|(i, e)| EdgeIndex {",
      "                    src: e.0,",
      "                    dst: e.1,",
      "                    idx: i,",
      "                })",
      "                .collect::<Vec<_>>();",
      "            let adj = edges.iter().copied().fold(vec![vec![]; nv], |mut acc, e| {",
      "                acc[e.src].push(e);",
      "                acc",
      "            });",
      "            CycleDetectionSolver { nv, adj }",
      "        }",
      "        fn dfs(",
      "            &self,",
      "            current_v: usize,",
      "            prev_e: Option<EdgeIndex>,",
      "            visited_pre: &mut Vec<bool>,",
      "            visited_post: &mut Vec<bool>,",
      "            history: &mut Vec<EdgeIndex>,",
      "        ) -> Option<usize> {",
      "            visited_pre[current_v] = true;",
      "            if let Some(prev_e) = prev_e {",
      "                assert_eq!(current_v, prev_e.dst);",
      "                history.push(prev_e);",
      "            }",
      "            for e in &self.adj[current_v] {",
      "                if visited_pre[e.dst] && !visited_post[e.dst] {",
      "                    history.push(*e);",
      "                    return Some(e.dst);",
      "                }",
      "                if visited_pre[e.dst] {",
      "                    continue;",
      "                }",
      "                let vertex_on_cycle = self.dfs(e.dst, Some(*e), visited_pre, visited_post, history);",
      "                if vertex_on_cycle.is_some() {",
      "                    return vertex_on_cycle;",
      "                }",
      "            }",
      "            history.pop();",
      "            visited_post[current_v] = true;",
      "            None",
      "        }",
      "        fn construct_cycle(&self, vertex_on_cycle: usize, history: &[EdgeIndex]) -> Vec<usize> {",
      "            let mut rev_cycle = vec![];",
      "            for e in history.iter().rev() {",
      "                rev_cycle.push(*e);",
      "                if e.src == vertex_on_cycle {",
      "                    break;",
      "                }",
      "            }",
      "            rev_cycle.iter().copied().rev().map(|e| e.idx).collect()",
      "        }",
      "        fn solve(&self) -> Option<Vec<usize>> {",
      "            let mut visited_pre = vec![false; self.nv];",
      "            let mut visited_post = vec![false; self.nv];",
      "            for start in 0..self.nv {",
      "                if visited_pre[start] {",
      "                    continue;",
      "                }",
      "                let mut history = vec![];",
      "                let vertex_on_cycle = self.dfs(",
      "                    start,",
      "                    None,",
      "                    &mut visited_pre,",
      "                    &mut visited_post,",
      "                    &mut history,",
      "                );",
      "                if let Some(vertex_on_cycle) = vertex_on_cycle {",
      "                    return Some(self.construct_cycle(vertex_on_cycle, &history));",
      "                }",
      "            }",
      "            None",
      "        }",
      "    }",
      "    /// 与えられた有向グラフにサイクルが存在するか判定して、存在したらサイクル上の点を返す",
      "    /// 有向グラフは以下の２つの情報で与えられる。",
      "    /// * `nv`: 頂点の数 `nv`",
      "    /// * `edges`: 辺のリスト。辺は始点と終点のペアで与えられる",
      "    /// # Returns",
      "    /// サイクルが見つかった場合は `Some` でサイクル上の頂点のインデックス（辺のインデックス）のリストを返し、見つからなかった場合は `None` を返す。",
      "    /// 返されるリストはサイクルの辺のインデックスである。",
      "    /// # 計算量",
      "    /// O(V + E) (V は頂点の数, E は辺の数)",
      "    pub fn cycle_detection(nv: usize, edges: &[(usize, usize)]) -> Option<Vec<usize>> {",
      "        CycleDetectionSolver::new(nv, edges).solve()",
      "    }",
      "}"
    ]
  },
  "default_hash_map": {
    "scope": "rust",
    "prefix": "default_hash_map",
    "body": [
      "use default_hash_map::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod default_hash_map {",
      "    use std::hash::Hash;",
      "    use std::{",
      "        borrow::Borrow,",
      "        collections::{",
      "            hash_map::{Iter, IterMut, Keys, Values, ValuesMut},",
      "            HashMap,",
      "        },",
      "    };",
      "    #[derive(Clone, Debug)]",
      "    pub struct DefaultHashMap<K, V> {",
      "        raw: HashMap<K, V>,",
      "        default: V,",
      "    }",
      "    impl<K, V> DefaultHashMap<K, V> {",
      "        pub fn new(default: V) -> DefaultHashMap<K, V> {",
      "            DefaultHashMap {",
      "                raw: HashMap::new(),",
      "                default,",
      "            }",
      "        }",
      "        pub fn from_hash_map(hash_map: HashMap<K, V>, default: V) -> DefaultHashMap<K, V> {",
      "            DefaultHashMap {",
      "                raw: hash_map,",
      "                default,",
      "            }",
      "        }",
      "        pub fn raw(&mut self) -> &mut HashMap<K, V> {",
      "            &mut self.raw",
      "        }",
      "        pub fn keys(&self) -> Keys<'_, K, V> {",
      "            self.raw.keys()",
      "        }",
      "        pub fn values(&self) -> Values<'_, K, V> {",
      "            self.raw.values()",
      "        }",
      "        pub fn values_mut(&mut self) -> ValuesMut<'_, K, V> {",
      "            self.raw.values_mut()",
      "        }",
      "        pub fn iter(&self) -> Iter<'_, K, V> {",
      "            self.raw.iter()",
      "        }",
      "        pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {",
      "            self.raw.iter_mut()",
      "        }",
      "        pub fn len(&mut self) -> usize {",
      "            self.raw.len()",
      "        }",
      "        pub fn is_empty(&mut self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "    }",
      "    impl<K, V> DefaultHashMap<K, V>",
      "    where",
      "        K: Eq + Hash,",
      "    {",
      "        pub fn get<Q>(&self, k: &Q) -> &V",
      "        where",
      "            K: Borrow<Q>,",
      "            Q: ?Sized + Hash + Eq,",
      "        {",
      "            self.raw.get(k).unwrap_or(&self.default)",
      "        }",
      "        pub fn get_mut(&mut self, k: K) -> &mut V",
      "        where",
      "            V: Clone,",
      "        {",
      "            self.raw.entry(k).or_insert(self.default.clone())",
      "        }",
      "        pub fn insert(&mut self, k: K, v: V) -> Option<V> {",
      "            self.raw.insert(k, v)",
      "        }",
      "        pub fn remove<Q>(&mut self, k: &Q) -> Option<V>",
      "        where",
      "            K: Borrow<Q>,",
      "            Q: ?Sized + Hash + Eq,",
      "        {",
      "            self.raw.remove(k)",
      "        }",
      "    }",
      "    impl<K, V> PartialEq for DefaultHashMap<K, V>",
      "    where",
      "        K: Eq + Hash,",
      "        V: PartialEq,",
      "    {",
      "        fn eq(&self, other: &DefaultHashMap<K, V>) -> bool {",
      "            self.raw == other.raw && self.default == other.default",
      "        }",
      "    }",
      "    impl<K, V> Eq for DefaultHashMap<K, V>",
      "    where",
      "        K: Eq + Hash,",
      "        V: Eq,",
      "    {",
      "    }",
      "    impl<K, V> Default for DefaultHashMap<K, V>",
      "    where",
      "        V: Default,",
      "    {",
      "        fn default() -> DefaultHashMap<K, V> {",
      "            DefaultHashMap::new(V::default())",
      "        }",
      "    }",
      "    impl<K, V> std::ops::Index<K> for DefaultHashMap<K, V>",
      "    where",
      "        K: Eq + Hash,",
      "    {",
      "        type Output = V;",
      "        #[inline]",
      "        fn index(&self, key: K) -> &V {",
      "            self.get(&key)",
      "        }",
      "    }",
      "    impl<K, V> std::ops::IndexMut<K> for DefaultHashMap<K, V>",
      "    where",
      "        K: Eq + Hash,",
      "        V: Clone,",
      "    {",
      "        #[inline]",
      "        fn index_mut(&mut self, key: K) -> &mut V {",
      "            self.get_mut(key)",
      "        }",
      "    }",
      "}"
    ]
  },
  "define_queries_macro": {
    "scope": "rust",
    "prefix": "define_queries_macro",
    "body": [
      "#[macro_use]",
      "pub mod define_queries {",
      "    /// クエリ形式の入力を proconio::input! で読み込める enum を定義するマクロ。",
      "    /// 出典： https://zenn.dev/magurofly/articles/6ee845bd5e385e",
      "    /// # 利用例",
      "    /// ```",
      "    /// use mylib::define_queries;",
      "    /// use proconio::marker::Usize1;",
      "    /// define_queries! {",
      "    ///     #[derive(Debug, PartialEq)]",
      "    ///     enum Query: usize {",
      "    ///         1 => Add { a: i64, b: i64 },",
      "    ///         2 => Show { k: Usize1 },",
      "    ///     }",
      "    /// }",
      "    /// ```",
      "    #[macro_export]",
      "    macro_rules ! define_queries {(\\$ (\\$ (# [\\$ attr : meta ] ) * enum \\$ enum_name : ident : \\$ sig : ty {\\$ (\\$ pattern : pat => \\$ variant : ident \\$ ({\\$ (\\$ name : ident : \\$ marker : ty \\$ (, ) ? ) ,* } ) ? \\$ (, ) ? ) ,* } ) * ) => {\\$ (\\$ (# [\\$ attr ] ) * enum \\$ enum_name {\\$ (\\$ variant \\$ ({\\$ (\\$ name : <\\$ marker as proconio :: source :: Readable >:: Output ) ,* } ) ? ) ,* } impl proconio :: source :: Readable for \\$ enum_name {type Output = Self ; fn read < R : std :: io :: BufRead , S : proconio :: source :: Source < R >> (source : & mut S ) -> Self {#! [allow (unreachable_patterns ) ] match <\\$ sig as proconio :: source :: Readable >:: read (source ) {\\$ (\\$ pattern => \\$ enum_name ::\\$ variant \\$ ({\\$ (\\$ name : <\\$ marker as proconio :: source :: Readable >:: read (source ) ) ,* } ) ? ) ,* , _ => unreachable ! () } } } ) * } }",
      "}"
    ]
  },
  "dfs_post_order": {
    "scope": "rust",
    "prefix": "dfs_post_order",
    "body": [
      "use mod_stack::*;",
      "pub mod mod_stack {",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Stack<T> {",
      "        raw: Vec<T>,",
      "    }",
      "    impl<T> Stack<T> {",
      "        pub fn new() -> Self {",
      "            Stack { raw: Vec::new() }",
      "        }",
      "        pub fn push(&mut self, value: T) {",
      "            self.raw.push(value)",
      "        }",
      "        pub fn pop(&mut self) -> Option<T> {",
      "            self.raw.pop()",
      "        }",
      "        pub fn peek(&self) -> Option<&T> {",
      "            self.raw.last()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.raw.len()",
      "        }",
      "    }",
      "    impl<T> Default for Stack<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "}",
      "/// 深さ優先探索 (DFS) を行い、帰りがけ順 (post-order) での頂点順序を返します。",
      "/// # 計算量",
      "/// O(V + E)",
      "pub fn dfs_post_order(adj: &[Vec<usize>], init: usize) -> Vec<usize> {",
      "    fn dfs(",
      "        adj: &[Vec<usize>],",
      "        current: usize,",
      "        visited: &mut Vec<bool>,",
      "        post_order: &mut Vec<usize>,",
      "    ) {",
      "        visited[current] = true;",
      "        for &next in &adj[current] {",
      "            if !visited[next] {",
      "                dfs(adj, next, visited, post_order);",
      "            }",
      "        }",
      "        post_order.push(current);",
      "    }",
      "    let nv = adj.len();",
      "    let mut visited = vec![false; nv];",
      "    let mut post_order = vec![];",
      "    dfs(adj, init, &mut visited, &mut post_order);",
      "    post_order",
      "}"
    ]
  },
  "dfs_pre_order": {
    "scope": "rust",
    "prefix": "dfs_pre_order",
    "body": [
      "use mod_stack::*;",
      "pub mod mod_stack {",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Stack<T> {",
      "        raw: Vec<T>,",
      "    }",
      "    impl<T> Stack<T> {",
      "        pub fn new() -> Self {",
      "            Stack { raw: Vec::new() }",
      "        }",
      "        pub fn push(&mut self, value: T) {",
      "            self.raw.push(value)",
      "        }",
      "        pub fn pop(&mut self) -> Option<T> {",
      "            self.raw.pop()",
      "        }",
      "        pub fn peek(&self) -> Option<&T> {",
      "            self.raw.last()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.raw.len()",
      "        }",
      "    }",
      "    impl<T> Default for Stack<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "}",
      "/// 深さ優先探索 (DFS) を行い、行きがけ順 (pre-order) での頂点順序を返します。",
      "/// # 計算量",
      "/// O(V + E)",
      "pub fn dfs_pre_order(adj: &[Vec<usize>], init: usize) -> Vec<usize> {",
      "    fn dfs(",
      "        adj: &[Vec<usize>],",
      "        current: usize,",
      "        visited: &mut Vec<bool>,",
      "        pre_order: &mut Vec<usize>,",
      "    ) {",
      "        visited[current] = true;",
      "        pre_order.push(current);",
      "        for &next in &adj[current] {",
      "            if !visited[next] {",
      "                dfs(adj, next, visited, pre_order);",
      "            }",
      "        }",
      "    }",
      "    let nv = adj.len();",
      "    let mut visited = vec![false; nv];",
      "    let mut pre_order = vec![];",
      "    dfs(adj, init, &mut visited, &mut pre_order);",
      "    pre_order",
      "}"
    ]
  },
  "dijkstra": {
    "scope": "rust",
    "prefix": "dijkstra",
    "body": [
      "use dijkstra::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod dijkstra {",
      "    use std::cmp::Reverse;",
      "    use std::collections::BinaryHeap;",
      "    /// ダイクストラ法の実行結果（最短距離と経路復元情報）を保持する構造体です。",
      "    #[derive(Clone, Debug)]",
      "    pub struct DijkstraResult {",
      "        /// 各頂点への最短距離です。到達不可能な場合は `None` となります。",
      "        pub dist: Vec<Option<i64>>,",
      "        /// 経路復元用の親頂点インデックスです。",
      "        pub prev: Vec<Option<usize>>,",
      "    }",
      "    impl DijkstraResult {",
      "        /// 頂点 `t` への最短経路を復元する（始点 -> ... -> t）",
      "        /// # Returns",
      "        /// 始点から `t` までの頂点列。`t` に到達不可能な場合は `None`。",
      "        /// # 計算量",
      "        /// O(経路の長さ)",
      "        pub fn restore(&self, t: usize) -> Option<Vec<usize>> {",
      "            self.dist[t]?;",
      "            let mut path: Vec<_> =",
      "                std::iter::successors(Some(t), |&curr| self.prev[curr]).collect();",
      "            path.reverse();",
      "            Some(path)",
      "        }",
      "    }",
      "    /// 非負コストの辺のみで構成されるグラフに対して、ダイクストラ法を用いて最短距離を求めます。",
      "    /// # Arguments",
      "    /// * `nv` - 頂点数",
      "    /// * `adj` - 頂点を受け取り、隣接する頂点とそのコストのペアのイテレータを返すクロージャー",
      "    /// * `init` - 始点となる頂点集合のイテレータ",
      "    /// # Returns",
      "    /// 始点集合 `init` からの最短距離を格納した `Vec<Option<i64>>`。到達不可能な頂点は `None`。",
      "    /// # 計算量",
      "    /// O(V + E log V)",
      "    pub fn dijkstra<F, It>(",
      "        nv: usize,",
      "        mut adj: F,",
      "        init: impl IntoIterator<Item = usize>,",
      "    ) -> Vec<Option<i64>>",
      "    where",
      "        F: FnMut(usize) -> It,",
      "        It: IntoIterator<Item = (usize, i64)>,",
      "    {",
      "        let mut dist = vec![None; nv];",
      "        let mut pq = BinaryHeap::new();",
      "        for s in init {",
      "            if dist[s].is_none() {",
      "                dist[s] = Some(0);",
      "                pq.push(Reverse((0, s)));",
      "            }",
      "        }",
      "        while let Some(Reverse((d, u))) = pq.pop() {",
      "            if dist[u].is_some_and(|cur| cur < d) {",
      "                continue;",
      "            }",
      "            for (v, cost) in adj(u) {",
      "                assert!(cost >= 0, \"cost must be non-negative\");",
      "                let next_d = d + cost;",
      "                if dist[v].is_none_or(|cur| cur > next_d) {",
      "                    dist[v] = Some(next_d);",
      "                    pq.push(Reverse((next_d, v)));",
      "                }",
      "            }",
      "        }",
      "        dist",
      "    }",
      "    /// 経路復元が可能なダイクストラ法を実行します。",
      "    /// # Arguments",
      "    /// * `nv` - 頂点数",
      "    /// * `adj` - 頂点を受け取り、隣接する頂点とそのコストのペアのイテレータを返すクロージャー",
      "    /// * `init` - 始点となる頂点集合のイテレータ",
      "    /// # Returns",
      "    /// 最短距離 `dist` と、復元用配列 `prev` を含む `DijkstraResult`。",
      "    /// # 計算量",
      "    /// O(V + E log V)",
      "    pub fn dijkstra_with_restore<F, It>(",
      "        nv: usize,",
      "        mut adj: F,",
      "        init: impl IntoIterator<Item = usize>,",
      "    ) -> DijkstraResult",
      "    where",
      "        F: FnMut(usize) -> It,",
      "        It: IntoIterator<Item = (usize, i64)>,",
      "    {",
      "        let mut dist = vec![None; nv];",
      "        let mut prev = vec![None; nv];",
      "        let mut pq = BinaryHeap::new();",
      "        for s in init {",
      "            if dist[s].is_none() {",
      "                dist[s] = Some(0);",
      "                pq.push(Reverse((0, s)));",
      "            }",
      "        }",
      "        while let Some(Reverse((d, u))) = pq.pop() {",
      "            if dist[u].is_some_and(|cur| cur < d) {",
      "                continue;",
      "            }",
      "            for (v, cost) in adj(u) {",
      "                assert!(cost >= 0, \"cost must be non-negative\");",
      "                let next_d = d + cost;",
      "                if dist[v].is_none_or(|cur| cur > next_d) {",
      "                    dist[v] = Some(next_d);",
      "                    prev[v] = Some(u);",
      "                    pq.push(Reverse((next_d, v)));",
      "                }",
      "            }",
      "        }",
      "        DijkstraResult { dist, prev }",
      "    }",
      "}"
    ]
  },
  "dijkstra_ix": {
    "scope": "rust",
    "prefix": "dijkstra_ix",
    "body": [
      "use dijkstra_ix::*;",
      "pub mod dijkstra_ix {",
      "    use super::dijkstra::{dijkstra, dijkstra_with_restore};",
      "    use super::{Bounds, Ix, IxVec};",
      "    /// ダイクストラ法の結果（Ix版）",
      "    #[derive(Clone, Debug)]",
      "    pub struct DijkstraIxResult<I: Ix> {",
      "        /// 各頂点への最短距離です。",
      "        pub dist: IxVec<I, Option<i64>>,",
      "        /// 経路復元用の親頂点情報です。",
      "        pub prev: IxVec<I, Option<I>>,",
      "    }",
      "    impl<I: Ix> DijkstraIxResult<I> {",
      "        /// 頂点 `t` への最短経路を復元する（始点 -> ... -> t）",
      "        /// # Returns",
      "        /// 始点から `t` までの頂点列。`t` に到達不可能な場合は `None`。",
      "        /// # 計算量",
      "        /// O(経路の長さ)",
      "        pub fn restore(&self, t: I) -> Option<Vec<I>> {",
      "            self.dist[t]?;",
      "            let mut path: Vec<_> =",
      "                std::iter::successors(Some(t), |&curr| self.prev[curr]).collect();",
      "            path.reverse();",
      "            Some(path)",
      "        }",
      "    }",
      "    /// Bounds を用いた任意の型 I に対するダイクストラ法",
      "    /// # Arguments",
      "    /// * `bounds` - 頂点のインデックス範囲",
      "    /// * `adj` - 頂点を受け取り、隣接する頂点とそのコストのペアのイテレータを返すクロージャー",
      "    /// * `init` - 始点となる頂点集合のイテレータ",
      "    /// # Returns",
      "    /// 始点集合 `init` からの最短距離を格納した `IxVec<I, Option<i64>>`。",
      "    /// # 計算量",
      "    /// O(V + E log V)",
      "    pub fn dijkstra_arbitrary<I, F, It>(",
      "        bounds: Bounds<I>,",
      "        mut adj: F,",
      "        init: impl IntoIterator<Item = I>,",
      "    ) -> IxVec<I, Option<i64>>",
      "    where",
      "        I: Ix,",
      "        F: FnMut(I) -> It,",
      "        It: IntoIterator<Item = (I, i64)>,",
      "    {",
      "        let nv = bounds.range_size();",
      "        let mut adj_usize = |u_idx: usize| {",
      "            let u = bounds.from_index(u_idx);",
      "            adj(u)",
      "                .into_iter()",
      "                .map(move |(v, cost)| (bounds.to_index(v), cost))",
      "        };",
      "        let init_usize = init.into_iter().map(|s| bounds.to_index(s));",
      "        let res_vec = dijkstra(nv, &mut adj_usize, init_usize);",
      "        IxVec::from_vec(bounds, res_vec)",
      "    }",
      "    /// Bounds を用いた任意の型 I に対するダイクストラ法 (経路復元付き)",
      "    /// # Arguments",
      "    /// * `bounds` - 頂点のインデックス範囲",
      "    /// * `adj` - 頂点を受け取り、隣接する頂点とそのコストのペアのイテレータを返すクロージャー",
      "    /// * `init` - 始点となる頂点集合のイテレータ",
      "    /// # Returns",
      "    /// 最短距離 `dist` と、復元用配列 `prev` を含む `DijkstraIxResult`。",
      "    /// # 計算量",
      "    /// O(V + E log V)",
      "    pub fn dijkstra_with_restore_arbitrary<I, F, It>(",
      "        bounds: Bounds<I>,",
      "        mut adj: F,",
      "        init: impl IntoIterator<Item = I>,",
      "    ) -> DijkstraIxResult<I>",
      "    where",
      "        I: Ix,",
      "        F: FnMut(I) -> It,",
      "        It: IntoIterator<Item = (I, i64)>,",
      "    {",
      "        let nv = bounds.range_size();",
      "        let mut adj_usize = |u_idx: usize| {",
      "            let u = bounds.from_index(u_idx);",
      "            adj(u)",
      "                .into_iter()",
      "                .map(move |(v, cost)| (bounds.to_index(v), cost))",
      "        };",
      "        let init_usize = init.into_iter().map(|s| bounds.to_index(s));",
      "        let res = dijkstra_with_restore(nv, &mut adj_usize, init_usize);",
      "        DijkstraIxResult {",
      "            dist: IxVec::from_vec(bounds, res.dist),",
      "            prev: IxVec::from_vec(",
      "                bounds,",
      "                res.prev",
      "                    .into_iter()",
      "                    .map(|p| p.map(|idx| bounds.from_index(idx)))",
      "                    .collect(),",
      "            ),",
      "        }",
      "    }",
      "}"
    ]
  },
  "divisors": {
    "scope": "rust",
    "prefix": "divisors",
    "body": [
      "/// n の正の約数を列挙する。",
      "/// # 計算量",
      "/// O(sqrt(n))",
      "pub fn divisors(n: i64) -> Vec<i64> {",
      "    use num::Integer;",
      "    use num_integer::Roots;",
      "    assert!(n >= 1);",
      "    let mut retval: Vec<i64> = Vec::new();",
      "    for i in 1..=n.sqrt() {",
      "        if n.is_multiple_of(&i) {",
      "            retval.push(i);",
      "            if i * i != n {",
      "                retval.push(n / i);",
      "            }",
      "        }",
      "    }",
      "    retval",
      "}"
    ]
  },
  "doubling": {
    "scope": "rust",
    "prefix": "doubling",
    "body": [
      "use doubling::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod doubling {",
      "    #[derive(Clone, Debug)]",
      "    pub struct Doubling {",
      "        n: usize,",
      "        log: usize,",
      "        dp: Vec<Vec<usize>>,",
      "    }",
      "    impl Doubling {",
      "        /// doubling 前処理の構築をする。",
      "        /// # Arguments",
      "        /// * `f` - 各頂点の遷移先",
      "        /// * `k` - 合成回数の最大値 (`k>=1`)",
      "        /// # 計算量",
      "        /// O(n log k) (n = f.len())",
      "        pub fn new(f: &[usize], k: usize) -> Doubling {",
      "            let n = f.len();",
      "            let log = (usize::BITS - k.leading_zeros()) as usize;",
      "            let mut dp = vec![vec![0; n]; log];",
      "            if k >= 1 {",
      "                dp[0] = f.to_vec();",
      "            }",
      "            for i in 1..log {",
      "                for x in 0..n {",
      "                    let fp = &dp[i - 1];",
      "                    dp[i][x] = fp[fp[x]];",
      "                }",
      "            }",
      "            Doubling { n, log, dp }",
      "        }",
      "        /// `(f の k 回合成)(x)` を求める。",
      "        /// # 計算量",
      "        /// O(log k)",
      "        pub fn eval(&self, k: usize, x: usize) -> usize {",
      "            assert!((0..self.n).contains(&x));",
      "            assert!(k < (1 << self.log));",
      "            if k == 0 {",
      "                return x;",
      "            }",
      "            let k_bits = (usize::BITS - k.leading_zeros()) as usize;",
      "            self.dp",
      "                .iter()",
      "                .enumerate()",
      "                .take(k_bits)",
      "                .filter(|(i, _)| (k >> i) & 1 == 1)",
      "                .map(|(_, fp)| fp)",
      "                .fold(x, |acc, fp| fp[acc])",
      "        }",
      "    }",
      "}"
    ]
  },
  "doubling_with_monoid": {
    "scope": "rust",
    "prefix": "doubling_with_monoid",
    "body": [
      "use doubling_with_monoid::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod doubling_with_monoid {",
      "    use ac_library::Monoid;",
      "    #[derive(Clone, Debug)]",
      "    pub struct DoublingWithMonoid<M: Monoid> {",
      "        n: usize,",
      "        log: usize,",
      "        dp_f: Vec<Vec<usize>>,",
      "        dp_g: Vec<Vec<M::S>>,",
      "    }",
      "    impl<M: Monoid> DoublingWithMonoid<M>",
      "    where",
      "        M::S: Clone,",
      "    {",
      "        /// doubling 前処理の構築をする",
      "        /// # Arguments",
      "        /// * `f` - `f[x]` は `x` の遷移先",
      "        /// * `g` - `g[x]` は `x→f[x]` の辺に対応するモノイドの値",
      "        /// * `k` - 合成回数の最大値 (`k>=1`)",
      "        /// # 計算量",
      "        /// O(n log k) (n = f.len())",
      "        pub fn new(f: &[usize], g: &[M::S], k: usize) -> Self {",
      "            let n = f.len();",
      "            let log = (usize::BITS - k.leading_zeros()) as usize;",
      "            let mut dp_f = vec![vec![0; n]; log];",
      "            let mut dp_g = vec![vec![M::identity(); n]; log];",
      "            if k >= 1 {",
      "                dp_f[0] = f.to_vec();",
      "                dp_g[0] = g.to_vec();",
      "            }",
      "            for i in 1..log {",
      "                for x in 0..n {",
      "                    let fp = &dp_f[i - 1];",
      "                    let gp = &dp_g[i - 1];",
      "                    dp_g[i][x] = M::binary_operation(&gp[x], &gp[fp[x]]);",
      "                    dp_f[i][x] = fp[fp[x]];",
      "                }",
      "            }",
      "            Self { n, log, dp_f, dp_g }",
      "        }",
      "        /// `f` の `k` 回合成を `f^k` とする。",
      "        /// `(f^k)(x)` と `x → f(x) → ... → (f^k)(x)` のパス上の値の総積（モノイド演算）を求める",
      "        /// # 計算量",
      "        /// O(log k)",
      "        pub fn eval(&self, k: usize, x: usize) -> (usize, M::S) {",
      "            assert!((0..self.n).contains(&x));",
      "            assert!(k < (1 << self.log));",
      "            if k == 0 {",
      "                return (x, M::identity());",
      "            }",
      "            let k_bits = (usize::BITS - k.leading_zeros()) as usize;",
      "            self.dp_f",
      "                .iter()",
      "                .zip(self.dp_g.iter())",
      "                .enumerate()",
      "                .take(k_bits)",
      "                .filter(|(i, _)| (k >> i) & 1 == 1)",
      "                .map(|(_, (fp, gp))| (fp, gp))",
      "                .fold((x, M::identity()), |(idx, val), (fp, gp)| {",
      "                    (fp[idx], M::binary_operation(&val, &gp[idx]))",
      "                })",
      "        }",
      "    }",
      "}"
    ]
  },
  "doubling_with_sum": {
    "scope": "rust",
    "prefix": "doubling_with_sum",
    "body": [
      "use doubling_with_sum::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod doubling_with_sum {",
      "    #[derive(Clone, Debug)]",
      "    pub struct DoublingWithSum {",
      "        n: usize,",
      "        log: usize,",
      "        dp_f: Vec<Vec<usize>>,",
      "        dp_g: Vec<Vec<i64>>,",
      "    }",
      "    impl DoublingWithSum {",
      "        /// doubling 前処理の構築をする",
      "        /// # Arguments",
      "        /// * `f` - `f[x]` は `x` の遷移先",
      "        /// * `g` - `g[x]` は `x→f[x]` の辺重み",
      "        /// * `k` - 合成回数の最大値 (`k>=1`)",
      "        /// # 計算量",
      "        /// O(n log k) (n = f.len())",
      "        pub fn new(f: &[usize], g: &[i64], k: usize) -> DoublingWithSum {",
      "            let n = f.len();",
      "            let log = (usize::BITS - k.leading_zeros()) as usize;",
      "            let mut dp_f = vec![vec![0; n]; log];",
      "            let mut dp_g = vec![vec![0; n]; log];",
      "            if k >= 1 {",
      "                dp_f[0] = f.to_vec();",
      "                dp_g[0] = g.to_vec();",
      "            }",
      "            for i in 1..log {",
      "                for x in 0..n {",
      "                    let fp = &dp_f[i - 1];",
      "                    let gp = &dp_g[i - 1];",
      "                    dp_g[i][x] = gp[x] + gp[fp[x]];",
      "                    dp_f[i][x] = fp[fp[x]];",
      "                }",
      "            }",
      "            DoublingWithSum { n, log, dp_f, dp_g }",
      "        }",
      "        /// `f` の `k` 回合成を `f^k` とする。",
      "        /// `(f^k)(x)` と `x → f(x) → ... → (f^k)(x)` のパス重みを求める。",
      "        /// # 計算量",
      "        /// O(log k)",
      "        pub fn eval(&self, k: usize, x: usize) -> (usize, i64) {",
      "            assert!((0..self.n).contains(&x));",
      "            assert!(k < (1 << self.log));",
      "            if k == 0 {",
      "                return (x, 0);",
      "            }",
      "            let k_bits = (usize::BITS - k.leading_zeros()) as usize;",
      "            self.dp_f",
      "                .iter()",
      "                .zip(self.dp_g.iter())",
      "                .enumerate()",
      "                .take(k_bits)",
      "                .filter(|(i, _)| (k >> i) & 1 == 1)",
      "                .map(|(_, (fp, gp))| (fp, gp))",
      "                .fold((x, 0), |(idx, val), (fp, gp)| (fp[idx], val + gp[idx]))",
      "        }",
      "    }",
      "}"
    ]
  },
  "dsu_core": {
    "scope": "rust",
    "prefix": "dsu_core",
    "body": [
      "use dsu_core::*;",
      "#[allow(clippy::module_inception)]",
      "/// ac_library::Dsu の merge のみ実装を変えたもの",
      "pub mod dsu_core {",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    /// DSU 内の各要素の状態（親のインデックスまたは集合のサイズ）を保持する構造体。",
      "    /// メモリ効率（32ビット整数 1 つ分）を維持したまま、以下の 2 つの状態を表現します。",
      "    /// 1. **Root (根)**:",
      "    ///    - 値が負の場合、その要素は集合の代表元（リーダー）です。",
      "    ///    - 値の絶対値 `|v|` は、その集合に属する要素の数（サイズ）を表します。",
      "    ///    - 例: `-1` はサイズ 1 の集合の根、`-5` はサイズ 5 の集合の根。",
      "    /// 2. **Child (子)**:",
      "    ///    - 値が 0 以上の場合、その要素は他の要素を親に持っています。",
      "    ///    - 値 `v` は、親要素のインデックスを表します。",
      "    struct Node(i32);",
      "    impl Node {",
      "        fn root(size: usize) -> Self {",
      "            Self(-(size as i32))",
      "        }",
      "        fn child(parent: usize) -> Self {",
      "            Self(parent as i32)",
      "        }",
      "        fn is_root(&self) -> bool {",
      "            self.0 < 0",
      "        }",
      "        fn parent(&self) -> usize {",
      "            self.0 as usize",
      "        }",
      "        fn size(&self) -> usize {",
      "            (-self.0) as usize",
      "        }",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    pub struct DsuCore {",
      "        n: usize,",
      "        nodes: Vec<Node>,",
      "        cnt_groups: usize,",
      "    }",
      "    impl DsuCore {",
      "        pub fn new(size: usize) -> Self {",
      "            Self {",
      "                n: size,",
      "                nodes: vec![Node::root(1); size],",
      "                cnt_groups: size,",
      "            }",
      "        }",
      "        /// 2 つの要素 `a` と `b` が属する集合を統合する",
      "        /// # 戻り値",
      "        /// - `Some((leader, merged))`:",
      "        ///   - `leader` は統合後の集合の代表元（リーダー）",
      "        ///   - `merged` は統合されて消える側の旧代表元",
      "        /// - `None`:",
      "        ///   - `a` と `b` がすでに同じ集合に属していた場合",
      "        pub fn merge(&mut self, a: usize, b: usize) -> Option<(usize, usize)> {",
      "            assert!(a < self.n);",
      "            assert!(b < self.n);",
      "            let (mut x, mut y) = (self.leader(a), self.leader(b));",
      "            if x == y {",
      "                return None;",
      "            }",
      "            if self.nodes[x].size() < self.nodes[y].size() {",
      "                std::mem::swap(&mut x, &mut y);",
      "            }",
      "            let size_x = self.nodes[x].size();",
      "            let size_y = self.nodes[y].size();",
      "            self.nodes[x] = Node::root(size_x + size_y);",
      "            self.nodes[y] = Node::child(x);",
      "            self.cnt_groups -= 1;",
      "            Some((x, y))",
      "        }",
      "        pub fn same(&mut self, a: usize, b: usize) -> bool {",
      "            assert!(a < self.n);",
      "            assert!(b < self.n);",
      "            self.leader(a) == self.leader(b)",
      "        }",
      "        pub fn leader(&mut self, a: usize) -> usize {",
      "            assert!(a < self.n);",
      "            if self.nodes[a].is_root() {",
      "                return a;",
      "            }",
      "            let parent = self.nodes[a].parent();",
      "            let new_parent = self.leader(parent);",
      "            self.nodes[a] = Node::child(new_parent);",
      "            new_parent",
      "        }",
      "        pub fn size(&mut self, a: usize) -> usize {",
      "            assert!(a < self.n);",
      "            let x = self.leader(a);",
      "            self.nodes[x].size()",
      "        }",
      "        pub fn count_group(&self) -> usize {",
      "            self.cnt_groups",
      "        }",
      "        pub fn groups(&mut self) -> Vec<Vec<usize>> {",
      "            let mut leader_buf = vec![0; self.n];",
      "            let mut group_size = vec![0; self.n];",
      "            for i in 0..self.n {",
      "                leader_buf[i] = self.leader(i);",
      "                group_size[leader_buf[i]] += 1;",
      "            }",
      "            let mut result = vec![Vec::new(); self.n];",
      "            for i in 0..self.n {",
      "                result[i].reserve(group_size[i]);",
      "            }",
      "            for i in 0..self.n {",
      "                result[leader_buf[i]].push(i);",
      "            }",
      "            result",
      "                .into_iter()",
      "                .filter(|x| !x.is_empty())",
      "                .collect::<Vec<Vec<usize>>>()",
      "        }",
      "    }",
      "}"
    ]
  },
  "dsu_ix": {
    "scope": "rust",
    "prefix": "dsu_ix",
    "body": [
      "use dsu_ix::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod dsu_ix {",
      "    use super::DsuCore;",
      "    use super::{Bounds, Ix};",
      "    #[derive(Clone, Debug)]",
      "    pub struct DsuIx<I: Ix> {",
      "        dsu: DsuCore,",
      "        bounds: Bounds<I>,",
      "    }",
      "    impl<I: Ix> DsuIx<I> {",
      "        /// 指定された範囲の要素を管理する DSU を作成する",
      "        /// # Arguments",
      "        /// * `bounds` - 要素のインデックス範囲",
      "        pub fn new(bounds: Bounds<I>) -> Self {",
      "            let n = bounds.range_size();",
      "            Self {",
      "                dsu: DsuCore::new(n),",
      "                bounds,",
      "            }",
      "        }",
      "        /// 2 つの要素 `a` と `b` が属する集合を統合する",
      "        /// # 戻り値",
      "        /// - `Some((leader, merged))`:",
      "        ///   - `leader` は統合後の集合の代表元（リーダー）",
      "        ///   - `merged` は統合されて消える側の旧代表元",
      "        /// - `None`:",
      "        ///   - `a` と `b` がすでに同じ集合に属していた場合",
      "        pub fn merge(&mut self, a: I, b: I) -> Option<(I, I)> {",
      "            let a_idx = self.bounds.to_index(a);",
      "            let b_idx = self.bounds.to_index(b);",
      "            let res = self.dsu.merge(a_idx, b_idx);",
      "            res.map(|(l, m)| (self.bounds.from_index(l), self.bounds.from_index(m)))",
      "        }",
      "        /// 要素 `a` と `b` が同じ集合に属しているか判定する",
      "        pub fn same(&mut self, a: I, b: I) -> bool {",
      "            let a_idx = self.bounds.to_index(a);",
      "            let b_idx = self.bounds.to_index(b);",
      "            self.dsu.same(a_idx, b_idx)",
      "        }",
      "        /// 要素 `a` が属する集合の代表元（リーダー）を返す",
      "        pub fn leader(&mut self, a: I) -> I {",
      "            let a_idx = self.bounds.to_index(a);",
      "            let l_idx = self.dsu.leader(a_idx);",
      "            self.bounds.from_index(l_idx)",
      "        }",
      "        /// 要素 `a` が属する集合の要素数を返す",
      "        pub fn size(&mut self, a: I) -> usize {",
      "            let a_idx = self.bounds.to_index(a);",
      "            self.dsu.size(a_idx)",
      "        }",
      "        /// 集合の総数を返す",
      "        pub fn count_group(&self) -> usize {",
      "            self.dsu.count_group()",
      "        }",
      "        /// すべての集合を、それぞれの要素のリストとして返す",
      "        pub fn groups(&mut self) -> Vec<Vec<I>> {",
      "            self.dsu",
      "                .groups()",
      "                .into_iter()",
      "                .map(|group| {",
      "                    group",
      "                        .into_iter()",
      "                        .map(|idx| self.bounds.from_index(idx))",
      "                        .collect()",
      "                })",
      "                .collect()",
      "        }",
      "    }",
      "}"
    ]
  },
  "dual_segtree": {
    "scope": "rust",
    "prefix": "dual_segtree",
    "body": [
      "use dual_segtree::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod dual_segtree {",
      "    use std::ops::{Bound, RangeBounds};",
      "    fn ceil_pow2(n: u32) -> u32 {",
      "        32 - n.saturating_sub(1).leading_zeros()",
      "    }",
      "    pub trait MapMonoid {",
      "        type F: Clone;",
      "        type S: Clone;",
      "        fn identity_map() -> Self::F;",
      "        fn mapping(f: &Self::F, x: &Self::S) -> Self::S;",
      "        fn composition(f: &Self::F, g: &Self::F) -> Self::F;",
      "    }",
      "    impl<F: MapMonoid> Default for DualSegtree<F>",
      "    where",
      "        F::S: Default,",
      "    {",
      "        fn default() -> Self {",
      "            Self::new(0)",
      "        }",
      "    }",
      "    impl<F: MapMonoid> DualSegtree<F> {",
      "        pub fn new(n: usize) -> Self",
      "        where",
      "            F::S: Default,",
      "        {",
      "            vec![F::S::default(); n].into()",
      "        }",
      "    }",
      "    impl<F: MapMonoid> From<Vec<F::S>> for DualSegtree<F>",
      "    where",
      "        F::S: Default,",
      "    {",
      "        fn from(v: Vec<F::S>) -> Self {",
      "            let n = v.len();",
      "            let log = ceil_pow2(n as u32) as usize;",
      "            let size = 1 << log;",
      "            let mut d = vec![F::S::default(); size];",
      "            let lz = vec![F::identity_map(); size];",
      "            d[..n].clone_from_slice(&v);",
      "            DualSegtree {",
      "                n,",
      "                size,",
      "                log,",
      "                d,",
      "                lz,",
      "            }",
      "        }",
      "    }",
      "    impl<F: MapMonoid> DualSegtree<F> {",
      "        pub fn set(&mut self, p: usize, x: F::S) {",
      "            assert!(p < self.n);",
      "            for i in (1..=self.log).rev() {",
      "                self.push((p + self.size) >> i);",
      "            }",
      "            self.d[p] = x;",
      "        }",
      "        pub fn get(&mut self, p: usize) -> F::S {",
      "            assert!(p < self.n);",
      "            for i in (1..=self.log).rev() {",
      "                self.push((p + self.size) >> i);",
      "            }",
      "            self.d[p].clone()",
      "        }",
      "        pub fn apply(&mut self, p: usize, f: F::F) {",
      "            assert!(p < self.n);",
      "            for i in (1..=self.log).rev() {",
      "                self.push((p + self.size) >> i);",
      "            }",
      "            self.d[p] = F::mapping(&f, &self.d[p]);",
      "        }",
      "        pub fn apply_range<R>(&mut self, range: R, f: F::F)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            let mut r = match range.end_bound() {",
      "                Bound::Included(r) => r + 1,",
      "                Bound::Excluded(r) => *r,",
      "                Bound::Unbounded => self.n,",
      "            };",
      "            let mut l = match range.start_bound() {",
      "                Bound::Included(l) => *l,",
      "                Bound::Excluded(l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            assert!(l <= r && r <= self.n);",
      "            if l == r {",
      "                return;",
      "            }",
      "            l += self.size;",
      "            r += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                if ((l >> i) << i) != l {",
      "                    self.push(l >> i);",
      "                }",
      "                if ((r >> i) << i) != r {",
      "                    self.push((r - 1) >> i);",
      "                }",
      "            }",
      "            {",
      "                while l < r {",
      "                    if l & 1 != 0 {",
      "                        self.all_apply(l, f.clone());",
      "                        l += 1;",
      "                    }",
      "                    if r & 1 != 0 {",
      "                        r -= 1;",
      "                        self.all_apply(r, f.clone());",
      "                    }",
      "                    l >>= 1;",
      "                    r >>= 1;",
      "                }",
      "            }",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<F::S> {",
      "            (0..self.n).map(|i| self.get(i)).collect()",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct DualSegtree<F>",
      "    where",
      "        F: MapMonoid,",
      "    {",
      "        n: usize,",
      "        size: usize,",
      "        log: usize,",
      "        d: Vec<F::S>,",
      "        lz: Vec<F::F>,",
      "    }",
      "    impl<F> DualSegtree<F>",
      "    where",
      "        F: MapMonoid,",
      "    {",
      "        fn all_apply(&mut self, k: usize, f: F::F) {",
      "            if k < self.size {",
      "                self.lz[k] = F::composition(&f, &self.lz[k]);",
      "            } else {",
      "                self.d[k - self.size] = F::mapping(&f, &self.d[k - self.size]);",
      "            }",
      "        }",
      "        fn push(&mut self, k: usize) {",
      "            self.all_apply(2 * k, self.lz[k].clone());",
      "            self.all_apply(2 * k + 1, self.lz[k].clone());",
      "            self.lz[k] = F::identity_map();",
      "        }",
      "    }",
      "}"
    ]
  },
  "dynamic_matrix": {
    "scope": "rust",
    "prefix": "dynamic_matrix",
    "body": [
      "use dynamic_matrix::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod dynamic_matrix {",
      "    use std::iter::{Product, Sum};",
      "    use std::ops::{Add, AddAssign, Index, IndexMut, Mul, Sub, SubAssign};",
      "    fn t_zero<T>() -> T",
      "    where",
      "        T: Sum,",
      "    {",
      "        std::iter::empty().sum()",
      "    }",
      "    fn t_one<T>() -> T",
      "    where",
      "        T: Product,",
      "    {",
      "        std::iter::empty().product()",
      "    }",
      "    #[derive(Debug, Clone, PartialEq, Eq)]",
      "    pub struct DynamicMatrix<T> {",
      "        pub rows: usize,",
      "        pub cols: usize,",
      "        pub data: Vec<Vec<T>>,",
      "    }",
      "    impl<T> DynamicMatrix<T>",
      "    where",
      "        T: Copy + Sum + Product + Add<Output = T> + Sub<Output = T> + Mul<Output = T>,",
      "    {",
      "        /// 指定されたサイズと初期値で新しい動的行列を作成します。",
      "        pub fn new(rows: usize, cols: usize, initial_value: T) -> Self {",
      "            let data = vec![vec![initial_value; cols]; rows];",
      "            Self { rows, cols, data }",
      "        }",
      "        /// 単位行列を作成します。正方行列の場合のみ有効です。",
      "        pub fn identity(size: usize) -> Self {",
      "            let mut matrix = Self::new(size, size, t_zero());",
      "            for i in 0..size {",
      "                matrix.data[i][i] = t_one();",
      "            }",
      "            matrix",
      "        }",
      "        /// `Vec<Vec<T>>`から行列を作成します。",
      "        pub fn from_vec(data: Vec<Vec<T>>) -> Self {",
      "            assert!(!data.is_empty(), \"Matrix cannot be empty\");",
      "            let rows = data.len();",
      "            let cols = data[0].len();",
      "            for row in &data {",
      "                assert_eq!(",
      "                    row.len(),",
      "                    cols,",
      "                    \"All rows must have the same number of columns\"",
      "                );",
      "            }",
      "            Self { rows, cols, data }",
      "        }",
      "    }",
      "    impl<T> Index<(usize, usize)> for DynamicMatrix<T> {",
      "        type Output = T;",
      "        fn index(&self, index: (usize, usize)) -> &Self::Output {",
      "            &self.data[index.0][index.1]",
      "        }",
      "    }",
      "    impl<T> IndexMut<(usize, usize)> for DynamicMatrix<T> {",
      "        fn index_mut(&mut self, index: (usize, usize)) -> &mut Self::Output {",
      "            &mut self.data[index.0][index.1]",
      "        }",
      "    }",
      "    impl<T> Add for DynamicMatrix<T>",
      "    where",
      "        T: Copy + Sum + Product + Add<Output = T> + Sub<Output = T> + Mul<Output = T>,",
      "    {",
      "        type Output = Self;",
      "        fn add(self, rhs: Self) -> Self::Output {",
      "            assert_eq!(",
      "                self.rows, rhs.rows,",
      "                \"Matrices must have the same number of rows for addition.\"",
      "            );",
      "            assert_eq!(",
      "                self.cols, rhs.cols,",
      "                \"Matrices must have the same number of columns for addition.\"",
      "            );",
      "            let mut result = Self::new(self.rows, self.cols, t_zero());",
      "            for i in 0..self.rows {",
      "                for j in 0..self.cols {",
      "                    result.data[i][j] = self.data[i][j] + rhs.data[i][j];",
      "                }",
      "            }",
      "            result",
      "        }",
      "    }",
      "    impl<T> AddAssign for DynamicMatrix<T>",
      "    where",
      "        T: Copy + Sum + Product + AddAssign + Sub<Output = T> + Mul<Output = T>,",
      "    {",
      "        fn add_assign(&mut self, rhs: Self) {",
      "            assert_eq!(",
      "                self.rows, rhs.rows,",
      "                \"Matrices must have the same number of rows for addition.\"",
      "            );",
      "            assert_eq!(",
      "                self.cols, rhs.cols,",
      "                \"Matrices must have the same number of columns for addition.\"",
      "            );",
      "            for i in 0..self.rows {",
      "                for j in 0..self.cols {",
      "                    self.data[i][j] += rhs.data[i][j];",
      "                }",
      "            }",
      "        }",
      "    }",
      "    impl<T> Sub for DynamicMatrix<T>",
      "    where",
      "        T: Copy + Sum + Product + Add<Output = T> + Sub<Output = T> + Mul<Output = T>,",
      "    {",
      "        type Output = Self;",
      "        fn sub(self, rhs: Self) -> Self::Output {",
      "            assert_eq!(",
      "                self.rows, rhs.rows,",
      "                \"Matrices must have the same number of rows for subtraction.\"",
      "            );",
      "            assert_eq!(",
      "                self.cols, rhs.cols,",
      "                \"Matrices must have the same number of columns for subtraction.\"",
      "            );",
      "            let mut result = Self::new(self.rows, self.cols, t_zero());",
      "            for i in 0..self.rows {",
      "                for j in 0..self.cols {",
      "                    result.data[i][j] = self.data[i][j] - rhs.data[i][j];",
      "                }",
      "            }",
      "            result",
      "        }",
      "    }",
      "    impl<T> SubAssign for DynamicMatrix<T>",
      "    where",
      "        T: Copy + Sum + Product + SubAssign + Add<Output = T> + Mul<Output = T>,",
      "    {",
      "        fn sub_assign(&mut self, rhs: Self) {",
      "            assert_eq!(",
      "                self.rows, rhs.rows,",
      "                \"Matrices must have the same number of rows for subtraction.\"",
      "            );",
      "            assert_eq!(",
      "                self.cols, rhs.cols,",
      "                \"Matrices must have the same number of columns for subtraction.\"",
      "            );",
      "            for i in 0..self.rows {",
      "                for j in 0..self.cols {",
      "                    self.data[i][j] -= rhs.data[i][j];",
      "                }",
      "            }",
      "        }",
      "    }",
      "    impl<T> Mul for DynamicMatrix<T>",
      "    where",
      "        T: Copy + Sum + Product + Add<Output = T> + Sub<Output = T> + Mul<Output = T>,",
      "    {",
      "        type Output = Self;",
      "        fn mul(self, rhs: Self) -> Self::Output {",
      "            assert_eq ! (self . cols , rhs . rows , \"The number of columns of the left matrix must equal the number of rows of the right matrix for multiplication.\" );",
      "            let mut result = Self::new(self.rows, rhs.cols, t_zero());",
      "            for i in 0..self.rows {",
      "                for j in 0..rhs.cols {",
      "                    for k in 0..self.cols {",
      "                        result.data[i][j] = result.data[i][j] + self.data[i][k] * rhs.data[k][j];",
      "                    }",
      "                }",
      "            }",
      "            result",
      "        }",
      "    }",
      "    impl<T> Mul<T> for DynamicMatrix<T>",
      "    where",
      "        T: Copy + Sum + Product + Mul<Output = T> + Add<Output = T> + Sub<Output = T>,",
      "    {",
      "        type Output = Self;",
      "        fn mul(self, rhs: T) -> Self::Output {",
      "            let mut result = Self::new(self.rows, self.cols, t_zero());",
      "            for i in 0..self.rows {",
      "                for j in 0..self.cols {",
      "                    result.data[i][j] = self.data[i][j] * rhs;",
      "                }",
      "            }",
      "            result",
      "        }",
      "    }",
      "    impl<T> DynamicMatrix<T>",
      "    where",
      "        T: Copy + Sum + Product + Add<Output = T> + Sub<Output = T> + Mul<Output = T>,",
      "    {",
      "        pub fn pow(self, mut n: u64) -> Self {",
      "            assert_eq!(",
      "                self.rows, self.cols,",
      "                \"Matrix must be square for exponentiation.\"",
      "            );",
      "            let mut res = DynamicMatrix::identity(self.rows);",
      "            let mut base = self;",
      "            while n > 0 {",
      "                if n % 2 == 1 {",
      "                    res = res * base.clone();",
      "                }",
      "                base = base.clone() * base.clone();",
      "                n /= 2;",
      "            }",
      "            res",
      "        }",
      "    }",
      "    impl<T> DynamicMatrix<T>",
      "    where",
      "        T: Copy + Sum + Product + Add<Output = T> + Sub<Output = T> + Mul<Output = T>,",
      "    {",
      "        pub fn apply(&self, x: Vec<T>) -> Vec<T> {",
      "            assert_eq ! (self . cols , x . len () , \"The number of columns of the matrix must equal the length of the vector for application.\" );",
      "            let mut result = vec![t_zero(); self.rows];",
      "            for i in 0..self.rows {",
      "                for j in 0..self.cols {",
      "                    result[i] = result[i] + self.data[i][j] * x[j];",
      "                }",
      "            }",
      "            result",
      "        }",
      "    }",
      "}"
    ]
  },
  "dynamic_monoid": {
    "scope": "rust",
    "prefix": "dynamic_monoid",
    "body": [
      "use dynamic_monoid::*;",
      "pub mod dynamic_monoid {",
      "    pub trait DynamicMonoid {",
      "        type S: Clone;",
      "        fn identity(&self) -> Self::S;",
      "        fn binary_operation(&self, a: &Self::S, b: &Self::S) -> Self::S;",
      "        /// base^n を求める",
      "        fn pow(&self, base: &Self::S, n: usize) -> Self::S {",
      "            let mut base = base.clone();",
      "            let mut ans = self.identity();",
      "            let mut n = n;",
      "            while n > 0 {",
      "                if n & 1 == 1 {",
      "                    ans = self.binary_operation(&ans, &base);",
      "                }",
      "                base = self.binary_operation(&base, &base);",
      "                n >>= 1;",
      "            }",
      "            ans",
      "        }",
      "    }",
      "}"
    ]
  },
  "dynamic_monoid_segtree": {
    "scope": "rust",
    "prefix": "dynamic_monoid_segtree",
    "body": [
      "use dynamic_monoid_segtree::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod dynamic_monoid_segtree {",
      "    use std::ops::{Bound, RangeBounds};",
      "    fn ceil_pow2(n: u32) -> u32 {",
      "        32 - n.saturating_sub(1).leading_zeros()",
      "    }",
      "    pub trait DynamicMonoid {",
      "        type S: Clone;",
      "        fn identity(&self) -> Self::S;",
      "        fn binary_operation(&self, a: &Self::S, b: &Self::S) -> Self::S;",
      "    }",
      "    impl<M: DynamicMonoid> DynamicMonoidSegtree<M> {",
      "        pub fn new(n: usize, m: M) -> DynamicMonoidSegtree<M> {",
      "            Self::from_vec(vec![m.identity(); n], m)",
      "        }",
      "        fn from_vec(v: Vec<M::S>, m: M) -> Self {",
      "            let n = v.len();",
      "            let log = ceil_pow2(n as u32) as usize;",
      "            let size = 1 << log;",
      "            let mut d = vec![m.identity(); 2 * size];",
      "            d[size..(size + n)].clone_from_slice(&v);",
      "            let mut ret = DynamicMonoidSegtree { n, size, log, d, m };",
      "            for i in (1..size).rev() {",
      "                ret.update(i);",
      "            }",
      "            ret",
      "        }",
      "    }",
      "    impl<M: DynamicMonoid> DynamicMonoidSegtree<M> {",
      "        pub fn set(&mut self, mut p: usize, x: M::S) {",
      "            assert!(p < self.n);",
      "            p += self.size;",
      "            self.d[p] = x;",
      "            for i in 1..=self.log {",
      "                self.update(p >> i);",
      "            }",
      "        }",
      "        pub fn get(&self, p: usize) -> M::S {",
      "            assert!(p < self.n);",
      "            self.d[p + self.size].clone()",
      "        }",
      "        pub fn prod<R>(&self, range: R) -> M::S",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            if range.start_bound() == Bound::Unbounded && range.end_bound() == Bound::Unbounded {",
      "                return self.all_prod();",
      "            }",
      "            let mut r = match range.end_bound() {",
      "                Bound::Included(r) => r + 1,",
      "                Bound::Excluded(r) => *r,",
      "                Bound::Unbounded => self.n,",
      "            };",
      "            let mut l = match range.start_bound() {",
      "                Bound::Included(l) => *l,",
      "                Bound::Excluded(l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            assert!(l <= r && r <= self.n);",
      "            let mut sml = self.m.identity();",
      "            let mut smr = self.m.identity();",
      "            l += self.size;",
      "            r += self.size;",
      "            while l < r {",
      "                if l & 1 != 0 {",
      "                    sml = self.m.binary_operation(&sml, &self.d[l]);",
      "                    l += 1;",
      "                }",
      "                if r & 1 != 0 {",
      "                    r -= 1;",
      "                    smr = self.m.binary_operation(&self.d[r], &smr);",
      "                }",
      "                l >>= 1;",
      "                r >>= 1;",
      "            }",
      "            self.m.binary_operation(&sml, &smr)",
      "        }",
      "        pub fn all_prod(&self) -> M::S {",
      "            self.d[1].clone()",
      "        }",
      "        pub fn max_right<F>(&self, mut l: usize, f: F) -> usize",
      "        where",
      "            F: Fn(&M::S) -> bool,",
      "        {",
      "            assert!(l <= self.n);",
      "            assert!(f(&self.m.identity()));",
      "            if l == self.n {",
      "                return self.n;",
      "            }",
      "            l += self.size;",
      "            let mut sm = self.m.identity();",
      "            while {",
      "                while l % 2 == 0 {",
      "                    l >>= 1;",
      "                }",
      "                if !f(&self.m.binary_operation(&sm, &self.d[l])) {",
      "                    while l < self.size {",
      "                        l *= 2;",
      "                        let res = self.m.binary_operation(&sm, &self.d[l]);",
      "                        if f(&res) {",
      "                            sm = res;",
      "                            l += 1;",
      "                        }",
      "                    }",
      "                    return l - self.size;",
      "                }",
      "                sm = self.m.binary_operation(&sm, &self.d[l]);",
      "                l += 1;",
      "                {",
      "                    let l = l as isize;",
      "                    (l & -l) != l",
      "                }",
      "            } {}",
      "            self.n",
      "        }",
      "        pub fn min_left<F>(&self, mut r: usize, f: F) -> usize",
      "        where",
      "            F: Fn(&M::S) -> bool,",
      "        {",
      "            assert!(r <= self.n);",
      "            assert!(f(&self.m.identity()));",
      "            if r == 0 {",
      "                return 0;",
      "            }",
      "            r += self.size;",
      "            let mut sm = self.m.identity();",
      "            while {",
      "                r -= 1;",
      "                while r > 1 && r % 2 == 1 {",
      "                    r >>= 1;",
      "                }",
      "                if !f(&self.m.binary_operation(&self.d[r], &sm)) {",
      "                    while r < self.size {",
      "                        r = 2 * r + 1;",
      "                        let res = self.m.binary_operation(&self.d[r], &sm);",
      "                        if f(&res) {",
      "                            sm = res;",
      "                            r -= 1;",
      "                        }",
      "                    }",
      "                    return r + 1 - self.size;",
      "                }",
      "                sm = self.m.binary_operation(&self.d[r], &sm);",
      "                {",
      "                    let r = r as isize;",
      "                    (r & -r) != r",
      "                }",
      "            } {}",
      "            0",
      "        }",
      "        fn update(&mut self, k: usize) {",
      "            self.d[k] = self.m.binary_operation(&self.d[2 * k], &self.d[2 * k + 1]);",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct DynamicMonoidSegtree<M>",
      "    where",
      "        M: DynamicMonoid,",
      "    {",
      "        n: usize,",
      "        size: usize,",
      "        log: usize,",
      "        d: Vec<M::S>,",
      "        m: M,",
      "    }",
      "}"
    ]
  },
  "enumerable_dsu": {
    "scope": "rust",
    "prefix": "enumerable_dsu",
    "body": [
      "use dsu_core::*;",
      "use enumerable_dsu::*;",
      "#[allow(clippy::module_inception)]",
      "/// ac_library::Dsu の merge のみ実装を変えたもの",
      "pub mod dsu_core {",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    /// DSU 内の各要素の状態（親のインデックスまたは集合のサイズ）を保持する構造体。",
      "    /// メモリ効率（32ビット整数 1 つ分）を維持したまま、以下の 2 つの状態を表現します。",
      "    /// 1. **Root (根)**:",
      "    ///    - 値が負の場合、その要素は集合の代表元（リーダー）です。",
      "    ///    - 値の絶対値 `|v|` は、その集合に属する要素の数（サイズ）を表します。",
      "    ///    - 例: `-1` はサイズ 1 の集合の根、`-5` はサイズ 5 の集合の根。",
      "    /// 2. **Child (子)**:",
      "    ///    - 値が 0 以上の場合、その要素は他の要素を親に持っています。",
      "    ///    - 値 `v` は、親要素のインデックスを表します。",
      "    struct Node(i32);",
      "    impl Node {",
      "        fn root(size: usize) -> Self {",
      "            Self(-(size as i32))",
      "        }",
      "        fn child(parent: usize) -> Self {",
      "            Self(parent as i32)",
      "        }",
      "        fn is_root(&self) -> bool {",
      "            self.0 < 0",
      "        }",
      "        fn parent(&self) -> usize {",
      "            self.0 as usize",
      "        }",
      "        fn size(&self) -> usize {",
      "            (-self.0) as usize",
      "        }",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    pub struct DsuCore {",
      "        n: usize,",
      "        nodes: Vec<Node>,",
      "        cnt_groups: usize,",
      "    }",
      "    impl DsuCore {",
      "        pub fn new(size: usize) -> Self {",
      "            Self {",
      "                n: size,",
      "                nodes: vec![Node::root(1); size],",
      "                cnt_groups: size,",
      "            }",
      "        }",
      "        /// 2 つの要素 `a` と `b` が属する集合を統合する",
      "        /// # 戻り値",
      "        /// - `Some((leader, merged))`:",
      "        ///   - `leader` は統合後の集合の代表元（リーダー）",
      "        ///   - `merged` は統合されて消える側の旧代表元",
      "        /// - `None`:",
      "        ///   - `a` と `b` がすでに同じ集合に属していた場合",
      "        pub fn merge(&mut self, a: usize, b: usize) -> Option<(usize, usize)> {",
      "            assert!(a < self.n);",
      "            assert!(b < self.n);",
      "            let (mut x, mut y) = (self.leader(a), self.leader(b));",
      "            if x == y {",
      "                return None;",
      "            }",
      "            if self.nodes[x].size() < self.nodes[y].size() {",
      "                std::mem::swap(&mut x, &mut y);",
      "            }",
      "            let size_x = self.nodes[x].size();",
      "            let size_y = self.nodes[y].size();",
      "            self.nodes[x] = Node::root(size_x + size_y);",
      "            self.nodes[y] = Node::child(x);",
      "            self.cnt_groups -= 1;",
      "            Some((x, y))",
      "        }",
      "        pub fn same(&mut self, a: usize, b: usize) -> bool {",
      "            assert!(a < self.n);",
      "            assert!(b < self.n);",
      "            self.leader(a) == self.leader(b)",
      "        }",
      "        pub fn leader(&mut self, a: usize) -> usize {",
      "            assert!(a < self.n);",
      "            if self.nodes[a].is_root() {",
      "                return a;",
      "            }",
      "            let parent = self.nodes[a].parent();",
      "            let new_parent = self.leader(parent);",
      "            self.nodes[a] = Node::child(new_parent);",
      "            new_parent",
      "        }",
      "        pub fn size(&mut self, a: usize) -> usize {",
      "            assert!(a < self.n);",
      "            let x = self.leader(a);",
      "            self.nodes[x].size()",
      "        }",
      "        pub fn count_group(&self) -> usize {",
      "            self.cnt_groups",
      "        }",
      "        pub fn groups(&mut self) -> Vec<Vec<usize>> {",
      "            let mut leader_buf = vec![0; self.n];",
      "            let mut group_size = vec![0; self.n];",
      "            for i in 0..self.n {",
      "                leader_buf[i] = self.leader(i);",
      "                group_size[leader_buf[i]] += 1;",
      "            }",
      "            let mut result = vec![Vec::new(); self.n];",
      "            for i in 0..self.n {",
      "                result[i].reserve(group_size[i]);",
      "            }",
      "            for i in 0..self.n {",
      "                result[leader_buf[i]].push(i);",
      "            }",
      "            result",
      "                .into_iter()",
      "                .filter(|x| !x.is_empty())",
      "                .collect::<Vec<Vec<usize>>>()",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::module_inception)]",
      "pub mod enumerable_dsu {",
      "    use super::DsuCore;",
      "    #[derive(Clone, Debug)]",
      "    /// 指定の元を含むグループを償却 O(α(n)) で取得できる DSU。",
      "    /// merge の償却計算量が O(log n) な点に注意",
      "    pub struct EnumerableDsu {",
      "        dsu: DsuCore,",
      "        groups: Vec<Vec<usize>>,",
      "    }",
      "    impl EnumerableDsu {",
      "        pub fn new(size: usize) -> EnumerableDsu {",
      "            let dsu = DsuCore::new(size);",
      "            let groups = (0..size).map(|i| vec![i]).collect();",
      "            EnumerableDsu { dsu, groups }",
      "        }",
      "        pub fn merge(&mut self, a: usize, b: usize) -> Option<(usize, usize)> {",
      "            let merge_result = self.dsu.merge(a, b);",
      "            if let Some((leader, merged)) = merge_result {",
      "                for x in std::mem::take(&mut self.groups[merged]) {",
      "                    self.groups[leader].push(x);",
      "                }",
      "            }",
      "            merge_result",
      "        }",
      "        pub fn same(&mut self, a: usize, b: usize) -> bool {",
      "            self.dsu.same(a, b)",
      "        }",
      "        pub fn leader(&mut self, a: usize) -> usize {",
      "            self.dsu.leader(a)",
      "        }",
      "        pub fn size(&mut self, a: usize) -> usize {",
      "            self.dsu.size(a)",
      "        }",
      "        pub fn groups(&mut self) -> Vec<Vec<usize>> {",
      "            self.dsu.groups()",
      "        }",
      "        pub fn count_group(&self) -> usize {",
      "            self.dsu.count_group()",
      "        }",
      "        pub fn group(&mut self, a: usize) -> &Vec<usize> {",
      "            let leader = self.leader(a);",
      "            &self.groups[leader]",
      "        }",
      "    }",
      "}"
    ]
  },
  "enumerable_union_find": {
    "scope": "rust",
    "prefix": "enumerable_union_find",
    "body": [
      "use enumerable_union_find::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod enumerable_union_find {",
      "    use itertools::Itertools;",
      "    #[derive(Clone, Debug)]",
      "    struct Node {",
      "        root: usize,",
      "        group: Vec<usize>,",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    pub struct UnionFind {",
      "        nodes: Vec<Node>,",
      "        cnt_groups: usize,",
      "    }",
      "    impl UnionFind {",
      "        pub fn new(n: usize) -> UnionFind {",
      "            let nodes = (0..n)",
      "                .map(|i| Node {",
      "                    root: i,",
      "                    group: vec![i],",
      "                })",
      "                .collect_vec();",
      "            UnionFind {",
      "                nodes,",
      "                cnt_groups: n,",
      "            }",
      "        }",
      "        fn root(&self, index: usize) -> usize {",
      "            self.nodes[index].root",
      "        }",
      "        pub fn same_count(&mut self, index: usize) -> usize {",
      "            let root_index = self.root(index);",
      "            self.nodes[root_index].group.len()",
      "        }",
      "        pub fn same(&mut self, x: usize, y: usize) -> bool {",
      "            self.root(x) == self.root(y)",
      "        }",
      "        pub fn num_groups(&self) -> usize {",
      "            self.cnt_groups",
      "        }",
      "        pub fn unite(&mut self, x: usize, y: usize) -> bool {",
      "            if self.same(x, y) {",
      "                return false;",
      "            }",
      "            self.cnt_groups -= 1;",
      "            let (smaller_root, larger_root) = {",
      "                let x_root = self.root(x);",
      "                let y_root = self.root(y);",
      "                let x_count = self.nodes[x_root].group.len();",
      "                let y_count = self.nodes[y_root].group.len();",
      "                if x_count < y_count {",
      "                    (x_root, y_root)",
      "                } else {",
      "                    (y_root, x_root)",
      "                }",
      "            };",
      "            for x in std::mem::take(&mut self.nodes[smaller_root].group) {",
      "                self.nodes[larger_root].group.push(x);",
      "                self.nodes[x].root = larger_root;",
      "            }",
      "            self.nodes[smaller_root].root = larger_root;",
      "            true",
      "        }",
      "        pub fn group(&mut self, x: usize) -> &Vec<usize> {",
      "            &self.nodes[self.root(x)].group",
      "        }",
      "        pub fn groups(&mut self) -> Vec<Vec<usize>> {",
      "            let n = self.nodes.len();",
      "            let roots = (0..n).map(|i| self.root(i)).collect_vec();",
      "            let group_size = (0..n).map(|i| roots[i]).fold(vec![0; n], |mut acc, x| {",
      "                acc[x] += 1;",
      "                acc",
      "            });",
      "            let result = {",
      "                let mut result = vec![Vec::new(); n];",
      "                for i in 0..n {",
      "                    result[i].reserve(group_size[i]);",
      "                }",
      "                for i in 0..n {",
      "                    result[roots[i]].push(i);",
      "                }",
      "                result",
      "            };",
      "            result.into_iter().filter(|x| !x.is_empty()).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "eratosthenes_sieve": {
    "scope": "rust",
    "prefix": "eratosthenes_sieve",
    "body": [
      "use eratosthenes_sieve::*;",
      "pub mod eratosthenes_sieve {",
      "    use std::collections::HashMap;",
      "    #[derive(Clone, Debug)]",
      "    pub struct EratosthenesSieve {",
      "        is_prime_list: Vec<bool>,",
      "        min_factor_list: Vec<Option<usize>>,",
      "    }",
      "    impl EratosthenesSieve {",
      "        /// [0, n] の区間でエラトステネスのふるいをする",
      "        /// # 計算量",
      "        /// O(n log(log(n)))",
      "        pub fn new(n: usize) -> Self {",
      "            let mut is_prime_list = vec![true; n + 1];",
      "            let mut min_factor_list = vec![None; n + 1];",
      "            is_prime_list[0] = false;",
      "            is_prime_list[1] = false;",
      "            for p in 2..=n {",
      "                if !is_prime_list[p] {",
      "                    continue;",
      "                }",
      "                min_factor_list[p] = Some(p);",
      "                for q in (p * 2..=n).step_by(p) {",
      "                    is_prime_list[q] = false;",
      "                    if min_factor_list[q].is_none() {",
      "                        min_factor_list[q] = Some(p);",
      "                    }",
      "                }",
      "            }",
      "            Self {",
      "                is_prime_list,",
      "                min_factor_list,",
      "            }",
      "        }",
      "        /// n が素数かどうか判定する",
      "        /// # 計算量",
      "        /// O(1)",
      "        pub fn is_prime(&self, n: usize) -> bool {",
      "            self.is_prime_list[n]",
      "        }",
      "        /// n を素因数分解する。key を素数、value をその素数の指数とした HashMap を返す。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn prime_factorize(&self, n: usize) -> HashMap<usize, usize> {",
      "            let mut n = n;",
      "            let mut cnt_table: HashMap<usize, usize> = HashMap::new();",
      "            while n > 1 {",
      "                let p = self.min_factor_list[n].unwrap();",
      "                let mut exp = 0;",
      "                while self.min_factor_list[n] == Some(p) {",
      "                    n /= p;",
      "                    exp += 1;",
      "                }",
      "                cnt_table.insert(p, exp);",
      "            }",
      "            cnt_table",
      "        }",
      "        /// n の正の約数を列挙する",
      "        /// # 計算量",
      "        /// O(nの約数の個数)",
      "        pub fn divisors(&self, n: usize) -> Vec<usize> {",
      "            let mut res = vec![1];",
      "            let pf = self.prime_factorize(n);",
      "            for (p, e) in pf {",
      "                for i in 0..res.len() {",
      "                    let mut tmp = 1;",
      "                    for _ in 0..e {",
      "                        tmp *= p;",
      "                        res.push(res[i] * tmp);",
      "                    }",
      "                }",
      "            }",
      "            res",
      "        }",
      "    }",
      "}"
    ]
  },
  "euler_phi": {
    "scope": "rust",
    "prefix": "euler_phi",
    "body": [
      "/// n を素因数分解する。key を素数、value をその素数の指数とした HashMap を返す。",
      "/// # 計算量",
      "/// O(sqrt(n))",
      "pub fn prime_factorize(n: i64) -> HashMap<i64, i64> {",
      "    use num::Integer;",
      "    use num_integer::Roots;",
      "    assert!(n >= 1);",
      "    let mut cnt_table: HashMap<i64, i64> = HashMap::new();",
      "    let mut n = n;",
      "    for i in 2..=n.sqrt() {",
      "        if n.is_multiple_of(&i) {",
      "            let mut cnt = 0;",
      "            while n.is_multiple_of(&i) {",
      "                n /= i;",
      "                cnt += 1;",
      "            }",
      "            cnt_table.insert(i, cnt);",
      "        }",
      "    }",
      "    if n != 1 {",
      "        cnt_table.insert(n, 1);",
      "    }",
      "    cnt_table",
      "}",
      "/// 0 から n - 1 までの数で n と互いに素とになる個数を求める(オイラーのトーシェント関数)",
      "/// # 計算量",
      "/// O(sqrt(n))",
      "pub fn euler_phi(n: i64) -> i64 {",
      "    assert!(n >= 1);",
      "    let pf = prime_factorize(n);",
      "    let mut res = n;",
      "    for p in pf.keys() {",
      "        res = res / p * (p - 1);",
      "    }",
      "    res",
      "}"
    ]
  },
  "euler_tour": {
    "scope": "rust",
    "prefix": "euler_tour",
    "body": [
      "use euler_tour::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod euler_tour {",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub enum InOut {",
      "        In(usize),",
      "        Out(usize),",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    pub struct EulerTour {",
      "        pub tour: Vec<InOut>,",
      "        pub in_time: Vec<usize>,",
      "        pub out_time: Vec<usize>,",
      "    }",
      "    impl EulerTour {",
      "        /// オイラーツアーを構築する。",
      "        /// # Arguments",
      "        /// * `tree_parent` - 各頂点の親頂点のインデックス。根の場合は自身のインデックスを指定する。",
      "        /// # 計算量",
      "        /// O(V)",
      "        pub fn new(tree_parent: &[usize]) -> Self {",
      "            let nv = tree_parent.len();",
      "            let tree_children = tree_parent.iter().copied().enumerate().fold(",
      "                vec![vec![]; nv],",
      "                |mut acc, (child, parent)| {",
      "                    if child != parent {",
      "                        acc[parent].push(child);",
      "                    }",
      "                    acc",
      "                },",
      "            );",
      "            let root = (0..nv).find(|&v| tree_parent[v] == v).unwrap();",
      "            let tour = {",
      "                fn dfs(tour: &mut Vec<InOut>, current: usize, tree_children: &[Vec<usize>]) {",
      "                    tour.push(InOut::In(current));",
      "                    for &child in &tree_children[current] {",
      "                        dfs(tour, child, tree_children);",
      "                    }",
      "                    tour.push(InOut::Out(current));",
      "                }",
      "                let mut tour = Vec::with_capacity(2 * nv);",
      "                dfs(&mut tour, root, &tree_children);",
      "                tour",
      "            };",
      "            let (in_time, out_time) = {",
      "                let mut in_time = vec![0; nv];",
      "                let mut out_time = vec![0; nv];",
      "                for (time, edge) in tour.iter().copied().enumerate() {",
      "                    match edge {",
      "                        InOut::In(v) => {",
      "                            in_time[v] = time;",
      "                        }",
      "                        InOut::Out(v) => {",
      "                            out_time[v] = time;",
      "                        }",
      "                    }",
      "                }",
      "                (in_time, out_time)",
      "            };",
      "            EulerTour {",
      "                tour,",
      "                in_time,",
      "                out_time,",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "extend_acl_monoid": {
    "scope": "rust",
    "prefix": "extend_acl_monoid",
    "body": [
      "use extend_acl_monoid::*;",
      "pub mod extend_acl_monoid {",
      "    use ac_library::Monoid;",
      "    pub trait MonoidExtPow: Monoid {",
      "        /// base^n を求める",
      "        fn pow(base: &Self::S, n: usize) -> Self::S {",
      "            let mut base = base.clone();",
      "            let mut ans = Self::identity();",
      "            let mut n = n;",
      "            while n > 0 {",
      "                if n & 1 == 1 {",
      "                    ans = Self::binary_operation(&ans, &base);",
      "                }",
      "                base = Self::binary_operation(&base, &base);",
      "                n >>= 1;",
      "            }",
      "            ans",
      "        }",
      "    }",
      "    impl<T> MonoidExtPow for T where T: Monoid {}",
      "}"
    ]
  },
  "find_pattern_by_z_algorithm": {
    "scope": "rust",
    "prefix": "find_pattern_by_z_algorithm",
    "body": [
      "/// Z-algorithm を用いて、`target `に出現する `pattern` の開始位置をすべて検索する。",
      "/// 結果はソートされている。",
      "/// 計算量: O(|T| + |P|)",
      "pub fn find_pattern_by_z_algorithm<T: Ord + Clone>(target: &[T], pattern: &[T]) -> Vec<usize> {",
      "    use ac_library::z_algorithm_arbitrary;",
      "    use itertools::Itertools;",
      "    let pt = [pattern, target].concat();",
      "    let z_arr = z_algorithm_arbitrary(&pt);",
      "    z_arr[pattern.len()..]",
      "        .iter()",
      "        .positions(|l| *l >= pattern.len())",
      "        .collect_vec()",
      "}"
    ]
  },
  "functional_graph": {
    "scope": "rust",
    "prefix": "functional_graph",
    "body": [
      "use functional_graph::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod functional_graph {",
      "    /// Functional Graph (各頂点の出次数が 1 の有向グラフ) の解析構造体",
      "    /// 各連結成分はちょうど1つのサイクルを持ち、そのサイクルにいくつかの木が流れ込む構造をしています。",
      "    #[derive(Clone, Debug)]",
      "    pub struct FunctionalGraph {",
      "        /// 頂点 u が属する連結成分の ID",
      "        comp_id: Vec<usize>,",
      "        /// 頂点 u からサイクルに到達するまでの距離。サイクル上の頂点は 0。",
      "        depth: Vec<usize>,",
      "        /// 頂点 u から進んで最初に到達するサイクル上の頂点",
      "        root_on_cycle: Vec<usize>,",
      "        /// サイクル内での位置 (0-indexed)",
      "        pos_in_cycle: Vec<usize>,",
      "        /// 各連結成分ごとのサイクル長",
      "        cycle_lens: Vec<usize>,",
      "        in_time: Vec<usize>,",
      "        out_time: Vec<usize>,",
      "    }",
      "    impl FunctionalGraph {",
      "        /// Functional Graph を構築する",
      "        /// # Arguments",
      "        /// * `next` - 各頂点の遷移先 (0..nv-1)",
      "        /// # 計算量",
      "        /// O(V)",
      "        pub fn new(next: &[usize]) -> Self {",
      "            let nv = next.len();",
      "            let mut in_degree = vec![0; nv];",
      "            for &v in next {",
      "                in_degree[v] += 1;",
      "            }",
      "            let mut queue = std::collections::VecDeque::new();",
      "            for i in 0..nv {",
      "                if in_degree[i] == 0 {",
      "                    queue.push_back(i);",
      "                }",
      "            }",
      "            let mut is_on_cycle = vec![true; nv];",
      "            while let Some(u) = queue.pop_front() {",
      "                is_on_cycle[u] = false;",
      "                let v = next[u];",
      "                in_degree[v] -= 1;",
      "                if in_degree[v] == 0 {",
      "                    queue.push_back(v);",
      "                }",
      "            }",
      "            let mut comp_id = vec![usize::MAX; nv];",
      "            let mut pos_in_cycle = vec![0; nv];",
      "            let mut cycles = Vec::new();",
      "            let mut cycle_lens = Vec::new();",
      "            for i in 0..nv {",
      "                if is_on_cycle[i] && comp_id[i] == usize::MAX {",
      "                    let cid = cycles.len();",
      "                    let mut curr_cycle = Vec::new();",
      "                    let mut curr = i;",
      "                    while comp_id[curr] == usize::MAX {",
      "                        comp_id[curr] = cid;",
      "                        pos_in_cycle[curr] = curr_cycle.len();",
      "                        curr_cycle.push(curr);",
      "                        curr = next[curr];",
      "                    }",
      "                    cycle_lens.push(curr_cycle.len());",
      "                    cycles.push(curr_cycle);",
      "                }",
      "            }",
      "            let mut rev_adj = vec![vec![]; nv];",
      "            for i in 0..nv {",
      "                if !is_on_cycle[i] {",
      "                    rev_adj[next[i]].push(i);",
      "                }",
      "            }",
      "            let mut depth = vec![0; nv];",
      "            let mut root_on_cycle = vec![0; nv];",
      "            let mut in_time = vec![0; nv];",
      "            let mut out_time = vec![0; nv];",
      "            let mut timer = 0;",
      "            for cid in 0..cycles.len() {",
      "                for &root in &cycles[cid] {",
      "                    Self::dfs_forest(",
      "                        root,",
      "                        root,",
      "                        cid,",
      "                        0,",
      "                        &rev_adj,",
      "                        &mut depth,",
      "                        &mut root_on_cycle,",
      "                        &mut comp_id,",
      "                        &mut in_time,",
      "                        &mut out_time,",
      "                        &mut timer,",
      "                    );",
      "                }",
      "            }",
      "            Self {",
      "                comp_id,",
      "                depth,",
      "                root_on_cycle,",
      "                pos_in_cycle,",
      "                cycle_lens,",
      "                in_time,",
      "                out_time,",
      "            }",
      "        }",
      "        fn dfs_forest(",
      "            u: usize,",
      "            root: usize,",
      "            cid: usize,",
      "            d: usize,",
      "            rev_adj: &[Vec<usize>],",
      "            depth: &mut [usize],",
      "            root_on_cycle: &mut [usize],",
      "            comp_id: &mut [usize],",
      "            in_time: &mut [usize],",
      "            out_time: &mut [usize],",
      "            timer: &mut usize,",
      "        ) {",
      "            in_time[u] = *timer;",
      "            *timer += 1;",
      "            depth[u] = d;",
      "            root_on_cycle[u] = root;",
      "            comp_id[u] = cid;",
      "            for &v in &rev_adj[u] {",
      "                Self::dfs_forest(",
      "                    v,",
      "                    root,",
      "                    cid,",
      "                    d + 1,",
      "                    rev_adj,",
      "                    depth,",
      "                    root_on_cycle,",
      "                    comp_id,",
      "                    in_time,",
      "                    out_time,",
      "                    timer,",
      "                );",
      "            }",
      "            out_time[u] = *timer;",
      "        }",
      "        /// 頂点 u から v への最短距離を返す。到達不能なら None。",
      "        /// # 計算量",
      "        /// O(1)",
      "        pub fn distance(&self, u: usize, v: usize) -> Option<usize> {",
      "            if self.comp_id[u] != self.comp_id[v] {",
      "                return None;",
      "            }",
      "            if self.depth[v] > 0 {",
      "                if self.root_on_cycle[u] == self.root_on_cycle[v]",
      "                    && self.in_time[v] <= self.in_time[u]",
      "                    && self.out_time[u] <= self.out_time[v]",
      "                {",
      "                    Some(self.depth[u] - self.depth[v])",
      "                } else {",
      "                    None",
      "                }",
      "            } else {",
      "                let d_to_cycle = self.depth[u];",
      "                let u_root = self.root_on_cycle[u];",
      "                let cid = self.comp_id[u];",
      "                let clen = self.cycle_lens[cid];",
      "                let dist_on_cycle =",
      "                    (self.pos_in_cycle[v] + clen - self.pos_in_cycle[u_root]) % clen;",
      "                Some(d_to_cycle + dist_on_cycle)",
      "            }",
      "        }",
      "        /// 頂点 u から v に到達可能か判定する",
      "        /// # 計算量",
      "        /// O(1)",
      "        pub fn is_reachable(&self, u: usize, v: usize) -> bool {",
      "            self.distance(u, v).is_some()",
      "        }",
      "    }",
      "}"
    ]
  },
  "general_additive_monoid": {
    "scope": "rust",
    "prefix": "general_additive_monoid",
    "body": [
      "use general_additive_monoid::*;",
      "pub mod general_additive_monoid {",
      "    use ac_library::Monoid;",
      "    use std::{convert::Infallible, iter::Sum, marker::PhantomData, ops::Add};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct GeneralAdditive<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T: Sum + Add<Output = T> + Copy> Monoid for GeneralAdditive<T> {",
      "        type S = T;",
      "        fn identity() -> Self::S {",
      "            std::iter::empty().sum()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a + *b",
      "        }",
      "    }",
      "}"
    ]
  },
  "general_multiplicative_monoid": {
    "scope": "rust",
    "prefix": "general_multiplicative_monoid",
    "body": [
      "use general_multiplicative_monoid::*;",
      "pub mod general_multiplicative_monoid {",
      "    use ac_library::Monoid;",
      "    use std::{convert::Infallible, iter::Product, marker::PhantomData, ops::Mul};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct GeneralMultiplicative<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T: Product + Mul<Output = T> + Copy> Monoid for GeneralMultiplicative<T> {",
      "        type S = T;",
      "        fn identity() -> Self::S {",
      "            std::iter::empty().product()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a * *b",
      "        }",
      "    }",
      "}"
    ]
  },
  "grid_dsu": {
    "scope": "rust",
    "prefix": "grid_dsu",
    "body": [
      "use grid_dsu::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod grid_dsu {",
      "    use super::{DsuCore, Pos};",
      "    use itertools::Itertools;",
      "    #[derive(Clone, Debug)]",
      "    pub struct GridDsu {",
      "        dsu: DsuCore,",
      "        w: usize,",
      "    }",
      "    impl GridDsu {",
      "        pub fn new(h: usize, w: usize) -> GridDsu {",
      "            GridDsu {",
      "                dsu: DsuCore::new(h * w),",
      "                w,",
      "            }",
      "        }",
      "        pub fn encode(&self, pos: Pos) -> usize {",
      "            (pos.y * self.w as i64 + pos.x) as usize",
      "        }",
      "        pub fn decode(&self, i: usize) -> Pos {",
      "            let y = (i / self.w) as i64;",
      "            let x = (i % self.w) as i64;",
      "            Pos::new(x, y)",
      "        }",
      "        pub fn size(&mut self, pos: Pos) -> usize {",
      "            self.dsu.size(self.encode(pos))",
      "        }",
      "        pub fn same(&mut self, pos1: Pos, pos2: Pos) -> bool {",
      "            self.dsu.same(self.encode(pos1), self.encode(pos2))",
      "        }",
      "        pub fn count_group(&self) -> usize {",
      "            self.dsu.count_group()",
      "        }",
      "        pub fn merge(&mut self, pos1: Pos, pos2: Pos) -> Option<(usize, usize)> {",
      "            self.dsu.merge(self.encode(pos1), self.encode(pos2))",
      "        }",
      "        pub fn groups(&mut self) -> Vec<Vec<Pos>> {",
      "            self.dsu",
      "                .groups()",
      "                .into_iter()",
      "                .map(|group| group.iter().copied().map(|i| self.decode(i)).collect_vec())",
      "                .collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "has_cycle_directed_by_topo_sort": {
    "scope": "rust",
    "prefix": "has_cycle_directed_by_topo_sort",
    "body": [
      "use mod_queue::*;",
      "/// トポロジカルソートを行います。",
      "/// # Arguments",
      "/// * `adj` - 隣接リスト",
      "/// # Returns",
      "/// トポロジカルソートされた頂点のリスト。サイクルが含まれる場合、リストの長さは `adj.len()` 未満になります。",
      "/// # 計算量",
      "/// O(V + E) (V は頂点数, E は辺数)",
      "pub fn topo_sort(adj: &[Vec<usize>]) -> Vec<usize> {",
      "    let n_vertex = adj.len();",
      "    let mut in_deg = vec![0; n_vertex];",
      "    for neighbors in adj {",
      "        for &next in neighbors {",
      "            in_deg[next] += 1;",
      "        }",
      "    }",
      "    let mut open: Queue<usize> = Queue::new();",
      "    for (v, &deg) in in_deg.iter().enumerate() {",
      "        if deg == 0 {",
      "            open.push(v);",
      "        }",
      "    }",
      "    let mut ans = vec![];",
      "    while let Some(current) = open.pop() {",
      "        ans.push(current);",
      "        for &next in &adj[current] {",
      "            in_deg[next] -= 1;",
      "            if in_deg[next] == 0 {",
      "                open.push(next);",
      "            }",
      "        }",
      "    }",
      "    ans",
      "}",
      "pub mod mod_queue {",
      "    use std::collections::VecDeque;",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Queue<T> {",
      "        raw: VecDeque<T>,",
      "    }",
      "    impl<T> Queue<T> {",
      "        pub fn new() -> Self {",
      "            Queue {",
      "                raw: VecDeque::new(),",
      "            }",
      "        }",
      "        pub fn push(&mut self, value: T) {",
      "            self.raw.push_back(value)",
      "        }",
      "        pub fn pop(&mut self) -> Option<T> {",
      "            self.raw.pop_front()",
      "        }",
      "        pub fn peek(&self) -> Option<&T> {",
      "            self.raw.front()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.raw.len()",
      "        }",
      "    }",
      "    impl<T> Default for Queue<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "}",
      "/// トポロジカルソートを用いて、有向グラフに閉路が含まれるかを判定します。",
      "/// # 計算量",
      "/// O(V + E)",
      "pub fn has_cycle_directed_by_topo_sort(adj: &[Vec<usize>]) -> bool {",
      "    let topo_sorted = topo_sort(adj);",
      "    topo_sorted.len() != adj.len()",
      "}"
    ]
  },
  "has_cycle_undirected": {
    "scope": "rust",
    "prefix": "has_cycle_undirected",
    "body": [
      "/// 無向グラフに閉路が含まれるかを判定します。",
      "/// # 計算量",
      "/// O(E α(V))",
      "pub fn has_cycle_undirected(n_vertex: usize, edges: &[(usize, usize)]) -> bool {",
      "    use petgraph::unionfind::UnionFind;",
      "    let mut uf = UnionFind::new(n_vertex);",
      "    for &(from, to) in edges {",
      "        if uf.equiv(from, to) {",
      "            return true;",
      "        }",
      "        uf.union(from, to);",
      "    }",
      "    false",
      "}"
    ]
  },
  "i64_combinatorics": {
    "scope": "rust",
    "prefix": "i64_combinatorics",
    "body": [
      "use mod_combinatorics::*;",
      "pub mod i64_combinatorics {",
      "    /// 組み合わせ nCk を計算する。",
      "    /// 計算量: O(k)",
      "    pub fn comb(n: i64, k: i64) -> i64 {",
      "        if n < 0 || k < 0 || n < k {",
      "            return 0;",
      "        }",
      "        (1..=k).fold(1, |acc, i| acc * (n - i + 1) / i)",
      "    }",
      "    /// 順列 nPk を計算する。",
      "    /// 計算量: O(k)",
      "    pub fn perm(n: i64, k: i64) -> i64 {",
      "        if n < 0 || k < 0 || n < k {",
      "            return 0;",
      "        }",
      "        (n - k + 1..=n).product::<i64>()",
      "    }",
      "    /// 階乗 n! を計算する。",
      "    /// 計算量: O(n)",
      "    pub fn factorial(n: i64) -> i64 {",
      "        if n < 0 {",
      "            return 0;",
      "        }",
      "        (1..=n).product::<i64>()",
      "    }",
      "}"
    ]
  },
  "imos_1d": {
    "scope": "rust",
    "prefix": "imos_1d",
    "body": [
      "use imos_1d::*;",
      "#[allow(clippy::module_inception)]",
      "/// 1次元いもす法を扱うモジュール",
      "/// # Examples",
      "/// ```",
      "/// use mylib::algorithm::imos::imos_1d::imos_1d::*;",
      "/// // [0, 5) の範囲で考える。1回差分を取るので end は 1つ余分に確保する",
      "/// let mut imos = Imos1D::new(0, 5 + 1);",
      "/// // [0, 2) に 1 を加算",
      "/// imos.add(0, 1);",
      "/// imos.add(2, -1);",
      "/// // [3, 5) に 2 を加算",
      "/// imos.add(3, 2);",
      "/// imos.add(5, -2);",
      "/// imos.summation();",
      "/// assert_eq!(imos.get(0), 1);",
      "/// assert_eq!(imos.get(1), 1);",
      "/// assert_eq!(imos.get(2), 0);",
      "/// assert_eq!(imos.get(3), 2);",
      "/// assert_eq!(imos.get(4), 2);",
      "/// ```",
      "pub mod imos_1d {",
      "    /// 1次元いもす法のための構造体",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Imos1D {",
      "        raw: Vec<i64>,",
      "        begin: i64,",
      "        end: i64,",
      "    }",
      "    impl Imos1D {",
      "        /// `[begin, end)` の半開区間を対象とする `Imos1D` を生成する。",
      "        /// `summation` を複数回適用する場合（例：アフィン変換や二次関数）、",
      "        /// その回数分だけ `end` を広めに確保する必要がある。",
      "        /// # Panics",
      "        /// `begin >= end` の場合、デバッグビルドではパニックする。",
      "        pub fn new(begin: i64, end: i64) -> Self {",
      "            debug_assert!(begin < end);",
      "            let len = (end - begin) as usize;",
      "            let raw = vec![0; len];",
      "            Self { raw, begin, end }",
      "        }",
      "        fn is_within(&self, i: i64) -> bool {",
      "            (self.begin..self.end).contains(&i)",
      "        }",
      "        /// `i` 番目の要素の値を取得する。",
      "        /// `summation` 実行前は差分が、実行後は累積和が返される。",
      "        /// # Panics",
      "        /// `i` が `[begin, end)` の範囲外の場合、デバッグビルドではパニックする。",
      "        pub fn get(&self, i: i64) -> i64 {",
      "            if cfg!(debug_assertions) && !self.is_within(i) {",
      "                panic!(",
      "                    \"index out of bounds: the range is [{}, {}) but the index is {}\",",
      "                    self.begin, self.end, i",
      "                );",
      "            }",
      "            self.raw[(i - self.begin) as usize]",
      "        }",
      "        /// `i` 番目の要素に `val` を加算する。",
      "        /// 区間 `[l, r)` に値を加算したい場合は、`imos.add(l, val)` と `imos.add(r, -val)` を呼び出す。",
      "        /// # Panics",
      "        /// `i` が `[begin, end)` の範囲外の場合、デバッグビルドではパニックする。",
      "        pub fn add(&mut self, i: i64, val: i64) {",
      "            if cfg!(debug_assertions) && !self.is_within(i) {",
      "                panic!(",
      "                    \"index out of bounds: the range is [{}, {}) but the index is {}\",",
      "                    self.begin, self.end, i",
      "                );",
      "            }",
      "            self.raw[(i - self.begin) as usize] += val;",
      "        }",
      "        /// 差分の累積和を計算する。",
      "        /// この操作により、各要素は区間加算を反映した最終的な値を持つようになる。",
      "        pub fn summation(&mut self) {",
      "            for i in 1..self.raw.len() {",
      "                self.raw[i] += self.raw[i - 1]",
      "            }",
      "        }",
      "        /// 累積和から差分を計算する（デバッグ用）。",
      "        pub fn difference(&mut self) {",
      "            for i in (1..self.raw.len()).rev() {",
      "                self.raw[i] -= self.raw[i - 1];",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "imos_1d_arbitrary": {
    "scope": "rust",
    "prefix": "imos_1d_arbitrary",
    "body": [
      "use ab_group::*;",
      "use imos_1d_arbitrary::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod ab_group {",
      "    use std::{",
      "        convert::Infallible,",
      "        iter::Sum,",
      "        marker::PhantomData,",
      "        ops::{Add, Neg, Sub},",
      "    };",
      "    /// 可換群 (Abelian Group)",
      "    pub trait AbGroup {",
      "        type S: Clone;",
      "        fn zero() -> Self::S;",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S;",
      "        fn neg(a: &Self::S) -> Self::S;",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            Self::add(a, &Self::neg(b))",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct AdditiveAbGroup<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T: Sum + Add<Output = T> + Sub<Output = T> + Neg<Output = T> + Copy> AbGroup",
      "        for AdditiveAbGroup<T>",
      "    {",
      "        type S = T;",
      "        fn zero() -> Self::S {",
      "            std::iter::empty().sum()",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a + *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            -(*a)",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a - *b",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct XorAbGroup(Infallible);",
      "    impl AbGroup for XorAbGroup {",
      "        type S = u64;",
      "        fn zero() -> Self::S {",
      "            0",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            *a",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::module_inception)]",
      "/// 可換群 (AbGroup) を用いた汎用的な 1次元いもす法を扱うモジュール",
      "pub mod imos_1d_arbitrary {",
      "    use super::AbGroup;",
      "    /// 1次元いもす法のための構造体 (汎用版)",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Imos1DArbitrary<G: AbGroup> {",
      "        raw: Vec<G::S>,",
      "        begin: i64,",
      "        end: i64,",
      "    }",
      "    impl<G: AbGroup> Imos1DArbitrary<G> {",
      "        /// `[begin, end)` の半開区間を対象とする `Imos1DArbitrary` を生成する。",
      "        /// `summation` を複数回適用する場合（例：アフィン変換や二次関数）、",
      "        /// その回数分だけ `end` を広めに確保する必要がある。",
      "        /// # Panics",
      "        /// `begin >= end` の場合、デバッグビルドではパニックする。",
      "        pub fn new(begin: i64, end: i64) -> Self {",
      "            debug_assert!(begin < end);",
      "            let len = (end - begin) as usize;",
      "            let mut raw = Vec::with_capacity(len);",
      "            for _ in 0..len {",
      "                raw.push(G::zero());",
      "            }",
      "            Self { raw, begin, end }",
      "        }",
      "        fn is_within(&self, i: i64) -> bool {",
      "            (self.begin..self.end).contains(&i)",
      "        }",
      "        /// `i` 番目の要素の値を取得する。",
      "        /// `summation` 実行前は差分が、実行後は累積和が返される。",
      "        /// # Panics",
      "        /// `i` が `[begin, end)` の範囲外の場合、デバッグビルドではパニックする。",
      "        pub fn get(&self, i: i64) -> G::S {",
      "            if cfg!(debug_assertions) && !self.is_within(i) {",
      "                panic!(",
      "                    \"index out of bounds: the range is [{}, {}) but the index is {}\",",
      "                    self.begin, self.end, i",
      "                );",
      "            }",
      "            self.raw[(i - self.begin) as usize].clone()",
      "        }",
      "        /// `i` 番目の要素に `val` を加算する。",
      "        /// 区間 `[l, r)` に値を加算したい場合は、`imos.add(l, val)` と `imos.add(r, G::neg(&val))` を呼び出す。",
      "        /// # Panics",
      "        /// `i` が `[begin, end)` の範囲外の場合、デバッグビルドではパニックする。",
      "        pub fn add(&mut self, i: i64, val: G::S) {",
      "            if cfg!(debug_assertions) && !self.is_within(i) {",
      "                panic!(",
      "                    \"index out of bounds: the range is [{}, {}) but the index is {}\",",
      "                    self.begin, self.end, i",
      "                );",
      "            }",
      "            let idx = (i - self.begin) as usize;",
      "            self.raw[idx] = G::add(&self.raw[idx], &val);",
      "        }",
      "        /// 差分の累積和を計算する。",
      "        /// この操作により、各要素は区間加算を反映した最終的な値を持つようになる。",
      "        pub fn summation(&mut self) {",
      "            for i in 1..self.raw.len() {",
      "                self.raw[i] = G::add(&self.raw[i - 1], &self.raw[i]);",
      "            }",
      "        }",
      "        /// 累積和から差分を計算する（デバッグ用）。",
      "        pub fn difference(&mut self) {",
      "            for i in (1..self.raw.len()).rev() {",
      "                self.raw[i] = G::sub(&self.raw[i], &self.raw[i - 1]);",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "imos_2d": {
    "scope": "rust",
    "prefix": "imos_2d",
    "body": [
      "use imos_2d::*;",
      "#[allow(clippy::module_inception)]",
      "/// 2次元いもす法を扱うモジュール",
      "/// # Examples",
      "/// ```",
      "/// use mylib::algorithm::imos::imos_2d::imos_2d::*;",
      "/// let (h, w) = (4, 5);",
      "/// // 1回差分を取るので、各次元の end を1つ余分に確保する",
      "/// let mut imos = Imos2D::new(0, h + 1, 0, w + 1);",
      "/// // 矩形領域 [1, 3) x [2, 4) に 1 を加算",
      "/// imos.add(1, 2, 1);",
      "/// imos.add(1, 4, -1);",
      "/// imos.add(3, 2, -1);",
      "/// imos.add(3, 4, 1);",
      "/// // x方向、y方向の順に累積和を計算",
      "/// imos.summation(0, 1);",
      "/// imos.summation(1, 0);",
      "/// assert_eq!(imos.get(1, 2), 1);",
      "/// assert_eq!(imos.get(2, 3), 1);",
      "/// assert_eq!(imos.get(0, 0), 0);",
      "/// ```",
      "pub mod imos_2d {",
      "    /// 2次元いもす法のための構造体",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Imos2D {",
      "        raw: Vec<Vec<i64>>,",
      "        y_begin: i64,",
      "        y_end: i64,",
      "        x_begin: i64,",
      "        x_end: i64,",
      "    }",
      "    impl Imos2D {",
      "        /// `[y_begin, y_end) x [x_begin, x_end)` の矩形領域を対象とする `Imos2D` を生成する。",
      "        /// `summation` を適用する方向や回数に応じて、`end` を広めに確保する必要がある。",
      "        /// # Panics",
      "        /// `begin >= end` となる次元がある場合、デバッグビルドではパニックする。",
      "        pub fn new(y_begin: i64, y_end: i64, x_begin: i64, x_end: i64) -> Self {",
      "            debug_assert!(y_begin < y_end);",
      "            debug_assert!(x_begin < x_end);",
      "            let height = (y_end - y_begin) as usize;",
      "            let width = (x_end - x_begin) as usize;",
      "            let raw = vec![vec![0; width]; height];",
      "            Self {",
      "                raw,",
      "                y_begin,",
      "                y_end,",
      "                x_begin,",
      "                x_end,",
      "            }",
      "        }",
      "        fn is_within(&self, y: i64, x: i64) -> bool {",
      "            (self.y_begin..self.y_end).contains(&y) && (self.x_begin..self.x_end).contains(&x)",
      "        }",
      "        /// `(y, x)` の要素の値を取得する。",
      "        /// `summation` 実行前は差分が、実行後は累積和が返される。",
      "        /// # Panics",
      "        /// `(y, x)` が範囲外の場合、デバッグビルドではパニックする。",
      "        pub fn get(&self, y: i64, x: i64) -> i64 {",
      "            if cfg!(debug_assertions) && !self.is_within(y, x) {",
      "                panic ! (\"index out of bounds: the domain is [{}, {}) × [{}, {}) but the index is ({}, {})\" , self . y_begin , self . y_end , self . x_begin , self . x_end , y , x );",
      "            }",
      "            self.raw[(y - self.y_begin) as usize][(x - self.x_begin) as usize]",
      "        }",
      "        pub fn y_begin(&self) -> i64 {",
      "            self.y_begin",
      "        }",
      "        pub fn y_end(&self) -> i64 {",
      "            self.y_end",
      "        }",
      "        pub fn x_begin(&self) -> i64 {",
      "            self.x_begin",
      "        }",
      "        pub fn x_end(&self) -> i64 {",
      "            self.x_end",
      "        }",
      "        /// `(y, x)` の要素に `val` を加算する。",
      "        /// 矩形領域 `[y1, y2) x [x1, x2)` に値を加算するには、4点の `add` を呼び出す。",
      "        /// # Panics",
      "        /// `(y, x)` が範囲外の場合、デバッグビルドではパニックする。",
      "        pub fn add(&mut self, y: i64, x: i64, val: i64) {",
      "            if cfg!(debug_assertions) && !self.is_within(y, x) {",
      "                panic ! (\"index out of bounds: the domain is [{}, {}) × [{}, {}) but the index is ({}, {})\" , self . y_begin , self . y_end , self . x_begin , self . x_end , y , x );",
      "            }",
      "            self.raw[(y - self.y_begin) as usize][(x - self.x_begin) as usize] += val;",
      "        }",
      "        /// `(d_y, d_x)` 方向の差分の累積和を計算する。",
      "        /// - `(1, 0)`: y方向の累積和",
      "        /// - `(0, 1)`: x方向の累積和",
      "        /// - `(1, 1)`: 右下方向の累積和",
      "        /// # Panics",
      "        /// `(d_y, d_x) == (0, 0)` の場合、デバッグビルドではパニックする。",
      "        pub fn summation(&mut self, d_y: i64, d_x: i64) {",
      "            debug_assert_ne!((d_y, d_x), (0, 0));",
      "            let height = self.y_end - self.y_begin;",
      "            let width = self.x_end - self.x_begin;",
      "            if d_y > 0 || (d_y == 0 && d_x > 0) {",
      "                for y in 0..height {",
      "                    for x in 0..width {",
      "                        let prev_y = y - d_y;",
      "                        let prev_x = x - d_x;",
      "                        if (0..height).contains(&prev_y) && (0..width).contains(&prev_x) {",
      "                            self.raw[y as usize][x as usize] +=",
      "                                self.raw[prev_y as usize][prev_x as usize]",
      "                        }",
      "                    }",
      "                }",
      "            } else {",
      "                for y in (0..height).rev() {",
      "                    for x in (0..width).rev() {",
      "                        let prev_y = y - d_y;",
      "                        let prev_x = x - d_x;",
      "                        if (0..height).contains(&prev_y) && (0..width).contains(&prev_x) {",
      "                            self.raw[y as usize][x as usize] +=",
      "                                self.raw[prev_y as usize][prev_x as usize]",
      "                        }",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        /// 別の Imos2D オブジェクトと要素ごとに足し合わせる。",
      "        /// 2つの Imos2D オブジェクトの領域が異なる場合は、領域の和集合を囲う最小の長方形を新しい領域とする。",
      "        pub fn add_imos(&self, other: &Self) -> Self {",
      "            use std::cmp::{max, min};",
      "            let new_y_begin = min(self.y_begin, other.y_begin);",
      "            let new_y_end = max(self.y_end, other.y_end);",
      "            let new_x_begin = min(self.x_begin, other.x_begin);",
      "            let new_x_end = max(self.x_end, other.x_end);",
      "            let mut result = Self::new(new_y_begin, new_y_end, new_x_begin, new_x_end);",
      "            for y in 0..self.raw.len() {",
      "                for x in 0..self.raw[y].len() {",
      "                    if self.raw[y][x] != 0 {",
      "                        let original_y = self.y_begin + y as i64;",
      "                        let original_x = self.x_begin + x as i64;",
      "                        result.add(original_y, original_x, self.raw[y][x]);",
      "                    }",
      "                }",
      "            }",
      "            for y in 0..other.raw.len() {",
      "                for x in 0..other.raw[y].len() {",
      "                    if other.raw[y][x] != 0 {",
      "                        let original_y = other.y_begin + y as i64;",
      "                        let original_x = other.x_begin + x as i64;",
      "                        result.add(original_y, original_x, other.raw[y][x]);",
      "                    }",
      "                }",
      "            }",
      "            result",
      "        }",
      "    }",
      "}"
    ]
  },
  "imos_2d_arbitrary": {
    "scope": "rust",
    "prefix": "imos_2d_arbitrary",
    "body": [
      "use ab_group::*;",
      "use imos_2d_arbitrary::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod ab_group {",
      "    use std::{",
      "        convert::Infallible,",
      "        iter::Sum,",
      "        marker::PhantomData,",
      "        ops::{Add, Neg, Sub},",
      "    };",
      "    /// 可換群 (Abelian Group)",
      "    pub trait AbGroup {",
      "        type S: Clone;",
      "        fn zero() -> Self::S;",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S;",
      "        fn neg(a: &Self::S) -> Self::S;",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            Self::add(a, &Self::neg(b))",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct AdditiveAbGroup<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T: Sum + Add<Output = T> + Sub<Output = T> + Neg<Output = T> + Copy> AbGroup",
      "        for AdditiveAbGroup<T>",
      "    {",
      "        type S = T;",
      "        fn zero() -> Self::S {",
      "            std::iter::empty().sum()",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a + *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            -(*a)",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a - *b",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct XorAbGroup(Infallible);",
      "    impl AbGroup for XorAbGroup {",
      "        type S = u64;",
      "        fn zero() -> Self::S {",
      "            0",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            *a",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::module_inception)]",
      "/// 可換群 (AbGroup) を用いた汎用的な 2次元いもす法を扱うモジュール",
      "pub mod imos_2d_arbitrary {",
      "    use super::AbGroup;",
      "    /// 2次元いもす法のための構造体 (汎用版)",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Imos2dArbitrary<G: AbGroup> {",
      "        raw: Vec<Vec<G::S>>,",
      "        y_begin: i64,",
      "        y_end: i64,",
      "        x_begin: i64,",
      "        x_end: i64,",
      "    }",
      "    impl<G: AbGroup> Imos2dArbitrary<G> {",
      "        /// `[y_begin, y_end) x [x_begin, x_end)` の矩形領域を対象とする `Imos2dArbitrary` を生成する。",
      "        /// `summation` を適用する方向や回数に応じて、`end` を広めに確保する必要がある。",
      "        /// # Panics",
      "        /// `begin >= end` となる次元がある場合、デバッグビルドではパニックする。",
      "        pub fn new(y_begin: i64, y_end: i64, x_begin: i64, x_end: i64) -> Self {",
      "            debug_assert!(y_begin < y_end);",
      "            debug_assert!(x_begin < x_end);",
      "            let height = (y_end - y_begin) as usize;",
      "            let width = (x_end - x_begin) as usize;",
      "            let mut raw = Vec::with_capacity(height);",
      "            for _ in 0..height {",
      "                let mut row = Vec::with_capacity(width);",
      "                for _ in 0..width {",
      "                    row.push(G::zero());",
      "                }",
      "                raw.push(row);",
      "            }",
      "            Self {",
      "                raw,",
      "                y_begin,",
      "                y_end,",
      "                x_begin,",
      "                x_end,",
      "            }",
      "        }",
      "        fn is_within(&self, y: i64, x: i64) -> bool {",
      "            (self.y_begin..self.y_end).contains(&y) && (self.x_begin..self.x_end).contains(&x)",
      "        }",
      "        /// `(y, x)` の要素の値を取得する。",
      "        /// `summation` 実行前は差分が、実行後は累積和が返される。",
      "        /// # Panics",
      "        /// `(y, x)` が範囲外の場合、デバッグビルドではパニックする。",
      "        pub fn get(&self, y: i64, x: i64) -> G::S {",
      "            if cfg!(debug_assertions) && !self.is_within(y, x) {",
      "                panic ! (\"index out of bounds: the domain is [{}, {}) × [{}, {}) but the index is ({}, {})\" , self . y_begin , self . y_end , self . x_begin , self . x_end , y , x );",
      "            }",
      "            self.raw[(y - self.y_begin) as usize][(x - self.x_begin) as usize].clone()",
      "        }",
      "        pub fn y_begin(&self) -> i64 {",
      "            self.y_begin",
      "        }",
      "        pub fn y_end(&self) -> i64 {",
      "            self.y_end",
      "        }",
      "        pub fn x_begin(&self) -> i64 {",
      "            self.x_begin",
      "        }",
      "        pub fn x_end(&self) -> i64 {",
      "            self.x_end",
      "        }",
      "        /// `(y, x)` の要素に `val` を加算する。",
      "        /// 矩形領域 `[y1, y2) x [x1, x2)` に値を加算するには、4点の `add` を呼び出す。",
      "        /// # Panics",
      "        /// `(y, x)` が範囲外の場合、デバッグビルドではパニックする。",
      "        pub fn add(&mut self, y: i64, x: i64, val: G::S) {",
      "            if cfg!(debug_assertions) && !self.is_within(y, x) {",
      "                panic ! (\"index out of bounds: the domain is [{}, {}) × [{}, {}) but the index is ({}, {})\" , self . y_begin , self . y_end , self . x_begin , self . x_end , y , x );",
      "            }",
      "            let row = (y - self.y_begin) as usize;",
      "            let col = (x - self.x_begin) as usize;",
      "            self.raw[row][col] = G::add(&self.raw[row][col], &val);",
      "        }",
      "        /// `(d_y, d_x)` 方向の差分の累積和を計算する。",
      "        /// - `(1, 0)`: y方向の累積和",
      "        /// - `(0, 1)`: x方向の累積和",
      "        /// - `(1, 1)`: 右下方向の累積和",
      "        /// # Panics",
      "        /// `(d_y, d_x) == (0, 0)` の場合、デバッグビルドではパニックする。",
      "        pub fn summation(&mut self, d_y: i64, d_x: i64) {",
      "            debug_assert_ne!((d_y, d_x), (0, 0));",
      "            let height = self.y_end - self.y_begin;",
      "            let width = self.x_end - self.x_begin;",
      "            if d_y > 0 || (d_y == 0 && d_x > 0) {",
      "                for y in 0..height {",
      "                    for x in 0..width {",
      "                        let prev_y = y - d_y;",
      "                        let prev_x = x - d_x;",
      "                        if (0..height).contains(&prev_y) && (0..width).contains(&prev_x) {",
      "                            self.raw[y as usize][x as usize] = G::add(",
      "                                &self.raw[prev_y as usize][prev_x as usize],",
      "                                &self.raw[y as usize][x as usize],",
      "                            );",
      "                        }",
      "                    }",
      "                }",
      "            } else {",
      "                for y in (0..height).rev() {",
      "                    for x in (0..width).rev() {",
      "                        let prev_y = y - d_y;",
      "                        let prev_x = x - d_x;",
      "                        if (0..height).contains(&prev_y) && (0..width).contains(&prev_x) {",
      "                            self.raw[y as usize][x as usize] = G::add(",
      "                                &self.raw[prev_y as usize][prev_x as usize],",
      "                                &self.raw[y as usize][x as usize],",
      "                            );",
      "                        }",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        /// 別の Imos2dArbitrary オブジェクトと要素ごとに足し合わせる。",
      "        /// 2つの Imos2dArbitrary オブジェクトの領域が異なる場合は、領域の和集合を囲う最小の長方形を新しい領域とする。",
      "        pub fn add_imos(&self, other: &Self) -> Self {",
      "            use std::cmp::{max, min};",
      "            let new_y_begin = min(self.y_begin, other.y_begin);",
      "            let new_y_end = max(self.y_end, other.y_end);",
      "            let new_x_begin = min(self.x_begin, other.x_begin);",
      "            let new_x_end = max(self.x_end, other.x_end);",
      "            let mut result = Self::new(new_y_begin, new_y_end, new_x_begin, new_x_end);",
      "            for y in 0..self.raw.len() {",
      "                for x in 0..self.raw[y].len() {",
      "                    let original_y = self.y_begin + y as i64;",
      "                    let original_x = self.x_begin + x as i64;",
      "                    result.add(original_y, original_x, self.raw[y][x].clone());",
      "                }",
      "            }",
      "            for y in 0..other.raw.len() {",
      "                for x in 0..other.raw[y].len() {",
      "                    let original_y = other.y_begin + y as i64;",
      "                    let original_x = other.x_begin + x as i64;",
      "                    result.add(original_y, original_x, other.raw[y][x].clone());",
      "                }",
      "            }",
      "            result",
      "        }",
      "    }",
      "}"
    ]
  },
  "inversion_number": {
    "scope": "rust",
    "prefix": "inversion_number",
    "body": [
      "/// 転倒数 `#{(i, j) | i < j and xs[i] > xs[j]}` を求める",
      "/// # 計算量",
      "/// O(m log m + n)",
      "/// (m = max(xs), n = xs.len())",
      "pub fn inversion_number(xs: &[usize]) -> i64 {",
      "    use ac_library::FenwickTree;",
      "    if xs.is_empty() {",
      "        return 0;",
      "    }",
      "    let max_val = xs.iter().copied().max().unwrap();",
      "    let mut fenwick = FenwickTree::new(max_val + 1, 0_i64);",
      "    let mut cnt = 0;",
      "    for &x in xs {",
      "        cnt += fenwick.sum(x + 1..);",
      "        fenwick.add(x, 1);",
      "    }",
      "    cnt",
      "}"
    ]
  },
  "is_bipartite_graph": {
    "scope": "rust",
    "prefix": "is_bipartite_graph",
    "body": [
      "use mod_queue::*;",
      "pub mod mod_queue {",
      "    use std::collections::VecDeque;",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Queue<T> {",
      "        raw: VecDeque<T>,",
      "    }",
      "    impl<T> Queue<T> {",
      "        pub fn new() -> Self {",
      "            Queue {",
      "                raw: VecDeque::new(),",
      "            }",
      "        }",
      "        pub fn push(&mut self, value: T) {",
      "            self.raw.push_back(value)",
      "        }",
      "        pub fn pop(&mut self) -> Option<T> {",
      "            self.raw.pop_front()",
      "        }",
      "        pub fn peek(&self) -> Option<&T> {",
      "            self.raw.front()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.raw.len()",
      "        }",
      "    }",
      "    impl<T> Default for Queue<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::collapsible_else_if)]",
      "/// グラフが二部グラフであるかを判定します。",
      "/// # 計算量",
      "/// O(V + E)",
      "pub fn is_bipartite_graph(adj: &[Vec<usize>]) -> bool {",
      "    let n_vertex = adj.len();",
      "    let mut visited = vec![false; n_vertex];",
      "    let mut odd_even_list = vec![-1; n_vertex];",
      "    for init in 0..n_vertex {",
      "        if visited[init] {",
      "            continue;",
      "        }",
      "        let mut open: Queue<usize> = Queue::new();",
      "        open.push(init);",
      "        visited[init] = true;",
      "        odd_even_list[init] = 0;",
      "        while let Some(current) = open.pop() {",
      "            for &next in &adj[current] {",
      "                if !visited[next] {",
      "                    visited[next] = true;",
      "                    open.push(next);",
      "                    odd_even_list[next] = 1 - odd_even_list[current];",
      "                } else {",
      "                    if odd_even_list[current] == odd_even_list[next] {",
      "                        return false;",
      "                    }",
      "                }",
      "            }",
      "        }",
      "    }",
      "    true",
      "}"
    ]
  },
  "is_bipartite_graph_by_uf": {
    "scope": "rust",
    "prefix": "is_bipartite_graph_by_uf",
    "body": [
      "/// Union-Find を用いて、グラフが二部グラフであるかを判定します。",
      "/// # 計算量",
      "/// O(E α(V))",
      "pub fn is_bipartite_graph_by_uf(n_vertex: usize, edges: &[(usize, usize)]) -> bool {",
      "    use petgraph::unionfind::UnionFind;",
      "    let mut uf = UnionFind::new(2 * n_vertex);",
      "    for &(from, to) in edges {",
      "        uf.union(from, to + n_vertex);",
      "        uf.union(from + n_vertex, to);",
      "    }",
      "    (0..n_vertex).all(|i| !uf.equiv(i, i + n_vertex))",
      "}"
    ]
  },
  "is_prime": {
    "scope": "rust",
    "prefix": "is_prime",
    "body": [
      "/// n が素数かどうか判定する",
      "/// # 計算量",
      "/// O(sqrt(n))",
      "pub fn is_prime(n: i64) -> bool {",
      "    use num::Integer;",
      "    use num_integer::Roots;",
      "    if n <= 1 {",
      "        return false;",
      "    }",
      "    for i in 2..=n.sqrt() {",
      "        if n.is_multiple_of(&i) {",
      "            return false;",
      "        }",
      "    }",
      "    true",
      "}"
    ]
  },
  "ix": {
    "scope": "rust",
    "prefix": "ix",
    "body": [
      "use ix::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod ix {",
      "    use std::ops::{Index, IndexMut};",
      "    /// Haskell の `Ix` 型クラスに相当するトレイトです。",
      "    /// 連続する値の範囲を定義し、その範囲内の値を整数インデックスにマッピングするために使用されます。",
      "    pub trait Ix: PartialOrd + Copy {",
      "        /// 範囲内の全ての要素を順番に返すイテレータを返します。",
      "        fn range(bounds: (Self, Self)) -> impl Iterator<Item = Self>;",
      "        /// 指定された範囲に含まれる要素の数を返します。",
      "        fn range_size(bounds: (Self, Self)) -> usize;",
      "        /// 指定された範囲内における、値 `i` の 0 始まりのインデックスを返します。",
      "        /// `i` が範囲外の場合はパニックします。",
      "        fn to_index(bounds: (Self, Self), i: Self) -> usize;",
      "        /// 指定された範囲内のインデックスから、元の値を復元します。",
      "        fn from_index(bounds: (Self, Self), index: usize) -> Self;",
      "        /// 値 `i` が指定された範囲内に含まれるかを判定します。",
      "        fn in_range(bounds: (Self, Self), i: Self) -> bool;",
      "    }",
      "    macro_rules ! impl_ix_for_integer {(\\$ (\\$ t : ty ) ,* ) => {\\$ (impl Ix for \\$ t {fn range ((l , r ) : (Self , Self ) ) -> impl Iterator < Item = Self > {l ..= r } fn range_size ((l , r ) : (Self , Self ) ) -> usize {if l > r {0 } else {(l . abs_diff (r ) as usize ) + 1 } } fn to_index ((l , r ) : (Self , Self ) , i : Self ) -> usize {if ! Self :: in_range ((l , r ) , i ) {panic ! (\"index out of bounds: {:?} is not in {:?}\" , i , (l , r ) ) ; } (l . abs_diff (i ) as usize ) } fn from_index ((l , r ) : (Self , Self ) , index : usize ) -> Self {if index >= Self :: range_size ((l , r ) ) {panic ! (\"index out of range: {} for bounds {:?}\" , index , (l , r ) ) ; } l + index as Self } fn in_range ((l , r ) : (Self , Self ) , i : Self ) -> bool {l <= i && i <= r } } ) * } ; }",
      "    impl_ix_for_integer!(u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize);",
      "    impl Ix for bool {",
      "        fn range((l, r): (Self, Self)) -> impl Iterator<Item = Self> {",
      "            (l as u8..=r as u8).map(|i| i != 0)",
      "        }",
      "        fn range_size((l, r): (Self, Self)) -> usize {",
      "            #[allow(clippy::bool_comparison)]",
      "            if l > r {",
      "                0",
      "            } else {",
      "                (r as usize) - (l as usize) + 1",
      "            }",
      "        }",
      "        fn to_index((l, r): (Self, Self), i: Self) -> usize {",
      "            if !Self::in_range((l, r), i) {",
      "                panic!(\"index out of bounds\");",
      "            }",
      "            (i as usize) - (l as usize)",
      "        }",
      "        fn from_index((l, r): (Self, Self), index: usize) -> Self {",
      "            if index >= Self::range_size((l, r)) {",
      "                panic!(\"index out of range\");",
      "            }",
      "            (l as usize + index) != 0",
      "        }",
      "        fn in_range((l, r): (Self, Self), i: Self) -> bool {",
      "            l <= i && i <= r",
      "        }",
      "    }",
      "    impl Ix for char {",
      "        fn range((l, r): (Self, Self)) -> impl Iterator<Item = Self> {",
      "            l..=r",
      "        }",
      "        fn range_size((l, r): (Self, Self)) -> usize {",
      "            if l > r {",
      "                0",
      "            } else {",
      "                (u32::from(r) - u32::from(l)) as usize + 1",
      "            }",
      "        }",
      "        fn to_index((l, r): (Self, Self), i: Self) -> usize {",
      "            if !Self::in_range((l, r), i) {",
      "                panic!(\"index out of bounds: {:?} is not in {:?}\", i, (l, r));",
      "            }",
      "            (u32::from(i) - u32::from(l)) as usize",
      "        }",
      "        fn from_index((l, r): (Self, Self), index: usize) -> Self {",
      "            if index >= Self::range_size((l, r)) {",
      "                panic!(\"index out of range: {} for bounds {:?}\", index, (l, r));",
      "            }",
      "            std::char::from_u32(u32::from(l) + index as u32).unwrap()",
      "        }",
      "        fn in_range((l, r): (Self, Self), i: Self) -> bool {",
      "            l <= i && i <= r",
      "        }",
      "    }",
      "    impl Ix for () {",
      "        fn range(_: (Self, Self)) -> impl Iterator<Item = Self> {",
      "            std::iter::once(())",
      "        }",
      "        fn range_size(_: (Self, Self)) -> usize {",
      "            1",
      "        }",
      "        fn to_index(_: (Self, Self), _: Self) -> usize {",
      "            0",
      "        }",
      "        fn from_index(_: (Self, Self), index: usize) -> Self {",
      "            if index != 0 {",
      "                panic!(\"index out of range\");",
      "            }",
      "        }",
      "        fn in_range(_: (Self, Self), _: Self) -> bool {",
      "            true",
      "        }",
      "    }",
      "    impl<A: Ix, B: Ix> Ix for (A, B) {",
      "        fn range(((l1, l2), (u1, u2)): (Self, Self)) -> impl Iterator<Item = Self> {",
      "            A::range((l1, u1)).flat_map(move |i1| B::range((l2, u2)).map(move |i2| (i1, i2)))",
      "        }",
      "        fn range_size(((l1, l2), (u1, u2)): (Self, Self)) -> usize {",
      "            A::range_size((l1, u1)) * B::range_size((l2, u2))",
      "        }",
      "        fn to_index(((l1, l2), (u1, u2)): (Self, Self), (i1, i2): Self) -> usize {",
      "            let idx1 = A::to_index((l1, u1), i1);",
      "            let idx2 = B::to_index((l2, u2), i2);",
      "            let stride2 = B::range_size((l2, u2));",
      "            idx1 * stride2 + idx2",
      "        }",
      "        fn from_index(((l1, l2), (u1, u2)): (Self, Self), index: usize) -> Self {",
      "            let size2 = B::range_size((l2, u2));",
      "            let idx1 = index / size2;",
      "            let idx2 = index % size2;",
      "            (A::from_index((l1, u1), idx1), B::from_index((l2, u2), idx2))",
      "        }",
      "        fn in_range(((l1, l2), (u1, u2)): (Self, Self), (i1, i2): Self) -> bool {",
      "            A::in_range((l1, u1), i1) && B::in_range((l2, u2), i2)",
      "        }",
      "    }",
      "    impl<A: Ix, B: Ix, C: Ix> Ix for (A, B, C) {",
      "        fn range(((l1, l2, l3), (u1, u2, u3)): (Self, Self)) -> impl Iterator<Item = Self> {",
      "            A::range((l1, u1)).flat_map(move |i1| {",
      "                B::range((l2, u2))",
      "                    .flat_map(move |i2| C::range((l3, u3)).map(move |i3| (i1, i2, i3)))",
      "            })",
      "        }",
      "        fn range_size(((l1, l2, l3), (u1, u2, u3)): (Self, Self)) -> usize {",
      "            A::range_size((l1, u1)) * B::range_size((l2, u2)) * C::range_size((l3, u3))",
      "        }",
      "        fn to_index(((l1, l2, l3), (u1, u2, u3)): (Self, Self), (i1, i2, i3): Self) -> usize {",
      "            let idx1 = A::to_index((l1, u1), i1);",
      "            let idx2 = B::to_index((l2, u2), i2);",
      "            let idx3 = C::to_index((l3, u3), i3);",
      "            let size2 = B::range_size((l2, u2));",
      "            let size3 = C::range_size((l3, u3));",
      "            (idx1 * size2 + idx2) * size3 + idx3",
      "        }",
      "        fn from_index(((l1, l2, l3), (u1, u2, u3)): (Self, Self), index: usize) -> Self {",
      "            let size3 = C::range_size((l3, u3));",
      "            let size23 = B::range_size((l2, u2)) * size3;",
      "            let idx1 = index / size23;",
      "            let idx2 = (index % size23) / size3;",
      "            let idx3 = index % size3;",
      "            (",
      "                A::from_index((l1, u1), idx1),",
      "                B::from_index((l2, u2), idx2),",
      "                C::from_index((l3, u3), idx3),",
      "            )",
      "        }",
      "        fn in_range(((l1, l2, l3), (u1, u2, u3)): (Self, Self), (i1, i2, i3): Self) -> bool {",
      "            A::in_range((l1, u1), i1) && B::in_range((l2, u2), i2) && C::in_range((l3, u3), i3)",
      "        }",
      "    }",
      "    impl<A: Ix, B: Ix, C: Ix, D: Ix> Ix for (A, B, C, D) {",
      "        fn range(((l1, l2, l3, l4), (u1, u2, u3, u4)): (Self, Self)) -> impl Iterator<Item = Self> {",
      "            A::range((l1, u1)).flat_map(move |i1| {",
      "                B::range((l2, u2)).flat_map(move |i2| {",
      "                    C::range((l3, u3))",
      "                        .flat_map(move |i3| D::range((l4, u4)).map(move |i4| (i1, i2, i3, i4)))",
      "                })",
      "            })",
      "        }",
      "        fn range_size(((l1, l2, l3, l4), (u1, u2, u3, u4)): (Self, Self)) -> usize {",
      "            A::range_size((l1, u1))",
      "                * B::range_size((l2, u2))",
      "                * C::range_size((l3, u3))",
      "                * D::range_size((l4, u4))",
      "        }",
      "        fn to_index(",
      "            ((l1, l2, l3, l4), (u1, u2, u3, u4)): (Self, Self),",
      "            (i1, i2, i3, i4): Self,",
      "        ) -> usize {",
      "            let idx1 = A::to_index((l1, u1), i1);",
      "            let idx2 = B::to_index((l2, u2), i2);",
      "            let idx3 = C::to_index((l3, u3), i3);",
      "            let idx4 = D::to_index((l4, u4), i4);",
      "            let size2 = B::range_size((l2, u2));",
      "            let size3 = C::range_size((l3, u3));",
      "            let size4 = D::range_size((l4, u4));",
      "            ((idx1 * size2 + idx2) * size3 + idx3) * size4 + idx4",
      "        }",
      "        fn from_index(((l1, l2, l3, l4), (u1, u2, u3, u4)): (Self, Self), index: usize) -> Self {",
      "            let size4 = D::range_size((l4, u4));",
      "            let size34 = C::range_size((l3, u3)) * size4;",
      "            let size234 = B::range_size((l2, u2)) * size34;",
      "            let idx1 = index / size234;",
      "            let idx2 = (index % size234) / size34;",
      "            let idx3 = (index % size34) / size4;",
      "            let idx4 = index % size4;",
      "            (",
      "                A::from_index((l1, u1), idx1),",
      "                B::from_index((l2, u2), idx2),",
      "                C::from_index((l3, u3), idx3),",
      "                D::from_index((l4, u4), idx4),",
      "            )",
      "        }",
      "        fn in_range(",
      "            ((l1, l2, l3, l4), (u1, u2, u3, u4)): (Self, Self),",
      "            (i1, i2, i3, i4): Self,",
      "        ) -> bool {",
      "            A::in_range((l1, u1), i1)",
      "                && B::in_range((l2, u2), i2)",
      "                && C::in_range((l3, u3), i3)",
      "                && D::in_range((l4, u4), i4)",
      "        }",
      "    }",
      "    /// 範囲を表す構造体です。",
      "    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]",
      "    pub struct Bounds<T> {",
      "        pub min: T,",
      "        pub max: T,",
      "    }",
      "    impl<T: Ix> Bounds<T> {",
      "        /// 新しい範囲を作成します。",
      "        pub fn new(min: T, max: T) -> Self {",
      "            Self { min, max }",
      "        }",
      "        /// 指定された範囲に含まれる要素の数を返します。",
      "        pub fn range_size(&self) -> usize {",
      "            T::range_size((self.min, self.max))",
      "        }",
      "        /// 指定された範囲内における、値 `val` の 0 始まりのインデックスを返します。",
      "        pub fn to_index(&self, val: T) -> usize {",
      "            T::to_index((self.min, self.max), val)",
      "        }",
      "        /// 指定された範囲内のインデックスから、元の値を復元します。",
      "        pub fn from_index(&self, index: usize) -> T {",
      "            T::from_index((self.min, self.max), index)",
      "        }",
      "        /// 値 `val` が指定された範囲内に含まれるかを判定します。",
      "        pub fn in_range(&self, val: T) -> bool {",
      "            T::in_range((self.min, self.max), val)",
      "        }",
      "        /// 範囲内の全ての要素を順番に返すイテレータを返します。",
      "        pub fn range(&self) -> impl Iterator<Item = T> {",
      "            T::range((self.min, self.max))",
      "        }",
      "    }",
      "    /// `Ix` トレイトを実装した型をインデックスとして使用できるベクタラッパーです。",
      "    /// 内部的には `Vec` を使用しており、`Ix::to_index` を用いてアクセスを変換します。",
      "    #[derive(Clone, Debug, PartialEq, Eq, Hash)]",
      "    pub struct IxVec<I, T> {",
      "        bounds: Bounds<I>,",
      "        data: Vec<T>,",
      "    }",
      "    impl<I: Ix, T> IxVec<I, T> {",
      "        /// 指定された範囲 `bounds` と初期値 `value` で `IxVec` を作成します。",
      "        pub fn new(bounds: Bounds<I>, value: T) -> Self",
      "        where",
      "            T: Clone,",
      "        {",
      "            let size = bounds.range_size();",
      "            Self {",
      "                bounds,",
      "                data: vec![value; size],",
      "            }",
      "        }",
      "        /// 指定された範囲 `bounds` と各要素を生成する関数 `f` で `IxVec` を作成します。",
      "        pub fn from_fn<F>(bounds: Bounds<I>, f: F) -> Self",
      "        where",
      "            F: FnMut(I) -> T,",
      "        {",
      "            let data = bounds.range().map(f).collect();",
      "            Self { bounds, data }",
      "        }",
      "        /// 既存の `Vec` から `IxVec` を作成します。",
      "        /// `data` の長さは `bounds` の範囲サイズと一致する必要があります。",
      "        pub fn from_vec(bounds: Bounds<I>, data: Vec<T>) -> Self {",
      "            let size = bounds.range_size();",
      "            assert_eq!(",
      "                data.len(),",
      "                size,",
      "                \"IxVec::from_vec: data length {} does not match range size {}\",",
      "                data.len(),",
      "                size",
      "            );",
      "            Self { bounds, data }",
      "        }",
      "        /// 要素数を返します。",
      "        pub fn len(&self) -> usize {",
      "            self.data.len()",
      "        }",
      "        /// 空であるかを返します。",
      "        pub fn is_empty(&self) -> bool {",
      "            self.data.is_empty()",
      "        }",
      "        /// 内部の `Vec` への参照を返します。",
      "        pub fn as_vec(&self) -> &Vec<T> {",
      "            &self.data",
      "        }",
      "        /// 内部の `Vec` を消費して返します。",
      "        pub fn into_vec(self) -> Vec<T> {",
      "            self.data",
      "        }",
      "        /// インデックスの範囲を返します。",
      "        pub fn bounds(&self) -> Bounds<I> {",
      "            self.bounds",
      "        }",
      "        /// 要素へのイテレータを返します。",
      "        pub fn iter(&self) -> std::slice::Iter<'_, T> {",
      "            self.data.iter()",
      "        }",
      "        /// 要素へのミュータブルイテレータを返します。",
      "        pub fn iter_mut(&mut self) -> std::slice::IterMut<'_, T> {",
      "            self.data.iter_mut()",
      "        }",
      "        /// インデックスとその要素のペアへのイテレータを返します。",
      "        pub fn iter_with_index(&self) -> impl Iterator<Item = (I, &T)> {",
      "            self.bounds.range().zip(self.data.iter())",
      "        }",
      "        /// 指定されたインデックスの要素への参照を返します。",
      "        /// インデックスが範囲外の場合は `None` を返します。",
      "        pub fn get(&self, index: I) -> Option<&T> {",
      "            if self.bounds.in_range(index) {",
      "                let i = self.bounds.to_index(index);",
      "                Some(&self.data[i])",
      "            } else {",
      "                None",
      "            }",
      "        }",
      "        /// 指定されたインデックスの要素へのミュータブル参照を返します。",
      "        /// インデックスが範囲外の場合は `None` を返します。",
      "        pub fn get_mut(&mut self, index: I) -> Option<&mut T> {",
      "            if self.bounds.in_range(index) {",
      "                let i = self.bounds.to_index(index);",
      "                Some(&mut self.data[i])",
      "            } else {",
      "                None",
      "            }",
      "        }",
      "        /// 指定されたインデックスが有効な範囲内にあるかを返します。",
      "        pub fn contains_index(&self, index: I) -> bool {",
      "            self.bounds.in_range(index)",
      "        }",
      "    }",
      "    impl<I: Ix, T> Index<I> for IxVec<I, T> {",
      "        type Output = T;",
      "        fn index(&self, index: I) -> &Self::Output {",
      "            let i = self.bounds.to_index(index);",
      "            &self.data[i]",
      "        }",
      "    }",
      "    impl<I: Ix, T> IndexMut<I> for IxVec<I, T> {",
      "        fn index_mut(&mut self, index: I) -> &mut Self::Output {",
      "            let i = self.bounds.to_index(index);",
      "            &mut self.data[i]",
      "        }",
      "    }",
      "    impl<I: Ix, T> Index<&I> for IxVec<I, T> {",
      "        type Output = T;",
      "        fn index(&self, index: &I) -> &Self::Output {",
      "            let i = self.bounds.to_index(*index);",
      "            &self.data[i]",
      "        }",
      "    }",
      "    impl<I: Ix, T> IndexMut<&I> for IxVec<I, T> {",
      "        fn index_mut(&mut self, index: &I) -> &mut Self::Output {",
      "            let i = self.bounds.to_index(*index);",
      "            &mut self.data[i]",
      "        }",
      "    }",
      "}"
    ]
  },
  "lazy_segtree_to_vec": {
    "scope": "rust",
    "prefix": "lazy_segtree_to_vec",
    "body": [
      "pub fn lazy_segtree_to_vec<F: ac_library::MapMonoid>(",
      "    seg: &mut ac_library::LazySegtree<F>,",
      "    len: usize,",
      ") -> Vec<<F::M as ac_library::Monoid>::S> {",
      "    (0..len).map(|i| seg.get(i)).collect()",
      "}"
    ]
  },
  "lca": {
    "scope": "rust",
    "prefix": "lca",
    "body": [
      "use lca::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod lca {",
      "    use ac_library::{Monoid, Segtree};",
      "    use std::convert::Infallible;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct MinI64Usize(Infallible);",
      "    impl Monoid for MinI64Usize {",
      "        type S = (i64, usize);",
      "        fn identity() -> Self::S {",
      "            (i64::MAX, usize::MAX)",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            std::cmp::min(*a, *b)",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct Lca {",
      "        dist: Vec<i64>,",
      "        euler_tour_dist: Segtree<MinI64Usize>,",
      "        euler_tour_in_time: Vec<usize>,",
      "        #[allow(dead_code)]",
      "        euler_tour_out_time: Vec<usize>,",
      "    }",
      "    impl Lca {",
      "        /// LCA (Lowest Common Ancestor) を構築する。",
      "        /// # Arguments",
      "        /// * `adj` - 木の隣接リスト (無向グラフまたは、親から子への有向グラフ)",
      "        /// * `root` - 根の頂点番号",
      "        /// # 計算量",
      "        /// O(V) (V は頂点数)",
      "        pub fn new(adj: &[Vec<usize>], root: usize) -> Self {",
      "            let nv = adj.len();",
      "            let dist = {",
      "                fn dfs(dist: &mut [i64], current: usize, adj: &[Vec<usize>], parent: usize) {",
      "                    for &child in &adj[current] {",
      "                        if child == parent {",
      "                            continue;",
      "                        }",
      "                        dist[child] = dist[current] + 1;",
      "                        dfs(dist, child, adj, current);",
      "                    }",
      "                }",
      "                let mut dist = vec![0; nv];",
      "                dfs(&mut dist, root, adj, root);",
      "                dist",
      "            };",
      "            let (euler_tour, euler_tour_in_time, euler_tour_out_time) = {",
      "                fn dfs(",
      "                    tour: &mut Vec<usize>,",
      "                    in_time: &mut [usize],",
      "                    out_time: &mut [usize],",
      "                    current: usize,",
      "                    adj: &[Vec<usize>],",
      "                    parent: usize,",
      "                ) {",
      "                    in_time[current] = in_time[current].min(tour.len());",
      "                    out_time[current] = out_time[current].max(tour.len());",
      "                    tour.push(current);",
      "                    for &child in &adj[current] {",
      "                        if child == parent {",
      "                            continue;",
      "                        }",
      "                        dfs(tour, in_time, out_time, child, adj, current);",
      "                        in_time[current] = in_time[current].min(tour.len());",
      "                        out_time[current] = out_time[current].max(tour.len());",
      "                        tour.push(current);",
      "                    }",
      "                }",
      "                let mut tour = vec![];",
      "                let mut in_time = vec![usize::MAX; nv];",
      "                let mut out_time = vec![usize::MIN; nv];",
      "                dfs(&mut tour, &mut in_time, &mut out_time, root, adj, root);",
      "                (tour, in_time, out_time)",
      "            };",
      "            let euler_tour_dist = Segtree::<MinI64Usize>::from(",
      "                euler_tour",
      "                    .iter()",
      "                    .copied()",
      "                    .map(|v| (dist[v], v))",
      "                    .collect::<Vec<(i64, usize)>>(),",
      "            );",
      "            Lca {",
      "                dist,",
      "                euler_tour_dist,",
      "                euler_tour_in_time,",
      "                euler_tour_out_time,",
      "            }",
      "        }",
      "        /// u と v の LCA を求める",
      "        /// # 計算量",
      "        /// O(log V)",
      "        pub fn lca(&self, u: usize, v: usize) -> usize {",
      "            let (time_min, time_max) = {",
      "                use std::cmp::{max, min};",
      "                let t1 = self.euler_tour_in_time[u];",
      "                let t2 = self.euler_tour_in_time[v];",
      "                (min(t1, t2), max(t1, t2))",
      "            };",
      "            self.euler_tour_dist.prod(time_min..=time_max).1",
      "        }",
      "        /// 頂点 u と v の距離を求めます。",
      "        /// # 計算量",
      "        /// O(log V)",
      "        pub fn dist(&self, u: usize, v: usize) -> i64 {",
      "            self.dist[u] + self.dist[v] - 2 * self.dist[self.lca(u, v)]",
      "        }",
      "        /// パス u-v 上に点 a があるかどうかを判定します。",
      "        /// # 計算量",
      "        /// O(log V)",
      "        pub fn is_path_on(&self, u: usize, v: usize, a: usize) -> bool {",
      "            self.dist(u, a) + self.dist(a, v) == self.dist(u, v)",
      "        }",
      "    }",
      "}"
    ]
  },
  "lca_doubling": {
    "scope": "rust",
    "prefix": "lca_doubling",
    "body": [
      "use lca_doubling::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod lca_doubling {",
      "    use std::mem::swap;",
      "    #[derive(Clone, Debug)]",
      "    pub struct Lca {",
      "        dist: Vec<i64>,",
      "        ancestor: Vec<Vec<usize>>,",
      "    }",
      "    impl Lca {",
      "        /// ダブリングを用いて LCA (Lowest Common Ancestor) を構築する。",
      "        /// # Arguments",
      "        /// * `adj` - 木の隣接リスト (無向グラフ、または親から子への有向グラフ)",
      "        /// * `root` - 根の頂点番号",
      "        /// # 計算量",
      "        /// O(V log V) (V は頂点数)",
      "        pub fn new(adj: &[Vec<usize>], root: usize) -> Self {",
      "            let nv = adj.len();",
      "            let mut dist = vec![-1; nv];",
      "            let mut parent = vec![root; nv];",
      "            let mut q = std::collections::VecDeque::new();",
      "            q.push_back(root);",
      "            dist[root] = 0;",
      "            while let Some(u) = q.pop_front() {",
      "                for &v in &adj[u] {",
      "                    if v != parent[u] {",
      "                        dist[v] = dist[u] + 1;",
      "                        parent[v] = u;",
      "                        q.push_back(v);",
      "                    }",
      "                }",
      "            }",
      "            let k = (usize::BITS - nv.leading_zeros()) as usize;",
      "            let mut ancestor = vec![vec![0; nv]; k];",
      "            ancestor[0] = parent;",
      "            for i in 1..k {",
      "                for v in 0..nv {",
      "                    let p = ancestor[i - 1][v];",
      "                    ancestor[i][v] = ancestor[i - 1][p];",
      "                }",
      "            }",
      "            Lca { dist, ancestor }",
      "        }",
      "        /// u と v の LCA を求める",
      "        /// # 計算量",
      "        /// O(log V)",
      "        pub fn lca(&self, u: usize, v: usize) -> usize {",
      "            let mut u = u;",
      "            let mut v = v;",
      "            if self.dist[u] < self.dist[v] {",
      "                swap(&mut u, &mut v);",
      "            }",
      "            let dist_diff = self.dist[u] - self.dist[v];",
      "            u = self",
      "                .ancestor",
      "                .iter()",
      "                .enumerate()",
      "                .filter(|(k, _)| (dist_diff >> k) & 1 == 1)",
      "                .map(|(_, f)| f)",
      "                .fold(u, |acc, f| f[acc]);",
      "            if u == v {",
      "                return u;",
      "            }",
      "            for f in self.ancestor.iter().rev() {",
      "                if f[u] != f[v] {",
      "                    u = f[u];",
      "                    v = f[v];",
      "                }",
      "            }",
      "            self.ancestor[0][u]",
      "        }",
      "        /// 頂点 u と v の距離を求めます。",
      "        /// # 計算量",
      "        /// O(log V)",
      "        pub fn dist(&self, u: usize, v: usize) -> i64 {",
      "            self.dist[u] + self.dist[v] - 2 * self.dist[self.lca(u, v)]",
      "        }",
      "        /// パス u-v 上に点 a があるかどうかを判定します。",
      "        /// # 計算量",
      "        /// O(log V)",
      "        pub fn is_path_on(&self, u: usize, v: usize, a: usize) -> bool {",
      "            self.dist(u, a) + self.dist(a, v) == self.dist(u, v)",
      "        }",
      "        /// u の k個上の祖先を求める",
      "        /// # 計算量",
      "        /// O(log V)",
      "        pub fn get_ancestor(&self, u: usize, k: usize) -> Option<usize> {",
      "            if self.dist[u] < k as i64 {",
      "                return None;",
      "            }",
      "            let mut current = u;",
      "            for i in 0..self.ancestor.len() {",
      "                if (k >> i) & 1 == 1 {",
      "                    current = self.ancestor[i][current];",
      "                }",
      "            }",
      "            Some(current)",
      "        }",
      "        /// u-v パスの k番目の頂点を取得する (u が 0番目)",
      "        /// # 計算量",
      "        /// O(log V)",
      "        pub fn get_kth_on_path(&self, u: usize, v: usize, k: usize) -> Option<usize> {",
      "            let l = self.lca(u, v);",
      "            let dist_u_l = self.dist[u] - self.dist[l];",
      "            if k as i64 <= dist_u_l {",
      "                self.get_ancestor(u, k)",
      "            } else {",
      "                let dist_l_v = self.dist[v] - self.dist[l];",
      "                let total_dist = dist_u_l + dist_l_v;",
      "                if k as i64 > total_dist {",
      "                    return None;",
      "                }",
      "                let k_from_l = k as i64 - dist_u_l;",
      "                let k_from_v = dist_l_v - k_from_l;",
      "                self.get_ancestor(v, k_from_v as usize)",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "lca_path_aggregate": {
    "scope": "rust",
    "prefix": "lca_path_aggregate",
    "body": [
      "use lca_path_aggregate::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod lca_path_aggregate {",
      "    use ac_library::Monoid;",
      "    use std::mem::swap;",
      "    #[derive(Clone, Debug)]",
      "    pub struct LcaPathAggregate<M: Monoid> {",
      "        dist: Vec<i64>,",
      "        ancestor: Vec<Vec<usize>>,",
      "        path_aggregate: Vec<Vec<M::S>>,",
      "    }",
      "    impl<M: Monoid> LcaPathAggregate<M>",
      "    where",
      "        M::S: Clone,",
      "    {",
      "        /// パス上の辺重みのモノイド積が計算可能な LCA 構造体を構築する。",
      "        /// # Arguments",
      "        /// * `adj` - 木の隣接リスト(無向グラフ、または親から子への有向グラフ)。`adj[u]` は `(v, w)` のリスト。ただし、`v` は隣接ノード、`w` は辺 `u-v` の重み。",
      "        /// * `root` - 木の根",
      "        /// # 計算量",
      "        /// O(V log V) (V は頂点数)",
      "        pub fn new(adj: &[Vec<(usize, M::S)>], root: usize) -> Self {",
      "            let nv = adj.len();",
      "            let mut dist = vec![-1; nv];",
      "            let mut parent = vec![root; nv];",
      "            let mut parent_edge_weight = vec![M::identity(); nv];",
      "            let mut q = std::collections::VecDeque::new();",
      "            q.push_back(root);",
      "            dist[root] = 0;",
      "            while let Some(u) = q.pop_front() {",
      "                for &(v, ref w) in &adj[u] {",
      "                    if v != parent[u] {",
      "                        dist[v] = dist[u] + 1;",
      "                        parent[v] = u;",
      "                        parent_edge_weight[v] = w.clone();",
      "                        q.push_back(v);",
      "                    }",
      "                }",
      "            }",
      "            let k = (usize::BITS - nv.leading_zeros()) as usize;",
      "            let mut ancestor = vec![vec![0; nv]; k];",
      "            ancestor[0] = parent;",
      "            for i in 1..k {",
      "                for v in 0..nv {",
      "                    let p = ancestor[i - 1][v];",
      "                    ancestor[i][v] = ancestor[i - 1][p];",
      "                }",
      "            }",
      "            let mut path_aggregate = vec![vec![M::identity(); nv]; k];",
      "            path_aggregate[0] = parent_edge_weight;",
      "            for i in 1..k {",
      "                for v in 0..nv {",
      "                    let p = ancestor[i - 1][v];",
      "                    path_aggregate[i][v] =",
      "                        M::binary_operation(&path_aggregate[i - 1][v], &path_aggregate[i - 1][p]);",
      "                }",
      "            }",
      "            Self {",
      "                dist,",
      "                ancestor,",
      "                path_aggregate,",
      "            }",
      "        }",
      "        /// u と v の LCA を求める",
      "        /// # 計算量",
      "        /// O(log V)",
      "        pub fn lca(&self, u: usize, v: usize) -> usize {",
      "            let mut u = u;",
      "            let mut v = v;",
      "            if self.dist[u] < self.dist[v] {",
      "                swap(&mut u, &mut v);",
      "            }",
      "            let dist_diff = self.dist[u] - self.dist[v];",
      "            for k in 0..self.ancestor.len() {",
      "                if (dist_diff >> k) & 1 == 1 {",
      "                    u = self.ancestor[k][u];",
      "                }",
      "            }",
      "            if u == v {",
      "                return u;",
      "            }",
      "            for k in (0..self.ancestor.len()).rev() {",
      "                if self.ancestor[k][u] != self.ancestor[k][v] {",
      "                    u = self.ancestor[k][u];",
      "                    v = self.ancestor[k][v];",
      "                }",
      "            }",
      "            self.ancestor[0][u]",
      "        }",
      "        /// u から v へのパス上の辺の重みの総和（モノイド積）を求める",
      "        /// このクエリはモノイドの可換性を要求します。",
      "        /// # 計算量",
      "        /// O(log V)",
      "        pub fn path_aggregate(&self, u: usize, v: usize) -> M::S {",
      "            let lca = self.lca(u, v);",
      "            let agg_u = self.query_path_up(u, self.dist[u] - self.dist[lca]);",
      "            let agg_v = self.query_path_up(v, self.dist[v] - self.dist[lca]);",
      "            M::binary_operation(&agg_u, &agg_v)",
      "        }",
      "        fn query_path_up(&self, u: usize, dist: i64) -> M::S {",
      "            let mut res = M::identity();",
      "            let mut current = u;",
      "            for k in 0..self.ancestor.len() {",
      "                if (dist >> k) & 1 == 1 {",
      "                    res = M::binary_operation(&res, &self.path_aggregate[k][current]);",
      "                    current = self.ancestor[k][current];",
      "                }",
      "            }",
      "            res",
      "        }",
      "        /// u と v の距離 (辺の数)",
      "        /// # 計算量",
      "        /// O(log V)",
      "        pub fn dist(&self, u: usize, v: usize) -> i64 {",
      "            let lca = self.lca(u, v);",
      "            self.dist[u] + self.dist[v] - 2 * self.dist[lca]",
      "        }",
      "    }",
      "}"
    ]
  },
  "leader_tracking_dsu": {
    "scope": "rust",
    "prefix": "leader_tracking_dsu",
    "body": [
      "use dsu_core::*;",
      "use leader_tracking_dsu::*;",
      "#[allow(clippy::module_inception)]",
      "/// ac_library::Dsu の merge のみ実装を変えたもの",
      "pub mod dsu_core {",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    /// DSU 内の各要素の状態（親のインデックスまたは集合のサイズ）を保持する構造体。",
      "    /// メモリ効率（32ビット整数 1 つ分）を維持したまま、以下の 2 つの状態を表現します。",
      "    /// 1. **Root (根)**:",
      "    ///    - 値が負の場合、その要素は集合の代表元（リーダー）です。",
      "    ///    - 値の絶対値 `|v|` は、その集合に属する要素の数（サイズ）を表します。",
      "    ///    - 例: `-1` はサイズ 1 の集合の根、`-5` はサイズ 5 の集合の根。",
      "    /// 2. **Child (子)**:",
      "    ///    - 値が 0 以上の場合、その要素は他の要素を親に持っています。",
      "    ///    - 値 `v` は、親要素のインデックスを表します。",
      "    struct Node(i32);",
      "    impl Node {",
      "        fn root(size: usize) -> Self {",
      "            Self(-(size as i32))",
      "        }",
      "        fn child(parent: usize) -> Self {",
      "            Self(parent as i32)",
      "        }",
      "        fn is_root(&self) -> bool {",
      "            self.0 < 0",
      "        }",
      "        fn parent(&self) -> usize {",
      "            self.0 as usize",
      "        }",
      "        fn size(&self) -> usize {",
      "            (-self.0) as usize",
      "        }",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    pub struct DsuCore {",
      "        n: usize,",
      "        nodes: Vec<Node>,",
      "        cnt_groups: usize,",
      "    }",
      "    impl DsuCore {",
      "        pub fn new(size: usize) -> Self {",
      "            Self {",
      "                n: size,",
      "                nodes: vec![Node::root(1); size],",
      "                cnt_groups: size,",
      "            }",
      "        }",
      "        /// 2 つの要素 `a` と `b` が属する集合を統合する",
      "        /// # 戻り値",
      "        /// - `Some((leader, merged))`:",
      "        ///   - `leader` は統合後の集合の代表元（リーダー）",
      "        ///   - `merged` は統合されて消える側の旧代表元",
      "        /// - `None`:",
      "        ///   - `a` と `b` がすでに同じ集合に属していた場合",
      "        pub fn merge(&mut self, a: usize, b: usize) -> Option<(usize, usize)> {",
      "            assert!(a < self.n);",
      "            assert!(b < self.n);",
      "            let (mut x, mut y) = (self.leader(a), self.leader(b));",
      "            if x == y {",
      "                return None;",
      "            }",
      "            if self.nodes[x].size() < self.nodes[y].size() {",
      "                std::mem::swap(&mut x, &mut y);",
      "            }",
      "            let size_x = self.nodes[x].size();",
      "            let size_y = self.nodes[y].size();",
      "            self.nodes[x] = Node::root(size_x + size_y);",
      "            self.nodes[y] = Node::child(x);",
      "            self.cnt_groups -= 1;",
      "            Some((x, y))",
      "        }",
      "        pub fn same(&mut self, a: usize, b: usize) -> bool {",
      "            assert!(a < self.n);",
      "            assert!(b < self.n);",
      "            self.leader(a) == self.leader(b)",
      "        }",
      "        pub fn leader(&mut self, a: usize) -> usize {",
      "            assert!(a < self.n);",
      "            if self.nodes[a].is_root() {",
      "                return a;",
      "            }",
      "            let parent = self.nodes[a].parent();",
      "            let new_parent = self.leader(parent);",
      "            self.nodes[a] = Node::child(new_parent);",
      "            new_parent",
      "        }",
      "        pub fn size(&mut self, a: usize) -> usize {",
      "            assert!(a < self.n);",
      "            let x = self.leader(a);",
      "            self.nodes[x].size()",
      "        }",
      "        pub fn count_group(&self) -> usize {",
      "            self.cnt_groups",
      "        }",
      "        pub fn groups(&mut self) -> Vec<Vec<usize>> {",
      "            let mut leader_buf = vec![0; self.n];",
      "            let mut group_size = vec![0; self.n];",
      "            for i in 0..self.n {",
      "                leader_buf[i] = self.leader(i);",
      "                group_size[leader_buf[i]] += 1;",
      "            }",
      "            let mut result = vec![Vec::new(); self.n];",
      "            for i in 0..self.n {",
      "                result[i].reserve(group_size[i]);",
      "            }",
      "            for i in 0..self.n {",
      "                result[leader_buf[i]].push(i);",
      "            }",
      "            result",
      "                .into_iter()",
      "                .filter(|x| !x.is_empty())",
      "                .collect::<Vec<Vec<usize>>>()",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::module_inception)]",
      "pub mod leader_tracking_dsu {",
      "    use super::DsuCore;",
      "    use std::collections::BTreeSet;",
      "    #[derive(Clone, Debug)]",
      "    /// リーダーの集合を O(1) で取得できる DSU。",
      "    /// merge の償却計算量が O(log n) な点に注意",
      "    pub struct LeaderTrackingDsu {",
      "        dsu: DsuCore,",
      "        leaders: BTreeSet<usize>,",
      "    }",
      "    impl LeaderTrackingDsu {",
      "        pub fn new(size: usize) -> LeaderTrackingDsu {",
      "            let dsu = DsuCore::new(size);",
      "            let leaders = (0..size).collect();",
      "            LeaderTrackingDsu { dsu, leaders }",
      "        }",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn merge(&mut self, a: usize, b: usize) -> Option<(usize, usize)> {",
      "            let merge_result = self.dsu.merge(a, b);",
      "            if let Some((_, merged)) = merge_result {",
      "                self.leaders.remove(&merged);",
      "            }",
      "            merge_result",
      "        }",
      "        pub fn same(&mut self, a: usize, b: usize) -> bool {",
      "            self.dsu.same(a, b)",
      "        }",
      "        pub fn leader(&mut self, a: usize) -> usize {",
      "            self.dsu.leader(a)",
      "        }",
      "        pub fn leaders(&self) -> &BTreeSet<usize> {",
      "            &self.leaders",
      "        }",
      "        pub fn size(&mut self, a: usize) -> usize {",
      "            self.dsu.size(a)",
      "        }",
      "        pub fn groups(&mut self) -> Vec<Vec<usize>> {",
      "            self.dsu.groups()",
      "        }",
      "        pub fn count_group(&self) -> usize {",
      "            self.dsu.count_group()",
      "        }",
      "    }",
      "}"
    ]
  },
  "lg": {
    "scope": "rust",
    "prefix": "lg",
    "body": [
      "use lg::*;",
      "pub mod lg {",
      "    use std::borrow::Borrow;",
      "    use std::fmt;",
      "    use std::iter::once;",
      "    /// Print the values with the line number.",
      "    /// # Examples",
      "    /// ```rust",
      "    /// # use mylib::*;",
      "    /// let x = 42;",
      "    /// let y = 43;",
      "    /// lg!(x);",
      "    /// lg!(x, y);",
      "    /// lg!(42, x, 43, y);",
      "    /// ```",
      "    #[macro_export]",
      "    macro_rules ! lg {(@ contents \\$ head : expr_2021 \\$ (, \\$ tail : expr_2021 ) * ) => {{\\$ crate :: __lg_internal ! (\\$ head ) ; \\$ (eprint ! (\",\" ) ; \\$ crate :: __lg_internal ! (\\$ tail ) ; ) * eprintln ! () ; } } ; (\\$ (\\$ expr : expr_2021 ) ,* \\$ (, ) ? ) => {{eprint ! (\"{}\\u{276f}\" , line ! () ) ; \\$ crate :: lg ! (@ contents \\$ (\\$ expr ) ,* ) } } ; }",
      "    #[doc(hidden)]",
      "    #[macro_export]",
      "    macro_rules! __lg_internal {",
      "        (\\$ value : expr_2021 ) => {{",
      "            match \\$value {",
      "                head => {",
      "                    eprint!(",
      "                        \" {} = {}\",",
      "                        stringify!(\\$value),",
      "                        \\$crate::__quiet(format!(\"{:?}\", &head))",
      "                    );",
      "                }",
      "            }",
      "        }};",
      "    }",
      "    /// Print many 1D arrays side-by-side with the line number.",
      "    /// # Examples",
      "    /// ```rust",
      "    /// # use mylib::*;",
      "    /// let a = [1, 2, 3];",
      "    /// let b = [4, 5, 6];",
      "    /// let c = [7, 8, 9];",
      "    /// rows! {",
      "    ///   \"id\", // the name of the index",
      "    ///   @\"a\" => a,",
      "    ///   b,",
      "    ///   @\"c\" => c,",
      "    /// }",
      "    /// ```",
      "    #[macro_export]",
      "    macro_rules ! rows {{\\$ index_label : literal , \\$ (@ offset \\$ offset : expr_2021 , ) ? \\$ (@ verticalbar \\$ verticalbar : expr_2021 , ) * \\$ (\\$ (@\\$ label : literal => ) ? \\$ values : expr_2021 ) ,* \\$ (, ) ? } => {{#! [allow (unused_assignments ) ] let mut rows = \\$ crate :: Rows :: default () ; rows . line_number (line ! () ) ; \\$ (rows . offset (\\$ offset ) ; ) ? \\$ (rows . verticalbar (\\$ verticalbar ) ; ) * rows . index_label (\\$ index_label ) ; \\$ ({let mut label = stringify ! (\\$ values ) . to_string () ; if label . starts_with (\"&\" ) {label = label [1 .. ] . to_string () ; } \\$ ({let label_ : &'static str = \\$ label ; label = label_ . to_string () ; } ) ? rows . row (label , \\$ values ) ; } ) * eprintln ! (\"{}\" , rows . to_string_table () ) ; } } ; }",
      "    /// Print the 2D array with the line number.",
      "    /// # Examples",
      "    /// ```rust",
      "    /// # use mylib::*;",
      "    /// let a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];",
      "    /// table! {",
      "    ///    @\"a\" => a,",
      "    /// }",
      "    /// table! {",
      "    ///   a,",
      "    /// }",
      "    /// ```",
      "    #[macro_export]",
      "    macro_rules ! table {{\\$ (@\\$ name : literal => ) ? \\$ values : expr_2021 \\$ (, ) ? } => {{#! [allow (unused_assignments ) ] let mut name = stringify ! (\\$ values ) . to_string () ; if name . starts_with (\"&\" ) {name = name [1 .. ] . to_string () ; } \\$ ({let name_ : &'static str = \\$ name ; name = name_ . to_string () ; } ) ? let mut rows = \\$ crate :: Rows :: default () ; rows . line_number (line ! () ) ; rows . table_name (name ) ; # [allow (array_into_iter ) ] for (i , row ) in \\$ values . into_iter () . enumerate () {rows . row (i . to_string () , row ) ; } eprintln ! (\"{}\" , rows . to_string_table () ) ; } } ; }",
      "    #[doc(hidden)]",
      "    pub fn __quiet(s: impl AsRef<str>) -> String {",
      "        s.as_ref()",
      "            .replace(\"340282366920938463463374607431768211455\", \"*\")",
      "            .replace(\"170141183460469231731687303715884105727\", \"*\")",
      "            .replace(\"18446744073709551615\", \"*\")",
      "            .replace(\"9223372036854775807\", \"*\")",
      "            .replace(\"-9223372036854775808\", \"*\")",
      "            .replace(\"4294967295\", \"*\")",
      "            .replace(\"2147483647\", \"*\")",
      "            .replace(\"-2147483648\", \"*\")",
      "            .replace(\"None\", \"*\")",
      "            .replace(\"Some\", \"\")",
      "            .replace(\"true\", \"#\")",
      "            .replace(\"false\", \".\")",
      "            .replace(['\"', '\\''], \"\")",
      "    }",
      "    #[doc(hidden)]",
      "    #[derive(Default)]",
      "    pub struct Rows {",
      "        line_number: String,",
      "        index_label: String,",
      "        offset: usize,",
      "        verticalbars: Vec<usize>,",
      "        table_name: String,",
      "        rows: Vec<Row>,",
      "    }",
      "    impl Rows {",
      "        pub fn line_number(&mut self, line_number: u32) -> &mut Self {",
      "            self.line_number = format!(\"{}\", line_number);",
      "            self",
      "        }",
      "        pub fn index_label(&mut self, index_label: impl Into<String>) -> &mut Self {",
      "            self.index_label = index_label.into();",
      "            self",
      "        }",
      "        pub fn offset(&mut self, offset: usize) -> &mut Self {",
      "            self.offset = offset;",
      "            self",
      "        }",
      "        pub fn verticalbar(&mut self, verticalbar: impl IntoIterator<Item = usize>) -> &mut Self {",
      "            self.verticalbars.extend(verticalbar);",
      "            self",
      "        }",
      "        pub fn table_name(&mut self, table_name: impl Into<String>) -> &mut Self {",
      "            self.table_name = table_name.into();",
      "            self",
      "        }",
      "        pub fn row(",
      "            &mut self,",
      "            label: impl Into<String>,",
      "            values: impl IntoIterator<Item = impl fmt::Debug>,",
      "        ) -> &mut Self {",
      "            self.rows.push(Row {",
      "                label: label.into(),",
      "                values: values",
      "                    .into_iter()",
      "                    .map(|value| __quiet(format!(\"{:?}\", value)))",
      "                    .collect(),",
      "            });",
      "            self",
      "        }",
      "        pub fn to_string_table(self) -> StringTable {",
      "            let Self {",
      "                line_number,",
      "                index_label,",
      "                offset,",
      "                verticalbars,",
      "                table_name,",
      "                rows,",
      "            } = self;",
      "            let w = rows",
      "                .iter()",
      "                .map(|row| row.values.len())",
      "                .max()",
      "                .unwrap_or_default();",
      "            let mut verticalbar_count = vec![0; w + 1];",
      "            for &v in &verticalbars {",
      "                if (offset..=offset + w).contains(&v) {",
      "                    verticalbar_count[v - offset] += 1;",
      "                }",
      "            }",
      "            StringTable {",
      "                head: StringRow {",
      "                    label: format!(",
      "                        \"{line_number}❯ {table_name}{index_label}\",",
      "                        index_label = if index_label.is_empty() {",
      "                            String::new()",
      "                        } else {",
      "                            format!(\"[{}]\", index_label)",
      "                        }",
      "                    ),",
      "                    values: (offset..offset + w)",
      "                        .map(|index| index.to_string())",
      "                        .collect(),",
      "                },",
      "                body: rows",
      "                    .iter()",
      "                    .map(|row| StringRow {",
      "                        label: row.label.clone(),",
      "                        values: row.values.clone(),",
      "                    })",
      "                    .collect(),",
      "                verticalbar_count,",
      "            }",
      "        }",
      "    }",
      "    struct Row {",
      "        label: String,",
      "        values: Vec<String>,",
      "    }",
      "    #[doc(hidden)]",
      "    pub struct StringTable {",
      "        head: StringRow,",
      "        body: Vec<StringRow>,",
      "        verticalbar_count: Vec<usize>,",
      "    }",
      "    impl fmt::Display for StringTable {",
      "        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "            let Self {",
      "                head,",
      "                body,",
      "                verticalbar_count,",
      "            } = self;",
      "            let w = body",
      "                .iter()",
      "                .map(|row| row.values.len())",
      "                .max()",
      "                .unwrap_or_default();",
      "            let label_width = once(head.label.chars().count())",
      "                .chain(body.iter().map(|row| row.label.chars().count()))",
      "                .max()",
      "                .unwrap();",
      "            let value_width = (0..w)",
      "                .map(|j| {",
      "                    once(j.to_string().len())",
      "                        .chain(",
      "                            body.iter()",
      "                                .map(|row| row.values.get(j).map_or(0, |s| s.chars().count())),",
      "                        )",
      "                        .max()",
      "                        .unwrap()",
      "                })",
      "                .collect::<Vec<_>>();",
      "            gray(f)?;",
      "            write!(",
      "                f,",
      "                \"{}\",",
      "                head.to_string(label_width, &value_width, verticalbar_count, true)",
      "            )?;",
      "            resetln(f)?;",
      "            for row in body {",
      "                write!(",
      "                    f,",
      "                    \"{}\",",
      "                    row.to_string(label_width, &value_width, verticalbar_count, false)",
      "                )?;",
      "                writeln!(f)?;",
      "            }",
      "            Ok(())",
      "        }",
      "    }",
      "    struct StringRow {",
      "        label: String,",
      "        values: Vec<String>,",
      "    }",
      "    impl StringRow {",
      "        fn to_string(",
      "            &self,",
      "            label_width: usize,",
      "            value_width: &[usize],",
      "            varticalbars_count: &[usize],",
      "            label_align_left: bool,",
      "        ) -> String {",
      "            let Self { label, values } = self;",
      "            let w = value_width.len();",
      "            let mut s = String::new();",
      "            s.push_str(&if label_align_left {",
      "                format!(\"{label:<label_width\\$} |\")",
      "            } else {",
      "                format!(\"{label:^label_width\\$} |\")",
      "            });",
      "            for j in 0..w {",
      "                let value_width = value_width[j];",
      "                s.push_str(\"|\".repeat(varticalbars_count[j]).as_str());",
      "                if varticalbars_count[j] == 0 && j != 0 && value_width <= 1 {",
      "                    s.push(' ');",
      "                }",
      "                match values.get(j) {",
      "                    Some(value) => {",
      "                        s.push_str(&format!(\" {value:>value_width\\$}\",));",
      "                    }",
      "                    None => {",
      "                        s.push_str(\" \".repeat(value_width + 1).as_str());",
      "                    }",
      "                }",
      "            }",
      "            s",
      "        }",
      "    }",
      "    const GRAY: &str = \"\\x1b[48;2;127;127;127;37m\";",
      "    const RESET: &str = \"\\x1b[0m\";",
      "    fn gray(f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "        write!(f, \"{GRAY}\")",
      "    }",
      "    fn resetln(f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "        writeln!(f, \"{RESET}\")",
      "    }",
      "    /// Format a iterator of [`bool`]s.",
      "    pub fn bools<B, I>(iter: I) -> String",
      "    where",
      "        B: Borrow<bool>,",
      "        I: IntoIterator<Item = B>,",
      "    {",
      "        format!(",
      "            \"[{}]\",",
      "            iter.into_iter()",
      "                .map(|b| ['.', '#'][usize::from(*(b.borrow()))])",
      "                .collect::<String>(),",
      "        )",
      "    }",
      "}"
    ]
  },
  "lis": {
    "scope": "rust",
    "prefix": "lis",
    "body": [
      "use lis::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod lis {",
      "    use ac_library::{Max, Segtree};",
      "    use itertools::Itertools;",
      "    /// 各要素を末尾とする最長増加部分列 (LIS) の長さを求める",
      "    /// 戻り値の `i` 番目の要素は、`xs[i]` を末尾とする LIS の長さを表す。",
      "    /// # 計算量",
      "    /// O(N log N)",
      "    pub fn lis_array<T: Ord>(xs: &[T]) -> Vec<usize> {",
      "        let n = xs.len();",
      "        if n == 0 {",
      "            return vec![];",
      "        }",
      "        let sorted = xs.iter().sorted().dedup().collect_vec();",
      "        let rank = xs",
      "            .iter()",
      "            .map(|x| sorted.binary_search(&x).unwrap())",
      "            .collect_vec();",
      "        let mut dp = vec![0; n];",
      "        let mut seg = Segtree::<Max<usize>>::new(sorted.len());",
      "        for (i, &x) in rank.iter().enumerate() {",
      "            dp[i] = seg.prod(..x) + 1;",
      "            if seg.get(x) < dp[i] {",
      "                seg.set(x, dp[i]);",
      "            }",
      "        }",
      "        dp",
      "    }",
      "    /// 最長増加部分列 (LIS) の長さを求める",
      "    /// # 計算量",
      "    /// O(N log N)",
      "    pub fn lis_len<T: Ord>(xs: &[T]) -> usize {",
      "        let mut dp = vec![];",
      "        for x in xs {",
      "            let i = dp.binary_search(&x).unwrap_or_else(|i| i);",
      "            if i < dp.len() {",
      "                dp[i] = x;",
      "            } else {",
      "                dp.push(x);",
      "            }",
      "        }",
      "        dp.len()",
      "    }",
      "}"
    ]
  },
  "lower_bound": {
    "scope": "rust",
    "prefix": "lower_bound",
    "body": [
      "/// 二分探索をする。",
      "/// ```text",
      "/// ng ng ng ok ok ok",
      "///          ↑ここの引数の値を返す",
      "/// ```",
      "/// # 計算量",
      "/// O(log(|ok - ng|))",
      "/// ## Arguments",
      "/// * ok != ng",
      "/// * |ok - ng| <= 2^63 - 1, |ok + ng| <= 2^63 - 1",
      "/// * p の定義域について",
      "///     * ng < ok の場合、p は区間 ng..ok で定義されている。",
      "///     * ok < ng の場合、p は区間 ok..ng で定義されている。",
      "/// * p の単調性について",
      "///     * ng < ok の場合、p は単調増加",
      "///     * ok < ng の場合、p は単調減少",
      "/// ## Return",
      "/// * ng < ok の場合: I = { i in ng..ok | p(i) == true } としたとき",
      "///     * I が空でなければ、min I を返す。",
      "///     * I が空ならば、ok を返す。",
      "/// * ok < ng の場合: I = { i in ok..ng | p(i) == true } としたとき",
      "///     * I が空でなければ、max I を返す。",
      "///     * I が空ならば、ok を返す。",
      "pub fn bin_search<F>(mut ok: i64, mut ng: i64, mut p: F) -> i64",
      "where",
      "    F: FnMut(i64) -> bool,",
      "{",
      "    debug_assert!(ok != ng);",
      "    debug_assert!(ok.checked_sub(ng).is_some());",
      "    debug_assert!(ok.checked_add(ng).is_some());",
      "    while num::abs(ok - ng) > 1 {",
      "        let mid = (ok + ng) / 2;",
      "        debug_assert!(mid != ok);",
      "        debug_assert!(mid != ng);",
      "        if p(mid) {",
      "            ok = mid;",
      "        } else {",
      "            ng = mid;",
      "        }",
      "    }",
      "    ok",
      "}",
      "/// 指定された要素以上の値が現れる最初の位置を返す。",
      "/// # 計算量",
      "/// O(log(|xs|))",
      "/// ## Arguments",
      "/// * xs: 単調増加",
      "///     * 単調増加でなくても、 `|i| xs[i] >= key` が単調ならOK",
      "/// ## Return",
      "/// `I = {i in 0..xs.len() | xs[i] >= key}` としたとき、`min I` を返す。",
      "/// ただし、`I` が空の場合は `xs.len()` を返す。",
      "/// 戻り値は、区間 `0..=xs.len()` の間で返る。",
      "pub fn lower_bound<T: PartialOrd>(xs: &[T], key: T) -> usize {",
      "    let pred = |i: i64| xs[i as usize] >= key;",
      "    bin_search(xs.len() as i64, -1_i64, pred) as usize",
      "}"
    ]
  },
  "lower_bound_dec": {
    "scope": "rust",
    "prefix": "lower_bound_dec",
    "body": [
      "/// 二分探索をする。",
      "/// ```text",
      "/// ng ng ng ok ok ok",
      "///          ↑ここの引数の値を返す",
      "/// ```",
      "/// # 計算量",
      "/// O(log(|ok - ng|))",
      "/// ## Arguments",
      "/// * ok != ng",
      "/// * |ok - ng| <= 2^63 - 1, |ok + ng| <= 2^63 - 1",
      "/// * p の定義域について",
      "///     * ng < ok の場合、p は区間 ng..ok で定義されている。",
      "///     * ok < ng の場合、p は区間 ok..ng で定義されている。",
      "/// * p の単調性について",
      "///     * ng < ok の場合、p は単調増加",
      "///     * ok < ng の場合、p は単調減少",
      "/// ## Return",
      "/// * ng < ok の場合: I = { i in ng..ok | p(i) == true } としたとき",
      "///     * I が空でなければ、min I を返す。",
      "///     * I が空ならば、ok を返す。",
      "/// * ok < ng の場合: I = { i in ok..ng | p(i) == true } としたとき",
      "///     * I が空でなければ、max I を返す。",
      "///     * I が空ならば、ok を返す。",
      "pub fn bin_search<F>(mut ok: i64, mut ng: i64, mut p: F) -> i64",
      "where",
      "    F: FnMut(i64) -> bool,",
      "{",
      "    debug_assert!(ok != ng);",
      "    debug_assert!(ok.checked_sub(ng).is_some());",
      "    debug_assert!(ok.checked_add(ng).is_some());",
      "    while num::abs(ok - ng) > 1 {",
      "        let mid = (ok + ng) / 2;",
      "        debug_assert!(mid != ok);",
      "        debug_assert!(mid != ng);",
      "        if p(mid) {",
      "            ok = mid;",
      "        } else {",
      "            ng = mid;",
      "        }",
      "    }",
      "    ok",
      "}",
      "/// 指定された要素以下の値が現れる最初の位置を返す。",
      "/// # 計算量",
      "/// O(log(|xs|))",
      "/// ## Arguments",
      "/// * xs: 単調減少",
      "///     * 単調減少でなくても、 `|i| xs[i] <= key` が単調ならOK",
      "/// ## Return",
      "/// `I = {i in 0..xs.len() | xs[i] <= key}` としたとき、`min I` を返す。",
      "/// ただし、`I` が空の場合は `xs.len()` を返す。",
      "/// 戻り値は、区間 `0..=xs.len()` の間で返る。",
      "pub fn lower_bound_dec<T: PartialOrd>(xs: &[T], key: T) -> usize {",
      "    let pred = |i: i64| xs[i as usize] <= key;",
      "    bin_search(xs.len() as i64, -1_i64, pred) as usize",
      "}"
    ]
  },
  "lowlink": {
    "scope": "rust",
    "prefix": "lowlink",
    "body": [
      "use lowlink::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod lowlink {",
      "    /// LowLink (無向グラフの橋、関節点の検出)",
      "    /// # 計算量",
      "    /// O(V + E)",
      "    #[derive(Clone, Debug)]",
      "    pub struct LowLink {",
      "        /// 各頂点の訪問順序 (0-indexed)",
      "        pub ord: Vec<usize>,",
      "        /// 各頂点から DFS 木の辺と後退辺を最大 1 回通って到達できる頂点の最小 ord",
      "        pub low: Vec<usize>,",
      "        /// 橋 (u, v) のリスト。常に u < v となるように正規化されている。",
      "        pub bridges: Vec<(usize, usize)>,",
      "        /// 関節点のリスト。昇順にソートされている。",
      "        pub articulation_points: Vec<usize>,",
      "    }",
      "    impl LowLink {",
      "        /// LowLink を構築する",
      "        /// # Arguments",
      "        /// * `nv` - 頂点数",
      "        /// * `adj_fn` - 頂点を受け取り、隣接する頂点のイテレータを返すクロージャー。",
      "        ///   **無向グラフ**として隣接頂点を返す必要があります。",
      "        /// # 計算量",
      "        /// O(V + E)",
      "        pub fn new<F, It>(nv: usize, mut adj_fn: F) -> Self",
      "        where",
      "            F: FnMut(usize) -> It,",
      "            It: IntoIterator<Item = usize>,",
      "        {",
      "            let mut ord = vec![usize::MAX; nv];",
      "            let mut low = vec![usize::MAX; nv];",
      "            let mut bridges = Vec::new();",
      "            let mut articulation_points = Vec::new();",
      "            let mut k = 0;",
      "            let adj = {",
      "                let mut adj = vec![vec![]; nv];",
      "                for i in 0..nv {",
      "                    for v in adj_fn(i) {",
      "                        if v != i {",
      "                            adj[i].push(v);",
      "                        }",
      "                    }",
      "                }",
      "                adj",
      "            };",
      "            for i in 0..nv {",
      "                if ord[i] == usize::MAX {",
      "                    Self::dfs(",
      "                        i,",
      "                        usize::MAX,",
      "                        &adj,",
      "                        &mut k,",
      "                        &mut ord,",
      "                        &mut low,",
      "                        &mut bridges,",
      "                        &mut articulation_points,",
      "                    );",
      "                }",
      "            }",
      "            bridges.sort();",
      "            articulation_points.sort();",
      "            articulation_points.dedup();",
      "            Self {",
      "                ord,",
      "                low,",
      "                bridges,",
      "                articulation_points,",
      "            }",
      "        }",
      "        /// DFS を行い、ord, low, bridges, articulation_points を計算する",
      "        /// # Arguments",
      "        /// * `u` - 現在の頂点",
      "        /// * `p` - 親頂点",
      "        /// * `adj` - 隣接リスト",
      "        /// * `k` - 訪問順序のカウンター",
      "        /// * `ord` - 各頂点の訪問順序",
      "        /// * `low` - 各頂点の lowlink 値",
      "        /// * `bridges` - 橋のリスト",
      "        /// * `articulation_points` - 関節点のリスト",
      "        #[allow(clippy::too_many_arguments)]",
      "        fn dfs(",
      "            u: usize,",
      "            p: usize,",
      "            adj: &[Vec<usize>],",
      "            k: &mut usize,",
      "            ord: &mut Vec<usize>,",
      "            low: &mut Vec<usize>,",
      "            bridges: &mut Vec<(usize, usize)>,",
      "            articulation_points: &mut Vec<usize>,",
      "        ) {",
      "            ord[u] = *k;",
      "            low[u] = *k;",
      "            *k += 1;",
      "            let mut is_articulation = false;",
      "            let mut child_count = 0;",
      "            for &v in &adj[u] {",
      "                if v == p {",
      "                    continue;",
      "                }",
      "                if ord[v] != usize::MAX {",
      "                    low[u] = low[u].min(ord[v]);",
      "                } else {",
      "                    child_count += 1;",
      "                    Self::dfs(v, u, adj, k, ord, low, bridges, articulation_points);",
      "                    low[u] = low[u].min(low[v]);",
      "                    if p != usize::MAX && low[v] >= ord[u] {",
      "                        is_articulation = true;",
      "                    }",
      "                    if low[v] > ord[u] {",
      "                        if u < v {",
      "                            bridges.push((u, v));",
      "                        } else {",
      "                            bridges.push((v, u));",
      "                        }",
      "                    }",
      "                }",
      "            }",
      "            if p == usize::MAX && child_count >= 2 {",
      "                is_articulation = true;",
      "            }",
      "            if is_articulation {",
      "                articulation_points.push(u);",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "lowlink_ix": {
    "scope": "rust",
    "prefix": "lowlink_ix",
    "body": [
      "use lowlink_ix::*;",
      "pub mod lowlink_ix {",
      "    use super::lowlink::LowLink;",
      "    use super::{Bounds, Ix, IxVec};",
      "    /// LowLink の結果 (Ix版)",
      "    #[derive(Clone, Debug)]",
      "    pub struct LowLinkIxResult<I: Ix> {",
      "        /// 各頂点の訪問順序 (0-indexed)",
      "        pub ord: IxVec<I, usize>,",
      "        /// 各頂点から DFS 木の辺と後退辺を最大 1 回通って到達できる頂点の最小 ord",
      "        pub low: IxVec<I, usize>,",
      "        /// 橋 (u, v) のリスト。",
      "        pub bridges: Vec<(I, I)>,",
      "        /// 関節点のリスト。",
      "        pub articulation_points: Vec<I>,",
      "    }",
      "    /// Bounds を用いた任意の型 I に対する LowLink (無向グラフ)",
      "    /// # Arguments",
      "    /// * `bounds` - 頂点のインデックス範囲",
      "    /// * `adj` - 頂点を受け取り、隣接する頂点のイテレータを返すクロージャー。",
      "    ///   **無向グラフ**として隣接頂点を返す必要があります。",
      "    /// # Returns",
      "    /// LowLink の結果を格納した `LowLinkIxResult<I>`。",
      "    /// # 計算量",
      "    /// O(V + E)",
      "    pub fn lowlink_arbitrary<I, F, It>(bounds: Bounds<I>, mut adj: F) -> LowLinkIxResult<I>",
      "    where",
      "        I: Ix,",
      "        F: FnMut(I) -> It,",
      "        It: IntoIterator<Item = I>,",
      "    {",
      "        let nv = bounds.range_size();",
      "        let mut adj_usize = |u_idx: usize| {",
      "            let u = bounds.from_index(u_idx);",
      "            adj(u).into_iter().map(move |v| bounds.to_index(v))",
      "        };",
      "        let res = LowLink::new(nv, &mut adj_usize);",
      "        LowLinkIxResult {",
      "            ord: IxVec::from_vec(bounds, res.ord),",
      "            low: IxVec::from_vec(bounds, res.low),",
      "            bridges: res",
      "                .bridges",
      "                .into_iter()",
      "                .map(|(u, v)| (bounds.from_index(u), bounds.from_index(v)))",
      "                .collect(),",
      "            articulation_points: res",
      "                .articulation_points",
      "                .into_iter()",
      "                .map(|u| bounds.from_index(u))",
      "                .collect(),",
      "        }",
      "    }",
      "}"
    ]
  },
  "make_adj_from_directed": {
    "scope": "rust",
    "prefix": "make_adj_from_directed",
    "body": [
      "/// 有向グラフの辺集合から隣接リストを作成します。",
      "/// # 計算量",
      "/// O(V + E)",
      "pub fn make_adj_from_directed(n_vertex: usize, edges: &[(usize, usize)]) -> Vec<Vec<usize>> {",
      "    let mut adj = vec![vec![]; n_vertex];",
      "    for &(from, to) in edges {",
      "        adj[from].push(to);",
      "    }",
      "    adj",
      "}"
    ]
  },
  "make_adj_from_undirected": {
    "scope": "rust",
    "prefix": "make_adj_from_undirected",
    "body": [
      "/// 無向グラフの辺集合から隣接リストを作成します。",
      "/// # 計算量",
      "/// O(V + E)",
      "pub fn make_adj_from_undirected(n_vertex: usize, edges: &[(usize, usize)]) -> Vec<Vec<usize>> {",
      "    let mut adj = vec![vec![]; n_vertex];",
      "    for &(from, to) in edges {",
      "        adj[from].push(to);",
      "        adj[to].push(from);",
      "    }",
      "    adj",
      "}"
    ]
  },
  "make_adj_from_weighted_directed": {
    "scope": "rust",
    "prefix": "make_adj_from_weighted_directed",
    "body": [
      "/// 重み付き有向グラフの辺集合から隣接リストを作成します。",
      "/// # 計算量",
      "/// O(V + E)",
      "pub fn make_adj_from_weighted_directed<T>(",
      "    n_vertex: usize,",
      "    edges: &[(usize, usize, T)],",
      ") -> Vec<Vec<(usize, T)>>",
      "where",
      "    T: Clone,",
      "{",
      "    let mut adj = vec![vec![]; n_vertex];",
      "    for (from, to, weight) in edges {",
      "        adj[*from].push((*to, weight.clone()));",
      "    }",
      "    adj",
      "}"
    ]
  },
  "make_adj_from_weighted_undirected": {
    "scope": "rust",
    "prefix": "make_adj_from_weighted_undirected",
    "body": [
      "/// 重み付き無向グラフの辺集合から隣接リストを作成します。",
      "/// # 計算量",
      "/// O(V + E)",
      "pub fn make_adj_from_weighted_undirected<T>(",
      "    n_vertex: usize,",
      "    edges: &[(usize, usize, T)],",
      ") -> Vec<Vec<(usize, T)>>",
      "where",
      "    T: Clone,",
      "{",
      "    let mut adj = vec![vec![]; n_vertex];",
      "    for (from, to, weight) in edges {",
      "        adj[*from].push((*to, weight.clone()));",
      "        adj[*to].push((*from, weight.clone()));",
      "    }",
      "    adj",
      "}"
    ]
  },
  "make_tree_children": {
    "scope": "rust",
    "prefix": "make_tree_children",
    "body": [
      "/// 根付き木の隣接リスト `adj` と根 `root` から、各頂点の子頂点リストを求めます。",
      "/// # 計算量",
      "/// O(V + E)",
      "pub fn make_tree_children(adj: &[Vec<usize>], root: usize) -> Vec<Vec<usize>> {",
      "    let n = adj.len();",
      "    let mut children = vec![vec![]; n];",
      "    let mut visited = vec![false; n];",
      "    let mut queue = std::collections::VecDeque::new();",
      "    visited[root] = true;",
      "    queue.push_back(root);",
      "    while let Some(v) = queue.pop_front() {",
      "        for &u in &adj[v] {",
      "            if !visited[u] {",
      "                visited[u] = true;",
      "                children[v].push(u);",
      "                queue.push_back(u);",
      "            }",
      "        }",
      "    }",
      "    children",
      "}"
    ]
  },
  "make_tree_parent": {
    "scope": "rust",
    "prefix": "make_tree_parent",
    "body": [
      "/// 根付き木の隣接リスト `adj` と根 `root` から、各頂点の親頂点を求めます。",
      "/// # 計算量",
      "/// O(V + E)",
      "pub fn make_tree_parent(adj: &[Vec<usize>], root: usize) -> Vec<Option<usize>> {",
      "    let n = adj.len();",
      "    let mut parent = vec![None; n];",
      "    let mut visited = vec![false; n];",
      "    let mut queue = std::collections::VecDeque::new();",
      "    visited[root] = true;",
      "    queue.push_back(root);",
      "    while let Some(v) = queue.pop_front() {",
      "        for &u in &adj[v] {",
      "            if !visited[u] {",
      "                visited[u] = true;",
      "                parent[u] = Some(v);",
      "                queue.push_back(u);",
      "            }",
      "        }",
      "    }",
      "    parent",
      "}"
    ]
  },
  "map_monoid_template": {
    "scope": "rust",
    "prefix": "map_monoid_template",
    "body": [
      "use map_monoid_template::*;",
      "#[allow(unused_variables)]",
      "#[allow(clippy::module_inception)]",
      "pub mod map_monoid_template {",
      "    use ac_library::lazysegtree::MapMonoid;",
      "    use ac_library::segtree::Monoid;",
      "    use std::convert::Infallible;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct RangeXxx {",
      "        pub len: usize,",
      "    }",
      "    impl RangeXxx {",
      "        pub fn unit(x: i64) -> Self {",
      "            Self { len: 1 }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeXxxMonoid(Infallible);",
      "    impl Monoid for RangeXxxMonoid {",
      "        type S = RangeXxx;",
      "        fn identity() -> Self::S {",
      "            RangeXxx { len: 0 }",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            RangeXxx { len: a.len + b.len }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeYyyRangeXxx(Infallible);",
      "    impl MapMonoid for RangeYyyRangeXxx {",
      "        type M = RangeXxxMonoid;",
      "        type F = ();",
      "        fn identity_map() -> Self::F {}",
      "        fn mapping(",
      "            f: &Self::F,",
      "            x: &<Self::M as ac_library::Monoid>::S,",
      "        ) -> <Self::M as ac_library::Monoid>::S {",
      "            RangeXxx { len: x.len }",
      "        }",
      "        fn composition(f: &Self::F, g: &Self::F) -> Self::F {}",
      "    }",
      "}"
    ]
  },
  "matrix": {
    "scope": "rust",
    "prefix": "matrix",
    "body": [
      "use matrix::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod matrix {",
      "    use std::ops::{Add, AddAssign, Index, IndexMut, Mul, Sub, SubAssign};",
      "    #[derive(Debug, Clone, Copy, PartialEq, Eq)]",
      "    pub struct Matrix<T, const R: usize, const C: usize> {",
      "        pub data: [[T; C]; R],",
      "    }",
      "    use std::iter::{Product, Sum};",
      "    fn t_zero<T>() -> T",
      "    where",
      "        T: Sum,",
      "    {",
      "        std::iter::empty().sum()",
      "    }",
      "    fn t_one<T>() -> T",
      "    where",
      "        T: Product,",
      "    {",
      "        std::iter::empty().product()",
      "    }",
      "    impl<T, const R: usize, const C: usize> Matrix<T, R, C>",
      "    where",
      "        T: Copy + Sum + Product + Add<Output = T> + Sub<Output = T> + Mul<Output = T>,",
      "    {",
      "        /// 指定された値で埋められた新しい行列を作成します。",
      "        pub fn new(initial_value: T) -> Self {",
      "            Self {",
      "                data: [[initial_value; C]; R],",
      "            }",
      "        }",
      "        /// 配列から行列を作成します。",
      "        pub fn from_array(data: [[T; C]; R]) -> Self {",
      "            Self { data }",
      "        }",
      "        /// スカラ倍 (Matrix * T)",
      "        pub fn scalar_mul(self, rhs: T) -> Self {",
      "            let mut result = Self::new(t_zero());",
      "            for i in 0..R {",
      "                for j in 0..C {",
      "                    result.data[i][j] = self.data[i][j] * rhs;",
      "                }",
      "            }",
      "            result",
      "        }",
      "        /// ベクトルを行列に適用します (行列-ベクトル積)。",
      "        /// `self`はR行C列の行列、`x`はC要素の列ベクトルです。",
      "        /// 結果はR要素の列ベクトルになります。",
      "        pub fn apply(self, x: [T; C]) -> [T; R] {",
      "            let mut result = [t_zero(); R];",
      "            for i in 0..R {",
      "                for j in 0..C {",
      "                    result[i] = result[i] + self.data[i][j] * x[j];",
      "                }",
      "            }",
      "            result",
      "        }",
      "    }",
      "    impl<T, const R: usize, const C: usize> Index<(usize, usize)> for Matrix<T, R, C> {",
      "        type Output = T;",
      "        fn index(&self, index: (usize, usize)) -> &Self::Output {",
      "            &self.data[index.0][index.1]",
      "        }",
      "    }",
      "    impl<T, const R: usize, const C: usize> IndexMut<(usize, usize)> for Matrix<T, R, C> {",
      "        fn index_mut(&mut self, index: (usize, usize)) -> &mut Self::Output {",
      "            &mut self.data[index.0][index.1]",
      "        }",
      "    }",
      "    impl<T, const R: usize, const C: usize> Add for Matrix<T, R, C>",
      "    where",
      "        T: Copy + Sum + Product + Add<Output = T> + Sub<Output = T> + Mul<Output = T>,",
      "    {",
      "        type Output = Self;",
      "        fn add(self, rhs: Self) -> Self::Output {",
      "            let mut result = Self::new(t_zero());",
      "            for i in 0..R {",
      "                for j in 0..C {",
      "                    result.data[i][j] = self.data[i][j] + rhs.data[i][j];",
      "                }",
      "            }",
      "            result",
      "        }",
      "    }",
      "    impl<T, const R: usize, const C: usize> AddAssign for Matrix<T, R, C>",
      "    where",
      "        T: Copy + Sum + Product + AddAssign + Sub<Output = T> + Mul<Output = T>,",
      "    {",
      "        fn add_assign(&mut self, rhs: Self) {",
      "            for i in 0..R {",
      "                for j in 0..C {",
      "                    self.data[i][j] += rhs.data[i][j];",
      "                }",
      "            }",
      "        }",
      "    }",
      "    impl<T, const R: usize, const C: usize> Sub for Matrix<T, R, C>",
      "    where",
      "        T: Copy + Sum + Product + Sub<Output = T> + Add<Output = T> + Mul<Output = T>,",
      "    {",
      "        type Output = Self;",
      "        fn sub(self, rhs: Self) -> Self::Output {",
      "            let mut result = Self::new(t_zero());",
      "            for i in 0..R {",
      "                for j in 0..C {",
      "                    result.data[i][j] = self.data[i][j] - rhs.data[i][j];",
      "                }",
      "            }",
      "            result",
      "        }",
      "    }",
      "    impl<T, const R: usize, const C: usize> SubAssign for Matrix<T, R, C>",
      "    where",
      "        T: Copy + Sum + Product + SubAssign + Add<Output = T> + Mul<Output = T>,",
      "    {",
      "        fn sub_assign(&mut self, rhs: Self) {",
      "            for i in 0..R {",
      "                for j in 0..C {",
      "                    self.data[i][j] -= rhs.data[i][j];",
      "                }",
      "            }",
      "        }",
      "    }",
      "    impl<T, const R: usize, const C: usize, const K: usize> Mul<Matrix<T, C, K>> for Matrix<T, R, C>",
      "    where",
      "        T: Copy + Sum + Product + Add<Output = T> + Sub<Output = T> + Mul<Output = T>,",
      "    {",
      "        type Output = Matrix<T, R, K>;",
      "        fn mul(self, rhs: Matrix<T, C, K>) -> Self::Output {",
      "            let mut result = Matrix::<T, R, K>::new(t_zero());",
      "            for i in 0..R {",
      "                for j in 0..K {",
      "                    for l in 0..C {",
      "                        result.data[i][j] = result.data[i][j] + self.data[i][l] * rhs.data[l][j];",
      "                    }",
      "                }",
      "            }",
      "            result",
      "        }",
      "    }",
      "    impl<T, const R: usize, const C: usize> Mul<i64> for Matrix<T, R, C>",
      "    where",
      "        T: Copy",
      "            + Sum",
      "            + Product",
      "            + Mul<i64, Output = T>",
      "            + Add<Output = T>",
      "            + Sub<Output = T>",
      "            + Mul<Output = T>,",
      "    {",
      "        type Output = Self;",
      "        fn mul(self, rhs: i64) -> Self::Output {",
      "            let mut result = Self::new(t_zero());",
      "            for i in 0..R {",
      "                for j in 0..C {",
      "                    result.data[i][j] = self.data[i][j] * rhs;",
      "                }",
      "            }",
      "            result",
      "        }",
      "    }",
      "    impl<T, const N: usize> Matrix<T, N, N>",
      "    where",
      "        T: Copy + Sum + Product + Add<Output = T> + Sub<Output = T> + Mul<Output = T>,",
      "    {",
      "        pub fn pow(self, mut n: u64) -> Self {",
      "            let mut res = Matrix::<T, N, N>::identity();",
      "            let mut base = self;",
      "            while n > 0 {",
      "                if n % 2 == 1 {",
      "                    res = res * base;",
      "                }",
      "                base = base * base;",
      "                n /= 2;",
      "            }",
      "            res",
      "        }",
      "        /// 単位行列を作成します。正方行列の場合のみ有効です。",
      "        pub fn identity() -> Self {",
      "            let mut matrix = Self::new(t_zero());",
      "            for i in 0..N {",
      "                matrix.data[i][i] = t_one();",
      "            }",
      "            matrix",
      "        }",
      "    }",
      "    impl<T> Matrix<T, 2, 2>",
      "    where",
      "        T: Copy + Sum + Product + Add<Output = T> + Sub<Output = T> + Mul<Output = T>,",
      "    {",
      "        /// 2x2行列の行列式を計算します。",
      "        pub fn det(self) -> T {",
      "            self.data[0][0] * self.data[1][1] - self.data[0][1] * self.data[1][0]",
      "        }",
      "    }",
      "    impl<T> Matrix<T, 3, 3>",
      "    where",
      "        T: Copy + Sum + Product + Add<Output = T> + Sub<Output = T> + Mul<Output = T>,",
      "    {",
      "        /// 3x3行列の行列式を計算します。",
      "        pub fn det(self) -> T {",
      "            let a = self.data[0][0];",
      "            let b = self.data[0][1];",
      "            let c = self.data[0][2];",
      "            let d = self.data[1][0];",
      "            let e = self.data[1][1];",
      "            let f = self.data[1][2];",
      "            let g = self.data[2][0];",
      "            let h = self.data[2][1];",
      "            let i = self.data[2][2];",
      "            a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)",
      "        }",
      "    }",
      "    impl<T> Matrix<T, 4, 4>",
      "    where",
      "        T: Copy + Sum + Product + Add<Output = T> + Sub<Output = T> + Mul<Output = T>,",
      "    {",
      "        /// 4x4行列の行列式を計算します。",
      "        pub fn det(self) -> T {",
      "            let m = self.data;",
      "            let m11 = Matrix::<T, 3, 3>::from_array([",
      "                [m[1][1], m[1][2], m[1][3]],",
      "                [m[2][1], m[2][2], m[2][3]],",
      "                [m[3][1], m[3][2], m[3][3]],",
      "            ]);",
      "            let m12 = Matrix::<T, 3, 3>::from_array([",
      "                [m[1][0], m[1][2], m[1][3]],",
      "                [m[2][0], m[2][2], m[2][3]],",
      "                [m[3][0], m[3][2], m[3][3]],",
      "            ]);",
      "            let m13 = Matrix::<T, 3, 3>::from_array([",
      "                [m[1][0], m[1][1], m[1][3]],",
      "                [m[2][0], m[2][1], m[2][3]],",
      "                [m[3][0], m[3][1], m[3][3]],",
      "            ]);",
      "            let m14 = Matrix::<T, 3, 3>::from_array([",
      "                [m[1][0], m[1][1], m[1][2]],",
      "                [m[2][0], m[2][1], m[2][2]],",
      "                [m[3][0], m[3][1], m[3][2]],",
      "            ]);",
      "            m[0][0] * m11.det() - m[0][1] * m12.det() + m[0][2] * m13.det() - m[0][3] * m14.det()",
      "        }",
      "    }",
      "    pub type Matrix22<T> = Matrix<T, 2, 2>;",
      "    pub type Matrix33<T> = Matrix<T, 3, 3>;",
      "    pub type Matrix44<T> = Matrix<T, 4, 4>;",
      "}"
    ]
  },
  "mex": {
    "scope": "rust",
    "prefix": "mex",
    "body": [
      "/// # 計算量",
      "/// O(xs.len())",
      "pub fn mex(xs: &[usize]) -> usize {",
      "    let contains = xs",
      "        .iter()",
      "        .copied()",
      "        .fold(vec![false; xs.len()], |mut acc, x| {",
      "            if x < xs.len() {",
      "                acc[x] |= true;",
      "            }",
      "            acc",
      "        });",
      "    contains",
      "        .iter()",
      "        .copied()",
      "        .position(|p| !p)",
      "        .unwrap_or(xs.len())",
      "}"
    ]
  },
  "min_max_monoid": {
    "scope": "rust",
    "prefix": "min_max_monoid",
    "body": [
      "use min_max_monoid::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod min_max_monoid {",
      "    use ac_library::Monoid;",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    pub trait BoundedBelow {",
      "        fn min_value() -> Self;",
      "    }",
      "    pub trait BoundedAbove {",
      "        fn max_value() -> Self;",
      "    }",
      "    macro_rules ! impl_bounded {(\\$ (\\$ ty : ty ) ,* ) => {\\$ (impl BoundedBelow for \\$ ty {# [inline ] fn min_value () -> Self {Self :: MIN } } impl BoundedAbove for \\$ ty {# [inline ] fn max_value () -> Self {Self :: MAX } } ) * } ; }",
      "    impl_bounded!(i8, i16, i32, i64, i128, isize, u8, u16, u32, u64, u128, usize);",
      "    impl<T: BoundedAbove> BoundedBelow for std::cmp::Reverse<T> {",
      "        #[inline]",
      "        fn min_value() -> Self {",
      "            std::cmp::Reverse(T::max_value())",
      "        }",
      "    }",
      "    impl<T: BoundedBelow> BoundedAbove for std::cmp::Reverse<T> {",
      "        #[inline]",
      "        fn max_value() -> Self {",
      "            std::cmp::Reverse(T::min_value())",
      "        }",
      "    }",
      "    macro_rules ! impl_bounded_tuples {(\\$ head : ident ) => {} ; (\\$ head : ident , \\$ (\\$ tail : ident ) ,* ) => {impl <\\$ head , \\$ (\\$ tail ) ,*> BoundedBelow for (\\$ head , \\$ (\\$ tail ) ,* ) where \\$ head : BoundedBelow , \\$ (\\$ tail : BoundedBelow ) ,* {# [inline ] fn min_value () -> Self {(\\$ head :: min_value () , \\$ (\\$ tail :: min_value () ) ,* ) } } impl <\\$ head , \\$ (\\$ tail ) ,*> BoundedAbove for (\\$ head , \\$ (\\$ tail ) ,* ) where \\$ head : BoundedAbove , \\$ (\\$ tail : BoundedAbove ) ,* {# [inline ] fn max_value () -> Self {(\\$ head :: max_value () , \\$ (\\$ tail :: max_value () ) ,* ) } } impl_bounded_tuples ! (\\$ (\\$ tail ) ,* ) ; } ; () => {} ; }",
      "    impl_bounded_tuples!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12);",
      "    /// 辞書式順序で最小の要素を管理するモノイド (単位元は最大値)",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct MinMonoid<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for MinMonoid<T>",
      "    where",
      "        T: BoundedAbove + Ord + Clone,",
      "    {",
      "        type S = T;",
      "        fn identity() -> Self::S {",
      "            T::max_value()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            std::cmp::min(a, b).clone()",
      "        }",
      "    }",
      "    /// 辞書式順序で最大の要素を管理するモノイド (単位元は最小値)",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct MaxMonoid<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for MaxMonoid<T>",
      "    where",
      "        T: BoundedBelow + Ord + Clone,",
      "    {",
      "        type S = T;",
      "        fn identity() -> Self::S {",
      "            T::min_value()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            std::cmp::max(a, b).clone()",
      "        }",
      "    }",
      "}"
    ]
  },
  "mod_combinatorics": {
    "scope": "rust",
    "prefix": "mod_combinatorics",
    "body": [
      "use mod_combinatorics::*;",
      "pub mod mod_combinatorics {",
      "    use ac_library::modint::ModIntBase;",
      "    #[derive(Clone, Debug)]",
      "    pub struct Comb<Mint: ModIntBase> {",
      "        fac: Vec<Mint>,",
      "        invfac: Vec<Mint>,",
      "    }",
      "    impl<Mint: ModIntBase> Comb<Mint> {",
      "        /// 階乗とその逆元を `max_val` まで前計算する。",
      "        /// 計算量: O(max_val)",
      "        pub fn new(max_val: usize) -> Self {",
      "            let mut inv = vec![Mint::new(0); max_val + 1];",
      "            let mut fac = vec![Mint::new(0); max_val + 1];",
      "            let mut invfac = vec![Mint::new(0); max_val + 1];",
      "            fac[0] = 1.into();",
      "            fac[1] = 1.into();",
      "            invfac[0] = 1.into();",
      "            invfac[1] = 1.into();",
      "            inv[1] = 1.into();",
      "            let modulus = Mint::modulus() as usize;",
      "            for i in 2..=max_val {",
      "                inv[i] = -inv[modulus % i] * Mint::new(modulus / i);",
      "                fac[i] = fac[i - 1] * Mint::new(i);",
      "                invfac[i] = invfac[i - 1] * inv[i];",
      "            }",
      "            Self { fac, invfac }",
      "        }",
      "        pub fn comb(&self, n: usize, k: usize) -> Mint {",
      "            if n < k {",
      "                0.into()",
      "            } else {",
      "                self.fac[n] * self.invfac[k] * self.invfac[n - k]",
      "            }",
      "        }",
      "        pub fn perm(&self, n: usize, k: usize) -> Mint {",
      "            if n < k {",
      "                0.into()",
      "            } else {",
      "                self.fac[n] * self.invfac[n - k]",
      "            }",
      "        }",
      "        pub fn factorial(&self, n: usize) -> Mint {",
      "            self.fac[n]",
      "        }",
      "        pub fn inv_factorial(&self, n: usize) -> Mint {",
      "            self.invfac[n]",
      "        }",
      "    }",
      "}"
    ]
  },
  "mod_ext_int": {
    "scope": "rust",
    "prefix": "mod_ext_int",
    "body": [
      "use mod_ext_int::*;",
      "pub mod mod_ext_int {",
      "    use ac_library::Monoid;",
      "    use std::{",
      "        cmp::Ordering,",
      "        convert::Infallible,",
      "        fmt,",
      "        ops::{Add, AddAssign, Mul, Sub, SubAssign},",
      "    };",
      "    pub const INF: ExtInt = ExtInt::INF;",
      "    pub fn fin(x: i64) -> ExtInt {",
      "        ExtInt::fin(x)",
      "    }",
      "    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]",
      "    pub struct ExtInt(i64);",
      "    impl ExtInt {",
      "        pub const INF: Self = Self(i64::MAX);",
      "        pub fn fin(x: i64) -> Self {",
      "            Self(x)",
      "        }",
      "        pub fn get_fin(self) -> i64 {",
      "            if self.is_fin() {",
      "                self.0",
      "            } else {",
      "                panic!(\"called `ExtInt::get_fin()` on a infinity\")",
      "            }",
      "        }",
      "        pub fn get_fin_or(self, default: i64) -> i64 {",
      "            if self.is_fin() {",
      "                self.0",
      "            } else {",
      "                default",
      "            }",
      "        }",
      "        #[inline]",
      "        pub fn is_fin(self) -> bool {",
      "            self.0 != i64::MAX",
      "        }",
      "        pub fn is_inf(self) -> bool {",
      "            self.0 == i64::MAX",
      "        }",
      "        pub fn to_option(self) -> Option<i64> {",
      "            if self.is_fin() {",
      "                Some(self.0)",
      "            } else {",
      "                None",
      "            }",
      "        }",
      "        pub fn from_option(opt: Option<i64>) -> ExtInt {",
      "            match opt {",
      "                Some(a) => Self(a),",
      "                None => Self::INF,",
      "            }",
      "        }",
      "        pub fn times(self, t: i64) -> Self {",
      "            self * t",
      "        }",
      "    }",
      "    impl Add for ExtInt {",
      "        type Output = ExtInt;",
      "        fn add(self, rhs: Self) -> Self::Output {",
      "            if self.is_inf() || rhs.is_inf() {",
      "                Self::INF",
      "            } else {",
      "                Self::fin(self.0 + rhs.0)",
      "            }",
      "        }",
      "    }",
      "    impl AddAssign for ExtInt {",
      "        fn add_assign(&mut self, rhs: Self) {",
      "            *self = *self + rhs;",
      "        }",
      "    }",
      "    impl Add<i64> for ExtInt {",
      "        type Output = ExtInt;",
      "        fn add(self, rhs: i64) -> Self::Output {",
      "            if self.is_inf() {",
      "                Self::INF",
      "            } else {",
      "                Self::fin(self.0 + rhs)",
      "            }",
      "        }",
      "    }",
      "    impl AddAssign<i64> for ExtInt {",
      "        fn add_assign(&mut self, rhs: i64) {",
      "            *self = *self + rhs;",
      "        }",
      "    }",
      "    impl Sub<i64> for ExtInt {",
      "        type Output = ExtInt;",
      "        fn sub(self, rhs: i64) -> Self::Output {",
      "            if self.is_inf() {",
      "                Self::INF",
      "            } else {",
      "                Self::fin(self.0 - rhs)",
      "            }",
      "        }",
      "    }",
      "    impl SubAssign<i64> for ExtInt {",
      "        fn sub_assign(&mut self, rhs: i64) {",
      "            *self = *self - rhs;",
      "        }",
      "    }",
      "    impl Mul<i64> for ExtInt {",
      "        type Output = ExtInt;",
      "        fn mul(self, rhs: i64) -> Self::Output {",
      "            match rhs.cmp(&0) {",
      "                Ordering::Less => panic!(\"multiplier must be non-negative.\"),",
      "                Ordering::Equal => Self::fin(0),",
      "                Ordering::Greater => {",
      "                    if self.is_fin() {",
      "                        Self::fin(self.0 * rhs)",
      "                    } else {",
      "                        Self::INF",
      "                    }",
      "                }",
      "            }",
      "        }",
      "    }",
      "    impl std::iter::Sum for ExtInt {",
      "        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {",
      "            let mut s = 0;",
      "            for x in iter {",
      "                if x.is_inf() {",
      "                    return Self::INF;",
      "                }",
      "                s += x.0;",
      "            }",
      "            Self::fin(s)",
      "        }",
      "    }",
      "    impl fmt::Display for ExtInt {",
      "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
      "            if self.is_inf() {",
      "                write!(f, \"+∞\")",
      "            } else {",
      "                write!(f, \"{}\", self.0)",
      "            }",
      "        }",
      "    }",
      "    impl fmt::Debug for ExtInt {",
      "        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "            if self.is_inf() {",
      "                write!(f, \"+∞\")",
      "            } else {",
      "                write!(f, \"{}\", self.0)",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct ExtIntAdditive(Infallible);",
      "    impl Monoid for ExtIntAdditive {",
      "        type S = ExtInt;",
      "        fn identity() -> Self::S {",
      "            ExtInt::fin(0)",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a + *b",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct ExtIntMin(Infallible);",
      "    impl Monoid for ExtIntMin {",
      "        type S = ExtInt;",
      "        fn identity() -> Self::S {",
      "            ExtInt::INF",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a.min(b)",
      "        }",
      "    }",
      "}"
    ]
  },
  "mod_ext_int_bounded": {
    "scope": "rust",
    "prefix": "mod_ext_int_bounded",
    "body": [
      "use mod_ext_int_bounded::*;",
      "/// MinMonoid/MaxMonoid を使うためのコード。",
      "/// min_max_monoid と ext_int のスニペットをあらかじめ貼った上で利用する",
      "pub mod mod_ext_int_bounded {",
      "    use super::mod_ext_int::ExtInt;",
      "    use super::{BoundedAbove, BoundedBelow};",
      "    impl BoundedBelow for ExtInt {",
      "        fn min_value() -> Self {",
      "            Self::fin(i64::MIN)",
      "        }",
      "    }",
      "    impl BoundedAbove for ExtInt {",
      "        fn max_value() -> Self {",
      "            Self::INF",
      "        }",
      "    }",
      "}"
    ]
  },
  "mod_neg_ext_int": {
    "scope": "rust",
    "prefix": "mod_neg_ext_int",
    "body": [
      "use mod_neg_ext_int::*;",
      "pub mod mod_neg_ext_int {",
      "    use ac_library::Monoid;",
      "    use std::{",
      "        cmp::Ordering,",
      "        convert::Infallible,",
      "        fmt,",
      "        ops::{Add, AddAssign, Mul, Sub, SubAssign},",
      "    };",
      "    pub const NEG_INF: NegExtInt = NegExtInt::NEG_INF;",
      "    pub fn fin(x: i64) -> NegExtInt {",
      "        NegExtInt::fin(x)",
      "    }",
      "    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]",
      "    pub struct NegExtInt(i64);",
      "    impl NegExtInt {",
      "        pub const NEG_INF: Self = Self(i64::MIN);",
      "        pub fn fin(x: i64) -> Self {",
      "            Self(x)",
      "        }",
      "        pub fn get_fin(self) -> i64 {",
      "            if self.is_fin() {",
      "                self.0",
      "            } else {",
      "                panic!(\"called `NegExtInt::get_fin()` on a negative infinity\")",
      "            }",
      "        }",
      "        pub fn get_fin_or(self, default: i64) -> i64 {",
      "            if self.is_fin() {",
      "                self.0",
      "            } else {",
      "                default",
      "            }",
      "        }",
      "        #[inline]",
      "        pub fn is_fin(self) -> bool {",
      "            self.0 != i64::MIN",
      "        }",
      "        pub fn is_neg_inf(self) -> bool {",
      "            self.0 == i64::MIN",
      "        }",
      "        pub fn to_option(self) -> Option<i64> {",
      "            if self.is_fin() {",
      "                Some(self.0)",
      "            } else {",
      "                None",
      "            }",
      "        }",
      "        pub fn from_option(opt: Option<i64>) -> NegExtInt {",
      "            match opt {",
      "                Some(a) => Self(a),",
      "                None => Self::NEG_INF,",
      "            }",
      "        }",
      "        pub fn times(self, t: i64) -> Self {",
      "            self * t",
      "        }",
      "    }",
      "    impl Add for NegExtInt {",
      "        type Output = NegExtInt;",
      "        fn add(self, rhs: Self) -> Self::Output {",
      "            if self.is_neg_inf() || rhs.is_neg_inf() {",
      "                Self::NEG_INF",
      "            } else {",
      "                Self::fin(self.0 + rhs.0)",
      "            }",
      "        }",
      "    }",
      "    impl AddAssign for NegExtInt {",
      "        fn add_assign(&mut self, rhs: Self) {",
      "            *self = *self + rhs;",
      "        }",
      "    }",
      "    impl Add<i64> for NegExtInt {",
      "        type Output = NegExtInt;",
      "        fn add(self, rhs: i64) -> Self::Output {",
      "            if self.is_neg_inf() {",
      "                Self::NEG_INF",
      "            } else {",
      "                Self::fin(self.0 + rhs)",
      "            }",
      "        }",
      "    }",
      "    impl AddAssign<i64> for NegExtInt {",
      "        fn add_assign(&mut self, rhs: i64) {",
      "            *self = *self + rhs;",
      "        }",
      "    }",
      "    impl Sub<i64> for NegExtInt {",
      "        type Output = NegExtInt;",
      "        fn sub(self, rhs: i64) -> Self::Output {",
      "            if self.is_neg_inf() {",
      "                Self::NEG_INF",
      "            } else {",
      "                Self::fin(self.0 - rhs)",
      "            }",
      "        }",
      "    }",
      "    impl SubAssign<i64> for NegExtInt {",
      "        fn sub_assign(&mut self, rhs: i64) {",
      "            *self = *self - rhs;",
      "        }",
      "    }",
      "    impl Mul<i64> for NegExtInt {",
      "        type Output = NegExtInt;",
      "        fn mul(self, rhs: i64) -> Self::Output {",
      "            match rhs.cmp(&0) {",
      "                Ordering::Less => panic!(\"multiplier must be non-negative.\"),",
      "                Ordering::Equal => Self::fin(0),",
      "                Ordering::Greater => {",
      "                    if self.is_fin() {",
      "                        Self::fin(self.0 * rhs)",
      "                    } else {",
      "                        Self::NEG_INF",
      "                    }",
      "                }",
      "            }",
      "        }",
      "    }",
      "    impl std::iter::Sum for NegExtInt {",
      "        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {",
      "            let mut s = 0;",
      "            for x in iter {",
      "                if x.is_neg_inf() {",
      "                    return Self::NEG_INF;",
      "                }",
      "                s += x.0;",
      "            }",
      "            Self::fin(s)",
      "        }",
      "    }",
      "    impl fmt::Display for NegExtInt {",
      "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
      "            if self.is_neg_inf() {",
      "                write!(f, \"-∞\")",
      "            } else {",
      "                write!(f, \"{}\", self.0)",
      "            }",
      "        }",
      "    }",
      "    impl fmt::Debug for NegExtInt {",
      "        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "            if self.is_neg_inf() {",
      "                write!(f, \"-∞\")",
      "            } else {",
      "                write!(f, \"{}\", self.0)",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct NegExtIntAdditive(Infallible);",
      "    impl Monoid for NegExtIntAdditive {",
      "        type S = NegExtInt;",
      "        fn identity() -> Self::S {",
      "            NegExtInt::fin(0)",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a + *b",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct NegExtIntMax(Infallible);",
      "    impl Monoid for NegExtIntMax {",
      "        type S = NegExtInt;",
      "        fn identity() -> Self::S {",
      "            NegExtInt::NEG_INF",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a.max(b)",
      "        }",
      "    }",
      "}"
    ]
  },
  "mod_neg_ext_int_bounded": {
    "scope": "rust",
    "prefix": "mod_neg_ext_int_bounded",
    "body": [
      "use mod_neg_ext_int_bounded::*;",
      "/// MinMonoid/MaxMonoid を使うためのコード。",
      "/// min_max_monoid と neg_ext_int のスニペットをあらかじめ貼った上で利用する",
      "pub mod mod_neg_ext_int_bounded {",
      "    use super::mod_neg_ext_int::NegExtInt;",
      "    use super::{BoundedAbove, BoundedBelow};",
      "    impl BoundedBelow for NegExtInt {",
      "        fn min_value() -> Self {",
      "            Self::NEG_INF",
      "        }",
      "    }",
      "    impl BoundedAbove for NegExtInt {",
      "        fn max_value() -> Self {",
      "            Self::fin(i64::MAX)",
      "        }",
      "    }",
      "}"
    ]
  },
  "mod_queue": {
    "scope": "rust",
    "prefix": "mod_queue",
    "body": [
      "use mod_queue::*;",
      "pub mod mod_queue {",
      "    use std::collections::VecDeque;",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Queue<T> {",
      "        raw: VecDeque<T>,",
      "    }",
      "    impl<T> Queue<T> {",
      "        pub fn new() -> Self {",
      "            Queue {",
      "                raw: VecDeque::new(),",
      "            }",
      "        }",
      "        pub fn push(&mut self, value: T) {",
      "            self.raw.push_back(value)",
      "        }",
      "        pub fn pop(&mut self) -> Option<T> {",
      "            self.raw.pop_front()",
      "        }",
      "        pub fn peek(&self) -> Option<&T> {",
      "            self.raw.front()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.raw.len()",
      "        }",
      "    }",
      "    impl<T> Default for Queue<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "}"
    ]
  },
  "mod_stack": {
    "scope": "rust",
    "prefix": "mod_stack",
    "body": [
      "use mod_stack::*;",
      "pub mod mod_stack {",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Stack<T> {",
      "        raw: Vec<T>,",
      "    }",
      "    impl<T> Stack<T> {",
      "        pub fn new() -> Self {",
      "            Stack { raw: Vec::new() }",
      "        }",
      "        pub fn push(&mut self, value: T) {",
      "            self.raw.push(value)",
      "        }",
      "        pub fn pop(&mut self) -> Option<T> {",
      "            self.raw.pop()",
      "        }",
      "        pub fn peek(&self) -> Option<&T> {",
      "            self.raw.last()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.raw.len()",
      "        }",
      "    }",
      "    impl<T> Default for Stack<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "}"
    ]
  },
  "modint_to_rational": {
    "scope": "rust",
    "prefix": "modint_to_rational",
    "body": [
      "use modint_to_rational::*;",
      "pub mod modint_to_rational {",
      "    use ac_library::modint::ModIntBase;",
      "    use num_rational::Rational64;",
      "    pub trait ToRational {",
      "        fn to_rational(&self) -> Option<Rational64>;",
      "        fn to_rational_str(&self) -> String {",
      "            self.to_rational()",
      "                .map(|x| x.to_string())",
      "                .unwrap_or(\"cannot reconstruct\".to_string())",
      "        }",
      "    }",
      "    impl<M: ModIntBase> ToRational for M {",
      "        /// modint を分数の形に復元する。デバッグ用。",
      "        /// 注意: 1000 * 2000 = 2*10^6 の計算をしている",
      "        fn to_rational(&self) -> Option<Rational64> {",
      "            if self.val() == 0 {",
      "                return Some(Rational64::new(0, 1));",
      "            }",
      "            for denom in 1..1000 {",
      "                let denom_inv = Self::new(denom).inv();",
      "                for numer in -1000..1000 {",
      "                    if *self == denom_inv * Self::new(numer) {",
      "                        return Some(Rational64::new(numer, denom));",
      "                    }",
      "                }",
      "            }",
      "            None",
      "        }",
      "    }",
      "}"
    ]
  },
  "modint_u64": {
    "scope": "rust",
    "prefix": "modint_u64",
    "body": [
      "use modint_u64::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod modint_u64 {",
      "    use std::{",
      "        convert::Infallible,",
      "        fmt,",
      "        hash::{Hash, Hasher},",
      "        iter::{Product, Sum},",
      "        marker::PhantomData,",
      "        ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign},",
      "        str::FromStr,",
      "    };",
      "    /// 2^61 -1",
      "    pub type ModInt2305843009213693951 = StaticModInt<Mod2305843009213693951>;",
      "    /// 10^18 + 3",
      "    pub type ModInt1000000000000000003 = StaticModInt<Mod1000000000000000003>;",
      "    pub type ModInt1000000007 = StaticModInt<Mod1000000007>;",
      "    pub type ModInt998244353 = StaticModInt<Mod998244353>;",
      "    /// Represents \\$\\mathbb{Z}/m\\mathbb{Z}\\$ where \\$m\\$ is a constant value.",
      "    /// Corresponds to `atcoder::static_modint` in the original ACL.",
      "    /// # Example",
      "    /// ```",
      "    /// use ac_library::ModInt1000000007 as Mint;",
      "    /// use proconio::{input, source::once::OnceSource};",
      "    /// input! {",
      "    ///     from OnceSource::from(\"1000000006 2\\n\"),",
      "    ///     a: Mint,",
      "    ///     b: Mint,",
      "    /// }",
      "    /// println!(\"{}\", a + b); // `1`",
      "    /// ```",
      "    #[derive(Copy, Clone, Eq, PartialEq)]",
      "    #[repr(transparent)]",
      "    pub struct StaticModInt<M> {",
      "        val: u64,",
      "        phantom: PhantomData<fn() -> M>,",
      "    }",
      "    impl<M: Modulus> StaticModInt<M> {",
      "        /// Returns the modulus, which is [`<M as Modulus>::VALUE`].",
      "        /// Corresponds to `atcoder::static_modint::mod` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::ModInt1000000007 as Mint;",
      "        /// assert_eq!(1_000_000_007, Mint::modulus());",
      "        /// ```",
      "        /// [`<M as Modulus>::VALUE`]: ../trait.Modulus.html#associatedconstant.VALUE",
      "        #[inline(always)]",
      "        pub fn modulus() -> u64 {",
      "            M::VALUE",
      "        }",
      "        /// Creates a new `StaticModInt`.",
      "        /// Takes [any primitive integer].",
      "        /// Corresponds to the constructor of `atcoder::static_modint` in the original ACL.",
      "        /// [any primitive integer]:  ../trait.RemEuclidU32.html",
      "        #[inline]",
      "        pub fn new<T: RemEuclidU64>(val: T) -> Self {",
      "            Self::raw(val.rem_euclid_u64(M::VALUE))",
      "        }",
      "        /// Constructs a `StaticModInt` from a `val < Self::modulus()` without checking it.",
      "        /// Corresponds to `atcoder::static_modint::raw` in the original ACL.",
      "        /// # Constraints",
      "        /// - `val` is less than `Self::modulus()`",
      "        /// See [`ModIntBase::raw`] for more more details.",
      "        /// [`ModIntBase::raw`]: ./trait.ModIntBase.html#tymethod.raw",
      "        #[inline]",
      "        pub fn raw(val: u64) -> Self {",
      "            Self {",
      "                val,",
      "                phantom: PhantomData,",
      "            }",
      "        }",
      "        /// Retruns the representative.",
      "        /// Corresponds to `atcoder::static_modint::val` in the original ACL.",
      "        #[inline]",
      "        pub fn val(self) -> u64 {",
      "            self.val",
      "        }",
      "        /// Returns `self` to the power of `n`.",
      "        /// Corresponds to `atcoder::static_modint::pow` in the original ACL.",
      "        #[inline]",
      "        pub fn pow(self, n: u64) -> Self {",
      "            <Self as ModIntBase>::pow(self, n)",
      "        }",
      "        /// Retruns the multiplicative inverse of `self`.",
      "        /// Corresponds to `atcoder::static_modint::inv` in the original ACL.",
      "        /// # Panics",
      "        /// Panics if the multiplicative inverse does not exist.",
      "        #[inline]",
      "        pub fn inv(self) -> Self {",
      "            if self.val() == 0 {",
      "                panic!(\"attempt to divide by zero\");",
      "            }",
      "            self.pow(M::VALUE - 2)",
      "        }",
      "    }",
      "    /// These methods are implemented for the struct.",
      "    /// You don't need to `use` `ModIntBase` to call methods of `StaticModInt`.",
      "    impl<M: Modulus> ModIntBase for StaticModInt<M> {",
      "        #[inline(always)]",
      "        fn modulus() -> u64 {",
      "            Self::modulus()",
      "        }",
      "        #[inline]",
      "        fn raw(val: u64) -> Self {",
      "            Self::raw(val)",
      "        }",
      "        #[inline]",
      "        fn val(self) -> u64 {",
      "            self.val()",
      "        }",
      "        #[inline]",
      "        fn inv(self) -> Self {",
      "            self.inv()",
      "        }",
      "    }",
      "    /// Represents a modulus.",
      "    /// # Example",
      "    /// ```",
      "    /// macro_rules! modulus {",
      "    ///     (\\$(\\$name:ident(\\$value:expr, \\$is_prime:expr)),*) => {",
      "    ///         \\$(",
      "    ///             #[derive(Copy, Clone, Eq, PartialEq)]",
      "    ///             enum \\$name {}",
      "    ///             impl ac_library::modint::Modulus for \\$name {",
      "    ///                 const VALUE: u32 = \\$value;",
      "    ///                 const HINT_VALUE_IS_PRIME: bool = \\$is_prime;",
      "    ///                 fn butterfly_cache() -> &'static ::std::thread::LocalKey<::std::cell::RefCell<::std::option::Option<ac_library::modint::ButterflyCache<Self>>>> {",
      "    ///                     thread_local! {",
      "    ///                         static BUTTERFLY_CACHE: ::std::cell::RefCell<::std::option::Option<ac_library::modint::ButterflyCache<\\$name>>> = ::std::default::Default::default();",
      "    ///                     }",
      "    ///                     &BUTTERFLY_CACHE",
      "    ///                 }",
      "    ///             }",
      "    ///         )*",
      "    ///     };",
      "    /// }",
      "    /// use ac_library::StaticModInt;",
      "    /// modulus!(Mod101(101, true), Mod103(103, true));",
      "    /// type Z101 = StaticModInt<Mod101>;",
      "    /// type Z103 = StaticModInt<Mod103>;",
      "    /// assert_eq!(Z101::new(101), Z101::new(0));",
      "    /// assert_eq!(Z103::new(103), Z103::new(0));",
      "    /// ```",
      "    pub trait Modulus: 'static + Copy + Eq {",
      "        const VALUE: u64;",
      "        const HINT_VALUE_IS_PRIME: bool;",
      "    }",
      "    /// Represents \\$2^{61}-1 = 2305843009213693951\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod2305843009213693951 {}",
      "    impl Modulus for Mod2305843009213693951 {",
      "        const VALUE: u64 = 2_305_843_009_213_693_951;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// Represents \\$10^{18}+3 = 1000000000000000003\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod1000000000000000003 {}",
      "    impl Modulus for Mod1000000000000000003 {",
      "        const VALUE: u64 = 1_000_000_000_000_000_003;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// Represents \\$1000000007\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod1000000007 {}",
      "    impl Modulus for Mod1000000007 {",
      "        const VALUE: u64 = 1_000_000_007;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// Represents \\$998244353\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod998244353 {}",
      "    impl Modulus for Mod998244353 {",
      "        const VALUE: u64 = 998_244_353;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// A trait for [`StaticModInt`] and [`DynamicModInt`].",
      "    /// Corresponds to `atcoder::internal::modint_base` in the original ACL.",
      "    /// [`StaticModInt`]: ../struct.StaticModInt.html",
      "    /// [`DynamicModInt`]: ../struct.DynamicModInt.html",
      "    pub trait ModIntBase:",
      "        Default",
      "        + FromStr",
      "        + From<i8>",
      "        + From<i16>",
      "        + From<i32>",
      "        + From<i64>",
      "        + From<i128>",
      "        + From<isize>",
      "        + From<u8>",
      "        + From<u16>",
      "        + From<u32>",
      "        + From<u64>",
      "        + From<u128>",
      "        + From<usize>",
      "        + Copy",
      "        + Eq",
      "        + Hash",
      "        + fmt::Display",
      "        + fmt::Debug",
      "        + Neg<Output = Self>",
      "        + Add<Output = Self>",
      "        + Sub<Output = Self>",
      "        + Mul<Output = Self>",
      "        + Div<Output = Self>",
      "        + AddAssign",
      "        + SubAssign",
      "        + MulAssign",
      "        + DivAssign",
      "    {",
      "        /// Returns the modulus.",
      "        /// Corresponds to `atcoder::static_modint::mod` and `atcoder::dynamic_modint::mod` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() {",
      "        ///     let _: u32 = Z::modulus();",
      "        /// }",
      "        /// ```",
      "        fn modulus() -> u64;",
      "        /// Constructs a `Self` from a `val < Self::modulus()` without checking it.",
      "        /// Corresponds to `atcoder::static_modint::raw` and `atcoder::dynamic_modint::raw` in the original ACL.",
      "        /// # Constraints",
      "        /// - `val` is less than `Self::modulus()`",
      "        /// **Note that all operations assume that inner values are smaller than the modulus.**",
      "        /// If `val` is greater than or equal to `Self::modulus()`, the behaviors are not defined.",
      "        /// ```should_panic",
      "        /// use ac_library::ModInt1000000007 as Mint;",
      "        /// let x = Mint::raw(1_000_000_007);",
      "        /// let y = x + x;",
      "        /// assert_eq!(0, y.val());",
      "        /// ```",
      "        /// ```text",
      "        /// thread 'main' panicked at 'assertion failed: `(left == right)`",
      "        ///   left: `0`,",
      "        ///  right: `1000000007`', src/modint.rs:8:1",
      "        /// note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace",
      "        /// ```",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() -> Z {",
      "        ///     debug_assert!(Z::modulus() >= 100);",
      "        ///     let mut acc = Z::new(0);",
      "        ///     for i in 0..100 {",
      "        ///         if i % 3 == 0 {",
      "        ///             // I know `i` is smaller than the modulus!",
      "        ///             acc += Z::raw(i);",
      "        ///         }",
      "        ///     }",
      "        ///     acc",
      "        /// }",
      "        /// ```",
      "        fn raw(val: u64) -> Self;",
      "        /// Retruns the representative.",
      "        /// Corresponds to `atcoder::static_modint::val` and `atcoder::dynamic_modint::val` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>(x: Z) {",
      "        ///     let _: u32 = x.val();",
      "        /// }",
      "        /// ```",
      "        fn val(self) -> u64;",
      "        /// Retruns the multiplicative inverse of `self`.",
      "        /// Corresponds to `atcoder::static_modint::inv` and `atcoder::dynamic_modint::inv` in the original ACL.",
      "        /// # Panics",
      "        /// Panics if the multiplicative inverse does not exist.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>(x: Z) {",
      "        ///     let _: Z = x.inv();",
      "        /// }",
      "        /// ```",
      "        fn inv(self) -> Self;",
      "        /// Creates a new `Self`.",
      "        /// Takes [any primitive integer].",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() {",
      "        ///     let _ = Z::new(1u32);",
      "        ///     let _ = Z::new(1usize);",
      "        ///     let _ = Z::new(-1i64);",
      "        /// }",
      "        /// ```",
      "        /// [any primitive integer]:  ../trait.RemEuclidU32.html",
      "        #[inline]",
      "        fn new<T: RemEuclidU64>(val: T) -> Self {",
      "            Self::raw(val.rem_euclid_u64(Self::modulus()))",
      "        }",
      "        /// Returns `self` to the power of `n`.",
      "        /// Corresponds to `atcoder::static_modint::pow` and `atcoder::dynamic_modint::pow` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() {",
      "        ///     let _: Z = Z::new(2).pow(3);",
      "        /// }",
      "        /// ```",
      "        #[inline]",
      "        fn pow(self, mut n: u64) -> Self {",
      "            let mut x = self;",
      "            let mut r = Self::raw(1);",
      "            while n > 0 {",
      "                if n & 1 == 1 {",
      "                    r *= x;",
      "                }",
      "                x *= x;",
      "                n >>= 1;",
      "            }",
      "            r",
      "        }",
      "    }",
      "    /// A trait for `{StaticModInt, DynamicModInt, ModIntBase}::new`.",
      "    pub trait RemEuclidU64 {",
      "        /// Calculates `self` \\$\\bmod\\$ `modulus` losslessly.",
      "        fn rem_euclid_u64(self, modulus: u64) -> u64;",
      "    }",
      "    macro_rules ! impl_rem_euclid_u64_for_small_signed {(\\$ (\\$ ty : tt ) ,* ) => {\\$ (impl RemEuclidU64 for \\$ ty {# [inline ] fn rem_euclid_u64 (self , modulus : u64 ) -> u64 {(self as i128 ) . rem_euclid (i128 :: from (modulus ) ) as _ } } ) * } }",
      "    impl_rem_euclid_u64_for_small_signed!(i8, i16, i32, i64, isize);",
      "    impl RemEuclidU64 for i128 {",
      "        #[inline]",
      "        fn rem_euclid_u64(self, modulus: u64) -> u64 {",
      "            self.rem_euclid(i128::from(modulus)) as _",
      "        }",
      "    }",
      "    macro_rules ! impl_rem_euclid_u64_for_small_unsigned {(\\$ (\\$ ty : tt ) ,* ) => {\\$ (impl RemEuclidU64 for \\$ ty {# [inline ] fn rem_euclid_u64 (self , modulus : u64 ) -> u64 {self as u64 % modulus } } ) * } }",
      "    macro_rules ! impl_rem_euclid_u64_for_large_unsigned {(\\$ (\\$ ty : tt ) ,* ) => {\\$ (impl RemEuclidU64 for \\$ ty {# [inline ] fn rem_euclid_u64 (self , modulus : u64 ) -> u64 {(self % (modulus as \\$ ty ) ) as _ } } ) * } }",
      "    impl_rem_euclid_u64_for_small_unsigned!(u8, u16, u32, u64, usize);",
      "    impl_rem_euclid_u64_for_large_unsigned!(u128);",
      "    trait InternalImplementations: ModIntBase {",
      "        #[inline]",
      "        fn default_impl() -> Self {",
      "            Self::raw(0)",
      "        }",
      "        #[inline]",
      "        fn from_str_impl(s: &str) -> Result<Self, Infallible> {",
      "            Ok(s.parse::<i64>()",
      "                .map(Self::new)",
      "                .unwrap_or_else(|_| todo!(\"parsing as an arbitrary precision integer?\")))",
      "        }",
      "        #[inline]",
      "        fn hash_impl(this: &Self, state: &mut impl Hasher) {",
      "            this.val().hash(state)",
      "        }",
      "        #[inline]",
      "        fn display_impl(this: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "            fmt::Display::fmt(&this.val(), f)",
      "        }",
      "        #[inline]",
      "        fn debug_impl(this: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "            fmt::Debug::fmt(&this.val(), f)",
      "        }",
      "        #[inline]",
      "        fn neg_impl(this: Self) -> Self {",
      "            Self::sub_impl(Self::raw(0), this)",
      "        }",
      "        #[inline]",
      "        fn add_impl(lhs: Self, rhs: Self) -> Self {",
      "            let modulus = Self::modulus();",
      "            let mut val = lhs.val() + rhs.val();",
      "            if val >= modulus {",
      "                val -= modulus;",
      "            }",
      "            Self::raw(val)",
      "        }",
      "        #[inline]",
      "        fn sub_impl(lhs: Self, rhs: Self) -> Self {",
      "            let modulus = Self::modulus();",
      "            let mut val = lhs.val().wrapping_sub(rhs.val());",
      "            if val >= modulus {",
      "                val = val.wrapping_add(modulus)",
      "            }",
      "            Self::raw(val)",
      "        }",
      "        fn mul_impl(lhs: Self, rhs: Self) -> Self;",
      "        #[inline]",
      "        fn div_impl(lhs: Self, rhs: Self) -> Self {",
      "            Self::mul_impl(lhs, rhs.inv())",
      "        }",
      "    }",
      "    impl<M: Modulus> InternalImplementations for StaticModInt<M> {",
      "        #[inline]",
      "        fn mul_impl(lhs: Self, rhs: Self) -> Self {",
      "            Self::raw((u128::from(lhs.val()) * u128::from(rhs.val()) % u128::from(M::VALUE)) as u64)",
      "        }",
      "    }",
      "    macro_rules ! impl_basic_traits {() => {} ; (impl <\\$ generic_param : ident : \\$ generic_param_bound : tt > _ for \\$ self : ty ; \\$ (\\$ rest : tt ) * ) => {impl <\\$ generic_param : \\$ generic_param_bound > Default for \\$ self {# [inline ] fn default () -> Self {Self :: default_impl () } } impl <\\$ generic_param : \\$ generic_param_bound > FromStr for \\$ self {type Err = Infallible ; # [inline ] fn from_str (s : & str ) -> Result < Self , Infallible > {Self :: from_str_impl (s ) } } impl <\\$ generic_param : \\$ generic_param_bound , V : RemEuclidU64 > From < V > for \\$ self {# [inline ] fn from (from : V ) -> Self {Self :: new (from ) } } # [allow (clippy :: derived_hash_with_manual_eq ) ] impl <\\$ generic_param : \\$ generic_param_bound > Hash for \\$ self {# [inline ] fn hash < H : Hasher > (& self , state : & mut H ) {Self :: hash_impl (self , state ) } } impl <\\$ generic_param : \\$ generic_param_bound > fmt :: Display for \\$ self {# [inline ] fn fmt (& self , f : & mut fmt :: Formatter <'_ > ) -> fmt :: Result {Self :: display_impl (self , f ) } } impl <\\$ generic_param : \\$ generic_param_bound > fmt :: Debug for \\$ self {# [inline ] fn fmt (& self , f : & mut fmt :: Formatter <'_ > ) -> fmt :: Result {Self :: debug_impl (self , f ) } } impl <\\$ generic_param : \\$ generic_param_bound > Neg for \\$ self {type Output = \\$ self ; # [inline ] fn neg (self ) -> \\$ self {Self :: neg_impl (self ) } } impl <\\$ generic_param : \\$ generic_param_bound > Neg for &'_ \\$ self {type Output = \\$ self ; # [inline ] fn neg (self ) -> \\$ self {<\\$ self >:: neg_impl (* self ) } } impl_basic_traits ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    impl_basic_traits! {impl < M : Modulus > _ for StaticModInt < M > ; }",
      "    macro_rules ! impl_bin_ops {() => {} ; (for <\\$ (\\$ generic_param : ident : \\$ generic_param_bound : tt ) ,*> <\\$ lhs_ty : ty > ~ <\\$ rhs_ty : ty > -> \\$ output : ty {{\\$ lhs_body : expr_2021 } ~ {\\$ rhs_body : expr_2021 } } \\$ (\\$ rest : tt ) * ) => {impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Add <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn add (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: add_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Sub <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn sub (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: sub_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Mul <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn mul (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: mul_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Div <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn div (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: div_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl_bin_ops ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    macro_rules ! impl_assign_ops {() => {} ; (for <\\$ (\\$ generic_param : ident : \\$ generic_param_bound : tt ) ,*> <\\$ lhs_ty : ty > ~= <\\$ rhs_ty : ty > {_ ~= {\\$ rhs_body : expr_2021 } } \\$ (\\$ rest : tt ) * ) => {impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> AddAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn add_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self + apply (\\$ rhs_body , rhs ) ; } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> SubAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn sub_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self - apply (\\$ rhs_body , rhs ) ; } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> MulAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn mul_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self * apply (\\$ rhs_body , rhs ) ; } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> DivAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn div_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self / apply (\\$ rhs_body , rhs ) ; } } impl_assign_ops ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    #[inline]",
      "    fn apply<F: FnOnce(X) -> O, X, O>(f: F, x: X) -> O {",
      "        f(x)",
      "    }",
      "    impl_bin_ops! {for < M : Modulus > < StaticModInt < M > > ~ < StaticModInt < M > > -> StaticModInt < M > {{| x | x } ~ {| x | x } } for < M : Modulus > < StaticModInt < M > > ~ <&'_ StaticModInt < M > > -> StaticModInt < M > {{| x | x } ~ {|& x | x } } for < M : Modulus > <&'_ StaticModInt < M > > ~ < StaticModInt < M > > -> StaticModInt < M > {{|& x | x } ~ {| x | x } } for < M : Modulus > <&'_ StaticModInt < M > > ~ <&'_ StaticModInt < M > > -> StaticModInt < M > {{|& x | x } ~ {|& x | x } } for < M : Modulus , T : RemEuclidU64 > < StaticModInt < M > > ~ < T > -> StaticModInt < M > {{| x | x } ~ {StaticModInt ::< M >:: new } } }",
      "    impl_assign_ops! {for < M : Modulus > < StaticModInt < M > > ~= < StaticModInt < M > > {_ ~= {| x | x } } for < M : Modulus > < StaticModInt < M > > ~= <&'_ StaticModInt < M > > {_ ~= {|& x | x } } for < M : Modulus , T : RemEuclidU64 > < StaticModInt < M > > ~= < T > {_ ~= {StaticModInt ::< M >:: new } } }",
      "    macro_rules ! impl_folding {() => {} ; (impl <\\$ generic_param : ident : \\$ generic_param_bound : tt > \\$ trait : ident < _ > for \\$ self : ty {fn \\$ method : ident (_ ) -> _ {_ (\\$ unit : expr_2021 , \\$ op : expr_2021 ) } } \\$ (\\$ rest : tt ) * ) => {impl <\\$ generic_param : \\$ generic_param_bound > \\$ trait < Self > for \\$ self {# [inline ] fn \\$ method < S > (iter : S ) -> Self where S : Iterator < Item = Self >, {iter . fold (\\$ unit , \\$ op ) } } impl <'a , \\$ generic_param : \\$ generic_param_bound > \\$ trait <&'a Self > for \\$ self {# [inline ] fn \\$ method < S > (iter : S ) -> Self where S : Iterator < Item = &'a Self >, {iter . fold (\\$ unit , \\$ op ) } } impl_folding ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    impl_folding! {impl < M : Modulus > Sum < _ > for StaticModInt < M > {fn sum (_ ) -> _ {_ (Self :: raw (0 ) , Add :: add ) } } impl < M : Modulus > Product < _ > for StaticModInt < M > {fn product (_ ) -> _ {_ (Self :: raw (1 ) , Mul :: mul ) } } }",
      "}"
    ]
  },
  "monoid_affine": {
    "scope": "rust",
    "prefix": "monoid_affine",
    "body": [
      "use monoid_affine::*;",
      "pub mod monoid_affine {",
      "    use ac_library::Monoid;",
      "    use std::{",
      "        convert::Infallible,",
      "        marker::PhantomData,",
      "        ops::{Add, Mul},",
      "    };",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct AffineTransform<T> {",
      "        slope: T,",
      "        intercept: T,",
      "    }",
      "    impl<T> AffineTransform<T> {",
      "        pub fn new(slope: T, intercept: T) -> Self {",
      "            Self { slope, intercept }",
      "        }",
      "        pub fn apply(&self, x: T) -> T",
      "        where",
      "            T: Copy + Mul<Output = T> + Add<Output = T>,",
      "        {",
      "            self.slope * x + self.intercept",
      "        }",
      "        pub fn identity() -> Self",
      "        where",
      "            T: From<i64>,",
      "        {",
      "            Self {",
      "                slope: 1.into(),",
      "                intercept: 0.into(),",
      "            }",
      "        }",
      "        pub fn composite(&self, rhs: &Self) -> Self",
      "        where",
      "            T: Copy + Mul<Output = T> + Add<Output = T>,",
      "        {",
      "            Self {",
      "                slope: self.slope * rhs.slope,",
      "                intercept: self.slope * rhs.intercept + self.intercept,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct AffineComposition<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for AffineComposition<T>",
      "    where",
      "        T: Copy + From<i64> + Add<Output = T> + Mul<Output = T>,",
      "    {",
      "        type S = AffineTransform<T>;",
      "        fn identity() -> Self::S {",
      "            AffineTransform::identity()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            a.composite(b)",
      "        }",
      "    }",
      "}"
    ]
  },
  "monoid_dsu": {
    "scope": "rust",
    "prefix": "monoid_dsu",
    "body": [
      "use dsu_core::*;",
      "use monoid_dsu::*;",
      "#[allow(clippy::module_inception)]",
      "/// ac_library::Dsu の merge のみ実装を変えたもの",
      "pub mod dsu_core {",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    /// DSU 内の各要素の状態（親のインデックスまたは集合のサイズ）を保持する構造体。",
      "    /// メモリ効率（32ビット整数 1 つ分）を維持したまま、以下の 2 つの状態を表現します。",
      "    /// 1. **Root (根)**:",
      "    ///    - 値が負の場合、その要素は集合の代表元（リーダー）です。",
      "    ///    - 値の絶対値 `|v|` は、その集合に属する要素の数（サイズ）を表します。",
      "    ///    - 例: `-1` はサイズ 1 の集合の根、`-5` はサイズ 5 の集合の根。",
      "    /// 2. **Child (子)**:",
      "    ///    - 値が 0 以上の場合、その要素は他の要素を親に持っています。",
      "    ///    - 値 `v` は、親要素のインデックスを表します。",
      "    struct Node(i32);",
      "    impl Node {",
      "        fn root(size: usize) -> Self {",
      "            Self(-(size as i32))",
      "        }",
      "        fn child(parent: usize) -> Self {",
      "            Self(parent as i32)",
      "        }",
      "        fn is_root(&self) -> bool {",
      "            self.0 < 0",
      "        }",
      "        fn parent(&self) -> usize {",
      "            self.0 as usize",
      "        }",
      "        fn size(&self) -> usize {",
      "            (-self.0) as usize",
      "        }",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    pub struct DsuCore {",
      "        n: usize,",
      "        nodes: Vec<Node>,",
      "        cnt_groups: usize,",
      "    }",
      "    impl DsuCore {",
      "        pub fn new(size: usize) -> Self {",
      "            Self {",
      "                n: size,",
      "                nodes: vec![Node::root(1); size],",
      "                cnt_groups: size,",
      "            }",
      "        }",
      "        /// 2 つの要素 `a` と `b` が属する集合を統合する",
      "        /// # 戻り値",
      "        /// - `Some((leader, merged))`:",
      "        ///   - `leader` は統合後の集合の代表元（リーダー）",
      "        ///   - `merged` は統合されて消える側の旧代表元",
      "        /// - `None`:",
      "        ///   - `a` と `b` がすでに同じ集合に属していた場合",
      "        pub fn merge(&mut self, a: usize, b: usize) -> Option<(usize, usize)> {",
      "            assert!(a < self.n);",
      "            assert!(b < self.n);",
      "            let (mut x, mut y) = (self.leader(a), self.leader(b));",
      "            if x == y {",
      "                return None;",
      "            }",
      "            if self.nodes[x].size() < self.nodes[y].size() {",
      "                std::mem::swap(&mut x, &mut y);",
      "            }",
      "            let size_x = self.nodes[x].size();",
      "            let size_y = self.nodes[y].size();",
      "            self.nodes[x] = Node::root(size_x + size_y);",
      "            self.nodes[y] = Node::child(x);",
      "            self.cnt_groups -= 1;",
      "            Some((x, y))",
      "        }",
      "        pub fn same(&mut self, a: usize, b: usize) -> bool {",
      "            assert!(a < self.n);",
      "            assert!(b < self.n);",
      "            self.leader(a) == self.leader(b)",
      "        }",
      "        pub fn leader(&mut self, a: usize) -> usize {",
      "            assert!(a < self.n);",
      "            if self.nodes[a].is_root() {",
      "                return a;",
      "            }",
      "            let parent = self.nodes[a].parent();",
      "            let new_parent = self.leader(parent);",
      "            self.nodes[a] = Node::child(new_parent);",
      "            new_parent",
      "        }",
      "        pub fn size(&mut self, a: usize) -> usize {",
      "            assert!(a < self.n);",
      "            let x = self.leader(a);",
      "            self.nodes[x].size()",
      "        }",
      "        pub fn count_group(&self) -> usize {",
      "            self.cnt_groups",
      "        }",
      "        pub fn groups(&mut self) -> Vec<Vec<usize>> {",
      "            let mut leader_buf = vec![0; self.n];",
      "            let mut group_size = vec![0; self.n];",
      "            for i in 0..self.n {",
      "                leader_buf[i] = self.leader(i);",
      "                group_size[leader_buf[i]] += 1;",
      "            }",
      "            let mut result = vec![Vec::new(); self.n];",
      "            for i in 0..self.n {",
      "                result[i].reserve(group_size[i]);",
      "            }",
      "            for i in 0..self.n {",
      "                result[leader_buf[i]].push(i);",
      "            }",
      "            result",
      "                .into_iter()",
      "                .filter(|x| !x.is_empty())",
      "                .collect::<Vec<Vec<usize>>>()",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::module_inception)]",
      "pub mod monoid_dsu {",
      "    use super::DsuCore;",
      "    use ac_library::Monoid;",
      "    #[derive(Clone, Debug)]",
      "    pub struct MonoidDsu<M: Monoid> {",
      "        dsu: DsuCore,",
      "        prods: Vec<M::S>,",
      "    }",
      "    impl<M: Monoid> MonoidDsu<M> {",
      "        pub fn new(data: &[M::S]) -> MonoidDsu<M> {",
      "            let dsu = DsuCore::new(data.len());",
      "            MonoidDsu {",
      "                dsu,",
      "                prods: data.to_vec(),",
      "            }",
      "        }",
      "        pub fn merge(&mut self, a: usize, b: usize) -> Option<(usize, usize)> {",
      "            let merge_result = self.dsu.merge(a, b);",
      "            if let Some((leader, merged)) = merge_result {",
      "                self.prods[leader] = M::binary_operation(&self.prods[leader], &self.prods[merged]);",
      "                self.prods[merged] = M::identity();",
      "            }",
      "            merge_result",
      "        }",
      "        pub fn same(&mut self, a: usize, b: usize) -> bool {",
      "            self.dsu.same(a, b)",
      "        }",
      "        pub fn leader(&mut self, a: usize) -> usize {",
      "            self.dsu.leader(a)",
      "        }",
      "        pub fn size(&mut self, a: usize) -> usize {",
      "            self.dsu.size(a)",
      "        }",
      "        pub fn groups(&mut self) -> Vec<Vec<usize>> {",
      "            self.dsu.groups()",
      "        }",
      "        pub fn count_group(&self) -> usize {",
      "            self.dsu.count_group()",
      "        }",
      "        pub fn prod(&mut self, a: usize) -> M::S {",
      "            let leader = self.leader(a);",
      "            self.prods[leader].clone()",
      "        }",
      "        /// 指定された要素 `a` が属するグループの現在の積に対して、新しい値 `d` を二項演算で適用する。",
      "        /// この操作は、グループの積 `p` を `M::binary_operation(p, d)` で更新する。",
      "        /// # 例",
      "        /// `Additive` Monoid を使用している場合、グループの合計値に `d` を加算する。",
      "        /// `Max` Monoid を使用している場合、グループの最大値を `max(current_max, d)` で更新する。",
      "        pub fn apply(&mut self, a: usize, d: &M::S) {",
      "            let leader = self.leader(a);",
      "            self.prods[leader] = M::binary_operation(&self.prods[leader], d);",
      "        }",
      "        pub fn groups_with_prod(&mut self) -> Vec<(Vec<usize>, M::S)> {",
      "            self.groups()",
      "                .into_iter()",
      "                .map(|x| {",
      "                    let prod = self.prod(x[0]);",
      "                    (x, prod)",
      "                })",
      "                .collect()",
      "        }",
      "    }",
      "}"
    ]
  },
  "monoid_gcd_lcm": {
    "scope": "rust",
    "prefix": "monoid_gcd_lcm",
    "body": [
      "use monoid_gcd_lcm::*;",
      "pub mod monoid_gcd_lcm {",
      "    use ac_library::Monoid;",
      "    use num_integer::Integer;",
      "    use std::{convert::Infallible, marker::PhantomData};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct Gcd<S>(Infallible, PhantomData<fn() -> S>);",
      "    impl<S> Monoid for Gcd<S>",
      "    where",
      "        S: Integer + Clone,",
      "    {",
      "        type S = S;",
      "        fn identity() -> Self::S {",
      "            S::zero()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            a.gcd(b)",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct Lcm<S>(Infallible, PhantomData<fn() -> S>);",
      "    impl<S> Monoid for Lcm<S>",
      "    where",
      "        S: Integer + Clone,",
      "    {",
      "        type S = S;",
      "        fn identity() -> Self::S {",
      "            S::one()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            a.lcm(b)",
      "        }",
      "    }",
      "}"
    ]
  },
  "monoid_matrix_mul": {
    "scope": "rust",
    "prefix": "monoid_matrix_mul",
    "body": [
      "use dynamic_monoid::*;",
      "use monoid_matrix_mul::*;",
      "pub mod dynamic_monoid {",
      "    pub trait DynamicMonoid {",
      "        type S: Clone;",
      "        fn identity(&self) -> Self::S;",
      "        fn binary_operation(&self, a: &Self::S, b: &Self::S) -> Self::S;",
      "        /// base^n を求める",
      "        fn pow(&self, base: &Self::S, n: usize) -> Self::S {",
      "            let mut base = base.clone();",
      "            let mut ans = self.identity();",
      "            let mut n = n;",
      "            while n > 0 {",
      "                if n & 1 == 1 {",
      "                    ans = self.binary_operation(&ans, &base);",
      "                }",
      "                base = self.binary_operation(&base, &base);",
      "                n >>= 1;",
      "            }",
      "            ans",
      "        }",
      "    }",
      "}",
      "pub mod monoid_matrix_mul {",
      "    use super::dynamic_monoid::DynamicMonoid;",
      "    use itertools::Itertools;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct MatrixMul {",
      "        size: usize,",
      "    }",
      "    impl MatrixMul {",
      "        pub fn new(size: usize) -> Self {",
      "            Self { size }",
      "        }",
      "    }",
      "    impl DynamicMonoid for MatrixMul {",
      "        type S = Vec<Vec<i64>>;",
      "        fn identity(&self) -> Self::S {",
      "            (0..self.size)",
      "                .map(|y| {",
      "                    (0..self.size)",
      "                        .map(move |x| if x == y { 1 } else { 0 })",
      "                        .collect_vec()",
      "                })",
      "                .collect_vec()",
      "        }",
      "        fn binary_operation(&self, a: &Self::S, b: &Self::S) -> Self::S {",
      "            (0..self.size)",
      "                .map(|y| {",
      "                    (0..self.size)",
      "                        .map(move |x| (0..self.size).map(|k| a[y][k] * b[k][x]).sum())",
      "                        .collect_vec()",
      "                })",
      "                .collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "monoid_rolling_hash": {
    "scope": "rust",
    "prefix": "monoid_rolling_hash",
    "body": [
      "use modint_u64::*;",
      "use monoid_rolling_hash::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod modint_u64 {",
      "    use std::{",
      "        convert::Infallible,",
      "        fmt,",
      "        hash::{Hash, Hasher},",
      "        iter::{Product, Sum},",
      "        marker::PhantomData,",
      "        ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign},",
      "        str::FromStr,",
      "    };",
      "    /// 2^61 -1",
      "    pub type ModInt2305843009213693951 = StaticModInt<Mod2305843009213693951>;",
      "    /// 10^18 + 3",
      "    pub type ModInt1000000000000000003 = StaticModInt<Mod1000000000000000003>;",
      "    pub type ModInt1000000007 = StaticModInt<Mod1000000007>;",
      "    pub type ModInt998244353 = StaticModInt<Mod998244353>;",
      "    /// Represents \\$\\mathbb{Z}/m\\mathbb{Z}\\$ where \\$m\\$ is a constant value.",
      "    /// Corresponds to `atcoder::static_modint` in the original ACL.",
      "    /// # Example",
      "    /// ```",
      "    /// use ac_library::ModInt1000000007 as Mint;",
      "    /// use proconio::{input, source::once::OnceSource};",
      "    /// input! {",
      "    ///     from OnceSource::from(\"1000000006 2\\n\"),",
      "    ///     a: Mint,",
      "    ///     b: Mint,",
      "    /// }",
      "    /// println!(\"{}\", a + b); // `1`",
      "    /// ```",
      "    #[derive(Copy, Clone, Eq, PartialEq)]",
      "    #[repr(transparent)]",
      "    pub struct StaticModInt<M> {",
      "        val: u64,",
      "        phantom: PhantomData<fn() -> M>,",
      "    }",
      "    impl<M: Modulus> StaticModInt<M> {",
      "        /// Returns the modulus, which is [`<M as Modulus>::VALUE`].",
      "        /// Corresponds to `atcoder::static_modint::mod` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::ModInt1000000007 as Mint;",
      "        /// assert_eq!(1_000_000_007, Mint::modulus());",
      "        /// ```",
      "        /// [`<M as Modulus>::VALUE`]: ../trait.Modulus.html#associatedconstant.VALUE",
      "        #[inline(always)]",
      "        pub fn modulus() -> u64 {",
      "            M::VALUE",
      "        }",
      "        /// Creates a new `StaticModInt`.",
      "        /// Takes [any primitive integer].",
      "        /// Corresponds to the constructor of `atcoder::static_modint` in the original ACL.",
      "        /// [any primitive integer]:  ../trait.RemEuclidU32.html",
      "        #[inline]",
      "        pub fn new<T: RemEuclidU64>(val: T) -> Self {",
      "            Self::raw(val.rem_euclid_u64(M::VALUE))",
      "        }",
      "        /// Constructs a `StaticModInt` from a `val < Self::modulus()` without checking it.",
      "        /// Corresponds to `atcoder::static_modint::raw` in the original ACL.",
      "        /// # Constraints",
      "        /// - `val` is less than `Self::modulus()`",
      "        /// See [`ModIntBase::raw`] for more more details.",
      "        /// [`ModIntBase::raw`]: ./trait.ModIntBase.html#tymethod.raw",
      "        #[inline]",
      "        pub fn raw(val: u64) -> Self {",
      "            Self {",
      "                val,",
      "                phantom: PhantomData,",
      "            }",
      "        }",
      "        /// Retruns the representative.",
      "        /// Corresponds to `atcoder::static_modint::val` in the original ACL.",
      "        #[inline]",
      "        pub fn val(self) -> u64 {",
      "            self.val",
      "        }",
      "        /// Returns `self` to the power of `n`.",
      "        /// Corresponds to `atcoder::static_modint::pow` in the original ACL.",
      "        #[inline]",
      "        pub fn pow(self, n: u64) -> Self {",
      "            <Self as ModIntBase>::pow(self, n)",
      "        }",
      "        /// Retruns the multiplicative inverse of `self`.",
      "        /// Corresponds to `atcoder::static_modint::inv` in the original ACL.",
      "        /// # Panics",
      "        /// Panics if the multiplicative inverse does not exist.",
      "        #[inline]",
      "        pub fn inv(self) -> Self {",
      "            if self.val() == 0 {",
      "                panic!(\"attempt to divide by zero\");",
      "            }",
      "            self.pow(M::VALUE - 2)",
      "        }",
      "    }",
      "    /// These methods are implemented for the struct.",
      "    /// You don't need to `use` `ModIntBase` to call methods of `StaticModInt`.",
      "    impl<M: Modulus> ModIntBase for StaticModInt<M> {",
      "        #[inline(always)]",
      "        fn modulus() -> u64 {",
      "            Self::modulus()",
      "        }",
      "        #[inline]",
      "        fn raw(val: u64) -> Self {",
      "            Self::raw(val)",
      "        }",
      "        #[inline]",
      "        fn val(self) -> u64 {",
      "            self.val()",
      "        }",
      "        #[inline]",
      "        fn inv(self) -> Self {",
      "            self.inv()",
      "        }",
      "    }",
      "    /// Represents a modulus.",
      "    /// # Example",
      "    /// ```",
      "    /// macro_rules! modulus {",
      "    ///     (\\$(\\$name:ident(\\$value:expr, \\$is_prime:expr)),*) => {",
      "    ///         \\$(",
      "    ///             #[derive(Copy, Clone, Eq, PartialEq)]",
      "    ///             enum \\$name {}",
      "    ///             impl ac_library::modint::Modulus for \\$name {",
      "    ///                 const VALUE: u32 = \\$value;",
      "    ///                 const HINT_VALUE_IS_PRIME: bool = \\$is_prime;",
      "    ///                 fn butterfly_cache() -> &'static ::std::thread::LocalKey<::std::cell::RefCell<::std::option::Option<ac_library::modint::ButterflyCache<Self>>>> {",
      "    ///                     thread_local! {",
      "    ///                         static BUTTERFLY_CACHE: ::std::cell::RefCell<::std::option::Option<ac_library::modint::ButterflyCache<\\$name>>> = ::std::default::Default::default();",
      "    ///                     }",
      "    ///                     &BUTTERFLY_CACHE",
      "    ///                 }",
      "    ///             }",
      "    ///         )*",
      "    ///     };",
      "    /// }",
      "    /// use ac_library::StaticModInt;",
      "    /// modulus!(Mod101(101, true), Mod103(103, true));",
      "    /// type Z101 = StaticModInt<Mod101>;",
      "    /// type Z103 = StaticModInt<Mod103>;",
      "    /// assert_eq!(Z101::new(101), Z101::new(0));",
      "    /// assert_eq!(Z103::new(103), Z103::new(0));",
      "    /// ```",
      "    pub trait Modulus: 'static + Copy + Eq {",
      "        const VALUE: u64;",
      "        const HINT_VALUE_IS_PRIME: bool;",
      "    }",
      "    /// Represents \\$2^{61}-1 = 2305843009213693951\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod2305843009213693951 {}",
      "    impl Modulus for Mod2305843009213693951 {",
      "        const VALUE: u64 = 2_305_843_009_213_693_951;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// Represents \\$10^{18}+3 = 1000000000000000003\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod1000000000000000003 {}",
      "    impl Modulus for Mod1000000000000000003 {",
      "        const VALUE: u64 = 1_000_000_000_000_000_003;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// Represents \\$1000000007\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod1000000007 {}",
      "    impl Modulus for Mod1000000007 {",
      "        const VALUE: u64 = 1_000_000_007;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// Represents \\$998244353\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod998244353 {}",
      "    impl Modulus for Mod998244353 {",
      "        const VALUE: u64 = 998_244_353;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// A trait for [`StaticModInt`] and [`DynamicModInt`].",
      "    /// Corresponds to `atcoder::internal::modint_base` in the original ACL.",
      "    /// [`StaticModInt`]: ../struct.StaticModInt.html",
      "    /// [`DynamicModInt`]: ../struct.DynamicModInt.html",
      "    pub trait ModIntBase:",
      "        Default",
      "        + FromStr",
      "        + From<i8>",
      "        + From<i16>",
      "        + From<i32>",
      "        + From<i64>",
      "        + From<i128>",
      "        + From<isize>",
      "        + From<u8>",
      "        + From<u16>",
      "        + From<u32>",
      "        + From<u64>",
      "        + From<u128>",
      "        + From<usize>",
      "        + Copy",
      "        + Eq",
      "        + Hash",
      "        + fmt::Display",
      "        + fmt::Debug",
      "        + Neg<Output = Self>",
      "        + Add<Output = Self>",
      "        + Sub<Output = Self>",
      "        + Mul<Output = Self>",
      "        + Div<Output = Self>",
      "        + AddAssign",
      "        + SubAssign",
      "        + MulAssign",
      "        + DivAssign",
      "    {",
      "        /// Returns the modulus.",
      "        /// Corresponds to `atcoder::static_modint::mod` and `atcoder::dynamic_modint::mod` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() {",
      "        ///     let _: u32 = Z::modulus();",
      "        /// }",
      "        /// ```",
      "        fn modulus() -> u64;",
      "        /// Constructs a `Self` from a `val < Self::modulus()` without checking it.",
      "        /// Corresponds to `atcoder::static_modint::raw` and `atcoder::dynamic_modint::raw` in the original ACL.",
      "        /// # Constraints",
      "        /// - `val` is less than `Self::modulus()`",
      "        /// **Note that all operations assume that inner values are smaller than the modulus.**",
      "        /// If `val` is greater than or equal to `Self::modulus()`, the behaviors are not defined.",
      "        /// ```should_panic",
      "        /// use ac_library::ModInt1000000007 as Mint;",
      "        /// let x = Mint::raw(1_000_000_007);",
      "        /// let y = x + x;",
      "        /// assert_eq!(0, y.val());",
      "        /// ```",
      "        /// ```text",
      "        /// thread 'main' panicked at 'assertion failed: `(left == right)`",
      "        ///   left: `0`,",
      "        ///  right: `1000000007`', src/modint.rs:8:1",
      "        /// note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace",
      "        /// ```",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() -> Z {",
      "        ///     debug_assert!(Z::modulus() >= 100);",
      "        ///     let mut acc = Z::new(0);",
      "        ///     for i in 0..100 {",
      "        ///         if i % 3 == 0 {",
      "        ///             // I know `i` is smaller than the modulus!",
      "        ///             acc += Z::raw(i);",
      "        ///         }",
      "        ///     }",
      "        ///     acc",
      "        /// }",
      "        /// ```",
      "        fn raw(val: u64) -> Self;",
      "        /// Retruns the representative.",
      "        /// Corresponds to `atcoder::static_modint::val` and `atcoder::dynamic_modint::val` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>(x: Z) {",
      "        ///     let _: u32 = x.val();",
      "        /// }",
      "        /// ```",
      "        fn val(self) -> u64;",
      "        /// Retruns the multiplicative inverse of `self`.",
      "        /// Corresponds to `atcoder::static_modint::inv` and `atcoder::dynamic_modint::inv` in the original ACL.",
      "        /// # Panics",
      "        /// Panics if the multiplicative inverse does not exist.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>(x: Z) {",
      "        ///     let _: Z = x.inv();",
      "        /// }",
      "        /// ```",
      "        fn inv(self) -> Self;",
      "        /// Creates a new `Self`.",
      "        /// Takes [any primitive integer].",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() {",
      "        ///     let _ = Z::new(1u32);",
      "        ///     let _ = Z::new(1usize);",
      "        ///     let _ = Z::new(-1i64);",
      "        /// }",
      "        /// ```",
      "        /// [any primitive integer]:  ../trait.RemEuclidU32.html",
      "        #[inline]",
      "        fn new<T: RemEuclidU64>(val: T) -> Self {",
      "            Self::raw(val.rem_euclid_u64(Self::modulus()))",
      "        }",
      "        /// Returns `self` to the power of `n`.",
      "        /// Corresponds to `atcoder::static_modint::pow` and `atcoder::dynamic_modint::pow` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() {",
      "        ///     let _: Z = Z::new(2).pow(3);",
      "        /// }",
      "        /// ```",
      "        #[inline]",
      "        fn pow(self, mut n: u64) -> Self {",
      "            let mut x = self;",
      "            let mut r = Self::raw(1);",
      "            while n > 0 {",
      "                if n & 1 == 1 {",
      "                    r *= x;",
      "                }",
      "                x *= x;",
      "                n >>= 1;",
      "            }",
      "            r",
      "        }",
      "    }",
      "    /// A trait for `{StaticModInt, DynamicModInt, ModIntBase}::new`.",
      "    pub trait RemEuclidU64 {",
      "        /// Calculates `self` \\$\\bmod\\$ `modulus` losslessly.",
      "        fn rem_euclid_u64(self, modulus: u64) -> u64;",
      "    }",
      "    macro_rules ! impl_rem_euclid_u64_for_small_signed {(\\$ (\\$ ty : tt ) ,* ) => {\\$ (impl RemEuclidU64 for \\$ ty {# [inline ] fn rem_euclid_u64 (self , modulus : u64 ) -> u64 {(self as i128 ) . rem_euclid (i128 :: from (modulus ) ) as _ } } ) * } }",
      "    impl_rem_euclid_u64_for_small_signed!(i8, i16, i32, i64, isize);",
      "    impl RemEuclidU64 for i128 {",
      "        #[inline]",
      "        fn rem_euclid_u64(self, modulus: u64) -> u64 {",
      "            self.rem_euclid(i128::from(modulus)) as _",
      "        }",
      "    }",
      "    macro_rules ! impl_rem_euclid_u64_for_small_unsigned {(\\$ (\\$ ty : tt ) ,* ) => {\\$ (impl RemEuclidU64 for \\$ ty {# [inline ] fn rem_euclid_u64 (self , modulus : u64 ) -> u64 {self as u64 % modulus } } ) * } }",
      "    macro_rules ! impl_rem_euclid_u64_for_large_unsigned {(\\$ (\\$ ty : tt ) ,* ) => {\\$ (impl RemEuclidU64 for \\$ ty {# [inline ] fn rem_euclid_u64 (self , modulus : u64 ) -> u64 {(self % (modulus as \\$ ty ) ) as _ } } ) * } }",
      "    impl_rem_euclid_u64_for_small_unsigned!(u8, u16, u32, u64, usize);",
      "    impl_rem_euclid_u64_for_large_unsigned!(u128);",
      "    trait InternalImplementations: ModIntBase {",
      "        #[inline]",
      "        fn default_impl() -> Self {",
      "            Self::raw(0)",
      "        }",
      "        #[inline]",
      "        fn from_str_impl(s: &str) -> Result<Self, Infallible> {",
      "            Ok(s.parse::<i64>()",
      "                .map(Self::new)",
      "                .unwrap_or_else(|_| todo!(\"parsing as an arbitrary precision integer?\")))",
      "        }",
      "        #[inline]",
      "        fn hash_impl(this: &Self, state: &mut impl Hasher) {",
      "            this.val().hash(state)",
      "        }",
      "        #[inline]",
      "        fn display_impl(this: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "            fmt::Display::fmt(&this.val(), f)",
      "        }",
      "        #[inline]",
      "        fn debug_impl(this: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "            fmt::Debug::fmt(&this.val(), f)",
      "        }",
      "        #[inline]",
      "        fn neg_impl(this: Self) -> Self {",
      "            Self::sub_impl(Self::raw(0), this)",
      "        }",
      "        #[inline]",
      "        fn add_impl(lhs: Self, rhs: Self) -> Self {",
      "            let modulus = Self::modulus();",
      "            let mut val = lhs.val() + rhs.val();",
      "            if val >= modulus {",
      "                val -= modulus;",
      "            }",
      "            Self::raw(val)",
      "        }",
      "        #[inline]",
      "        fn sub_impl(lhs: Self, rhs: Self) -> Self {",
      "            let modulus = Self::modulus();",
      "            let mut val = lhs.val().wrapping_sub(rhs.val());",
      "            if val >= modulus {",
      "                val = val.wrapping_add(modulus)",
      "            }",
      "            Self::raw(val)",
      "        }",
      "        fn mul_impl(lhs: Self, rhs: Self) -> Self;",
      "        #[inline]",
      "        fn div_impl(lhs: Self, rhs: Self) -> Self {",
      "            Self::mul_impl(lhs, rhs.inv())",
      "        }",
      "    }",
      "    impl<M: Modulus> InternalImplementations for StaticModInt<M> {",
      "        #[inline]",
      "        fn mul_impl(lhs: Self, rhs: Self) -> Self {",
      "            Self::raw((u128::from(lhs.val()) * u128::from(rhs.val()) % u128::from(M::VALUE)) as u64)",
      "        }",
      "    }",
      "    macro_rules ! impl_basic_traits {() => {} ; (impl <\\$ generic_param : ident : \\$ generic_param_bound : tt > _ for \\$ self : ty ; \\$ (\\$ rest : tt ) * ) => {impl <\\$ generic_param : \\$ generic_param_bound > Default for \\$ self {# [inline ] fn default () -> Self {Self :: default_impl () } } impl <\\$ generic_param : \\$ generic_param_bound > FromStr for \\$ self {type Err = Infallible ; # [inline ] fn from_str (s : & str ) -> Result < Self , Infallible > {Self :: from_str_impl (s ) } } impl <\\$ generic_param : \\$ generic_param_bound , V : RemEuclidU64 > From < V > for \\$ self {# [inline ] fn from (from : V ) -> Self {Self :: new (from ) } } # [allow (clippy :: derived_hash_with_manual_eq ) ] impl <\\$ generic_param : \\$ generic_param_bound > Hash for \\$ self {# [inline ] fn hash < H : Hasher > (& self , state : & mut H ) {Self :: hash_impl (self , state ) } } impl <\\$ generic_param : \\$ generic_param_bound > fmt :: Display for \\$ self {# [inline ] fn fmt (& self , f : & mut fmt :: Formatter <'_ > ) -> fmt :: Result {Self :: display_impl (self , f ) } } impl <\\$ generic_param : \\$ generic_param_bound > fmt :: Debug for \\$ self {# [inline ] fn fmt (& self , f : & mut fmt :: Formatter <'_ > ) -> fmt :: Result {Self :: debug_impl (self , f ) } } impl <\\$ generic_param : \\$ generic_param_bound > Neg for \\$ self {type Output = \\$ self ; # [inline ] fn neg (self ) -> \\$ self {Self :: neg_impl (self ) } } impl <\\$ generic_param : \\$ generic_param_bound > Neg for &'_ \\$ self {type Output = \\$ self ; # [inline ] fn neg (self ) -> \\$ self {<\\$ self >:: neg_impl (* self ) } } impl_basic_traits ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    impl_basic_traits! {impl < M : Modulus > _ for StaticModInt < M > ; }",
      "    macro_rules ! impl_bin_ops {() => {} ; (for <\\$ (\\$ generic_param : ident : \\$ generic_param_bound : tt ) ,*> <\\$ lhs_ty : ty > ~ <\\$ rhs_ty : ty > -> \\$ output : ty {{\\$ lhs_body : expr_2021 } ~ {\\$ rhs_body : expr_2021 } } \\$ (\\$ rest : tt ) * ) => {impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Add <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn add (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: add_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Sub <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn sub (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: sub_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Mul <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn mul (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: mul_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Div <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn div (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: div_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl_bin_ops ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    macro_rules ! impl_assign_ops {() => {} ; (for <\\$ (\\$ generic_param : ident : \\$ generic_param_bound : tt ) ,*> <\\$ lhs_ty : ty > ~= <\\$ rhs_ty : ty > {_ ~= {\\$ rhs_body : expr_2021 } } \\$ (\\$ rest : tt ) * ) => {impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> AddAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn add_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self + apply (\\$ rhs_body , rhs ) ; } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> SubAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn sub_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self - apply (\\$ rhs_body , rhs ) ; } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> MulAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn mul_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self * apply (\\$ rhs_body , rhs ) ; } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> DivAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn div_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self / apply (\\$ rhs_body , rhs ) ; } } impl_assign_ops ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    #[inline]",
      "    fn apply<F: FnOnce(X) -> O, X, O>(f: F, x: X) -> O {",
      "        f(x)",
      "    }",
      "    impl_bin_ops! {for < M : Modulus > < StaticModInt < M > > ~ < StaticModInt < M > > -> StaticModInt < M > {{| x | x } ~ {| x | x } } for < M : Modulus > < StaticModInt < M > > ~ <&'_ StaticModInt < M > > -> StaticModInt < M > {{| x | x } ~ {|& x | x } } for < M : Modulus > <&'_ StaticModInt < M > > ~ < StaticModInt < M > > -> StaticModInt < M > {{|& x | x } ~ {| x | x } } for < M : Modulus > <&'_ StaticModInt < M > > ~ <&'_ StaticModInt < M > > -> StaticModInt < M > {{|& x | x } ~ {|& x | x } } for < M : Modulus , T : RemEuclidU64 > < StaticModInt < M > > ~ < T > -> StaticModInt < M > {{| x | x } ~ {StaticModInt ::< M >:: new } } }",
      "    impl_assign_ops! {for < M : Modulus > < StaticModInt < M > > ~= < StaticModInt < M > > {_ ~= {| x | x } } for < M : Modulus > < StaticModInt < M > > ~= <&'_ StaticModInt < M > > {_ ~= {|& x | x } } for < M : Modulus , T : RemEuclidU64 > < StaticModInt < M > > ~= < T > {_ ~= {StaticModInt ::< M >:: new } } }",
      "    macro_rules ! impl_folding {() => {} ; (impl <\\$ generic_param : ident : \\$ generic_param_bound : tt > \\$ trait : ident < _ > for \\$ self : ty {fn \\$ method : ident (_ ) -> _ {_ (\\$ unit : expr_2021 , \\$ op : expr_2021 ) } } \\$ (\\$ rest : tt ) * ) => {impl <\\$ generic_param : \\$ generic_param_bound > \\$ trait < Self > for \\$ self {# [inline ] fn \\$ method < S > (iter : S ) -> Self where S : Iterator < Item = Self >, {iter . fold (\\$ unit , \\$ op ) } } impl <'a , \\$ generic_param : \\$ generic_param_bound > \\$ trait <&'a Self > for \\$ self {# [inline ] fn \\$ method < S > (iter : S ) -> Self where S : Iterator < Item = &'a Self >, {iter . fold (\\$ unit , \\$ op ) } } impl_folding ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    impl_folding! {impl < M : Modulus > Sum < _ > for StaticModInt < M > {fn sum (_ ) -> _ {_ (Self :: raw (0 ) , Add :: add ) } } impl < M : Modulus > Product < _ > for StaticModInt < M > {fn product (_ ) -> _ {_ (Self :: raw (1 ) , Mul :: mul ) } } }",
      "}",
      "pub mod monoid_rolling_hash {",
      "    use ac_library::Monoid;",
      "    use std::convert::Infallible;",
      "    type Mint = super::ModInt2305843009213693951;",
      "    pub fn generate_random_base() -> i64 {",
      "        use rand::{rngs::SmallRng, Rng, SeedableRng};",
      "        let mut rng = SmallRng::from_os_rng();",
      "        rng.random_range(2..Mint::modulus() as i64)",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct RollingHash {",
      "        hash: Mint,",
      "        base: Mint,",
      "    }",
      "    impl RollingHash {",
      "        /// 文字列のハッシュ値を取得します。",
      "        pub fn get_hash(&self) -> u64 {",
      "            self.hash.val()",
      "        }",
      "        /// 単一の要素から RollingHash を生成する関数を返します。",
      "        /// `base` は `generate_random_base()` で生成された乱数をすることが想定されています。",
      "        /// # Examples",
      "        /// ```",
      "        /// use mylib::string::rolling_hash::monoid_rolling_hash::*;",
      "        /// let base = generate_random_base();",
      "        /// let char_to_rh = RollingHash::unit(base);",
      "        /// let rh_a = char_to_rh('a' as i64);",
      "        /// ```",
      "        pub fn unit(base: i64) -> impl Fn(i64) -> RollingHash {",
      "            move |x| RollingHash {",
      "                hash: Mint::new(x),",
      "                base: Mint::new(base),",
      "            }",
      "        }",
      "        /// 指定されたハッシュ値とベース値で新しい `RollingHash` を構築します。",
      "        /// `hash` は要素のハッシュ値、`base` はハッシュ計算に使用するベース値です。",
      "        /// 通常は`unit`関数を使用することが推奨されます。",
      "        pub fn new(hash: i64, base: i64) -> Self {",
      "            Self {",
      "                hash: Mint::new(hash),",
      "                base: Mint::new(base),",
      "            }",
      "        }",
      "        /// 空の文字列のハッシュ値を返します",
      "        pub fn identity() -> Self {",
      "            RollingHash {",
      "                hash: Mint::new(0),",
      "                base: Mint::new(1),",
      "            }",
      "        }",
      "        /// `self` の後に `other` が続く文字列の `RollingHash` を連結します。",
      "        pub fn concat(&self, other: &RollingHash) -> RollingHash {",
      "            RollingHash {",
      "                hash: self.hash * other.base + other.hash,",
      "                base: self.base * other.base,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RollingHashConcat(Infallible);",
      "    impl Monoid for RollingHashConcat {",
      "        type S = RollingHash;",
      "        fn identity() -> Self::S {",
      "            RollingHash::identity()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            RollingHash::concat(a, b)",
      "        }",
      "    }",
      "}"
    ]
  },
  "monoid_template": {
    "scope": "rust",
    "prefix": "monoid_template",
    "body": [
      "use monoid_template::*;",
      "#[allow(unused_variables)]",
      "pub mod monoid_template {",
      "    use ac_library::segtree::Monoid;",
      "    use std::convert::Infallible;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct RangeXxx {",
      "        pub len: usize,",
      "    }",
      "    impl RangeXxx {",
      "        pub fn unit(x: i64) -> Self {",
      "            Self { len: 1 }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeXxxMonoid(Infallible);",
      "    impl Monoid for RangeXxxMonoid {",
      "        type S = RangeXxx;",
      "        fn identity() -> Self::S {",
      "            RangeXxx { len: 0 }",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            RangeXxx { len: a.len + b.len }",
      "        }",
      "    }",
      "}"
    ]
  },
  "monoid_transform": {
    "scope": "rust",
    "prefix": "monoid_transform",
    "body": [
      "use dynamic_monoid::*;",
      "use monoid_transform::*;",
      "pub mod dynamic_monoid {",
      "    pub trait DynamicMonoid {",
      "        type S: Clone;",
      "        fn identity(&self) -> Self::S;",
      "        fn binary_operation(&self, a: &Self::S, b: &Self::S) -> Self::S;",
      "        /// base^n を求める",
      "        fn pow(&self, base: &Self::S, n: usize) -> Self::S {",
      "            let mut base = base.clone();",
      "            let mut ans = self.identity();",
      "            let mut n = n;",
      "            while n > 0 {",
      "                if n & 1 == 1 {",
      "                    ans = self.binary_operation(&ans, &base);",
      "                }",
      "                base = self.binary_operation(&base, &base);",
      "                n >>= 1;",
      "            }",
      "            ans",
      "        }",
      "    }",
      "}",
      "pub mod monoid_transform {",
      "    use super::dynamic_monoid::DynamicMonoid;",
      "    use itertools::Itertools;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct Transform {",
      "        n: usize,",
      "    }",
      "    impl Transform {",
      "        pub fn new(n: usize) -> Self {",
      "            Self { n }",
      "        }",
      "    }",
      "    impl DynamicMonoid for Transform {",
      "        type S = Vec<usize>;",
      "        fn identity(&self) -> Self::S {",
      "            (0..self.n).collect_vec()",
      "        }",
      "        fn binary_operation(&self, a: &Self::S, b: &Self::S) -> Self::S {",
      "            (0..self.n).map(|i| a[b[i]]).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "monoid_union_find": {
    "scope": "rust",
    "prefix": "monoid_union_find",
    "body": [
      "use monoid_union_find::*;",
      "#[allow(clippy::module_inception)]",
      "/// 可換モノイドをのっけた Union Find",
      "pub mod monoid_union_find {",
      "    use ac_library::Monoid;",
      "    use itertools::Itertools;",
      "    #[derive(Clone, Debug)]",
      "    struct RootInfo<S: Clone> {",
      "        count: usize,",
      "        prod: S,",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    struct NonRootInfo {",
      "        parent: usize,",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    enum Node<S: Clone> {",
      "        Root(RootInfo<S>),",
      "        NonRoot(NonRootInfo),",
      "    }",
      "    impl<S: Clone> Node<S> {",
      "        fn root(count: usize, prod: S) -> Node<S> {",
      "            Node::Root(RootInfo { count, prod })",
      "        }",
      "        fn non_root(parent: usize) -> Node<S> {",
      "            Node::NonRoot(NonRootInfo { parent })",
      "        }",
      "        fn as_root(&self) -> &RootInfo<S> {",
      "            match self {",
      "                Node::Root(info) => info,",
      "                Node::NonRoot(_) => panic!(),",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    pub struct MonoidUnionFind<M: Monoid> {",
      "        nodes: Vec<Node<M::S>>,",
      "        cnt_groups: usize,",
      "    }",
      "    impl<M: Monoid> MonoidUnionFind<M> {",
      "        pub fn new(data: &[M::S]) -> MonoidUnionFind<M> {",
      "            let nodes = data.iter().map(|d| Node::root(1, d.clone())).collect_vec();",
      "            MonoidUnionFind {",
      "                nodes,",
      "                cnt_groups: data.len(),",
      "            }",
      "        }",
      "        pub fn root(&mut self, index: usize) -> usize {",
      "            match &self.nodes[index] {",
      "                Node::Root(_) => index,",
      "                Node::NonRoot(info) => {",
      "                    let root = self.root(info.parent);",
      "                    self.nodes[index] = Node::non_root(root);",
      "                    root",
      "                }",
      "            }",
      "        }",
      "        pub fn same_count(&mut self, index: usize) -> usize {",
      "            let root_index = self.root(index);",
      "            self.nodes[root_index].as_root().count",
      "        }",
      "        pub fn same_prod(&mut self, index: usize) -> M::S {",
      "            let root_index = self.root(index);",
      "            self.nodes[root_index].as_root().prod.clone()",
      "        }",
      "        pub fn same_prod_ref(&mut self, index: usize) -> &M::S {",
      "            let root_index = self.root(index);",
      "            &self.nodes[root_index].as_root().prod",
      "        }",
      "        pub fn same(&mut self, x: usize, y: usize) -> bool {",
      "            self.root(x) == self.root(y)",
      "        }",
      "        pub fn num_groups(&self) -> usize {",
      "            self.cnt_groups",
      "        }",
      "        pub fn unite(&mut self, x: usize, y: usize) -> bool {",
      "            if self.same(x, y) {",
      "                return false;",
      "            }",
      "            self.cnt_groups -= 1;",
      "            let (smaller_root, larger_root) = {",
      "                let x_root = self.root(x);",
      "                let y_root = self.root(y);",
      "                let x_count = self.nodes[x_root].as_root().count;",
      "                let y_count = self.nodes[y_root].as_root().count;",
      "                if x_count < y_count {",
      "                    (x_root, y_root)",
      "                } else {",
      "                    (y_root, x_root)",
      "                }",
      "            };",
      "            let smaller_root_info = self.nodes[smaller_root].as_root();",
      "            let larger_root_info = self.nodes[larger_root].as_root();",
      "            let count = smaller_root_info.count + larger_root_info.count;",
      "            let prod = M::binary_operation(&smaller_root_info.prod, &larger_root_info.prod);",
      "            self.nodes[smaller_root] = Node::non_root(larger_root);",
      "            self.nodes[larger_root] = Node::root(count, prod);",
      "            true",
      "        }",
      "        pub fn groups(&mut self) -> Vec<Vec<usize>> {",
      "            let n = self.nodes.len();",
      "            let roots = (0..n).map(|i| self.root(i)).collect_vec();",
      "            let group_size = (0..n).map(|i| roots[i]).fold(vec![0; n], |mut acc, x| {",
      "                acc[x] += 1;",
      "                acc",
      "            });",
      "            let result = {",
      "                let mut result = vec![Vec::new(); n];",
      "                for i in 0..n {",
      "                    result[i].reserve(group_size[i]);",
      "                }",
      "                for i in 0..n {",
      "                    result[roots[i]].push(i);",
      "                }",
      "                result",
      "            };",
      "            result.into_iter().filter(|x| !x.is_empty()).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "offset_vec": {
    "scope": "rust",
    "prefix": "offset_vec",
    "body": [
      "use offset_vec::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod offset_vec {",
      "    use std::ops::{",
      "        Index, IndexMut, Range, RangeFrom, RangeFull, RangeInclusive, RangeTo, RangeToInclusive,",
      "    };",
      "    /// [begin, end) の範囲の添字を許容する Vec。",
      "    /// 負の添字も使用可能。",
      "    #[derive(Debug, Clone, PartialEq, Eq, Hash)]",
      "    pub struct OffsetVec<T> {",
      "        data: Vec<T>,",
      "        begin: i64,",
      "        end: i64,",
      "    }",
      "    impl<T> OffsetVec<T> {",
      "        /// 指定された範囲 [begin, end) で初期化する。",
      "        pub fn new(begin: i64, end: i64, default: T) -> Self",
      "        where",
      "            T: Clone,",
      "        {",
      "            assert!(begin <= end);",
      "            let size = (end - begin) as usize;",
      "            Self {",
      "                data: vec![default; size],",
      "                begin,",
      "                end,",
      "            }",
      "        }",
      "        /// 指定された開始位置とデータで初期化する。",
      "        pub fn from_vec(begin: i64, data: Vec<T>) -> Self {",
      "            let end = begin + data.len() as i64;",
      "            Self { data, begin, end }",
      "        }",
      "        pub fn begin(&self) -> i64 {",
      "            self.begin",
      "        }",
      "        pub fn end(&self) -> i64 {",
      "            self.end",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.data.len()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.data.is_empty()",
      "        }",
      "        pub fn iter(&self) -> std::slice::Iter<'_, T> {",
      "            self.data.iter()",
      "        }",
      "        pub fn iter_mut(&mut self) -> std::slice::IterMut<'_, T> {",
      "            self.data.iter_mut()",
      "        }",
      "        pub fn as_slice(&self) -> &[T] {",
      "            &self.data",
      "        }",
      "        pub fn as_mut_slice(&mut self) -> &mut [T] {",
      "            &mut self.data",
      "        }",
      "        pub fn iter_with_index(&self) -> impl Iterator<Item = (i64, &T)> {",
      "            let begin = self.begin;",
      "            self.data",
      "                .iter()",
      "                .enumerate()",
      "                .map(move |(i, v)| (begin + i as i64, v))",
      "        }",
      "        pub fn is_within(&self, index: i64) -> bool {",
      "            self.begin <= index && index < self.end",
      "        }",
      "        fn check_range(&self, index: i64) {",
      "            assert!(",
      "                self.is_within(index),",
      "                \"the range is [{}, {}) but the index is {}\",",
      "                self.begin,",
      "                self.end,",
      "                index",
      "            );",
      "        }",
      "        fn to_raw_index(&self, index: i64) -> usize {",
      "            (index - self.begin) as usize",
      "        }",
      "    }",
      "    impl<T> Index<i64> for OffsetVec<T> {",
      "        type Output = T;",
      "        fn index(&self, index: i64) -> &Self::Output {",
      "            self.check_range(index);",
      "            &self.data[self.to_raw_index(index)]",
      "        }",
      "    }",
      "    impl<T> IndexMut<i64> for OffsetVec<T> {",
      "        fn index_mut(&mut self, index: i64) -> &mut Self::Output {",
      "            self.check_range(index);",
      "            let raw_index = self.to_raw_index(index);",
      "            &mut self.data[raw_index]",
      "        }",
      "    }",
      "    impl<T> Index<Range<i64>> for OffsetVec<T> {",
      "        type Output = [T];",
      "        fn index(&self, range: Range<i64>) -> &Self::Output {",
      "            &self.data[self.to_raw_index(range.start)..self.to_raw_index(range.end)]",
      "        }",
      "    }",
      "    impl<T> IndexMut<Range<i64>> for OffsetVec<T> {",
      "        fn index_mut(&mut self, range: Range<i64>) -> &mut Self::Output {",
      "            let s = self.to_raw_index(range.start);",
      "            let e = self.to_raw_index(range.end);",
      "            &mut self.data[s..e]",
      "        }",
      "    }",
      "    impl<T> Index<RangeInclusive<i64>> for OffsetVec<T> {",
      "        type Output = [T];",
      "        fn index(&self, range: RangeInclusive<i64>) -> &Self::Output {",
      "            &self.data[self.to_raw_index(*range.start())..=self.to_raw_index(*range.end())]",
      "        }",
      "    }",
      "    impl<T> IndexMut<RangeInclusive<i64>> for OffsetVec<T> {",
      "        fn index_mut(&mut self, range: RangeInclusive<i64>) -> &mut Self::Output {",
      "            let s = self.to_raw_index(*range.start());",
      "            let e = self.to_raw_index(*range.end());",
      "            &mut self.data[s..=e]",
      "        }",
      "    }",
      "    impl<T> Index<RangeFrom<i64>> for OffsetVec<T> {",
      "        type Output = [T];",
      "        fn index(&self, range: RangeFrom<i64>) -> &Self::Output {",
      "            &self.data[self.to_raw_index(range.start)..]",
      "        }",
      "    }",
      "    impl<T> IndexMut<RangeFrom<i64>> for OffsetVec<T> {",
      "        fn index_mut(&mut self, range: RangeFrom<i64>) -> &mut Self::Output {",
      "            let s = self.to_raw_index(range.start);",
      "            &mut self.data[s..]",
      "        }",
      "    }",
      "    impl<T> Index<RangeTo<i64>> for OffsetVec<T> {",
      "        type Output = [T];",
      "        fn index(&self, range: RangeTo<i64>) -> &Self::Output {",
      "            &self.data[..self.to_raw_index(range.end)]",
      "        }",
      "    }",
      "    impl<T> IndexMut<RangeTo<i64>> for OffsetVec<T> {",
      "        fn index_mut(&mut self, range: RangeTo<i64>) -> &mut Self::Output {",
      "            let e = self.to_raw_index(range.end);",
      "            &mut self.data[..e]",
      "        }",
      "    }",
      "    impl<T> Index<RangeToInclusive<i64>> for OffsetVec<T> {",
      "        type Output = [T];",
      "        fn index(&self, range: RangeToInclusive<i64>) -> &Self::Output {",
      "            &self.data[..=self.to_raw_index(range.end)]",
      "        }",
      "    }",
      "    impl<T> IndexMut<RangeToInclusive<i64>> for OffsetVec<T> {",
      "        fn index_mut(&mut self, range: RangeToInclusive<i64>) -> &mut Self::Output {",
      "            let e = self.to_raw_index(range.end);",
      "            &mut self.data[..=e]",
      "        }",
      "    }",
      "    impl<T> Index<RangeFull> for OffsetVec<T> {",
      "        type Output = [T];",
      "        fn index(&self, _: RangeFull) -> &Self::Output {",
      "            &self.data[..]",
      "        }",
      "    }",
      "    impl<T> IndexMut<RangeFull> for OffsetVec<T> {",
      "        fn index_mut(&mut self, _: RangeFull) -> &mut Self::Output {",
      "            &mut self.data[..]",
      "        }",
      "    }",
      "}"
    ]
  },
  "pos": {
    "scope": "rust",
    "prefix": "pos",
    "body": [
      "use pos::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod pos {",
      "    use std::io::BufRead;",
      "    use std::iter::Sum;",
      "    use std::ops::{Add, AddAssign, Mul, MulAssign, Neg, Sub, SubAssign};",
      "    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]",
      "    pub struct Pos {",
      "        pub x: i64,",
      "        pub y: i64,",
      "    }",
      "    impl Pos {",
      "        pub fn new(x: i64, y: i64) -> Pos {",
      "            Pos { x, y }",
      "        }",
      "        pub fn scalar_mul(self, rhs: i64) -> Pos {",
      "            Pos::new(self.x * rhs, self.y * rhs)",
      "        }",
      "        pub fn inner_product(self, rhs: Self) -> i64 {",
      "            self.x * rhs.x + self.y * rhs.y",
      "        }",
      "        pub fn outer_product(self, rhs: Self) -> i64 {",
      "            self.x * rhs.y - self.y * rhs.x",
      "        }",
      "        pub fn norm_square(self) -> i64 {",
      "            self.inner_product(self)",
      "        }",
      "        pub fn l1_norm(self) -> i64 {",
      "            self.x.abs() + self.y.abs()",
      "        }",
      "        pub fn linf_norm(self) -> i64 {",
      "            self.x.abs().max(self.y.abs())",
      "        }",
      "        pub fn dist_square(self, rhs: Self) -> i64 {",
      "            (self - rhs).norm_square()",
      "        }",
      "        pub fn l1_dist(self, rhs: Self) -> i64 {",
      "            (self - rhs).l1_norm()",
      "        }",
      "        pub fn linf_dist(self, rhs: Self) -> i64 {",
      "            (self - rhs).linf_norm()",
      "        }",
      "        pub fn normalize(self) -> Pos {",
      "            if self.x == 0 && self.y == 0 {",
      "                return self;",
      "            }",
      "            let g = num::integer::gcd(self.x.abs(), self.y.abs());",
      "            Pos::new(self.x / g, self.y / g)",
      "        }",
      "        pub fn rotate90(self) -> Pos {",
      "            Pos::new(-self.y, self.x)",
      "        }",
      "        pub fn rotate270(self) -> Pos {",
      "            Pos::new(self.y, -self.x)",
      "        }",
      "        /// グリッドの幅 `width` を指定して、座標 `(x, y)` を 1次元インデックス `y * width + x` に変換する。",
      "        pub fn to_index_1d(self, width: usize) -> usize {",
      "            assert!(",
      "                self.x >= 0 && self.y >= 0,",
      "                \"Pos::to_index_1d: x と y は 0 以上である必要があります。pos: ({}, {})\",",
      "                self.x,",
      "                self.y",
      "            );",
      "            assert!(",
      "                (self.x as usize) < width,",
      "                \"Pos::to_index_1d: x は width 未満である必要があります。x: {}, width: {}\",",
      "                self.x,",
      "                width",
      "            );",
      "            (self.y as usize) * width + (self.x as usize)",
      "        }",
      "        /// 1次元インデックスとグリッドの幅 `width` から、座標 `(x, y)` を復元する。",
      "        pub fn from_index_1d(index: usize, width: usize) -> Pos {",
      "            Pos::new((index % width) as i64, (index / width) as i64)",
      "        }",
      "        pub fn around4_pos_iter(self) -> impl Iterator<Item = Pos> {",
      "            DIR4_LIST.iter().copied().map(move |d| self + d)",
      "        }",
      "        pub fn around8_pos_iter(self) -> impl Iterator<Item = Pos> {",
      "            DIR8_LIST.iter().copied().map(move |d| self + d)",
      "        }",
      "    }",
      "    impl Add for Pos {",
      "        type Output = Pos;",
      "        fn add(self, rhs: Self) -> Self::Output {",
      "            Pos::new(self.x + rhs.x, self.y + rhs.y)",
      "        }",
      "    }",
      "    impl Sub for Pos {",
      "        type Output = Pos;",
      "        fn sub(self, rhs: Self) -> Self::Output {",
      "            Pos::new(self.x - rhs.x, self.y - rhs.y)",
      "        }",
      "    }",
      "    impl Neg for Pos {",
      "        type Output = Self;",
      "        fn neg(self) -> Self::Output {",
      "            Pos::new(-self.x, -self.y)",
      "        }",
      "    }",
      "    impl Sum for Pos {",
      "        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {",
      "            iter.fold(Pos::new(0, 0), |acc, x| acc + x)",
      "        }",
      "    }",
      "    impl<'a> Sum<&'a Pos> for Pos {",
      "        fn sum<I: Iterator<Item = &'a Self>>(iter: I) -> Self {",
      "            iter.fold(Pos::new(0, 0), |a, b| a + *b)",
      "        }",
      "    }",
      "    impl num_traits::Zero for Pos {",
      "        fn zero() -> Self {",
      "            Pos::new(0, 0)",
      "        }",
      "        fn is_zero(&self) -> bool {",
      "            self.x.is_zero() && self.y.is_zero()",
      "        }",
      "    }",
      "    impl AddAssign for Pos {",
      "        fn add_assign(&mut self, rhs: Self) {",
      "            *self = *self + rhs",
      "        }",
      "    }",
      "    impl SubAssign for Pos {",
      "        fn sub_assign(&mut self, rhs: Self) {",
      "            *self = *self - rhs",
      "        }",
      "    }",
      "    impl Mul<i64> for Pos {",
      "        type Output = Pos;",
      "        fn mul(self, rhs: i64) -> Self::Output {",
      "            Pos::new(self.x * rhs, self.y * rhs)",
      "        }",
      "    }",
      "    impl MulAssign<i64> for Pos {",
      "        fn mul_assign(&mut self, rhs: i64) {",
      "            *self = *self * rhs",
      "        }",
      "    }",
      "    use std::fmt::{Debug, Error, Formatter};",
      "    impl Debug for Pos {",
      "        fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {",
      "            f.write_fmt(format_args!(\"({}, {})\", self.x, self.y))?;",
      "            Ok(())",
      "        }",
      "    }",
      "    use proconio::source::{Readable, Source};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub enum PosXY {}",
      "    impl Readable for PosXY {",
      "        type Output = Pos;",
      "        fn read<R: BufRead, S: Source<R>>(source: &mut S) -> Pos {",
      "            let x = i64::read(source);",
      "            let y = i64::read(source);",
      "            Pos::new(x, y)",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub enum PosYX {}",
      "    impl Readable for PosYX {",
      "        type Output = Pos;",
      "        fn read<R: BufRead, S: Source<R>>(source: &mut S) -> Pos {",
      "            let y = i64::read(source);",
      "            let x = i64::read(source);",
      "            Pos::new(x, y)",
      "        }",
      "    }",
      "    /// 1-indexed で与えられた座標(YX)",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub enum PosYX1 {}",
      "    impl Readable for PosYX1 {",
      "        type Output = Pos;",
      "        fn read<R: BufRead, S: Source<R>>(source: &mut S) -> Pos {",
      "            let y = i64::read(source) - 1;",
      "            let x = i64::read(source) - 1;",
      "            Pos::new(x, y)",
      "        }",
      "    }",
      "    pub const DIR8_LIST: [Pos; 8] = [",
      "        Pos { x: 0, y: 1 },",
      "        Pos { x: 1, y: 1 },",
      "        Pos { x: 1, y: 0 },",
      "        Pos { x: 1, y: -1 },",
      "        Pos { x: 0, y: -1 },",
      "        Pos { x: -1, y: -1 },",
      "        Pos { x: -1, y: 0 },",
      "        Pos { x: -1, y: 1 },",
      "    ];",
      "    pub const DIR4_LIST: [Pos; 4] = [",
      "        Pos { x: 0, y: 1 },",
      "        Pos { x: 1, y: 0 },",
      "        Pos { x: 0, y: -1 },",
      "        Pos { x: -1, y: 0 },",
      "    ];",
      "}"
    ]
  },
  "pos3d": {
    "scope": "rust",
    "prefix": "pos3d",
    "body": [
      "use pos3d::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod pos3d {",
      "    use std::io::BufRead;",
      "    use std::iter::Sum;",
      "    use std::ops::{Add, AddAssign, Mul, MulAssign, Neg, Sub, SubAssign};",
      "    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]",
      "    pub struct Pos3d {",
      "        pub x: i64,",
      "        pub y: i64,",
      "        pub z: i64,",
      "    }",
      "    impl Pos3d {",
      "        pub fn new(x: i64, y: i64, z: i64) -> Pos3d {",
      "            Pos3d { x, y, z }",
      "        }",
      "        pub fn scalar_mul(self, rhs: i64) -> Pos3d {",
      "            Pos3d::new(self.x * rhs, self.y * rhs, self.z * rhs)",
      "        }",
      "        pub fn inner_product(self, rhs: Self) -> i64 {",
      "            self.x * rhs.x + self.y * rhs.y + self.z * rhs.z",
      "        }",
      "        pub fn outer_product(self, rhs: Self) -> Pos3d {",
      "            Pos3d::new(",
      "                self.y * rhs.z - self.z * rhs.y,",
      "                self.z * rhs.x - self.x * rhs.z,",
      "                self.x * rhs.y - self.y * rhs.x,",
      "            )",
      "        }",
      "        pub fn norm_square(self) -> i64 {",
      "            self.inner_product(self)",
      "        }",
      "        pub fn l1_norm(self) -> i64 {",
      "            self.x.abs() + self.y.abs() + self.z.abs()",
      "        }",
      "        pub fn linf_norm(self) -> i64 {",
      "            self.x.abs().max(self.y.abs()).max(self.z.abs())",
      "        }",
      "        pub fn dist_square(self, rhs: Self) -> i64 {",
      "            (self - rhs).norm_square()",
      "        }",
      "        pub fn l1_dist(self, rhs: Self) -> i64 {",
      "            (self - rhs).l1_norm()",
      "        }",
      "        pub fn linf_dist(self, rhs: Self) -> i64 {",
      "            (self - rhs).linf_norm()",
      "        }",
      "        pub fn normalize(self) -> Pos3d {",
      "            if self.x == 0 && self.y == 0 && self.z == 0 {",
      "                return self;",
      "            }",
      "            let g = num::integer::gcd(self.x.abs(), num::integer::gcd(self.y.abs(), self.z.abs()));",
      "            Pos3d::new(self.x / g, self.y / g, self.z / g)",
      "        }",
      "        /// グリッドの幅 `width` と高さ `height` を指定して、座標 `(x, y, z)` を 1次元インデックス `z * (width * height) + y * width + x` に変換する。",
      "        pub fn to_index_1d(self, width: usize, height: usize) -> usize {",
      "            assert!(",
      "                self.x >= 0 && self.y >= 0 && self.z >= 0,",
      "                \"Pos3d::to_index_1d: x, y, z は 0 以上である必要があります。pos: ({}, {}, {})\",",
      "                self.x,",
      "                self.y,",
      "                self.z",
      "            );",
      "            assert!(",
      "                (self.x as usize) < width,",
      "                \"Pos3d::to_index_1d: x は width 未満である必要があります。x: {}, width: {}\",",
      "                self.x,",
      "                width",
      "            );",
      "            assert!(",
      "                (self.y as usize) < height,",
      "                \"Pos3d::to_index_1d: y は height 未満である必要があります。y: {}, height: {}\",",
      "                self.y,",
      "                height",
      "            );",
      "            (self.z as usize) * width * height + (self.y as usize) * width + (self.x as usize)",
      "        }",
      "        /// 1次元インデックスとグリッドの幅 `width`, 高さ `height` から、座標 `(x, y, z)` を復元する。",
      "        pub fn from_index_1d(index: usize, width: usize, height: usize) -> Pos3d {",
      "            let z = index / (width * height);",
      "            let rem = index % (width * height);",
      "            let y = rem / width;",
      "            let x = rem % width;",
      "            Pos3d::new(x as i64, y as i64, z as i64)",
      "        }",
      "        pub fn around6_pos_iter(self) -> impl Iterator<Item = Pos3d> {",
      "            DIR6_LIST.iter().copied().map(move |d| self + d)",
      "        }",
      "        pub fn around26_pos_iter(self) -> impl Iterator<Item = Pos3d> {",
      "            DIR26_LIST.iter().copied().map(move |d| self + d)",
      "        }",
      "    }",
      "    impl Add for Pos3d {",
      "        type Output = Pos3d;",
      "        fn add(self, rhs: Self) -> Self::Output {",
      "            Pos3d::new(self.x + rhs.x, self.y + rhs.y, self.z + rhs.z)",
      "        }",
      "    }",
      "    impl Sub for Pos3d {",
      "        type Output = Pos3d;",
      "        fn sub(self, rhs: Self) -> Self::Output {",
      "            Pos3d::new(self.x - rhs.x, self.y - rhs.y, self.z - rhs.z)",
      "        }",
      "    }",
      "    impl Neg for Pos3d {",
      "        type Output = Self;",
      "        fn neg(self) -> Self::Output {",
      "            Pos3d::new(-self.x, -self.y, -self.z)",
      "        }",
      "    }",
      "    impl Sum for Pos3d {",
      "        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {",
      "            iter.fold(Pos3d::new(0, 0, 0), |acc, x| acc + x)",
      "        }",
      "    }",
      "    impl<'a> Sum<&'a Pos3d> for Pos3d {",
      "        fn sum<I: Iterator<Item = &'a Self>>(iter: I) -> Self {",
      "            iter.fold(Pos3d::new(0, 0, 0), |a, b| a + *b)",
      "        }",
      "    }",
      "    impl num_traits::Zero for Pos3d {",
      "        fn zero() -> Self {",
      "            Pos3d::new(0, 0, 0)",
      "        }",
      "        fn is_zero(&self) -> bool {",
      "            self.x.is_zero() && self.y.is_zero() && self.z.is_zero()",
      "        }",
      "    }",
      "    impl AddAssign for Pos3d {",
      "        fn add_assign(&mut self, rhs: Self) {",
      "            *self = *self + rhs",
      "        }",
      "    }",
      "    impl SubAssign for Pos3d {",
      "        fn sub_assign(&mut self, rhs: Self) {",
      "            *self = *self - rhs",
      "        }",
      "    }",
      "    impl Mul<i64> for Pos3d {",
      "        type Output = Pos3d;",
      "        fn mul(self, rhs: i64) -> Self::Output {",
      "            self.scalar_mul(rhs)",
      "        }",
      "    }",
      "    impl MulAssign<i64> for Pos3d {",
      "        fn mul_assign(&mut self, rhs: i64) {",
      "            *self = *self * rhs",
      "        }",
      "    }",
      "    use std::fmt::{Debug, Error, Formatter};",
      "    impl Debug for Pos3d {",
      "        fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {",
      "            f.write_fmt(format_args!(\"({}, {}, {})\", self.x, self.y, self.z))?;",
      "            Ok(())",
      "        }",
      "    }",
      "    use proconio::source::{Readable, Source};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub enum PosXYZ {}",
      "    impl Readable for PosXYZ {",
      "        type Output = Pos3d;",
      "        fn read<R: BufRead, S: Source<R>>(source: &mut S) -> Pos3d {",
      "            let x = i64::read(source);",
      "            let y = i64::read(source);",
      "            let z = i64::read(source);",
      "            Pos3d::new(x, y, z)",
      "        }",
      "    }",
      "    pub const DIR6_LIST: [Pos3d; 6] = [",
      "        Pos3d { x: 1, y: 0, z: 0 },",
      "        Pos3d { x: -1, y: 0, z: 0 },",
      "        Pos3d { x: 0, y: 1, z: 0 },",
      "        Pos3d { x: 0, y: -1, z: 0 },",
      "        Pos3d { x: 0, y: 0, z: 1 },",
      "        Pos3d { x: 0, y: 0, z: -1 },",
      "    ];",
      "    # [rustfmt :: skip ] pub const DIR26_LIST : [Pos3d ; 26 ] = [Pos3d {x : 1 , y : 0 , z : 0 } , Pos3d {x : - 1 , y : 0 , z : 0 } , Pos3d {x : 0 , y : 1 , z : 0 } , Pos3d {x : 0 , y : - 1 , z : 0 } , Pos3d {x : 0 , y : 0 , z : 1 } , Pos3d {x : 0 , y : 0 , z : - 1 } , Pos3d {x : 1 , y : 1 , z : 0 } , Pos3d {x : 1 , y : - 1 , z : 0 } , Pos3d {x : - 1 , y : 1 , z : 0 } , Pos3d {x : - 1 , y : - 1 , z : 0 } , Pos3d {x : 1 , y : 0 , z : 1 } , Pos3d {x : 1 , y : 0 , z : - 1 } , Pos3d {x : - 1 , y : 0 , z : 1 } , Pos3d {x : - 1 , y : 0 , z : - 1 } , Pos3d {x : 0 , y : 1 , z : 1 } , Pos3d {x : 0 , y : 1 , z : - 1 } , Pos3d {x : 0 , y : - 1 , z : 1 } , Pos3d {x : 0 , y : - 1 , z : - 1 } , Pos3d {x : 1 , y : 1 , z : 1 } , Pos3d {x : 1 , y : 1 , z : - 1 } , Pos3d {x : 1 , y : - 1 , z : 1 } , Pos3d {x : 1 , y : - 1 , z : - 1 } , Pos3d {x : - 1 , y : 1 , z : 1 } , Pos3d {x : - 1 , y : 1 , z : - 1 } , Pos3d {x : - 1 , y : - 1 , z : 1 } , Pos3d {x : - 1 , y : - 1 , z : - 1 } , ] ;",
      "}"
    ]
  },
  "pos3d_f64": {
    "scope": "rust",
    "prefix": "pos3d_f64",
    "body": [
      "use pos3d_f64::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod pos3d_f64 {",
      "    use std::iter::Sum;",
      "    use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign};",
      "    #[derive(Clone, Copy, PartialEq, PartialOrd)]",
      "    pub struct Pos3dF64 {",
      "        pub x: f64,",
      "        pub y: f64,",
      "        pub z: f64,",
      "    }",
      "    impl Pos3dF64 {",
      "        pub fn new(x: f64, y: f64, z: f64) -> Pos3dF64 {",
      "            Pos3dF64 { x, y, z }",
      "        }",
      "        pub fn scalar_mul(self, rhs: f64) -> Pos3dF64 {",
      "            self * rhs",
      "        }",
      "        pub fn inner_product(self, rhs: Self) -> f64 {",
      "            self.x * rhs.x + self.y * rhs.y + self.z * rhs.z",
      "        }",
      "        pub fn outer_product(self, rhs: Self) -> Pos3dF64 {",
      "            Pos3dF64::new(",
      "                self.y * rhs.z - self.z * rhs.y,",
      "                self.z * rhs.x - self.x * rhs.z,",
      "                self.x * rhs.y - self.y * rhs.x,",
      "            )",
      "        }",
      "        pub fn norm_square(self) -> f64 {",
      "            self.inner_product(self)",
      "        }",
      "        pub fn norm(self) -> f64 {",
      "            self.norm_square().sqrt()",
      "        }",
      "        pub fn dist(self, rhs: Self) -> f64 {",
      "            (self - rhs).norm()",
      "        }",
      "        pub fn dist_square(self, rhs: Self) -> f64 {",
      "            (self - rhs).norm_square()",
      "        }",
      "        pub fn normalize(self) -> Pos3dF64 {",
      "            self / self.norm()",
      "        }",
      "    }",
      "    impl Add for Pos3dF64 {",
      "        type Output = Pos3dF64;",
      "        fn add(self, rhs: Self) -> Self::Output {",
      "            Pos3dF64::new(self.x + rhs.x, self.y + rhs.y, self.z + rhs.z)",
      "        }",
      "    }",
      "    impl Sub for Pos3dF64 {",
      "        type Output = Pos3dF64;",
      "        fn sub(self, rhs: Self) -> Self::Output {",
      "            Pos3dF64::new(self.x - rhs.x, self.y - rhs.y, self.z - rhs.z)",
      "        }",
      "    }",
      "    impl Neg for Pos3dF64 {",
      "        type Output = Self;",
      "        fn neg(self) -> Self::Output {",
      "            Pos3dF64::new(-self.x, -self.y, -self.z)",
      "        }",
      "    }",
      "    impl Sum for Pos3dF64 {",
      "        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {",
      "            iter.fold(Pos3dF64::new(0.0, 0.0, 0.0), |acc, x| acc + x)",
      "        }",
      "    }",
      "    impl<'a> Sum<&'a Pos3dF64> for Pos3dF64 {",
      "        fn sum<I: Iterator<Item = &'a Self>>(iter: I) -> Self {",
      "            iter.fold(Pos3dF64::new(0.0, 0.0, 0.0), |a, b| a + *b)",
      "        }",
      "    }",
      "    impl num_traits::Zero for Pos3dF64 {",
      "        fn zero() -> Self {",
      "            Pos3dF64::new(0.0, 0.0, 0.0)",
      "        }",
      "        fn is_zero(&self) -> bool {",
      "            self.x.is_zero() && self.y.is_zero() && self.z.is_zero()",
      "        }",
      "    }",
      "    impl AddAssign for Pos3dF64 {",
      "        fn add_assign(&mut self, rhs: Self) {",
      "            *self = *self + rhs",
      "        }",
      "    }",
      "    impl SubAssign for Pos3dF64 {",
      "        fn sub_assign(&mut self, rhs: Self) {",
      "            *self = *self - rhs",
      "        }",
      "    }",
      "    impl Mul<f64> for Pos3dF64 {",
      "        type Output = Pos3dF64;",
      "        fn mul(self, rhs: f64) -> Self::Output {",
      "            Pos3dF64::new(self.x * rhs, self.y * rhs, self.z * rhs)",
      "        }",
      "    }",
      "    impl MulAssign<f64> for Pos3dF64 {",
      "        fn mul_assign(&mut self, rhs: f64) {",
      "            *self = *self * rhs;",
      "        }",
      "    }",
      "    impl Div<f64> for Pos3dF64 {",
      "        type Output = Pos3dF64;",
      "        fn div(self, rhs: f64) -> Self::Output {",
      "            Pos3dF64::new(self.x / rhs, self.y / rhs, self.z / rhs)",
      "        }",
      "    }",
      "    impl DivAssign<f64> for Pos3dF64 {",
      "        fn div_assign(&mut self, rhs: f64) {",
      "            *self = *self / rhs;",
      "        }",
      "    }",
      "    use std::fmt::{Debug, Error, Formatter};",
      "    impl Debug for Pos3dF64 {",
      "        fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {",
      "            f.write_fmt(format_args!(\"({}, {}, {})\", self.x, self.y, self.z))?;",
      "            Ok(())",
      "        }",
      "    }",
      "    use proconio::source::{Readable, Source};",
      "    use std::io::BufRead;",
      "    impl Readable for Pos3dF64 {",
      "        type Output = Pos3dF64;",
      "        fn read<R: BufRead, S: Source<R>>(source: &mut S) -> Pos3dF64 {",
      "            let x = f64::read(source);",
      "            let y = f64::read(source);",
      "            let z = f64::read(source);",
      "            Pos3dF64::new(x, y, z)",
      "        }",
      "    }",
      "}"
    ]
  },
  "pos3d_ix": {
    "scope": "rust",
    "prefix": "pos3d_ix",
    "body": [
      "use pos3d_ix::*;",
      "pub mod pos3d_ix {",
      "    use super::pos3d::Pos3d;",
      "    use super::Ix;",
      "    impl Ix for Pos3d {",
      "        fn range((min, max): (Self, Self)) -> impl Iterator<Item = Self> {",
      "            (min.z..=max.z).flat_map(move |z| {",
      "                (min.y..=max.y).flat_map(move |y| (min.x..=max.x).map(move |x| Pos3d::new(x, y, z)))",
      "            })",
      "        }",
      "        fn range_size((min, max): (Self, Self)) -> usize {",
      "            if min.x > max.x || min.y > max.y || min.z > max.z {",
      "                0",
      "            } else {",
      "                ((max.x - min.x + 1) * (max.y - min.y + 1) * (max.z - min.z + 1)) as usize",
      "            }",
      "        }",
      "        fn to_index((min, max): (Self, Self), i: Self) -> usize {",
      "            if !Self::in_range((min, max), i) {",
      "                panic!(\"index out of bounds: {:?} is not in {:?}\", i, (min, max));",
      "            }",
      "            let width = (max.x - min.x + 1) as usize;",
      "            let height = (max.y - min.y + 1) as usize;",
      "            let dz = (i.z - min.z) as usize;",
      "            let dy = (i.y - min.y) as usize;",
      "            let dx = (i.x - min.x) as usize;",
      "            dz * (width * height) + dy * width + dx",
      "        }",
      "        fn from_index((min, max): (Self, Self), index: usize) -> Self {",
      "            if index >= Self::range_size((min, max)) {",
      "                panic!(\"index out of range: {} for bounds {:?}\", index, (min, max));",
      "            }",
      "            let width = (max.x - min.x + 1) as usize;",
      "            let height = (max.y - min.y + 1) as usize;",
      "            let dz = (index / (width * height)) as i64;",
      "            let rem = index % (width * height);",
      "            let dy = (rem / width) as i64;",
      "            let dx = (rem % width) as i64;",
      "            Pos3d::new(min.x + dx, min.y + dy, min.z + dz)",
      "        }",
      "        fn in_range((min, max): (Self, Self), i: Self) -> bool {",
      "            min.x <= i.x",
      "                && i.x <= max.x",
      "                && min.y <= i.y",
      "                && i.y <= max.y",
      "                && min.z <= i.z",
      "                && i.z <= max.z",
      "        }",
      "    }",
      "}"
    ]
  },
  "pos_ab_group": {
    "scope": "rust",
    "prefix": "pos_ab_group",
    "body": [
      "use pos_ab_group::*;",
      "pub mod pos_ab_group {",
      "    use super::pos::Pos;",
      "    use super::AbGroup;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct PosAbGroup;",
      "    impl AbGroup for PosAbGroup {",
      "        type S = Pos;",
      "        fn zero() -> Self::S {",
      "            Pos::new(0, 0)",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a + *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            -(*a)",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a - *b",
      "        }",
      "    }",
      "}"
    ]
  },
  "pos_f64": {
    "scope": "rust",
    "prefix": "pos_f64",
    "body": [
      "use pos_f64::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod pos_f64 {",
      "    use std::iter::Sum;",
      "    use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign};",
      "    #[derive(Clone, Copy, PartialEq, PartialOrd)]",
      "    pub struct PosF64 {",
      "        pub x: f64,",
      "        pub y: f64,",
      "    }",
      "    impl PosF64 {",
      "        pub fn new(x: f64, y: f64) -> PosF64 {",
      "            PosF64 { x, y }",
      "        }",
      "        pub fn scalar_mul(self, rhs: f64) -> PosF64 {",
      "            self * rhs",
      "        }",
      "        pub fn inner_product(self, rhs: Self) -> f64 {",
      "            self.x * rhs.x + self.y * rhs.y",
      "        }",
      "        pub fn outer_product(self, rhs: Self) -> f64 {",
      "            self.x * rhs.y - self.y * rhs.x",
      "        }",
      "        pub fn norm_square(self) -> f64 {",
      "            self.inner_product(self)",
      "        }",
      "        pub fn norm(self) -> f64 {",
      "            self.norm_square().sqrt()",
      "        }",
      "        pub fn dist(self, rhs: Self) -> f64 {",
      "            (self - rhs).norm()",
      "        }",
      "        pub fn dist_square(self, rhs: Self) -> f64 {",
      "            (self - rhs).norm_square()",
      "        }",
      "        pub fn rotate(self, theta: f64) -> PosF64 {",
      "            let (s, c) = theta.sin_cos();",
      "            PosF64::new(self.x * c - self.y * s, self.x * s + self.y * c)",
      "        }",
      "        pub fn normalize(self) -> PosF64 {",
      "            self / self.norm()",
      "        }",
      "    }",
      "    impl Add for PosF64 {",
      "        type Output = PosF64;",
      "        fn add(self, rhs: Self) -> Self::Output {",
      "            PosF64::new(self.x + rhs.x, self.y + rhs.y)",
      "        }",
      "    }",
      "    impl Sub for PosF64 {",
      "        type Output = PosF64;",
      "        fn sub(self, rhs: Self) -> Self::Output {",
      "            PosF64::new(self.x - rhs.x, self.y - rhs.y)",
      "        }",
      "    }",
      "    impl Neg for PosF64 {",
      "        type Output = Self;",
      "        fn neg(self) -> Self::Output {",
      "            PosF64::new(-self.x, -self.y)",
      "        }",
      "    }",
      "    impl Sum for PosF64 {",
      "        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {",
      "            iter.fold(PosF64::new(0.0, 0.0), |acc, x| acc + x)",
      "        }",
      "    }",
      "    impl<'a> Sum<&'a PosF64> for PosF64 {",
      "        fn sum<I: Iterator<Item = &'a Self>>(iter: I) -> Self {",
      "            iter.fold(PosF64::new(0.0, 0.0), |a, b| a + *b)",
      "        }",
      "    }",
      "    impl num_traits::Zero for PosF64 {",
      "        fn zero() -> Self {",
      "            PosF64::new(0.0, 0.0)",
      "        }",
      "        fn is_zero(&self) -> bool {",
      "            self.x.is_zero() && self.y.is_zero()",
      "        }",
      "    }",
      "    impl AddAssign for PosF64 {",
      "        fn add_assign(&mut self, rhs: Self) {",
      "            *self = *self + rhs",
      "        }",
      "    }",
      "    impl SubAssign for PosF64 {",
      "        fn sub_assign(&mut self, rhs: Self) {",
      "            *self = *self - rhs",
      "        }",
      "    }",
      "    impl Mul<f64> for PosF64 {",
      "        type Output = PosF64;",
      "        fn mul(self, rhs: f64) -> Self::Output {",
      "            PosF64::new(self.x * rhs, self.y * rhs)",
      "        }",
      "    }",
      "    impl MulAssign<f64> for PosF64 {",
      "        fn mul_assign(&mut self, rhs: f64) {",
      "            *self = *self * rhs;",
      "        }",
      "    }",
      "    impl Div<f64> for PosF64 {",
      "        type Output = PosF64;",
      "        fn div(self, rhs: f64) -> Self::Output {",
      "            PosF64::new(self.x / rhs, self.y / rhs)",
      "        }",
      "    }",
      "    impl DivAssign<f64> for PosF64 {",
      "        fn div_assign(&mut self, rhs: f64) {",
      "            *self = *self / rhs;",
      "        }",
      "    }",
      "    use std::fmt::{Debug, Error, Formatter};",
      "    impl Debug for PosF64 {",
      "        fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {",
      "            f.write_fmt(format_args!(\"({}, {})\", self.x, self.y))?;",
      "            Ok(())",
      "        }",
      "    }",
      "    use proconio::source::{Readable, Source};",
      "    use std::io::BufRead;",
      "    impl Readable for PosF64 {",
      "        type Output = PosF64;",
      "        fn read<R: BufRead, S: Source<R>>(source: &mut S) -> PosF64 {",
      "            let x = f64::read(source);",
      "            let y = f64::read(source);",
      "            PosF64::new(x, y)",
      "        }",
      "    }",
      "}"
    ]
  },
  "pos_ix": {
    "scope": "rust",
    "prefix": "pos_ix",
    "body": [
      "use pos_ix::*;",
      "pub mod pos_ix {",
      "    use super::pos::Pos;",
      "    use super::Ix;",
      "    impl Ix for Pos {",
      "        fn range((min, max): (Self, Self)) -> impl Iterator<Item = Self> {",
      "            (min.y..=max.y).flat_map(move |y| (min.x..=max.x).map(move |x| Pos::new(x, y)))",
      "        }",
      "        fn range_size((min, max): (Self, Self)) -> usize {",
      "            if min.x > max.x || min.y > max.y {",
      "                0",
      "            } else {",
      "                ((max.x - min.x + 1) * (max.y - min.y + 1)) as usize",
      "            }",
      "        }",
      "        fn to_index((min, max): (Self, Self), i: Self) -> usize {",
      "            if !Self::in_range((min, max), i) {",
      "                panic!(\"index out of bounds: {:?} is not in {:?}\", i, (min, max));",
      "            }",
      "            let width = (max.x - min.x + 1) as usize;",
      "            let dy = (i.y - min.y) as usize;",
      "            let dx = (i.x - min.x) as usize;",
      "            dy * width + dx",
      "        }",
      "        fn from_index((min, max): (Self, Self), index: usize) -> Self {",
      "            if index >= Self::range_size((min, max)) {",
      "                panic!(\"index out of range: {} for bounds {:?}\", index, (min, max));",
      "            }",
      "            let width = (max.x - min.x + 1) as usize;",
      "            let dy = (index / width) as i64;",
      "            let dx = (index % width) as i64;",
      "            Pos::new(min.x + dx, min.y + dy)",
      "        }",
      "        fn in_range((min, max): (Self, Self), i: Self) -> bool {",
      "            min.x <= i.x && i.x <= max.x && min.y <= i.y && i.y <= max.y",
      "        }",
      "    }",
      "}"
    ]
  },
  "positional_notation": {
    "scope": "rust",
    "prefix": "positional_notation",
    "body": [
      "use positional_notation::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod positional_notation {",
      "    /// 配列 xs で表された base 進数の値を評価する。",
      "    /// 例: `eval_base_n_value(&[1, 2, 3], 10) == 123`",
      "    pub fn eval_base_n_value(xs: &[i64], base: i64) -> i64 {",
      "        xs.iter().fold(0, |acc, &x| acc * base + x)",
      "    }",
      "    /// x の base 進数での表記を Vec で表す。",
      "    /// 例",
      "    /// * `to_base_n_value(123, 10) == vec![1, 2, 3]`",
      "    /// * `to_base_n_value(0, 10) == vec![]`",
      "    pub fn to_base_n_value(x: i64, base: i64) -> Vec<i64> {",
      "        assert!(x >= 0);",
      "        assert!(base >= 2);",
      "        let mut ret = vec![];",
      "        let mut x = x;",
      "        while x > 0 {",
      "            ret.push(x % base);",
      "            x /= base;",
      "        }",
      "        ret.reverse();",
      "        ret",
      "    }",
      "    /// x を base 進数で表記した際の桁数を返す。",
      "    /// 例",
      "    /// * `count_digits(123, 10) == 3`",
      "    /// * `count_digits(0, 10) == 0`",
      "    pub fn count_digits(mut x: i64, base: i64) -> usize {",
      "        assert!(x >= 0);",
      "        assert!(base >= 2);",
      "        if x == 0 {",
      "            return 0;",
      "        }",
      "        let mut count = 0;",
      "        while x > 0 {",
      "            x /= base;",
      "            count += 1;",
      "        }",
      "        count",
      "    }",
      "    /// `to_base_n_value_iter` 関数が返すイテレータ。",
      "    /// 数値を指定された基数で表した際の各桁を順に生成する。",
      "    pub struct BaseNIterator {",
      "        n: i64,",
      "        base: i64,",
      "        current_power: i64,",
      "    }",
      "    impl Iterator for BaseNIterator {",
      "        type Item = i64;",
      "        fn next(&mut self) -> Option<Self::Item> {",
      "            if self.current_power == 0 {",
      "                return None;",
      "            }",
      "            let digit = self.n / self.current_power;",
      "            self.n %= self.current_power;",
      "            self.current_power /= self.base;",
      "            Some(digit)",
      "        }",
      "    }",
      "    /// x の base 進数での表記をイテレータで返す。",
      "    /// 例",
      "    /// - `to_base_n_value_iter(123, 10).collect() == vec![1, 2, 3]`",
      "    /// - `to_base_n_value_iter(0, 10).collect() == vec![]`",
      "    pub fn to_base_n_value_iter(x: i64, base: i64) -> BaseNIterator {",
      "        assert!(x >= 0);",
      "        assert!(base >= 2);",
      "        if x == 0 {",
      "            return BaseNIterator {",
      "                n: 0,",
      "                base,",
      "                current_power: 0,",
      "            };",
      "        }",
      "        let mut current_power = 1;",
      "        while x / current_power >= base {",
      "            current_power *= base;",
      "        }",
      "        BaseNIterator {",
      "            n: x,",
      "            base,",
      "            current_power,",
      "        }",
      "    }",
      "}"
    ]
  },
  "potentialized_dsu": {
    "scope": "rust",
    "prefix": "potentialized_dsu",
    "body": [
      "use ab_group::*;",
      "use potentialized_dsu::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod ab_group {",
      "    use std::{",
      "        convert::Infallible,",
      "        iter::Sum,",
      "        marker::PhantomData,",
      "        ops::{Add, Neg, Sub},",
      "    };",
      "    /// 可換群 (Abelian Group)",
      "    pub trait AbGroup {",
      "        type S: Clone;",
      "        fn zero() -> Self::S;",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S;",
      "        fn neg(a: &Self::S) -> Self::S;",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            Self::add(a, &Self::neg(b))",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct AdditiveAbGroup<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T: Sum + Add<Output = T> + Sub<Output = T> + Neg<Output = T> + Copy> AbGroup",
      "        for AdditiveAbGroup<T>",
      "    {",
      "        type S = T;",
      "        fn zero() -> Self::S {",
      "            std::iter::empty().sum()",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a + *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            -(*a)",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a - *b",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct XorAbGroup(Infallible);",
      "    impl AbGroup for XorAbGroup {",
      "        type S = u64;",
      "        fn zero() -> Self::S {",
      "            0",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            *a",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::module_inception)]",
      "pub mod potentialized_dsu {",
      "    use super::{AbGroup, AdditiveAbGroup};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub enum MergeResult {",
      "        /// 新しくマージされた場合",
      "        Merged { leader: usize, merged: usize },",
      "        /// すでに同じ集合だった場合（変化なし）",
      "        Unchanged,",
      "        /// 矛盾があった場合",
      "        Contradiction,",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    /// DSU 内の各要素の状態（親のインデックスまたは集合のサイズ）を保持する構造体。",
      "    /// メモリ効率（32ビット整数 1 つ分）を維持したまま、以下の 2 つの状態を表現します。",
      "    /// 1. **Root (根)**:",
      "    ///    - 値が負の場合、その要素は集合の代表元（リーダー）です。",
      "    ///    - 値の絶対値 `|v|` は、その集合に属する要素の数（サイズ）を表します。",
      "    ///    - 例: `-1` はサイズ 1 の集合の根、`-5` はサイズ 5 の集合の根。",
      "    /// 2. **Child (子)**:",
      "    ///    - 値が 0 以上の場合、その要素は他の要素を親に持っています。",
      "    ///    - 値 `v` は、親要素のインデックスを表します。",
      "    struct Node(i32);",
      "    impl Node {",
      "        fn root(size: usize) -> Self {",
      "            Self(-(size as i32))",
      "        }",
      "        fn child(parent: usize) -> Self {",
      "            Self(parent as i32)",
      "        }",
      "        fn is_root(&self) -> bool {",
      "            self.0 < 0",
      "        }",
      "        fn parent(&self) -> usize {",
      "            self.0 as usize",
      "        }",
      "        fn size(&self) -> usize {",
      "            (-self.0) as usize",
      "        }",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    pub struct PotentializedDsuArbitrary<G: AbGroup>",
      "    where",
      "        G::S: PartialEq,",
      "    {",
      "        n: usize,",
      "        nodes: Vec<Node>,",
      "        p_diff: Vec<G::S>,",
      "        cnt_groups: usize,",
      "    }",
      "    pub type PotentializedDsu = PotentializedDsuArbitrary<AdditiveAbGroup<i64>>;",
      "    impl<G: AbGroup> PotentializedDsuArbitrary<G>",
      "    where",
      "        G::S: PartialEq,",
      "    {",
      "        pub fn new(size: usize) -> Self {",
      "            Self {",
      "                n: size,",
      "                nodes: vec![Node::root(1); size],",
      "                p_diff: vec![G::zero(); size],",
      "                cnt_groups: size,",
      "            }",
      "        }",
      "        /// 2 つの要素 `src` と `dst` が属する集合を統合する。",
      "        /// diff = dst のポテンシャル - src のポテンシャル となるように統合する",
      "        pub fn merge(&mut self, src: usize, dst: usize, mut diff: G::S) -> MergeResult {",
      "            assert!(src < self.n);",
      "            assert!(dst < self.n);",
      "            let (mut lsrc, mut psrc) = self.leader_potential(src);",
      "            let (mut ldst, mut pdst) = self.leader_potential(dst);",
      "            if lsrc == ldst {",
      "                let result = if self.diff(src, dst).unwrap() == diff {",
      "                    MergeResult::Unchanged",
      "                } else {",
      "                    MergeResult::Contradiction",
      "                };",
      "                return result;",
      "            }",
      "            if self.nodes[ldst].size() < self.nodes[lsrc].size() {",
      "                std::mem::swap(&mut lsrc, &mut ldst);",
      "                std::mem::swap(&mut psrc, &mut pdst);",
      "                diff = G::neg(&diff);",
      "            }",
      "            let size_lsrc = self.nodes[lsrc].size();",
      "            let size_ldst = self.nodes[ldst].size();",
      "            self.nodes[ldst] = Node::root(size_lsrc + size_ldst);",
      "            self.nodes[lsrc] = Node::child(ldst);",
      "            self.cnt_groups -= 1;",
      "            let ldiff = G::add(&G::neg(&psrc), &G::add(&diff, &pdst));",
      "            self.p_diff[lsrc] = ldiff;",
      "            MergeResult::Merged {",
      "                leader: ldst,",
      "                merged: lsrc,",
      "            }",
      "        }",
      "        pub fn same(&mut self, a: usize, b: usize) -> bool {",
      "            assert!(a < self.n);",
      "            assert!(b < self.n);",
      "            self.leader(a) == self.leader(b)",
      "        }",
      "        /// dst のポテンシャル - src のポテンシャル を求める",
      "        pub fn diff(&mut self, src: usize, dst: usize) -> Option<G::S> {",
      "            if self.same(src, dst) {",
      "                let (_, psrc) = self.leader_potential(src);",
      "                let (_, pdst) = self.leader_potential(dst);",
      "                let diff = G::sub(&psrc, &pdst);",
      "                Some(diff)",
      "            } else {",
      "                None",
      "            }",
      "        }",
      "        fn leader_potential(&mut self, a: usize) -> (usize, G::S) {",
      "            assert!(a < self.n);",
      "            if self.nodes[a].is_root() {",
      "                return (a, G::zero());",
      "            }",
      "            let parent = self.nodes[a].parent();",
      "            let (leader, parent_potential) = self.leader_potential(parent);",
      "            self.nodes[a] = Node::child(leader);",
      "            let potential = G::add(&self.p_diff[a], &parent_potential);",
      "            self.p_diff[a] = potential.clone();",
      "            (leader, potential)",
      "        }",
      "        pub fn leader(&mut self, a: usize) -> usize {",
      "            self.leader_potential(a).0",
      "        }",
      "        pub fn size(&mut self, a: usize) -> usize {",
      "            assert!(a < self.n);",
      "            let x = self.leader(a);",
      "            self.nodes[x].size()",
      "        }",
      "        pub fn count_group(&self) -> usize {",
      "            self.cnt_groups",
      "        }",
      "        pub fn groups(&mut self) -> Vec<Vec<usize>> {",
      "            let mut leader_buf = vec![0; self.n];",
      "            let mut group_size = vec![0; self.n];",
      "            for i in 0..self.n {",
      "                leader_buf[i] = self.leader(i);",
      "                group_size[leader_buf[i]] += 1;",
      "            }",
      "            let mut result = vec![Vec::new(); self.n];",
      "            for i in 0..self.n {",
      "                result[i].reserve(group_size[i]);",
      "            }",
      "            for i in 0..self.n {",
      "                result[leader_buf[i]].push(i);",
      "            }",
      "            result",
      "                .into_iter()",
      "                .filter(|x| !x.is_empty())",
      "                .collect::<Vec<Vec<usize>>>()",
      "        }",
      "    }",
      "}"
    ]
  },
  "potentialized_union_find": {
    "scope": "rust",
    "prefix": "potentialized_union_find",
    "body": [
      "use potentialized_union_find::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod potentialized_union_find {",
      "    use itertools::Itertools;",
      "    #[derive(Clone, Debug)]",
      "    struct RootInfo {",
      "        count: usize,",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    struct NonRootInfo {",
      "        parent: usize,",
      "        /// 親のポテンシャル - 自分のポテンシャル",
      "        potential_diff: i64,",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    enum Node {",
      "        Root(RootInfo),",
      "        NonRoot(NonRootInfo),",
      "    }",
      "    impl Node {",
      "        fn root(count: usize) -> Node {",
      "            Node::Root(RootInfo { count })",
      "        }",
      "        fn non_root(parent: usize, potential_diff: i64) -> Node {",
      "            Node::NonRoot(NonRootInfo {",
      "                parent,",
      "                potential_diff,",
      "            })",
      "        }",
      "        fn as_root(&self) -> &RootInfo {",
      "            match self {",
      "                Node::Root(info) => info,",
      "                Node::NonRoot(_) => panic!(),",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    struct ToRoot {",
      "        root_index: usize,",
      "        /// root のポテンシャル - 自分のポテンシャル",
      "        potential_diff: i64,",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    pub struct PotentializedUnionFind {",
      "        nodes: Vec<Node>,",
      "        cnt_groups: usize,",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub enum UnionResult {",
      "        Consistent { updated: bool },",
      "        Inconsistent,",
      "    }",
      "    impl UnionResult {",
      "        pub fn updated(&self) -> bool {",
      "            match self {",
      "                UnionResult::Consistent { updated } => *updated,",
      "                UnionResult::Inconsistent => false,",
      "            }",
      "        }",
      "        pub fn is_consistent(&self) -> bool {",
      "            matches!(self, UnionResult::Consistent { .. })",
      "        }",
      "        pub fn is_inconsistent(&self) -> bool {",
      "            matches!(self, UnionResult::Inconsistent)",
      "        }",
      "    }",
      "    impl PotentializedUnionFind {",
      "        pub fn new(n: usize) -> PotentializedUnionFind {",
      "            PotentializedUnionFind {",
      "                nodes: vec![Node::Root(RootInfo { count: 1 }); n],",
      "                cnt_groups: n,",
      "            }",
      "        }",
      "        fn root_node(&mut self, index: usize) -> ToRoot {",
      "            match &self.nodes[index] {",
      "                Node::Root(_) => ToRoot {",
      "                    root_index: index,",
      "                    potential_diff: 0,",
      "                },",
      "                Node::NonRoot(my_info) => {",
      "                    let to_parent_potential_diff = my_info.potential_diff;",
      "                    let parent_to_root = self.root_node(my_info.parent);",
      "                    let new_potential_diff =",
      "                        to_parent_potential_diff + parent_to_root.potential_diff;",
      "                    self.nodes[index] =",
      "                        Node::non_root(parent_to_root.root_index, new_potential_diff);",
      "                    ToRoot {",
      "                        root_index: parent_to_root.root_index,",
      "                        potential_diff: new_potential_diff,",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        pub fn root(&mut self, index: usize) -> usize {",
      "            self.root_node(index).root_index",
      "        }",
      "        pub fn same_count(&mut self, index: usize) -> usize {",
      "            let root_index = self.root(index);",
      "            self.nodes[root_index].as_root().count",
      "        }",
      "        pub fn same(&mut self, x: usize, y: usize) -> bool {",
      "            self.root(x) == self.root(y)",
      "        }",
      "        pub fn num_groups(&self) -> usize {",
      "            self.cnt_groups",
      "        }",
      "        /// diff = dst のポテンシャル - src のポテンシャル となるように統合する",
      "        pub fn unite(&mut self, src: usize, dst: usize, diff: i64) -> UnionResult {",
      "            if self.same(src, dst) {",
      "                if self.diff(src, dst) == Some(diff) {",
      "                    return UnionResult::Consistent { updated: false };",
      "                } else {",
      "                    return UnionResult::Inconsistent;",
      "                }",
      "            }",
      "            self.cnt_groups -= 1;",
      "            let src_root_node = self.root_node(src);",
      "            let dst_root_node = self.root_node(dst);",
      "            let root_diff = -src_root_node.potential_diff + diff + dst_root_node.potential_diff;",
      "            let (src_root_node, dst_root_node, root_diff) = {",
      "                let src_cnt = self.nodes[src_root_node.root_index].as_root().count;",
      "                let dst_cnt = self.nodes[dst_root_node.root_index].as_root().count;",
      "                if src_cnt <= dst_cnt {",
      "                    (src_root_node, dst_root_node, root_diff)",
      "                } else {",
      "                    (dst_root_node, src_root_node, -root_diff)",
      "                }",
      "            };",
      "            let count_sum = self.nodes[src_root_node.root_index].as_root().count",
      "                + self.nodes[dst_root_node.root_index].as_root().count;",
      "            self.nodes[src_root_node.root_index] =",
      "                Node::non_root(dst_root_node.root_index, root_diff);",
      "            self.nodes[dst_root_node.root_index] = Node::root(count_sum);",
      "            UnionResult::Consistent { updated: true }",
      "        }",
      "        /// dst のポテンシャル - src のポテンシャル を求める",
      "        pub fn diff(&mut self, src: usize, dst: usize) -> Option<i64> {",
      "            if self.same(src, dst) {",
      "                Some(self.root_node(src).potential_diff - self.root_node(dst).potential_diff)",
      "            } else {",
      "                None",
      "            }",
      "        }",
      "        pub fn groups(&mut self) -> Vec<Vec<usize>> {",
      "            let n = self.nodes.len();",
      "            let roots = (0..n).map(|i| self.root(i)).collect_vec();",
      "            let group_size = (0..n).map(|i| roots[i]).fold(vec![0; n], |mut acc, x| {",
      "                acc[x] += 1;",
      "                acc",
      "            });",
      "            let result = {",
      "                let mut result = vec![Vec::new(); n];",
      "                for i in 0..n {",
      "                    result[i].reserve(group_size[i]);",
      "                }",
      "                for i in 0..n {",
      "                    result[roots[i]].push(i);",
      "                }",
      "                result",
      "            };",
      "            result.into_iter().filter(|x| !x.is_empty()).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "prime_factorize": {
    "scope": "rust",
    "prefix": "prime_factorize",
    "body": [
      "/// n を素因数分解する。key を素数、value をその素数の指数とした HashMap を返す。",
      "/// # 計算量",
      "/// O(sqrt(n))",
      "pub fn prime_factorize(n: i64) -> HashMap<i64, i64> {",
      "    use num::Integer;",
      "    use num_integer::Roots;",
      "    assert!(n >= 1);",
      "    let mut cnt_table: HashMap<i64, i64> = HashMap::new();",
      "    let mut n = n;",
      "    for i in 2..=n.sqrt() {",
      "        if n.is_multiple_of(&i) {",
      "            let mut cnt = 0;",
      "            while n.is_multiple_of(&i) {",
      "                n /= i;",
      "                cnt += 1;",
      "            }",
      "            cnt_table.insert(i, cnt);",
      "        }",
      "    }",
      "    if n != 1 {",
      "        cnt_table.insert(n, 1);",
      "    }",
      "    cnt_table",
      "}"
    ]
  },
  "random_test": {
    "scope": "rust",
    "prefix": "random_test",
    "body": [
      "use random_test::*;",
      "/// ランダムなテストケースを生成するためのユーティリティモジュール",
      "pub mod random_test {",
      "    use itertools::Itertools;",
      "    use num::Integer;",
      "    use num_integer::Roots;",
      "    use petgraph::unionfind::UnionFind;",
      "    use rand::Rng;",
      "    use std::{collections::HashSet, hash::Hash};",
      "    /// 指定された個数のユニークな値を生成する。",
      "    /// `gen` クロージャが返す値が `n` 種類に達するまで値の生成を繰り返す。",
      "    /// # Arguments",
      "    /// * `n` - 生成するユニークな値の個数",
      "    /// * `gen` - 値を生成するクロージャ",
      "    /// # Examples",
      "    /// ```",
      "    /// use mylib::utils::random::random_test::*;",
      "    /// use rand::{Rng, rngs::SmallRng, SeedableRng};",
      "    /// let mut rng = SmallRng::from_os_rng();",
      "    /// let uniq_seq = generate_random_uniq_sequence(10, || rng.random_range(0..100));",
      "    /// assert_eq!(uniq_seq.len(), 10);",
      "    /// ```",
      "    pub fn generate_random_uniq_sequence<T, F>(n: usize, mut r#gen: F) -> Vec<T>",
      "    where",
      "        T: Hash + PartialEq + Eq,",
      "        F: FnMut() -> T,",
      "    {",
      "        let mut set: HashSet<T> = HashSet::new();",
      "        while set.len() != n {",
      "            set.insert(r#gen());",
      "        }",
      "        set.into_iter().collect_vec()",
      "    }",
      "    /// 条件 `pred` を満たすランダムな値を生成する。",
      "    /// `gen` クロージャで値を生成し、`pred` が `true` を返すまで繰り返す。",
      "    /// # Arguments",
      "    /// * `gen` - 値を生成するクロージャ",
      "    /// * `pred` - 値が満たすべき条件を判定するクロージャ",
      "    /// # Examples",
      "    /// ```",
      "    /// use mylib::utils::random::random_test::*;",
      "    /// use rand::{Rng, rngs::SmallRng, SeedableRng};",
      "    /// let mut rng = SmallRng::from_os_rng();",
      "    /// let even_number = generate_random_while(|| rng.random_range(0..100), |&x| x % 2 == 0);",
      "    /// assert!(even_number % 2 == 0);",
      "    /// ```",
      "    pub fn generate_random_while<T, F, P>(mut r#gen: F, mut pred: P) -> T",
      "    where",
      "        F: FnMut() -> T,",
      "        P: FnMut(&T) -> bool,",
      "    {",
      "        loop {",
      "            let x = r#gen();",
      "            if pred(&x) {",
      "                return x;",
      "            }",
      "        }",
      "    }",
      "    /// `n_vertices` 頂点のランダムな木（辺のリスト）を生成する。",
      "    /// # Arguments",
      "    /// * `rng` - 乱数生成器",
      "    /// * `n_vertices` - 木の頂点数",
      "    /// # Examples",
      "    /// ```",
      "    /// use mylib::utils::random::random_test::*;",
      "    /// use rand::{Rng, rngs::SmallRng, SeedableRng};",
      "    /// let mut rng = SmallRng::from_os_rng();",
      "    /// let tree = generate_random_tree(&mut rng, 5);",
      "    /// assert_eq!(tree.len(), 4);",
      "    /// ```",
      "    pub fn generate_random_tree<R>(rng: &mut R, n_vertices: usize) -> Vec<(usize, usize)>",
      "    where",
      "        R: Rng,",
      "    {",
      "        let mut edges: Vec<(usize, usize)> = Vec::new();",
      "        let mut uf: UnionFind<usize> = UnionFind::new(n_vertices);",
      "        while edges.len() != n_vertices - 1 {",
      "            let x = rng.random_range(0..n_vertices);",
      "            let y = rng.random_range(0..n_vertices);",
      "            if uf.union(x, y) {",
      "                edges.push((x, y));",
      "            }",
      "        }",
      "        edges",
      "    }",
      "    fn is_prime(n: i64) -> bool {",
      "        if n <= 1 {",
      "            return false;",
      "        }",
      "        for i in 2..=n.sqrt() {",
      "            if n.is_multiple_of(&i) {",
      "                return false;",
      "            }",
      "        }",
      "        true",
      "    }",
      "    /// 指定された範囲 `[begin, end)` 内のランダムな素数を生成する。",
      "    /// # Arguments",
      "    /// * `rng` - 乱数生成器",
      "    /// * `begin` - 範囲の下限（含む）",
      "    /// * `end` - 範囲の上限（含まない）",
      "    /// # Examples",
      "    /// ```",
      "    /// use mylib::utils::random::random_test::*;",
      "    /// use rand::{Rng, rngs::SmallRng, SeedableRng};",
      "    /// let mut rng = SmallRng::from_os_rng();",
      "    /// let prime = generate_random_prime(&mut rng, 0, 100);",
      "    /// ```",
      "    pub fn generate_random_prime<R>(rng: &mut R, begin: i64, end: i64) -> i64",
      "    where",
      "        R: Rng,",
      "    {",
      "        let r#gen = || rng.random_range(begin..end);",
      "        generate_random_while(r#gen, |x| is_prime(*x))",
      "    }",
      "}"
    ]
  },
  "range_add_dual_segtree": {
    "scope": "rust",
    "prefix": "range_add_dual_segtree",
    "body": [
      "use range_add_dual_segtree::*;",
      "pub mod range_add_dual_segtree {",
      "    use super::dual_segtree::*;",
      "    use std::convert::Infallible;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct AddMonoid(Infallible);",
      "    impl MapMonoid for AddMonoid {",
      "        type F = i64;",
      "        type S = i64;",
      "        fn identity_map() -> Self::F {",
      "            0",
      "        }",
      "        fn mapping(&f: &i64, &x: &i64) -> i64 {",
      "            f + x",
      "        }",
      "        fn composition(&f: &i64, &g: &i64) -> i64 {",
      "            f + g",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_add_fenwick_tree": {
    "scope": "rust",
    "prefix": "range_add_fenwick_tree",
    "body": [
      "use ab_group::*;",
      "use range_add_fenwick_tree::*;",
      "use range_sum_fenwick_tree::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_sum_fenwick_tree {",
      "    use super::{AbGroup, AdditiveAbGroup};",
      "    use std::ops::{Bound, RangeBounds};",
      "    /// 可換群 (AbGroup) を用いた汎用的な Fenwick Tree (Binary Indexed Tree)。",
      "    /// 0-indexed で実装されています。",
      "    /// 基本的な加算・区間和クエリに加え、get/set や、二分探索 (max_right / min_left) を提供します。",
      "    #[derive(Clone)]",
      "    pub struct RangeSumFenwickTreeArbitrary<G: AbGroup> {",
      "        n: usize,",
      "        pub(crate) ary: Vec<G::S>,",
      "    }",
      "    /// i64 の加算群を用いた標準的な Fenwick Tree のエイリアス。",
      "    pub type RangeSumFenwickTreeI64 = RangeSumFenwickTreeArbitrary<AdditiveAbGroup<i64>>;",
      "    /// 任意の数値型 T の加算群を用いた Fenwick Tree のエイリアス。",
      "    pub type RangeSumFenwickTree<T> = RangeSumFenwickTreeArbitrary<AdditiveAbGroup<T>>;",
      "    pub type FenwickTree<T> = RangeSumFenwickTree<T>;",
      "    impl<G: AbGroup> RangeSumFenwickTreeArbitrary<G> {",
      "        /// サイズ `n` の Fenwick Tree を作成します。",
      "        /// 要素はすべて `G::zero()` で初期化されます。",
      "        /// # 計算量",
      "        /// O(n)",
      "        pub fn new(n: usize) -> Self {",
      "            let ary = vec![G::zero(); n];",
      "            RangeSumFenwickTreeArbitrary { n, ary }",
      "        }",
      "        /// 配列スライスから Fenwick Tree を作成します。",
      "        /// # 計算量",
      "        /// O(n)",
      "        pub fn from_slice(slice: &[G::S]) -> Self {",
      "            let n = slice.len();",
      "            let mut ary = slice.to_vec();",
      "            for i in 0..n {",
      "                let j = i | (i + 1);",
      "                if j < n {",
      "                    let val_i = ary[i].clone();",
      "                    ary[j] = G::add(&ary[j], &val_i);",
      "                }",
      "            }",
      "            RangeSumFenwickTreeArbitrary { n, ary }",
      "        }",
      "        /// `[0, idx)` の区間の総和を計算します。",
      "        /// # Panics",
      "        /// `idx > n` の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn prefix_sum(&self, mut idx: usize) -> G::S {",
      "            assert!(",
      "                idx <= self.n,",
      "                \"RangeSumFenwickTreeArbitrary::prefix_sum: index out of bounds. idx: {}, n: {}\",",
      "                idx,",
      "                self.n",
      "            );",
      "            let mut sum = G::zero();",
      "            while idx > 0 {",
      "                sum = G::add(&sum, &self.ary[idx - 1]);",
      "                idx &= idx - 1;",
      "            }",
      "            sum",
      "        }",
      "        /// `idx` 番目の要素に `val` を加算（群の演算を適用）します。",
      "        /// # Panics",
      "        /// `idx >= n` の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn add(&mut self, mut idx: usize, val: G::S) {",
      "            assert!(",
      "                idx < self.n,",
      "                \"RangeSumFenwickTreeArbitrary::add: index out of bounds. idx: {}, n: {}\",",
      "                idx,",
      "                self.n",
      "            );",
      "            let n = self.n;",
      "            idx += 1;",
      "            while idx <= n {",
      "                self.ary[idx - 1] = G::add(&self.ary[idx - 1], &val);",
      "                idx += idx & idx.wrapping_neg();",
      "            }",
      "        }",
      "        fn resolve_range<R: RangeBounds<usize>>(&self, range: R) -> (usize, usize) {",
      "            let l = match range.start_bound() {",
      "                Bound::Included(&l) => l,",
      "                Bound::Excluded(&l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            let r = match range.end_bound() {",
      "                Bound::Included(&r) => r + 1,",
      "                Bound::Excluded(&r) => r,",
      "                Bound::Unbounded => self.n,",
      "            };",
      "            (l, r)",
      "        }",
      "        /// 指定された範囲の区間和を計算します。",
      "        /// # Panics",
      "        /// 範囲が不正、または `n` を超える場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn range_sum<R>(&self, range: R) -> G::S",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            let (l, r) = self.resolve_range(range);",
      "            assert!(",
      "                l <= r && r <= self.n,",
      "                \"RangeSumFenwickTreeArbitrary::range_sum: invalid range. l: {}, r: {}, n: {}\",",
      "                l,",
      "                r,",
      "                self.n",
      "            );",
      "            G::sub(&self.prefix_sum(r), &self.prefix_sum(l))",
      "        }",
      "        /// `l` を左端として、`f(sum(l..r))` が true になる最大の `r` を返します。",
      "        /// `f` は単調性を持つ必要があります。",
      "        /// 具体的には、`f(sum(l..i))` が true ならば、任意の `j < i` に対して `f(sum(l..j))` も true である必要があります。",
      "        /// また、`f(zero)` は true である必要があります。",
      "        /// # Panics",
      "        /// `l > n` または `f(zero)` が false の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn max_right<F>(&self, l: usize, mut f: F) -> usize",
      "        where",
      "            F: FnMut(&G::S) -> bool,",
      "        {",
      "            assert!(",
      "                l <= self.n,",
      "                \"RangeSumFenwickTreeArbitrary::max_right: index out of bounds. l: {}, n: {}\",",
      "                l,",
      "                self.n",
      "            );",
      "            let zero = G::zero();",
      "            assert!(",
      "                f(&zero),",
      "                \"RangeSumFenwickTreeArbitrary::max_right: The predicate f(zero) must be true.\"",
      "            );",
      "            let val_l = self.prefix_sum(l);",
      "            let mut r = 0;",
      "            let mut current_val = G::zero();",
      "            let mut k = if self.n == 0 {",
      "                0",
      "            } else {",
      "                1 << (usize::BITS - 1 - self.n.leading_zeros())",
      "            };",
      "            while k > 0 {",
      "                if r + k <= self.n {",
      "                    let next_val = G::add(&current_val, &self.ary[r + k - 1]);",
      "                    if r + k <= l || f(&G::sub(&next_val, &val_l)) {",
      "                        r += k;",
      "                        current_val = next_val;",
      "                    }",
      "                }",
      "                k >>= 1;",
      "            }",
      "            r",
      "        }",
      "        /// `r` を右端として、`f(sum(l..r))` が true になる最小の `l` を返します。",
      "        /// `f` は単調性を持つ必要があります。",
      "        /// 具体的には、`f(sum(i..r))` が true ならば、任意の `j > i` に対して `f(sum(j..r))` も true である必要があります。",
      "        /// また、`f(zero)` は true である必要があります。",
      "        /// # Panics",
      "        /// `r > n` または `f(zero)` が false の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn min_left<F>(&self, r: usize, mut f: F) -> usize",
      "        where",
      "            F: FnMut(&G::S) -> bool,",
      "        {",
      "            assert!(",
      "                r <= self.n,",
      "                \"RangeSumFenwickTreeArbitrary::min_left: index out of bounds. r: {}, n: {}\",",
      "                r,",
      "                self.n",
      "            );",
      "            let zero = G::zero();",
      "            assert!(",
      "                f(&zero),",
      "                \"RangeSumFenwickTreeArbitrary::min_left: The predicate f(zero) must be true.\"",
      "            );",
      "            let val_r = self.prefix_sum(r);",
      "            if f(&val_r) {",
      "                return 0;",
      "            }",
      "            let mut idx = 0;",
      "            let mut current_val = G::zero();",
      "            let mut k = if self.n == 0 {",
      "                0",
      "            } else {",
      "                1 << (usize::BITS - 1 - self.n.leading_zeros())",
      "            };",
      "            while k > 0 {",
      "                if idx + k <= r {",
      "                    let next_val = G::add(&current_val, &self.ary[idx + k - 1]);",
      "                    if !f(&G::sub(&val_r, &next_val)) {",
      "                        idx += k;",
      "                        current_val = next_val;",
      "                    }",
      "                }",
      "                k >>= 1;",
      "            }",
      "            idx + 1",
      "        }",
      "        /// `idx` 番目の要素の値を取得します。",
      "        /// # Panics",
      "        /// `idx >= n` の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn get(&self, idx: usize) -> G::S {",
      "            assert!(",
      "                idx < self.n,",
      "                \"RangeSumFenwickTreeArbitrary::get: index out of bounds. idx: {}, n: {}\",",
      "                idx,",
      "                self.n",
      "            );",
      "            self.range_sum(idx..=idx)",
      "        }",
      "        /// `idx` 番目の要素の値を `val` に設定します。",
      "        /// # Panics",
      "        /// `idx >= n` の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn set(&mut self, idx: usize, val: G::S) {",
      "            assert!(",
      "                idx < self.n,",
      "                \"RangeSumFenwickTreeArbitrary::set: index out of bounds. idx: {}, n: {}\",",
      "                idx,",
      "                self.n",
      "            );",
      "            let old_val = self.get(idx);",
      "            self.add(idx, G::sub(&val, &old_val));",
      "        }",
      "        /// Fenwick Tree の現在の状態を `Vec<G::S>` として返します。",
      "        /// # 計算量",
      "        /// O(n log n)",
      "        pub fn to_vec(&self) -> Vec<G::S> {",
      "            (0..self.n).map(|i| self.get(i)).collect()",
      "        }",
      "        /// 保持している要素数を返します。",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.n",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::module_inception)]",
      "pub mod ab_group {",
      "    use std::{",
      "        convert::Infallible,",
      "        iter::Sum,",
      "        marker::PhantomData,",
      "        ops::{Add, Neg, Sub},",
      "    };",
      "    /// 可換群 (Abelian Group)",
      "    pub trait AbGroup {",
      "        type S: Clone;",
      "        fn zero() -> Self::S;",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S;",
      "        fn neg(a: &Self::S) -> Self::S;",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            Self::add(a, &Self::neg(b))",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct AdditiveAbGroup<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T: Sum + Add<Output = T> + Sub<Output = T> + Neg<Output = T> + Copy> AbGroup",
      "        for AdditiveAbGroup<T>",
      "    {",
      "        type S = T;",
      "        fn zero() -> Self::S {",
      "            std::iter::empty().sum()",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a + *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            -(*a)",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a - *b",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct XorAbGroup(Infallible);",
      "    impl AbGroup for XorAbGroup {",
      "        type S = u64;",
      "        fn zero() -> Self::S {",
      "            0",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            *a",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::module_inception)]",
      "pub mod range_add_fenwick_tree {",
      "    use super::{AbGroup, AdditiveAbGroup, RangeSumFenwickTreeArbitrary};",
      "    use std::ops::{Bound, RangeBounds};",
      "    /// 1次元の階差数列を管理する Fenwick Tree。",
      "    /// 内部的には階差数列を `RangeSumFenwickTreeArbitrary` で管理しています。",
      "    #[derive(Clone)]",
      "    pub struct RangeAddFenwickTreeArbitrary<G: AbGroup> {",
      "        ft: RangeSumFenwickTreeArbitrary<G>,",
      "    }",
      "    /// i64 の加算群を用いた標準的な Range Add Fenwick Tree のエイリアス。",
      "    pub type RangeAddFenwickTreeI64 = RangeAddFenwickTreeArbitrary<AdditiveAbGroup<i64>>;",
      "    /// 任意の数値型 T の加算群を用いた Range Add Fenwick Tree のエイリアス。",
      "    pub type RangeAddFenwickTree<T> = RangeAddFenwickTreeArbitrary<AdditiveAbGroup<T>>;",
      "    impl<G: AbGroup> RangeAddFenwickTreeArbitrary<G> {",
      "        /// サイズ `n` の Range Add Fenwick Tree を作成します。",
      "        /// # 計算量",
      "        /// O(n)",
      "        pub fn new(n: usize) -> Self {",
      "            Self {",
      "                ft: RangeSumFenwickTreeArbitrary::new(n + 1),",
      "            }",
      "        }",
      "        /// 配列のスライスから Range Add Fenwick Tree を作成します。",
      "        /// # 計算量",
      "        /// O(n)",
      "        pub fn from_slice(slice: &[G::S]) -> Self {",
      "            let n = slice.len();",
      "            let mut diff = vec![G::zero(); n + 1];",
      "            if n > 0 {",
      "                diff[0] = slice[0].clone();",
      "                for i in 1..n {",
      "                    diff[i] = G::sub(&slice[i], &slice[i - 1]);",
      "                }",
      "                diff[n] = G::neg(&slice[n - 1]);",
      "            }",
      "            Self {",
      "                ft: RangeSumFenwickTreeArbitrary::from_slice(&diff),",
      "            }",
      "        }",
      "        /// 指定された範囲 `range` に `val` を加算します。",
      "        /// # Panics",
      "        /// 範囲が不正な場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn range_add<R>(&mut self, range: R, val: G::S)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            let (l, r) = self.resolve_range(range);",
      "            let n = self.ft.len() - 1;",
      "            assert!(",
      "                l <= r && r <= n,",
      "                \"RangeAddFenwickTreeArbitrary::range_add: invalid range. l: {}, r: {}, n: {}\",",
      "                l,",
      "                r,",
      "                n",
      "            );",
      "            self.ft.add(l, val.clone());",
      "            self.ft.add(r, G::neg(&val));",
      "        }",
      "        fn resolve_range<R: RangeBounds<usize>>(&self, range: R) -> (usize, usize) {",
      "            let n = self.ft.len() - 1;",
      "            let l = match range.start_bound() {",
      "                Bound::Included(&l) => l,",
      "                Bound::Excluded(&l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            let r = match range.end_bound() {",
      "                Bound::Included(&r) => r + 1,",
      "                Bound::Excluded(&r) => r,",
      "                Bound::Unbounded => n,",
      "            };",
      "            (l, r)",
      "        }",
      "        /// `idx` 番目の要素に `val` を加算します。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn add(&mut self, idx: usize, val: G::S) {",
      "            self.range_add(idx..=idx, val);",
      "        }",
      "        /// `idx` 番目の要素の値を `val` に設定します。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn set(&mut self, idx: usize, val: G::S) {",
      "            let old = self.get(idx);",
      "            self.add(idx, G::sub(&val, &old));",
      "        }",
      "        /// `idx` 番目の要素の値を取得します。",
      "        /// # Panics",
      "        /// `idx >= n` の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn get(&self, idx: usize) -> G::S {",
      "            let n = self.ft.len() - 1;",
      "            assert!(",
      "                idx < n,",
      "                \"RangeAddFenwickTreeArbitrary::get: index out of bounds. idx: {}, n: {}\",",
      "                idx,",
      "                n",
      "            );",
      "            self.ft.prefix_sum(idx + 1)",
      "        }",
      "        /// 現在の状態を `Vec<G::S>` として返します。",
      "        /// # 計算量",
      "        /// O(n log n)",
      "        pub fn to_vec(&self) -> Vec<G::S> {",
      "            let n = self.ft.len() - 1;",
      "            (0..n).map(|i| self.get(i)).collect()",
      "        }",
      "        /// 保持している要素数を返します。",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.ft.len() - 1",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_add_imos": {
    "scope": "rust",
    "prefix": "range_add_imos",
    "body": [
      "use range_add_imos::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_add_imos {",
      "    /// いもす法（差分配列）を用いて、配列に対する区間加算クエリを効率的に処理するデータ構造です。",
      "    /// 最終的な配列の状態を一度に計算する場合（オフライン処理）に特に有用です。",
      "    /// 各区間加算操作はO(1)で、最終的な配列を構築するのにO(N)かかります。",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct RangeAddImos {",
      "        n: usize,",
      "        diff: Vec<i64>,",
      "    }",
      "    impl RangeAddImos {",
      "        /// サイズ `n` の新しい `RangeAddImos` インスタンスを作成します。",
      "        /// # 計算量",
      "        /// O(n)",
      "        pub fn new(n: usize) -> Self {",
      "            Self {",
      "                n,",
      "                diff: vec![0; n + 1],",
      "            }",
      "        }",
      "        /// 指定された `range` に `x` を加算します。",
      "        /// # Panics",
      "        /// 範囲が不正な場合にパニックします。",
      "        /// # 計算量",
      "        /// O(1)",
      "        pub fn range_add(&mut self, range: impl std::ops::RangeBounds<usize>, x: i64) {",
      "            let range = open_range_bounds(range, self.n);",
      "            let l = range.start;",
      "            let r = range.end;",
      "            assert!(l <= r && r <= self.n);",
      "            self.diff[l] += x;",
      "            self.diff[r] -= x;",
      "        }",
      "        /// 差分配列から最終的な配列を構築します。",
      "        /// # 計算量",
      "        /// O(n)",
      "        pub fn to_vec(mut self) -> Vec<i64> {",
      "            if self.n == 0 {",
      "                return Vec::new();",
      "            }",
      "            for i in 1..self.n {",
      "                self.diff[i] += self.diff[i - 1];",
      "            }",
      "            self.diff.truncate(self.n);",
      "            self.diff",
      "        }",
      "        /// 指定されたインデックス `p` に `x` を加算します。",
      "        /// # Panics",
      "        /// `p >= n` の場合にパニックする可能性があります。",
      "        /// `range_add` の内部で範囲チェックが行われます。",
      "        /// # 計算量",
      "        /// O(1)",
      "        pub fn add(&mut self, p: usize, x: i64) {",
      "            self.range_add(p..(p + 1), x);",
      "        }",
      "        /// 配列スライスから`RangeAddImos`インスタンスを作成します。",
      "        /// # 計算量",
      "        /// O(n)",
      "        pub fn from_slice(xs: &[i64]) -> Self {",
      "            let n = xs.len();",
      "            let mut diff = vec![0; n + 1];",
      "            if n > 0 {",
      "                diff[0] = xs[0];",
      "                for i in 1..n {",
      "                    diff[i] = xs[i] - xs[i - 1];",
      "                }",
      "            }",
      "            Self { n, diff }",
      "        }",
      "    }",
      "    fn open_range_bounds(",
      "        range: impl std::ops::RangeBounds<usize>,",
      "        len: usize,",
      "    ) -> std::ops::Range<usize> {",
      "        use std::ops::Bound::{Excluded, Included, Unbounded};",
      "        let l = match range.start_bound() {",
      "            Unbounded => 0,",
      "            Included(&x) => x,",
      "            Excluded(&x) => x + 1,",
      "        };",
      "        let r = match range.end_bound() {",
      "            Unbounded => len,",
      "            Included(&x) => x + 1,",
      "            Excluded(&x) => x,",
      "        };",
      "        l..r",
      "    }",
      "}"
    ]
  },
  "range_add_imos_arbitrary": {
    "scope": "rust",
    "prefix": "range_add_imos_arbitrary",
    "body": [
      "use ab_group::*;",
      "use range_add_imos_arbitrary::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod ab_group {",
      "    use std::{",
      "        convert::Infallible,",
      "        iter::Sum,",
      "        marker::PhantomData,",
      "        ops::{Add, Neg, Sub},",
      "    };",
      "    /// 可換群 (Abelian Group)",
      "    pub trait AbGroup {",
      "        type S: Clone;",
      "        fn zero() -> Self::S;",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S;",
      "        fn neg(a: &Self::S) -> Self::S;",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            Self::add(a, &Self::neg(b))",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct AdditiveAbGroup<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T: Sum + Add<Output = T> + Sub<Output = T> + Neg<Output = T> + Copy> AbGroup",
      "        for AdditiveAbGroup<T>",
      "    {",
      "        type S = T;",
      "        fn zero() -> Self::S {",
      "            std::iter::empty().sum()",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a + *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            -(*a)",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a - *b",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct XorAbGroup(Infallible);",
      "    impl AbGroup for XorAbGroup {",
      "        type S = u64;",
      "        fn zero() -> Self::S {",
      "            0",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            *a",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::module_inception)]",
      "/// 可換群 (AbGroup) を用いた汎用的な 1次元区間加算いもす法を扱うモジュール",
      "pub mod range_add_imos_arbitrary {",
      "    use super::AbGroup;",
      "    /// いもす法（差分配列）を用いて、配列に対する区間加算クエリを効率的に処理するデータ構造 (汎用版)。",
      "    /// 最終的な配列の状態を一度に計算する場合（オフライン処理）に特に有用です。",
      "    /// 各区間加算操作はO(1)で、最終的な配列を構築するのにO(N)かかります。",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct RangeAddImosArbitrary<G: AbGroup> {",
      "        n: usize,",
      "        diff: Vec<G::S>,",
      "    }",
      "    impl<G: AbGroup> RangeAddImosArbitrary<G> {",
      "        /// サイズ `n` の新しい `RangeAddImosArbitrary` インスタンスを作成します。",
      "        /// # 計算量",
      "        /// O(n)",
      "        pub fn new(n: usize) -> Self {",
      "            let mut diff = Vec::with_capacity(n + 1);",
      "            for _ in 0..=n {",
      "                diff.push(G::zero());",
      "            }",
      "            Self { n, diff }",
      "        }",
      "        /// 指定された `range` に `x` を加算します。",
      "        /// # Panics",
      "        /// 範囲が不正な場合にパニックします。",
      "        /// # 計算量",
      "        /// O(1)",
      "        pub fn range_add(&mut self, range: impl std::ops::RangeBounds<usize>, x: G::S) {",
      "            let range = open_range_bounds(range, self.n);",
      "            let l = range.start;",
      "            let r = range.end;",
      "            assert!(l <= r && r <= self.n);",
      "            self.diff[l] = G::add(&self.diff[l], &x);",
      "            self.diff[r] = G::sub(&self.diff[r], &x);",
      "        }",
      "        /// 差分配列から最終的な配列を構築します。",
      "        /// # 計算量",
      "        /// O(n)",
      "        pub fn to_vec(mut self) -> Vec<G::S> {",
      "            if self.n == 0 {",
      "                return Vec::new();",
      "            }",
      "            for i in 1..self.n {",
      "                self.diff[i] = G::add(&self.diff[i - 1], &self.diff[i]);",
      "            }",
      "            self.diff.truncate(self.n);",
      "            self.diff",
      "        }",
      "        /// 指定されたインデックス `p` に `x` を加算します。",
      "        /// # 計算量",
      "        /// O(1)",
      "        pub fn add(&mut self, p: usize, x: G::S) {",
      "            self.range_add(p..(p + 1), x);",
      "        }",
      "        /// 配列スライスから `RangeAddImosArbitrary` インスタンスを作成します。",
      "        /// # 計算量",
      "        /// O(n)",
      "        pub fn from_slice(xs: &[G::S]) -> Self {",
      "            let n = xs.len();",
      "            let mut diff = Vec::with_capacity(n + 1);",
      "            if n == 0 {",
      "                diff.push(G::zero());",
      "            } else {",
      "                diff.push(xs[0].clone());",
      "                for i in 1..n {",
      "                    diff.push(G::sub(&xs[i], &xs[i - 1]));",
      "                }",
      "                diff.push(G::neg(&xs[n - 1]));",
      "            }",
      "            Self { n, diff }",
      "        }",
      "    }",
      "    fn open_range_bounds(",
      "        range: impl std::ops::RangeBounds<usize>,",
      "        len: usize,",
      "    ) -> std::ops::Range<usize> {",
      "        use std::ops::Bound::{Excluded, Included, Unbounded};",
      "        let l = match range.start_bound() {",
      "            Unbounded => 0,",
      "            Included(&x) => x,",
      "            Excluded(&x) => x + 1,",
      "        };",
      "        let r = match range.end_bound() {",
      "            Unbounded => len,",
      "            Included(&x) => x + 1,",
      "            Excluded(&x) => x,",
      "        };",
      "        l..r",
      "    }",
      "}"
    ]
  },
  "range_add_range_max": {
    "scope": "rust",
    "prefix": "range_add_range_max",
    "body": [
      "use range_add_range_max::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_add_range_max {",
      "    use ac_library::{LazySegtree, MapMonoid, Monoid};",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    use std::ops::{Add, RangeBounds};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeMax<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for RangeMax<T>",
      "    where",
      "        T: Copy + Ord + Bounded,",
      "    {",
      "        type S = T;",
      "        fn identity() -> T {",
      "            T::min_value()",
      "        }",
      "        fn binary_operation(a: &T, b: &T) -> T {",
      "            *a.max(b)",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct AddAction<T> {",
      "        add_val: T,",
      "    }",
      "    impl<T> AddAction<T>",
      "    where",
      "        T: Copy + From<i64>,",
      "    {",
      "        pub fn new(val: T) -> Self {",
      "            Self { add_val: val }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeAddRangeMax<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> MapMonoid for RangeAddRangeMax<T>",
      "    where",
      "        T: Copy + Ord + From<i64> + Bounded + Add<Output = T>,",
      "    {",
      "        type M = RangeMax<T>;",
      "        type F = AddAction<T>;",
      "        fn identity_map() -> Self::F {",
      "            AddAction {",
      "                add_val: T::from(0),",
      "            }",
      "        }",
      "        fn composition(f: &Self::F, g: &Self::F) -> Self::F {",
      "            AddAction {",
      "                add_val: g.add_val + f.add_val,",
      "            }",
      "        }",
      "        fn mapping(f: &Self::F, x: &<Self::M as Monoid>::S) -> <Self::M as Monoid>::S {",
      "            if *x == T::min_value() {",
      "                T::min_value()",
      "            } else {",
      "                *x + f.add_val",
      "            }",
      "        }",
      "    }",
      "    pub trait Bounded {",
      "        fn min_value() -> Self;",
      "        fn max_value() -> Self;",
      "    }",
      "    impl Bounded for i64 {",
      "        fn min_value() -> Self {",
      "            i64::MIN",
      "        }",
      "        fn max_value() -> Self {",
      "            i64::MAX",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct RangeAddRangeMaxSegtree<T>",
      "    where",
      "        T: Copy + Ord + From<i64> + Bounded + Add<Output = T>,",
      "    {",
      "        segtree: LazySegtree<RangeAddRangeMax<T>>,",
      "        len: usize,",
      "    }",
      "    impl<T> RangeAddRangeMaxSegtree<T>",
      "    where",
      "        T: Copy + Ord + From<i64> + Bounded + Add<Output = T>,",
      "    {",
      "        pub fn new(n: usize) -> Self {",
      "            let xs = vec![0.into(); n];",
      "            Self::from_slice(&xs)",
      "        }",
      "        pub fn from_slice(xs: &[T]) -> Self {",
      "            let len = xs.len();",
      "            Self {",
      "                segtree: LazySegtree::from(xs.to_vec()),",
      "                len,",
      "            }",
      "        }",
      "        pub fn set(&mut self, p: usize, x: T) {",
      "            self.segtree.set(p, x);",
      "        }",
      "        pub fn get(&mut self, p: usize) -> T {",
      "            self.segtree.get(p)",
      "        }",
      "        pub fn range_max<R>(&mut self, range: R) -> T",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range)",
      "        }",
      "        pub fn all_max(&self) -> T {",
      "            self.segtree.all_prod()",
      "        }",
      "        pub fn range_add<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, AddAction::new(x))",
      "        }",
      "        /// 左端 `l` を固定し、区間 `[l, r)` での最大値が述語 `g` を満たすような最大の `r` を返します。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn max_right<G>(&mut self, l: usize, g: G) -> usize",
      "        where",
      "            G: Fn(T) -> bool,",
      "        {",
      "            self.segtree.max_right(l, g)",
      "        }",
      "        /// 右端 `r` を固定し、区間 `[l, r)` での最大値が述語 `g` を満たすような最小の `l` を返します。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn min_left<G>(&mut self, r: usize, g: G) -> usize",
      "        where",
      "            G: Fn(T) -> bool,",
      "        {",
      "            self.segtree.min_left(r, g)",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<T> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_add_range_min": {
    "scope": "rust",
    "prefix": "range_add_range_min",
    "body": [
      "use range_add_range_min::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_add_range_min {",
      "    use ac_library::{LazySegtree, MapMonoid, Monoid};",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    use std::ops::{Add, RangeBounds};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeMin<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for RangeMin<T>",
      "    where",
      "        T: Copy + Ord + Bounded,",
      "    {",
      "        type S = T;",
      "        fn identity() -> T {",
      "            T::max_value()",
      "        }",
      "        fn binary_operation(a: &T, b: &T) -> T {",
      "            *a.min(b)",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct AddAction<T> {",
      "        add_val: T,",
      "    }",
      "    impl<T> AddAction<T>",
      "    where",
      "        T: Copy + From<i64>,",
      "    {",
      "        pub fn new(val: T) -> Self {",
      "            Self { add_val: val }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeAddRangeMin<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> MapMonoid for RangeAddRangeMin<T>",
      "    where",
      "        T: Copy + Ord + From<i64> + Bounded + Add<Output = T>,",
      "    {",
      "        type M = RangeMin<T>;",
      "        type F = AddAction<T>;",
      "        fn identity_map() -> Self::F {",
      "            AddAction {",
      "                add_val: T::from(0),",
      "            }",
      "        }",
      "        fn composition(f: &Self::F, g: &Self::F) -> Self::F {",
      "            AddAction {",
      "                add_val: g.add_val + f.add_val,",
      "            }",
      "        }",
      "        fn mapping(f: &Self::F, x: &<Self::M as Monoid>::S) -> <Self::M as Monoid>::S {",
      "            if *x == T::max_value() {",
      "                T::max_value()",
      "            } else {",
      "                *x + f.add_val",
      "            }",
      "        }",
      "    }",
      "    pub trait Bounded {",
      "        fn min_value() -> Self;",
      "        fn max_value() -> Self;",
      "    }",
      "    impl Bounded for i64 {",
      "        fn min_value() -> Self {",
      "            i64::MIN",
      "        }",
      "        fn max_value() -> Self {",
      "            i64::MAX",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct RangeAddRangeMinSegtree<T>",
      "    where",
      "        T: Copy + Ord + From<i64> + Bounded + Add<Output = T>,",
      "    {",
      "        segtree: LazySegtree<RangeAddRangeMin<T>>,",
      "        len: usize,",
      "    }",
      "    impl<T> RangeAddRangeMinSegtree<T>",
      "    where",
      "        T: Copy + Ord + From<i64> + Bounded + Add<Output = T>,",
      "    {",
      "        pub fn new(n: usize) -> Self {",
      "            let xs = vec![0.into(); n];",
      "            Self::from_slice(&xs)",
      "        }",
      "        pub fn from_slice(xs: &[T]) -> Self {",
      "            let len = xs.len();",
      "            Self {",
      "                segtree: LazySegtree::from(xs.to_vec()),",
      "                len,",
      "            }",
      "        }",
      "        pub fn set(&mut self, p: usize, x: T) {",
      "            self.segtree.set(p, x);",
      "        }",
      "        pub fn get(&mut self, p: usize) -> T {",
      "            self.segtree.get(p)",
      "        }",
      "        pub fn range_min<R>(&mut self, range: R) -> T",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range)",
      "        }",
      "        pub fn all_min(&self) -> T {",
      "            self.segtree.all_prod()",
      "        }",
      "        pub fn range_add<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, AddAction::new(x))",
      "        }",
      "        /// 左端 `l` を固定し、区間 `[l, r)` での最小値が述語 `g` を満たすような最大の `r` を返します。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn max_right<G>(&mut self, l: usize, g: G) -> usize",
      "        where",
      "            G: Fn(T) -> bool,",
      "        {",
      "            self.segtree.max_right(l, g)",
      "        }",
      "        /// 右端 `r` を固定し、区間 `[l, r)` での最小値が述語 `g` を満たすような最小の `l` を返します。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn min_left<G>(&mut self, r: usize, g: G) -> usize",
      "        where",
      "            G: Fn(T) -> bool,",
      "        {",
      "            self.segtree.min_left(r, g)",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<T> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_add_range_sum_fenwick_tree": {
    "scope": "rust",
    "prefix": "range_add_range_sum_fenwick_tree",
    "body": [
      "use ab_group::*;",
      "use range_add_range_sum_fenwick_tree::*;",
      "use range_sum_fenwick_tree::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_sum_fenwick_tree {",
      "    use super::{AbGroup, AdditiveAbGroup};",
      "    use std::ops::{Bound, RangeBounds};",
      "    /// 可換群 (AbGroup) を用いた汎用的な Fenwick Tree (Binary Indexed Tree)。",
      "    /// 0-indexed で実装されています。",
      "    /// 基本的な加算・区間和クエリに加え、get/set や、二分探索 (max_right / min_left) を提供します。",
      "    #[derive(Clone)]",
      "    pub struct RangeSumFenwickTreeArbitrary<G: AbGroup> {",
      "        n: usize,",
      "        pub(crate) ary: Vec<G::S>,",
      "    }",
      "    /// i64 の加算群を用いた標準的な Fenwick Tree のエイリアス。",
      "    pub type RangeSumFenwickTreeI64 = RangeSumFenwickTreeArbitrary<AdditiveAbGroup<i64>>;",
      "    /// 任意の数値型 T の加算群を用いた Fenwick Tree のエイリアス。",
      "    pub type RangeSumFenwickTree<T> = RangeSumFenwickTreeArbitrary<AdditiveAbGroup<T>>;",
      "    pub type FenwickTree<T> = RangeSumFenwickTree<T>;",
      "    impl<G: AbGroup> RangeSumFenwickTreeArbitrary<G> {",
      "        /// サイズ `n` の Fenwick Tree を作成します。",
      "        /// 要素はすべて `G::zero()` で初期化されます。",
      "        /// # 計算量",
      "        /// O(n)",
      "        pub fn new(n: usize) -> Self {",
      "            let ary = vec![G::zero(); n];",
      "            RangeSumFenwickTreeArbitrary { n, ary }",
      "        }",
      "        /// 配列スライスから Fenwick Tree を作成します。",
      "        /// # 計算量",
      "        /// O(n)",
      "        pub fn from_slice(slice: &[G::S]) -> Self {",
      "            let n = slice.len();",
      "            let mut ary = slice.to_vec();",
      "            for i in 0..n {",
      "                let j = i | (i + 1);",
      "                if j < n {",
      "                    let val_i = ary[i].clone();",
      "                    ary[j] = G::add(&ary[j], &val_i);",
      "                }",
      "            }",
      "            RangeSumFenwickTreeArbitrary { n, ary }",
      "        }",
      "        /// `[0, idx)` の区間の総和を計算します。",
      "        /// # Panics",
      "        /// `idx > n` の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn prefix_sum(&self, mut idx: usize) -> G::S {",
      "            assert!(",
      "                idx <= self.n,",
      "                \"RangeSumFenwickTreeArbitrary::prefix_sum: index out of bounds. idx: {}, n: {}\",",
      "                idx,",
      "                self.n",
      "            );",
      "            let mut sum = G::zero();",
      "            while idx > 0 {",
      "                sum = G::add(&sum, &self.ary[idx - 1]);",
      "                idx &= idx - 1;",
      "            }",
      "            sum",
      "        }",
      "        /// `idx` 番目の要素に `val` を加算（群の演算を適用）します。",
      "        /// # Panics",
      "        /// `idx >= n` の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn add(&mut self, mut idx: usize, val: G::S) {",
      "            assert!(",
      "                idx < self.n,",
      "                \"RangeSumFenwickTreeArbitrary::add: index out of bounds. idx: {}, n: {}\",",
      "                idx,",
      "                self.n",
      "            );",
      "            let n = self.n;",
      "            idx += 1;",
      "            while idx <= n {",
      "                self.ary[idx - 1] = G::add(&self.ary[idx - 1], &val);",
      "                idx += idx & idx.wrapping_neg();",
      "            }",
      "        }",
      "        fn resolve_range<R: RangeBounds<usize>>(&self, range: R) -> (usize, usize) {",
      "            let l = match range.start_bound() {",
      "                Bound::Included(&l) => l,",
      "                Bound::Excluded(&l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            let r = match range.end_bound() {",
      "                Bound::Included(&r) => r + 1,",
      "                Bound::Excluded(&r) => r,",
      "                Bound::Unbounded => self.n,",
      "            };",
      "            (l, r)",
      "        }",
      "        /// 指定された範囲の区間和を計算します。",
      "        /// # Panics",
      "        /// 範囲が不正、または `n` を超える場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn range_sum<R>(&self, range: R) -> G::S",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            let (l, r) = self.resolve_range(range);",
      "            assert!(",
      "                l <= r && r <= self.n,",
      "                \"RangeSumFenwickTreeArbitrary::range_sum: invalid range. l: {}, r: {}, n: {}\",",
      "                l,",
      "                r,",
      "                self.n",
      "            );",
      "            G::sub(&self.prefix_sum(r), &self.prefix_sum(l))",
      "        }",
      "        /// `l` を左端として、`f(sum(l..r))` が true になる最大の `r` を返します。",
      "        /// `f` は単調性を持つ必要があります。",
      "        /// 具体的には、`f(sum(l..i))` が true ならば、任意の `j < i` に対して `f(sum(l..j))` も true である必要があります。",
      "        /// また、`f(zero)` は true である必要があります。",
      "        /// # Panics",
      "        /// `l > n` または `f(zero)` が false の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn max_right<F>(&self, l: usize, mut f: F) -> usize",
      "        where",
      "            F: FnMut(&G::S) -> bool,",
      "        {",
      "            assert!(",
      "                l <= self.n,",
      "                \"RangeSumFenwickTreeArbitrary::max_right: index out of bounds. l: {}, n: {}\",",
      "                l,",
      "                self.n",
      "            );",
      "            let zero = G::zero();",
      "            assert!(",
      "                f(&zero),",
      "                \"RangeSumFenwickTreeArbitrary::max_right: The predicate f(zero) must be true.\"",
      "            );",
      "            let val_l = self.prefix_sum(l);",
      "            let mut r = 0;",
      "            let mut current_val = G::zero();",
      "            let mut k = if self.n == 0 {",
      "                0",
      "            } else {",
      "                1 << (usize::BITS - 1 - self.n.leading_zeros())",
      "            };",
      "            while k > 0 {",
      "                if r + k <= self.n {",
      "                    let next_val = G::add(&current_val, &self.ary[r + k - 1]);",
      "                    if r + k <= l || f(&G::sub(&next_val, &val_l)) {",
      "                        r += k;",
      "                        current_val = next_val;",
      "                    }",
      "                }",
      "                k >>= 1;",
      "            }",
      "            r",
      "        }",
      "        /// `r` を右端として、`f(sum(l..r))` が true になる最小の `l` を返します。",
      "        /// `f` は単調性を持つ必要があります。",
      "        /// 具体的には、`f(sum(i..r))` が true ならば、任意の `j > i` に対して `f(sum(j..r))` も true である必要があります。",
      "        /// また、`f(zero)` は true である必要があります。",
      "        /// # Panics",
      "        /// `r > n` または `f(zero)` が false の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn min_left<F>(&self, r: usize, mut f: F) -> usize",
      "        where",
      "            F: FnMut(&G::S) -> bool,",
      "        {",
      "            assert!(",
      "                r <= self.n,",
      "                \"RangeSumFenwickTreeArbitrary::min_left: index out of bounds. r: {}, n: {}\",",
      "                r,",
      "                self.n",
      "            );",
      "            let zero = G::zero();",
      "            assert!(",
      "                f(&zero),",
      "                \"RangeSumFenwickTreeArbitrary::min_left: The predicate f(zero) must be true.\"",
      "            );",
      "            let val_r = self.prefix_sum(r);",
      "            if f(&val_r) {",
      "                return 0;",
      "            }",
      "            let mut idx = 0;",
      "            let mut current_val = G::zero();",
      "            let mut k = if self.n == 0 {",
      "                0",
      "            } else {",
      "                1 << (usize::BITS - 1 - self.n.leading_zeros())",
      "            };",
      "            while k > 0 {",
      "                if idx + k <= r {",
      "                    let next_val = G::add(&current_val, &self.ary[idx + k - 1]);",
      "                    if !f(&G::sub(&val_r, &next_val)) {",
      "                        idx += k;",
      "                        current_val = next_val;",
      "                    }",
      "                }",
      "                k >>= 1;",
      "            }",
      "            idx + 1",
      "        }",
      "        /// `idx` 番目の要素の値を取得します。",
      "        /// # Panics",
      "        /// `idx >= n` の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn get(&self, idx: usize) -> G::S {",
      "            assert!(",
      "                idx < self.n,",
      "                \"RangeSumFenwickTreeArbitrary::get: index out of bounds. idx: {}, n: {}\",",
      "                idx,",
      "                self.n",
      "            );",
      "            self.range_sum(idx..=idx)",
      "        }",
      "        /// `idx` 番目の要素の値を `val` に設定します。",
      "        /// # Panics",
      "        /// `idx >= n` の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn set(&mut self, idx: usize, val: G::S) {",
      "            assert!(",
      "                idx < self.n,",
      "                \"RangeSumFenwickTreeArbitrary::set: index out of bounds. idx: {}, n: {}\",",
      "                idx,",
      "                self.n",
      "            );",
      "            let old_val = self.get(idx);",
      "            self.add(idx, G::sub(&val, &old_val));",
      "        }",
      "        /// Fenwick Tree の現在の状態を `Vec<G::S>` として返します。",
      "        /// # 計算量",
      "        /// O(n log n)",
      "        pub fn to_vec(&self) -> Vec<G::S> {",
      "            (0..self.n).map(|i| self.get(i)).collect()",
      "        }",
      "        /// 保持している要素数を返します。",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.n",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::module_inception)]",
      "pub mod ab_group {",
      "    use std::{",
      "        convert::Infallible,",
      "        iter::Sum,",
      "        marker::PhantomData,",
      "        ops::{Add, Neg, Sub},",
      "    };",
      "    /// 可換群 (Abelian Group)",
      "    pub trait AbGroup {",
      "        type S: Clone;",
      "        fn zero() -> Self::S;",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S;",
      "        fn neg(a: &Self::S) -> Self::S;",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            Self::add(a, &Self::neg(b))",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct AdditiveAbGroup<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T: Sum + Add<Output = T> + Sub<Output = T> + Neg<Output = T> + Copy> AbGroup",
      "        for AdditiveAbGroup<T>",
      "    {",
      "        type S = T;",
      "        fn zero() -> Self::S {",
      "            std::iter::empty().sum()",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a + *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            -(*a)",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a - *b",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct XorAbGroup(Infallible);",
      "    impl AbGroup for XorAbGroup {",
      "        type S = u64;",
      "        fn zero() -> Self::S {",
      "            0",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            *a",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::module_inception)]",
      "pub mod range_add_range_sum_fenwick_tree {",
      "    use super::RangeSumFenwickTree;",
      "    use std::iter::Sum;",
      "    use std::ops::{Add, Bound, Mul, Neg, RangeBounds, Sub};",
      "    /// 任意の数値型 T に対して区間加算・区間和取得が可能な Fenwick Tree (Range Add Range Sum Fenwick Tree)。",
      "    #[derive(Clone)]",
      "    pub struct RangeAddRangeSumFenwickTree<T>",
      "    where",
      "        T: Copy + Add<Output = T> + Sub<Output = T> + Mul<i64, Output = T> + Neg<Output = T> + Sum,",
      "    {",
      "        n: usize,",
      "        ft0: RangeSumFenwickTree<T>,",
      "        ft1: RangeSumFenwickTree<T>,",
      "    }",
      "    /// i64 の加算群を用いた標準的な Range Add Range Sum Fenwick Tree のエイリアス。",
      "    pub type RangeAddRangeSumFenwickTreeI64 = RangeAddRangeSumFenwickTree<i64>;",
      "    impl<T> RangeAddRangeSumFenwickTree<T>",
      "    where",
      "        T: Copy + Add<Output = T> + Sub<Output = T> + Mul<i64, Output = T> + Neg<Output = T> + Sum,",
      "    {",
      "        /// サイズ `n` の Range Add Range Sum Fenwick Tree を作成します。",
      "        /// # 計算量",
      "        /// O(n)",
      "        pub fn new(n: usize) -> Self {",
      "            RangeAddRangeSumFenwickTree {",
      "                n,",
      "                ft0: RangeSumFenwickTree::new(n + 1),",
      "                ft1: RangeSumFenwickTree::new(n + 1),",
      "            }",
      "        }",
      "        /// 配列のスライスから Range Add Range Sum Fenwick Tree を作成します。",
      "        /// # 計算量",
      "        /// O(n)",
      "        pub fn from_slice(slice: &[T]) -> Self {",
      "            let n = slice.len();",
      "            let mut d = vec![std::iter::empty::<T>().sum(); n + 1];",
      "            let mut di = vec![std::iter::empty::<T>().sum(); n + 1];",
      "            if n > 0 {",
      "                d[0] = slice[0];",
      "                for i in 1..n {",
      "                    let val = slice[i] - slice[i - 1];",
      "                    d[i] = val;",
      "                    di[i] = val * (i as i64);",
      "                }",
      "                d[n] = -slice[n - 1];",
      "                di[n] = d[n] * (n as i64);",
      "            }",
      "            Self {",
      "                n,",
      "                ft0: RangeSumFenwickTree::from_slice(&d),",
      "                ft1: RangeSumFenwickTree::from_slice(&di),",
      "            }",
      "        }",
      "        /// 指定された範囲 `range` に `val` を加算します。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn range_add<R>(&mut self, range: R, val: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            let (l, r) = self.resolve_range(range);",
      "            assert!(",
      "                l <= r && r <= self.n,",
      "                \"RangeAddRangeSumFenwickTree::range_add: invalid range. l: {}, r: {}, n: {}\",",
      "                l,",
      "                r,",
      "                self.n",
      "            );",
      "            self.ft0.add(l, val);",
      "            self.ft0.add(r, -val);",
      "            let l_val = val * (l as i64);",
      "            let r_val = (-val) * (r as i64);",
      "            self.ft1.add(l, l_val);",
      "            self.ft1.add(r, r_val);",
      "        }",
      "        /// `idx` 番目の要素に `val` を加算します。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn add(&mut self, idx: usize, val: T) {",
      "            self.range_add(idx..=idx, val);",
      "        }",
      "        /// `idx` 番目の要素の値を `val` に設定します。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn set(&mut self, idx: usize, val: T) {",
      "            let old = self.get(idx);",
      "            self.add(idx, val - old);",
      "        }",
      "        /// `[0, idx)` の区間和を計算します。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn prefix_sum(&self, idx: usize) -> T {",
      "            let sum0 = self.ft0.prefix_sum(idx);",
      "            let sum1 = self.ft1.prefix_sum(idx);",
      "            sum0 * (idx as i64) - sum1",
      "        }",
      "        /// 指定された範囲 `range` の区間和を計算します。",
      "        /// # Panics",
      "        /// 範囲が不正な場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn range_sum<R>(&self, range: R) -> T",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            let (l, r) = self.resolve_range(range);",
      "            assert!(",
      "                l <= r && r <= self.n,",
      "                \"RangeAddRangeSumFenwickTree::range_sum: invalid range. l: {}, r: {}, n: {}\",",
      "                l,",
      "                r,",
      "                self.n",
      "            );",
      "            self.prefix_sum(r) - self.prefix_sum(l)",
      "        }",
      "        fn resolve_range<R: RangeBounds<usize>>(&self, range: R) -> (usize, usize) {",
      "            let l = match range.start_bound() {",
      "                Bound::Included(&l) => l,",
      "                Bound::Excluded(&l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            let r = match range.end_bound() {",
      "                Bound::Included(&r) => r + 1,",
      "                Bound::Excluded(&r) => r,",
      "                Bound::Unbounded => self.n,",
      "            };",
      "            (l, r)",
      "        }",
      "        /// `p` 番目の要素を取得します。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn get(&self, p: usize) -> T {",
      "            self.range_sum(p..=p)",
      "        }",
      "        /// `l` を左端として、`f(sum(l..r))` が true になる最大の `r` を返します。",
      "        /// `f` は単調性を持つ必要があります。具体的には元の配列の要素がすべて非負である必要があります。",
      "        /// また、`f(0)` は true である必要があります。",
      "        /// # Panics",
      "        /// `l > n` または `f(0)` が false の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn max_right<F>(&self, l: usize, mut f: F) -> usize",
      "        where",
      "            F: FnMut(&T) -> bool,",
      "        {",
      "            assert!(",
      "                l <= self.n,",
      "                \"RangeAddRangeSumFenwickTree::max_right: index out of bounds. l: {}, n: {}\",",
      "                l,",
      "                self.n",
      "            );",
      "            assert!(",
      "                f(&std::iter::empty::<T>().sum()),",
      "                \"RangeAddRangeSumFenwickTree::max_right: The predicate f(0) must be true.\"",
      "            );",
      "            let val_l = self.prefix_sum(l);",
      "            let mut r = 0;",
      "            let mut sum0: T = std::iter::empty::<T>().sum();",
      "            let mut sum1: T = std::iter::empty::<T>().sum();",
      "            let mut k = if self.n + 1 == 0 {",
      "                0",
      "            } else {",
      "                1 << (usize::BITS - 1 - (self.n + 1).leading_zeros())",
      "            };",
      "            while k > 0 {",
      "                if r + k <= self.n {",
      "                    let next_sum0 = sum0 + self.ft0.ary[r + k - 1];",
      "                    let next_sum1 = sum1 + self.ft1.ary[r + k - 1];",
      "                    let total_sum = next_sum0 * ((r + k) as i64) - next_sum1;",
      "                    let current_range_sum = total_sum - val_l;",
      "                    if r + k <= l || f(&current_range_sum) {",
      "                        r += k;",
      "                        sum0 = next_sum0;",
      "                        sum1 = next_sum1;",
      "                    }",
      "                }",
      "                k >>= 1;",
      "            }",
      "            r",
      "        }",
      "        /// `r` を右端として、`f(sum(l..r))` が true になる最小の `l` を返します。",
      "        /// `f` は単調性を持つ必要があります。具体的には元の配列の要素がすべて非負である必要があります。",
      "        /// また、`f(0)` は true である必要があります。",
      "        /// # Panics",
      "        /// `r > n` または `f(0)` が false の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn min_left<F>(&self, r: usize, mut f: F) -> usize",
      "        where",
      "            F: FnMut(&T) -> bool,",
      "        {",
      "            assert!(",
      "                r <= self.n,",
      "                \"RangeAddRangeSumFenwickTree::min_left: index out of bounds. r: {}, n: {}\",",
      "                r,",
      "                self.n",
      "            );",
      "            assert!(",
      "                f(&std::iter::empty::<T>().sum()),",
      "                \"RangeAddRangeSumFenwickTree::min_left: The predicate f(0) must be true.\"",
      "            );",
      "            let val_r = self.prefix_sum(r);",
      "            if f(&val_r) {",
      "                return 0;",
      "            }",
      "            let mut idx = 0;",
      "            let mut sum0: T = std::iter::empty::<T>().sum();",
      "            let mut sum1: T = std::iter::empty::<T>().sum();",
      "            let mut k = if self.n + 1 == 0 {",
      "                0",
      "            } else {",
      "                1 << (usize::BITS - 1 - (self.n + 1).leading_zeros())",
      "            };",
      "            while k > 0 {",
      "                if idx + k <= r {",
      "                    let next_sum0 = sum0 + self.ft0.ary[idx + k - 1];",
      "                    let next_sum1 = sum1 + self.ft1.ary[idx + k - 1];",
      "                    let total_sum = next_sum0 * ((idx + k) as i64) - next_sum1;",
      "                    let current_range_sum = val_r - total_sum;",
      "                    if !f(&current_range_sum) {",
      "                        idx += k;",
      "                        sum0 = next_sum0;",
      "                        sum1 = next_sum1;",
      "                    }",
      "                }",
      "                k >>= 1;",
      "            }",
      "            idx + 1",
      "        }",
      "        /// 現在の状態を `Vec<T>` として返します。",
      "        /// # 計算量",
      "        /// O(n log n)",
      "        pub fn to_vec(&self) -> Vec<T> {",
      "            (0..self.n).map(|i| self.get(i)).collect()",
      "        }",
      "        /// 保持している要素数を返します。",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.n",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_affine_dual_segtree": {
    "scope": "rust",
    "prefix": "range_affine_dual_segtree",
    "body": [
      "use range_affine_dual_segtree::*;",
      "pub mod range_affine_dual_segtree {",
      "    use super::dual_segtree::*;",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    use std::ops::{Add, Mul};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct Affine<T> {",
      "        pub slope: T,",
      "        pub intercept: T,",
      "    }",
      "    impl<T> Affine<T> {",
      "        pub fn new(slope: T, intercept: T) -> Affine<T> {",
      "            Affine { slope, intercept }",
      "        }",
      "    }",
      "    impl<T> Affine<T>",
      "    where",
      "        T: From<i64>,",
      "    {",
      "        /// 区間変更用（定数関数）",
      "        pub fn constant_func(x: T) -> Affine<T> {",
      "            Affine {",
      "                slope: 0.into(),",
      "                intercept: x,",
      "            }",
      "        }",
      "        /// 区間加算用",
      "        pub fn addition_func(x: T) -> Affine<T> {",
      "            Affine {",
      "                slope: 1.into(),",
      "                intercept: x,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct AffineMonoid<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> MapMonoid for AffineMonoid<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        type F = Affine<T>;",
      "        type S = T;",
      "        fn identity_map() -> Affine<T> {",
      "            Affine {",
      "                slope: 1.into(),",
      "                intercept: 0.into(),",
      "            }",
      "        }",
      "        fn composition(a: &Affine<T>, b: &Affine<T>) -> Affine<T> {",
      "            Affine {",
      "                slope: a.slope * b.slope,",
      "                intercept: a.slope * b.intercept + a.intercept,",
      "            }",
      "        }",
      "        fn mapping(f: &Affine<T>, x: &T) -> T {",
      "            f.slope * *x + f.intercept",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_affine_range_minmax": {
    "scope": "rust",
    "prefix": "range_affine_range_minmax",
    "body": [
      "use range_affine_range_minmax::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_affine_range_minmax {",
      "    use ac_library::{LazySegtree, MapMonoid, Monoid};",
      "    use itertools::Itertools;",
      "    use std::{cmp::Ordering, convert::Infallible, ops::RangeBounds};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeMinMax {",
      "        pub min: i64,",
      "        pub max: i64,",
      "        pub len: i64,",
      "    }",
      "    impl RangeMinMax {",
      "        pub fn new(min: i64, max: i64, len: i64) -> Self {",
      "            Self { min, max, len }",
      "        }",
      "        pub fn unit(x: i64) -> Self {",
      "            Self {",
      "                min: x,",
      "                max: x,",
      "                len: 1,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct Affine {",
      "        pub slope: i64,",
      "        pub intercept: i64,",
      "    }",
      "    impl Affine {",
      "        /// 区間変更用（定数関数）",
      "        pub fn constant_func(x: i64) -> Affine {",
      "            Affine {",
      "                slope: 0,",
      "                intercept: x,",
      "            }",
      "        }",
      "        /// 区間加算用",
      "        pub fn addition_func(x: i64) -> Affine {",
      "            Affine {",
      "                slope: 1,",
      "                intercept: x,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeMinMaxMonoid(Infallible);",
      "    impl Monoid for RangeMinMaxMonoid {",
      "        type S = RangeMinMax;",
      "        fn identity() -> RangeMinMax {",
      "            RangeMinMax {",
      "                min: i64::MAX,",
      "                max: i64::MIN,",
      "                len: 0,",
      "            }",
      "        }",
      "        fn binary_operation(a: &RangeMinMax, b: &RangeMinMax) -> RangeMinMax {",
      "            RangeMinMax {",
      "                min: i64::min(a.min, b.min),",
      "                max: i64::max(a.max, b.max),",
      "                len: a.len + b.len,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeAffineRangeMinMax(Infallible);",
      "    impl MapMonoid for RangeAffineRangeMinMax {",
      "        type M = RangeMinMaxMonoid;",
      "        type F = Affine;",
      "        fn identity_map() -> Affine {",
      "            Affine {",
      "                slope: 1,",
      "                intercept: 0,",
      "            }",
      "        }",
      "        fn composition(a: &Affine, b: &Affine) -> Affine {",
      "            Affine {",
      "                slope: a.slope * b.slope,",
      "                intercept: a.slope * b.intercept + a.intercept,",
      "            }",
      "        }",
      "        fn mapping(f: &Affine, x: &RangeMinMax) -> RangeMinMax {",
      "            if x.len == 0 {",
      "                return RangeMinMaxMonoid::identity();",
      "            }",
      "            match f.slope.cmp(&0) {",
      "                Ordering::Equal => RangeMinMax {",
      "                    min: f.intercept,",
      "                    max: f.intercept,",
      "                    len: x.len,",
      "                },",
      "                Ordering::Greater => RangeMinMax {",
      "                    min: f.intercept + f.slope * x.min,",
      "                    max: f.intercept + f.slope * x.max,",
      "                    len: x.len,",
      "                },",
      "                Ordering::Less => RangeMinMax {",
      "                    min: f.intercept + f.slope * x.max,",
      "                    max: f.intercept + f.slope * x.min,",
      "                    len: x.len,",
      "                },",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct RangeAffineRangeMinMaxSegtree {",
      "        segtree: LazySegtree<RangeAffineRangeMinMax>,",
      "        len: usize,",
      "    }",
      "    impl RangeAffineRangeMinMaxSegtree {",
      "        pub fn new(n: usize) -> Self {",
      "            let xs = vec![0; n];",
      "            Self::from_slice(&xs)",
      "        }",
      "        pub fn from_slice(xs: &[i64]) -> RangeAffineRangeMinMaxSegtree {",
      "            let initial_data = xs.iter().copied().map(RangeMinMax::unit).collect_vec();",
      "            let len = initial_data.len();",
      "            RangeAffineRangeMinMaxSegtree {",
      "                segtree: LazySegtree::from(initial_data),",
      "                len,",
      "            }",
      "        }",
      "        pub fn set(&mut self, p: usize, x: i64) {",
      "            self.segtree.set(p, RangeMinMax::unit(x));",
      "        }",
      "        pub fn get(&mut self, p: usize) -> i64 {",
      "            self.segtree.get(p).min",
      "        }",
      "        pub fn range_min<R>(&mut self, range: R) -> i64",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range).min",
      "        }",
      "        pub fn range_max<R>(&mut self, range: R) -> i64",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range).max",
      "        }",
      "        pub fn all_min(&self) -> i64 {",
      "            self.segtree.all_prod().min",
      "        }",
      "        pub fn all_max(&self) -> i64 {",
      "            self.segtree.all_prod().max",
      "        }",
      "        pub fn affine(&mut self, p: usize, slope: i64, intercept: i64) {",
      "            self.segtree.apply(p, Affine { slope, intercept })",
      "        }",
      "        pub fn update(&mut self, p: usize, x: i64) {",
      "            self.segtree.apply(p, Affine::constant_func(x))",
      "        }",
      "        pub fn add(&mut self, p: usize, x: i64) {",
      "            self.segtree.apply(p, Affine::addition_func(x))",
      "        }",
      "        pub fn range_affine<R>(&mut self, range: R, slope: i64, intercept: i64)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, Affine { slope, intercept })",
      "        }",
      "        pub fn range_update<R>(&mut self, range: R, x: i64)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, Affine::constant_func(x))",
      "        }",
      "        pub fn range_add<R>(&mut self, range: R, x: i64)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, Affine::addition_func(x))",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<i64> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_affine_range_sum": {
    "scope": "rust",
    "prefix": "range_affine_range_sum",
    "body": [
      "use range_affine_range_sum::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_affine_range_sum {",
      "    use ac_library::{LazySegtree, MapMonoid, Monoid};",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    use std::ops::{Add, Mul, RangeBounds};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeSum<T> {",
      "        pub sum: T,",
      "        pub len: i64,",
      "    }",
      "    impl<T> RangeSum<T> {",
      "        pub fn unit(x: T) -> RangeSum<T> {",
      "            RangeSum { sum: x, len: 1 }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct Affine<T> {",
      "        pub slope: T,",
      "        pub intercept: T,",
      "    }",
      "    impl<T> Affine<T>",
      "    where",
      "        T: From<i64>,",
      "    {",
      "        /// 区間変更用（定数関数）",
      "        pub fn constant_func(x: T) -> Affine<T> {",
      "            Affine {",
      "                slope: 0.into(),",
      "                intercept: x,",
      "            }",
      "        }",
      "        /// 区間加算用",
      "        pub fn addition_func(x: T) -> Affine<T> {",
      "            Affine {",
      "                slope: 1.into(),",
      "                intercept: x,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct ValueLenSum<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for ValueLenSum<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        type S = RangeSum<T>;",
      "        fn identity() -> RangeSum<T> {",
      "            RangeSum {",
      "                sum: 0.into(),",
      "                len: 0,",
      "            }",
      "        }",
      "        fn binary_operation(a: &RangeSum<T>, b: &RangeSum<T>) -> RangeSum<T> {",
      "            RangeSum {",
      "                sum: a.sum + b.sum,",
      "                len: a.len + b.len,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeAffineRangeSum<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> MapMonoid for RangeAffineRangeSum<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        type M = ValueLenSum<T>;",
      "        type F = Affine<T>;",
      "        fn identity_map() -> Affine<T> {",
      "            Affine {",
      "                slope: 1.into(),",
      "                intercept: 0.into(),",
      "            }",
      "        }",
      "        fn composition(a: &Affine<T>, b: &Affine<T>) -> Affine<T> {",
      "            Affine {",
      "                slope: a.slope * b.slope,",
      "                intercept: a.slope * b.intercept + a.intercept,",
      "            }",
      "        }",
      "        fn mapping(f: &Affine<T>, x: &RangeSum<T>) -> RangeSum<T> {",
      "            RangeSum {",
      "                sum: f.slope * x.sum + f.intercept * x.len.into(),",
      "                len: x.len,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct RangeAffineRangeSumSegtree<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        segtree: LazySegtree<RangeAffineRangeSum<T>>,",
      "        len: usize,",
      "    }",
      "    impl<T> RangeAffineRangeSumSegtree<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        pub fn new(n: usize) -> Self {",
      "            let xs = vec![0.into(); n];",
      "            Self::from_slice(&xs)",
      "        }",
      "        pub fn from_slice(xs: &[T]) -> RangeAffineRangeSumSegtree<T> {",
      "            let xs = xs.iter().copied().map(RangeSum::unit).collect_vec();",
      "            let len = xs.len();",
      "            RangeAffineRangeSumSegtree {",
      "                segtree: LazySegtree::from(xs),",
      "                len,",
      "            }",
      "        }",
      "        pub fn set(&mut self, p: usize, x: T) {",
      "            self.segtree.set(p, RangeSum::unit(x));",
      "        }",
      "        pub fn get(&mut self, p: usize) -> T {",
      "            self.segtree.get(p).sum",
      "        }",
      "        pub fn range_sum<R>(&mut self, range: R) -> T",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range).sum",
      "        }",
      "        pub fn all_sum(&self) -> T {",
      "            self.segtree.all_prod().sum",
      "        }",
      "        pub fn affine(&mut self, p: usize, slope: T, intercept: T) {",
      "            self.segtree.apply(p, Affine { slope, intercept })",
      "        }",
      "        pub fn update(&mut self, p: usize, x: T) {",
      "            self.segtree.apply(p, Affine::constant_func(x))",
      "        }",
      "        pub fn add(&mut self, p: usize, x: T) {",
      "            self.segtree.apply(p, Affine::addition_func(x))",
      "        }",
      "        pub fn range_affine<R>(&mut self, range: R, slope: T, intercept: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, Affine { slope, intercept })",
      "        }",
      "        pub fn range_update<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, Affine::constant_func(x))",
      "        }",
      "        pub fn range_add<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, Affine::addition_func(x))",
      "        }",
      "        /// 左端 `l` を固定し、区間 `[l, r)` での総和が述語 `g` を満たすような最大の `r` を返します。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn max_right<G>(&mut self, l: usize, g: G) -> usize",
      "        where",
      "            G: Fn(T) -> bool,",
      "        {",
      "            self.segtree.max_right(l, |x| g(x.sum))",
      "        }",
      "        /// 右端 `r` を固定し、区間 `[l, r)` での総和が述語 `g` を満たすような最小の `l` を返します。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn min_left<G>(&mut self, r: usize, g: G) -> usize",
      "        where",
      "            G: Fn(T) -> bool,",
      "        {",
      "            self.segtree.min_left(r, |x| g(x.sum))",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<T> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_affine_range_sum_of_square": {
    "scope": "rust",
    "prefix": "range_affine_range_sum_of_square",
    "body": [
      "use range_affine_range_sum_of_square::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_affine_range_sum_of_square {",
      "    use ac_library::{LazySegtree, MapMonoid, Monoid};",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    use std::ops::{Add, Mul, RangeBounds};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeSum<T> {",
      "        pub sum_sq: T,",
      "        pub sum: T,",
      "        pub len: i64,",
      "    }",
      "    impl<T> RangeSum<T>",
      "    where",
      "        T: Copy + Mul<Output = T>,",
      "    {",
      "        pub fn unit(x: T) -> RangeSum<T> {",
      "            RangeSum {",
      "                sum_sq: x * x,",
      "                sum: x,",
      "                len: 1,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct Affine<T> {",
      "        pub slope: T,",
      "        pub intercept: T,",
      "    }",
      "    impl<T> Affine<T>",
      "    where",
      "        T: From<i64>,",
      "    {",
      "        /// 区間変更用（定数関数）",
      "        pub fn constant_func(x: T) -> Affine<T> {",
      "            Affine {",
      "                slope: 0.into(),",
      "                intercept: x,",
      "            }",
      "        }",
      "        /// 区間加算用",
      "        pub fn addition_func(x: T) -> Affine<T> {",
      "            Affine {",
      "                slope: 1.into(),",
      "                intercept: x,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct ValueLenSum<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for ValueLenSum<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        type S = RangeSum<T>;",
      "        fn identity() -> RangeSum<T> {",
      "            RangeSum {",
      "                sum_sq: 0.into(),",
      "                sum: 0.into(),",
      "                len: 0,",
      "            }",
      "        }",
      "        fn binary_operation(a: &RangeSum<T>, b: &RangeSum<T>) -> RangeSum<T> {",
      "            RangeSum {",
      "                sum_sq: a.sum_sq + b.sum_sq,",
      "                sum: a.sum + b.sum,",
      "                len: a.len + b.len,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeAffineRangeSumOfSquare<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> MapMonoid for RangeAffineRangeSumOfSquare<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        type M = ValueLenSum<T>;",
      "        type F = Affine<T>;",
      "        fn identity_map() -> Affine<T> {",
      "            Affine {",
      "                slope: 1.into(),",
      "                intercept: 0.into(),",
      "            }",
      "        }",
      "        fn composition(a: &Affine<T>, b: &Affine<T>) -> Affine<T> {",
      "            Affine {",
      "                slope: a.slope * b.slope,",
      "                intercept: a.slope * b.intercept + a.intercept,",
      "            }",
      "        }",
      "        fn mapping(f: &Affine<T>, x: &RangeSum<T>) -> RangeSum<T> {",
      "            let a = f.slope;",
      "            let b = f.intercept;",
      "            let len_t: T = x.len.into();",
      "            let new_sum_sq = a * a * x.sum_sq + (a + a) * b * x.sum + b * b * len_t;",
      "            let new_sum = a * x.sum + b * len_t;",
      "            RangeSum {",
      "                sum_sq: new_sum_sq,",
      "                sum: new_sum,",
      "                len: x.len,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct RangeAffineRangeSumOfSquareSegtree<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        segtree: LazySegtree<RangeAffineRangeSumOfSquare<T>>,",
      "        len: usize,",
      "    }",
      "    impl<T> RangeAffineRangeSumOfSquareSegtree<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        pub fn new(n: usize) -> Self {",
      "            let xs = vec![0.into(); n];",
      "            Self::from_slice(&xs)",
      "        }",
      "        pub fn from_slice(xs: &[T]) -> RangeAffineRangeSumOfSquareSegtree<T> {",
      "            let xs = xs.iter().copied().map(RangeSum::unit).collect_vec();",
      "            let len = xs.len();",
      "            RangeAffineRangeSumOfSquareSegtree {",
      "                segtree: LazySegtree::from(xs),",
      "                len,",
      "            }",
      "        }",
      "        pub fn set(&mut self, p: usize, x: T) {",
      "            self.segtree.set(p, RangeSum::unit(x));",
      "        }",
      "        pub fn get(&mut self, p: usize) -> T {",
      "            self.segtree.get(p).sum",
      "        }",
      "        pub fn range_sum_of_square<R>(&mut self, range: R) -> T",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range).sum_sq",
      "        }",
      "        pub fn all_sum_of_square(&self) -> T {",
      "            self.segtree.all_prod().sum_sq",
      "        }",
      "        pub fn range_sum<R>(&mut self, range: R) -> T",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range).sum",
      "        }",
      "        pub fn all_sum(&self) -> T {",
      "            self.segtree.all_prod().sum",
      "        }",
      "        pub fn affine(&mut self, p: usize, slope: T, intercept: T) {",
      "            self.segtree.apply(p, Affine { slope, intercept })",
      "        }",
      "        pub fn update(&mut self, p: usize, x: T) {",
      "            self.segtree.apply(p, Affine::constant_func(x))",
      "        }",
      "        pub fn add(&mut self, p: usize, x: T) {",
      "            self.segtree.apply(p, Affine::addition_func(x))",
      "        }",
      "        pub fn range_affine<R>(&mut self, range: R, slope: T, intercept: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, Affine { slope, intercept })",
      "        }",
      "        pub fn range_update<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, Affine::constant_func(x))",
      "        }",
      "        pub fn range_add<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, Affine::addition_func(x))",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<T> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_chmax_range_max": {
    "scope": "rust",
    "prefix": "range_chmax_range_max",
    "body": [
      "use range_chmax_range_max::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_chmax_range_max {",
      "    use ac_library::lazysegtree::MapMonoid;",
      "    use ac_library::LazySegtree;",
      "    use ac_library::Max;",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    use std::ops::RangeBounds;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeChmaxRangeMax(Infallible);",
      "    impl MapMonoid for RangeChmaxRangeMax {",
      "        type M = Max<i64>;",
      "        type F = i64;",
      "        fn identity_map() -> Self::F {",
      "            i64::MIN",
      "        }",
      "        fn mapping(",
      "            f: &Self::F,",
      "            x: &<Self::M as ac_library::Monoid>::S,",
      "        ) -> <Self::M as ac_library::Monoid>::S {",
      "            (*f).max(*x)",
      "        }",
      "        fn composition(f: &Self::F, g: &Self::F) -> Self::F {",
      "            (*f).max(*g)",
      "        }",
      "    }",
      "    pub struct RangeChmaxRangeMaxSegtree {",
      "        segtree: LazySegtree<RangeChmaxRangeMax>,",
      "        len: usize,",
      "    }",
      "    impl RangeChmaxRangeMaxSegtree {",
      "        pub fn new(n: usize) -> Self {",
      "            let xs = vec![0; n];",
      "            Self::from_slice(&xs)",
      "        }",
      "        pub fn from_slice(xs: &[i64]) -> RangeChmaxRangeMaxSegtree {",
      "            let len = xs.len();",
      "            RangeChmaxRangeMaxSegtree {",
      "                segtree: LazySegtree::from(xs.to_vec()),",
      "                len,",
      "            }",
      "        }",
      "        pub fn set(&mut self, p: usize, x: i64) {",
      "            self.segtree.set(p, x);",
      "        }",
      "        pub fn get(&mut self, p: usize) -> i64 {",
      "            self.segtree.get(p)",
      "        }",
      "        pub fn range_max<R>(&mut self, range: R) -> i64",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range)",
      "        }",
      "        pub fn all_max(&self) -> i64 {",
      "            self.segtree.all_prod()",
      "        }",
      "        pub fn chmax(&mut self, p: usize, x: i64) {",
      "            self.segtree.apply(p, x)",
      "        }",
      "        pub fn range_chmax<R>(&mut self, range: R, x: i64)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, x)",
      "        }",
      "        /// 左端 `l` を固定し、区間 `[l, r)` での最大値が述語 `g` を満たすような最大の `r` を返します。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn max_right<G>(&mut self, l: usize, g: G) -> usize",
      "        where",
      "            G: Fn(i64) -> bool,",
      "        {",
      "            self.segtree.max_right(l, g)",
      "        }",
      "        /// 右端 `r` を固定し、区間 `[l, r)` での最大値が述語 `g` を満たすような最小の `l` を返します。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn min_left<G>(&mut self, r: usize, g: G) -> usize",
      "        where",
      "            G: Fn(i64) -> bool,",
      "        {",
      "            self.segtree.min_left(r, g)",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<i64> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_chmax_range_sum": {
    "scope": "rust",
    "prefix": "range_chmax_range_sum",
    "body": [
      "use abstract_segtree_beats::*;",
      "use range_chmax_range_sum::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod abstract_segtree_beats {",
      "    fn ceil_pow2(n: u32) -> u32 {",
      "        32 - n.saturating_sub(1).leading_zeros()",
      "    }",
      "    pub trait MonoidBeats {",
      "        type S: Clone;",
      "        fn identity() -> Self::S;",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S;",
      "        fn fails(a: &Self::S) -> bool;",
      "    }",
      "    pub trait MapMonoidBeats {",
      "        type M: MonoidBeats;",
      "        type F: Clone;",
      "        fn identity_element() -> <Self::M as MonoidBeats>::S {",
      "            Self::M::identity()",
      "        }",
      "        fn binary_operation(",
      "            a: &<Self::M as MonoidBeats>::S,",
      "            b: &<Self::M as MonoidBeats>::S,",
      "        ) -> <Self::M as MonoidBeats>::S {",
      "            Self::M::binary_operation(a, b)",
      "        }",
      "        fn fails(a: &<Self::M as MonoidBeats>::S) -> bool {",
      "            Self::M::fails(a)",
      "        }",
      "        fn identity_map() -> Self::F;",
      "        fn mapping(f: &Self::F, x: &<Self::M as MonoidBeats>::S) -> <Self::M as MonoidBeats>::S;",
      "        fn composition(f: &Self::F, g: &Self::F) -> Self::F;",
      "    }",
      "    impl<F: MapMonoidBeats> Default for SegtreeBeats<F> {",
      "        fn default() -> Self {",
      "            Self::new(0)",
      "        }",
      "    }",
      "    impl<F: MapMonoidBeats> SegtreeBeats<F> {",
      "        pub fn new(n: usize) -> Self {",
      "            vec![F::identity_element(); n].into()",
      "        }",
      "    }",
      "    impl<F: MapMonoidBeats> From<Vec<<F::M as MonoidBeats>::S>> for SegtreeBeats<F> {",
      "        fn from(v: Vec<<F::M as MonoidBeats>::S>) -> Self {",
      "            let n = v.len();",
      "            let log = ceil_pow2(n as u32) as usize;",
      "            let size = 1 << log;",
      "            let mut d = vec![F::identity_element(); 2 * size];",
      "            let lz = vec![F::identity_map(); size];",
      "            d[size..(size + n)].clone_from_slice(&v);",
      "            let mut ret = SegtreeBeats {",
      "                n,",
      "                size,",
      "                log,",
      "                d,",
      "                lz,",
      "            };",
      "            for i in (1..size).rev() {",
      "                ret.update(i);",
      "            }",
      "            ret",
      "        }",
      "    }",
      "    impl<F: MapMonoidBeats> SegtreeBeats<F> {",
      "        pub fn set(&mut self, mut p: usize, x: <F::M as MonoidBeats>::S) {",
      "            assert!(p < self.n);",
      "            p += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(p >> i);",
      "            }",
      "            self.d[p] = x;",
      "            for i in 1..=self.log {",
      "                self.update(p >> i);",
      "            }",
      "        }",
      "        pub fn get(&mut self, mut p: usize) -> <F::M as MonoidBeats>::S {",
      "            assert!(p < self.n);",
      "            p += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(p >> i);",
      "            }",
      "            self.d[p].clone()",
      "        }",
      "        pub fn prod<R>(&mut self, range: R) -> <F::M as MonoidBeats>::S",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            if range.start_bound() == Bound::Unbounded && range.end_bound() == Bound::Unbounded {",
      "                return self.all_prod();",
      "            }",
      "            let mut r = match range.end_bound() {",
      "                Bound::Included(r) => r + 1,",
      "                Bound::Excluded(r) => *r,",
      "                Bound::Unbounded => self.n,",
      "            };",
      "            let mut l = match range.start_bound() {",
      "                Bound::Included(l) => *l,",
      "                Bound::Excluded(l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            assert!(l <= r && r <= self.n);",
      "            if l == r {",
      "                return F::identity_element();",
      "            }",
      "            l += self.size;",
      "            r += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                if ((l >> i) << i) != l {",
      "                    self.push(l >> i);",
      "                }",
      "                if ((r >> i) << i) != r {",
      "                    self.push(r >> i);",
      "                }",
      "            }",
      "            let mut sml = F::identity_element();",
      "            let mut smr = F::identity_element();",
      "            while l < r {",
      "                if l & 1 != 0 {",
      "                    sml = F::binary_operation(&sml, &self.d[l]);",
      "                    l += 1;",
      "                }",
      "                if r & 1 != 0 {",
      "                    r -= 1;",
      "                    smr = F::binary_operation(&self.d[r], &smr);",
      "                }",
      "                l >>= 1;",
      "                r >>= 1;",
      "            }",
      "            F::binary_operation(&sml, &smr)",
      "        }",
      "        pub fn all_prod(&self) -> <F::M as MonoidBeats>::S {",
      "            self.d[1].clone()",
      "        }",
      "        pub fn apply(&mut self, mut p: usize, f: F::F) {",
      "            assert!(p < self.n);",
      "            p += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(p >> i);",
      "            }",
      "            self.d[p] = F::mapping(&f, &self.d[p]);",
      "            for i in 1..=self.log {",
      "                self.update(p >> i);",
      "            }",
      "        }",
      "        pub fn apply_range<R>(&mut self, range: R, f: F::F)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            let mut r = match range.end_bound() {",
      "                Bound::Included(r) => r + 1,",
      "                Bound::Excluded(r) => *r,",
      "                Bound::Unbounded => self.n,",
      "            };",
      "            let mut l = match range.start_bound() {",
      "                Bound::Included(l) => *l,",
      "                Bound::Excluded(l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            assert!(l <= r && r <= self.n);",
      "            if l == r {",
      "                return;",
      "            }",
      "            l += self.size;",
      "            r += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                if ((l >> i) << i) != l {",
      "                    self.push(l >> i);",
      "                }",
      "                if ((r >> i) << i) != r {",
      "                    self.push((r - 1) >> i);",
      "                }",
      "            }",
      "            {",
      "                let l2 = l;",
      "                let r2 = r;",
      "                while l < r {",
      "                    if l & 1 != 0 {",
      "                        self.all_apply(l, f.clone());",
      "                        l += 1;",
      "                    }",
      "                    if r & 1 != 0 {",
      "                        r -= 1;",
      "                        self.all_apply(r, f.clone());",
      "                    }",
      "                    l >>= 1;",
      "                    r >>= 1;",
      "                }",
      "                l = l2;",
      "                r = r2;",
      "            }",
      "            for i in 1..=self.log {",
      "                if ((l >> i) << i) != l {",
      "                    self.update(l >> i);",
      "                }",
      "                if ((r >> i) << i) != r {",
      "                    self.update((r - 1) >> i);",
      "                }",
      "            }",
      "        }",
      "        pub fn max_right<G>(&mut self, mut l: usize, g: G) -> usize",
      "        where",
      "            G: Fn(<F::M as MonoidBeats>::S) -> bool,",
      "        {",
      "            assert!(l <= self.n);",
      "            assert!(g(F::identity_element()));",
      "            if l == self.n {",
      "                return self.n;",
      "            }",
      "            l += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(l >> i);",
      "            }",
      "            let mut sm = F::identity_element();",
      "            while {",
      "                while l % 2 == 0 {",
      "                    l >>= 1;",
      "                }",
      "                if !g(F::binary_operation(&sm, &self.d[l])) {",
      "                    while l < self.size {",
      "                        self.push(l);",
      "                        l *= 2;",
      "                        let res = F::binary_operation(&sm, &self.d[l]);",
      "                        if g(res.clone()) {",
      "                            sm = res;",
      "                            l += 1;",
      "                        }",
      "                    }",
      "                    return l - self.size;",
      "                }",
      "                sm = F::binary_operation(&sm, &self.d[l]);",
      "                l += 1;",
      "                {",
      "                    let l = l as isize;",
      "                    (l & -l) != l",
      "                }",
      "            } {}",
      "            self.n",
      "        }",
      "        pub fn min_left<G>(&mut self, mut r: usize, g: G) -> usize",
      "        where",
      "            G: Fn(<F::M as MonoidBeats>::S) -> bool,",
      "        {",
      "            assert!(r <= self.n);",
      "            assert!(g(F::identity_element()));",
      "            if r == 0 {",
      "                return 0;",
      "            }",
      "            r += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push((r - 1) >> i);",
      "            }",
      "            let mut sm = F::identity_element();",
      "            while {",
      "                r -= 1;",
      "                while r > 1 && r % 2 != 0 {",
      "                    r >>= 1;",
      "                }",
      "                if !g(F::binary_operation(&self.d[r], &sm)) {",
      "                    while r < self.size {",
      "                        self.push(r);",
      "                        r = 2 * r + 1;",
      "                        let res = F::binary_operation(&self.d[r], &sm);",
      "                        if g(res.clone()) {",
      "                            sm = res;",
      "                            r -= 1;",
      "                        }",
      "                    }",
      "                    return r + 1 - self.size;",
      "                }",
      "                sm = F::binary_operation(&self.d[r], &sm);",
      "                {",
      "                    let r = r as isize;",
      "                    (r & -r) != r",
      "                }",
      "            } {}",
      "            0",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<<F::M as MonoidBeats>::S> {",
      "            (0..self.n).map(|i| self.get(i)).collect()",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct SegtreeBeats<F>",
      "    where",
      "        F: MapMonoidBeats,",
      "    {",
      "        n: usize,",
      "        size: usize,",
      "        log: usize,",
      "        d: Vec<<F::M as MonoidBeats>::S>,",
      "        lz: Vec<F::F>,",
      "    }",
      "    impl<F> SegtreeBeats<F>",
      "    where",
      "        F: MapMonoidBeats,",
      "    {",
      "        fn update(&mut self, k: usize) {",
      "            self.d[k] = F::binary_operation(&self.d[2 * k], &self.d[2 * k + 1]);",
      "        }",
      "        fn all_apply(&mut self, k: usize, f: F::F) {",
      "            self.d[k] = F::mapping(&f, &self.d[k]);",
      "            if k < self.size {",
      "                self.lz[k] = F::composition(&f, &self.lz[k]);",
      "                if F::fails(&self.d[k]) {",
      "                    self.push(k);",
      "                    self.update(k)",
      "                }",
      "            }",
      "        }",
      "        fn push(&mut self, k: usize) {",
      "            self.all_apply(2 * k, self.lz[k].clone());",
      "            self.all_apply(2 * k + 1, self.lz[k].clone());",
      "            self.lz[k] = F::identity_map();",
      "        }",
      "    }",
      "    use std::{",
      "        fmt::{Debug, Error, Formatter, Write},",
      "        ops::{Bound, RangeBounds},",
      "    };",
      "    impl<F> Debug for SegtreeBeats<F>",
      "    where",
      "        F: MapMonoidBeats,",
      "        F::F: Debug,",
      "        <F::M as MonoidBeats>::S: Debug,",
      "    {",
      "        fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {",
      "            for i in 0..self.log {",
      "                for j in 0..1 << i {",
      "                    f.write_fmt(format_args!(",
      "                        \"{:?}[{:?}]\\t\",",
      "                        self.d[(1 << i) + j],",
      "                        self.lz[(1 << i) + j]",
      "                    ))?;",
      "                }",
      "                f.write_char('\\n')?;",
      "            }",
      "            for i in 0..self.size {",
      "                f.write_fmt(format_args!(\"{:?}\\t\", self.d[self.size + i]))?;",
      "            }",
      "            Ok(())",
      "        }",
      "    }",
      "}",
      "pub mod range_chmax_range_sum {",
      "    use super::{MapMonoidBeats, MonoidBeats, SegtreeBeats};",
      "    use itertools::Itertools;",
      "    use std::{",
      "        cmp::{max, min},",
      "        convert::Infallible,",
      "        ops::RangeBounds,",
      "    };",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct RangeSum {",
      "        pub sum: i64,",
      "        pub len: usize,",
      "        pub min: i64,",
      "        pub min_cnt: usize,",
      "        pub min_2nd: i64,",
      "    }",
      "    impl RangeSum {",
      "        pub fn unit(x: i64) -> Option<RangeSum> {",
      "            Some(RangeSum {",
      "                sum: x,",
      "                len: 1,",
      "                min: x,",
      "                min_cnt: 1,",
      "                min_2nd: i64::MAX,",
      "            })",
      "        }",
      "    }",
      "    fn second_smallest(a0: i64, a1: i64, b0: i64, b1: i64) -> i64 {",
      "        if a0 == b0 {",
      "            min(a1, b1)",
      "        } else if a1 <= b0 {",
      "            a1",
      "        } else if b1 <= a0 {",
      "            b1",
      "        } else {",
      "            max(a0, b0)",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeSumMonoid(Infallible);",
      "    impl MonoidBeats for RangeSumMonoid {",
      "        type S = Option<RangeSum>;",
      "        fn identity() -> Self::S {",
      "            Some(RangeSum {",
      "                sum: 0,",
      "                len: 0,",
      "                min: i64::MAX,",
      "                min_cnt: 0,",
      "                min_2nd: i64::MAX,",
      "            })",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            match (a, b) {",
      "                (None, None) => None,",
      "                (None, Some(_)) => None,",
      "                (Some(_), None) => None,",
      "                (Some(a), Some(b)) => Some(RangeSum {",
      "                    sum: a.sum + b.sum,",
      "                    len: a.len + b.len,",
      "                    min: min(a.min, b.min),",
      "                    min_cnt: a.min_cnt * (a.min <= b.min) as usize",
      "                        + b.min_cnt * (b.min <= a.min) as usize,",
      "                    min_2nd: second_smallest(a.min, a.min_2nd, b.min, b.min_2nd),",
      "                }),",
      "            }",
      "        }",
      "        fn fails(a: &Self::S) -> bool {",
      "            a.is_none()",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct ChmaxFunc {",
      "        pub chmax_val: i64,",
      "    }",
      "    impl ChmaxFunc {",
      "        pub fn new(x: i64) -> Self {",
      "            ChmaxFunc { chmax_val: x }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeChmaxRangeSum(Infallible);",
      "    impl MapMonoidBeats for RangeChmaxRangeSum {",
      "        type F = ChmaxFunc;",
      "        type M = RangeSumMonoid;",
      "        fn identity_map() -> Self::F {",
      "            ChmaxFunc {",
      "                chmax_val: i64::MIN,",
      "            }",
      "        }",
      "        #[allow(clippy::if_same_then_else)]",
      "        fn mapping(f: &Self::F, x: &<Self::M as MonoidBeats>::S) -> <Self::M as MonoidBeats>::S {",
      "            match x {",
      "                None => None,",
      "                Some(x) => {",
      "                    if x.len == 0 {",
      "                        Some(*x)",
      "                    } else if f.chmax_val <= x.min {",
      "                        Some(*x)",
      "                    } else if f.chmax_val < x.min_2nd {",
      "                        Some(RangeSum {",
      "                            sum: x.sum + (f.chmax_val - x.min) * x.min_cnt as i64,",
      "                            len: x.len,",
      "                            min: f.chmax_val,",
      "                            min_cnt: x.min_cnt,",
      "                            min_2nd: x.min_2nd,",
      "                        })",
      "                    } else {",
      "                        None",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        fn composition(f: &Self::F, g: &Self::F) -> Self::F {",
      "            ChmaxFunc {",
      "                chmax_val: max(f.chmax_val, g.chmax_val),",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct RangeChmaxRangeSumSegtree {",
      "        segtree: SegtreeBeats<RangeChmaxRangeSum>,",
      "        len: usize,",
      "    }",
      "    impl RangeChmaxRangeSumSegtree {",
      "        pub fn new(n: usize) -> Self {",
      "            let segtree = SegtreeBeats::<RangeChmaxRangeSum>::new(n);",
      "            Self { segtree, len: n }",
      "        }",
      "        pub fn from_slice(xs: &[i64]) -> Self {",
      "            let len = xs.len();",
      "            let segtree = SegtreeBeats::<RangeChmaxRangeSum>::from(",
      "                xs.iter().copied().map(RangeSum::unit).collect_vec(),",
      "            );",
      "            Self { segtree, len }",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn set(&mut self, p: usize, x: i64) {",
      "            self.segtree.set(p, RangeSum::unit(x));",
      "        }",
      "        pub fn get(&mut self, p: usize) -> i64 {",
      "            self.segtree.get(p).unwrap().sum",
      "        }",
      "        pub fn sum<R: RangeBounds<usize>>(&mut self, range: R) -> i64 {",
      "            self.segtree.prod(range).unwrap().sum",
      "        }",
      "        pub fn all_sum(&mut self) -> i64 {",
      "            self.segtree.all_prod().unwrap().sum",
      "        }",
      "        pub fn chmax<R: RangeBounds<usize>>(&mut self, range: R, x: i64) {",
      "            self.segtree.apply_range(range, ChmaxFunc::new(x));",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<i64> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_chmin_chmax_add_range_min": {
    "scope": "rust",
    "prefix": "range_chmin_chmax_add_range_min",
    "body": [
      "use range_chmin_chmax_add_range_min::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_chmin_chmax_add_range_min {",
      "    use ac_library::{LazySegtree, MapMonoid, Monoid};",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    use std::ops::{Add, Mul, RangeBounds};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeMin<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for RangeMin<T>",
      "    where",
      "        T: Copy + Ord + Bounded,",
      "    {",
      "        type S = T;",
      "        fn identity() -> T {",
      "            T::max_value()",
      "        }",
      "        fn binary_operation(a: &T, b: &T) -> T {",
      "            *a.min(b)",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct ChminChmaxAddAction<T> {",
      "        chmin_val: T,",
      "        chmax_val: T,",
      "        add_val: T,",
      "    }",
      "    impl<T> ChminChmaxAddAction<T>",
      "    where",
      "        T: Copy + Ord + Bounded + From<i64>,",
      "    {",
      "        pub fn new_chmin(val: T) -> Self {",
      "            Self {",
      "                chmin_val: val,",
      "                chmax_val: T::min_value(),",
      "                add_val: T::from(0),",
      "            }",
      "        }",
      "        pub fn new_chmax(val: T) -> Self {",
      "            Self {",
      "                chmin_val: T::max_value(),",
      "                chmax_val: val,",
      "                add_val: T::from(0),",
      "            }",
      "        }",
      "        pub fn new_add(val: T) -> Self {",
      "            Self {",
      "                chmin_val: T::max_value(),",
      "                chmax_val: T::min_value(),",
      "                add_val: val,",
      "            }",
      "        }",
      "        pub fn new_update(val: T) -> Self {",
      "            Self {",
      "                chmin_val: val,",
      "                chmax_val: val,",
      "                add_val: T::from(0),",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeChminChmaxAddRangeMin<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> MapMonoid for RangeChminChmaxAddRangeMin<T>",
      "    where",
      "        T: Copy + Ord + From<i64> + Bounded + Add<Output = T> + Mul<Output = T>,",
      "    {",
      "        type M = RangeMin<T>;",
      "        type F = ChminChmaxAddAction<T>;",
      "        fn identity_map() -> Self::F {",
      "            ChminChmaxAddAction {",
      "                chmin_val: T::max_value(),",
      "                chmax_val: T::min_value(),",
      "                add_val: T::from(0),",
      "            }",
      "        }",
      "        fn composition(f: &Self::F, g: &Self::F) -> Self::F {",
      "            let new_add = g.add_val + f.add_val;",
      "            let new_chmin_tmp = if g.chmin_val == T::max_value() {",
      "                T::max_value()",
      "            } else {",
      "                g.chmin_val + f.add_val",
      "            };",
      "            let new_chmax_tmp = if g.chmax_val == T::min_value() {",
      "                T::min_value()",
      "            } else {",
      "                g.chmax_val + f.add_val",
      "            };",
      "            let new_chmin = new_chmin_tmp.clamp(f.chmax_val, f.chmin_val);",
      "            let new_chmax = new_chmax_tmp.clamp(f.chmax_val, f.chmin_val);",
      "            ChminChmaxAddAction {",
      "                chmin_val: new_chmin,",
      "                chmax_val: new_chmax,",
      "                add_val: new_add,",
      "            }",
      "        }",
      "        fn mapping(f: &Self::F, x: &<Self::M as Monoid>::S) -> <Self::M as Monoid>::S {",
      "            (*x + f.add_val).clamp(f.chmax_val, f.chmin_val)",
      "        }",
      "    }",
      "    pub trait Bounded {",
      "        fn min_value() -> Self;",
      "        fn max_value() -> Self;",
      "    }",
      "    impl Bounded for i64 {",
      "        fn min_value() -> Self {",
      "            i64::MIN",
      "        }",
      "        fn max_value() -> Self {",
      "            i64::MAX",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct RangeChminChmaxAddRangeMinSegtree<T>",
      "    where",
      "        T: Copy + Ord + From<i64> + Bounded + Add<Output = T> + Mul<Output = T>,",
      "    {",
      "        segtree: LazySegtree<RangeChminChmaxAddRangeMin<T>>,",
      "        len: usize,",
      "    }",
      "    impl<T> RangeChminChmaxAddRangeMinSegtree<T>",
      "    where",
      "        T: Copy + Ord + From<i64> + Bounded + Add<Output = T> + Mul<Output = T>,",
      "    {",
      "        pub fn new(n: usize) -> Self {",
      "            let xs = vec![0.into(); n];",
      "            Self::from_slice(&xs)",
      "        }",
      "        pub fn from_slice(xs: &[T]) -> Self {",
      "            let len = xs.len();",
      "            Self {",
      "                segtree: LazySegtree::from(xs.to_vec()),",
      "                len,",
      "            }",
      "        }",
      "        pub fn set(&mut self, p: usize, x: T) {",
      "            self.segtree.set(p, x);",
      "        }",
      "        pub fn get(&mut self, p: usize) -> T {",
      "            self.segtree.get(p)",
      "        }",
      "        pub fn range_min<R>(&mut self, range: R) -> T",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range)",
      "        }",
      "        pub fn all_min(&self) -> T {",
      "            self.segtree.all_prod()",
      "        }",
      "        pub fn range_chmin<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree",
      "                .apply_range(range, ChminChmaxAddAction::new_chmin(x))",
      "        }",
      "        pub fn range_chmax<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree",
      "                .apply_range(range, ChminChmaxAddAction::new_chmax(x))",
      "        }",
      "        pub fn range_add<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree",
      "                .apply_range(range, ChminChmaxAddAction::new_add(x))",
      "        }",
      "        pub fn range_update<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree",
      "                .apply_range(range, ChminChmaxAddAction::new_update(x))",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<T> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_chmin_chmax_add_range_min_max": {
    "scope": "rust",
    "prefix": "range_chmin_chmax_add_range_min_max",
    "body": [
      "use range_chmin_chmax_add_range_min_max::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_chmin_chmax_add_range_min_max {",
      "    use ac_library::{LazySegtree, MapMonoid, Monoid};",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    use std::ops::{Add, Mul, RangeBounds};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeMinMax<T> {",
      "        pub min: T,",
      "        pub max: T,",
      "    }",
      "    impl<T> RangeMinMax<T> {",
      "        pub fn new(min: T, max: T) -> Self {",
      "            Self { min, max }",
      "        }",
      "        pub fn unit(x: T) -> Self",
      "        where",
      "            T: Copy,",
      "        {",
      "            Self { min: x, max: x }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeMinMaxMonoid<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for RangeMinMaxMonoid<T>",
      "    where",
      "        T: Copy + Ord + Bounded,",
      "    {",
      "        type S = RangeMinMax<T>;",
      "        fn identity() -> Self::S {",
      "            RangeMinMax {",
      "                min: T::max_value(),",
      "                max: T::min_value(),",
      "            }",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            RangeMinMax {",
      "                min: a.min.min(b.min),",
      "                max: a.max.max(b.max),",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct ChminChmaxAddAction<T> {",
      "        chmin_val: T,",
      "        chmax_val: T,",
      "        add_val: T,",
      "    }",
      "    impl<T> ChminChmaxAddAction<T>",
      "    where",
      "        T: Copy + Ord + Bounded + From<i64>,",
      "    {",
      "        pub fn new_chmin(val: T) -> Self {",
      "            Self {",
      "                chmin_val: val,",
      "                chmax_val: T::min_value(),",
      "                add_val: T::from(0),",
      "            }",
      "        }",
      "        pub fn new_chmax(val: T) -> Self {",
      "            Self {",
      "                chmin_val: T::max_value(),",
      "                chmax_val: val,",
      "                add_val: T::from(0),",
      "            }",
      "        }",
      "        pub fn new_add(val: T) -> Self {",
      "            Self {",
      "                chmin_val: T::max_value(),",
      "                chmax_val: T::min_value(),",
      "                add_val: val,",
      "            }",
      "        }",
      "        pub fn new_update(val: T) -> Self {",
      "            Self {",
      "                chmin_val: val,",
      "                chmax_val: val,",
      "                add_val: T::from(0),",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeChminChmaxAddRangeMinMax<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> MapMonoid for RangeChminChmaxAddRangeMinMax<T>",
      "    where",
      "        T: Copy + Ord + From<i64> + Bounded + Add<Output = T> + Mul<Output = T>,",
      "    {",
      "        type M = RangeMinMaxMonoid<T>;",
      "        type F = ChminChmaxAddAction<T>;",
      "        fn identity_map() -> Self::F {",
      "            ChminChmaxAddAction {",
      "                chmin_val: T::max_value(),",
      "                chmax_val: T::min_value(),",
      "                add_val: T::from(0),",
      "            }",
      "        }",
      "        fn composition(f: &Self::F, g: &Self::F) -> Self::F {",
      "            let new_add = g.add_val + f.add_val;",
      "            let new_chmin_tmp = if g.chmin_val == T::max_value() {",
      "                T::max_value()",
      "            } else {",
      "                g.chmin_val + f.add_val",
      "            };",
      "            let new_chmax_tmp = if g.chmax_val == T::min_value() {",
      "                T::min_value()",
      "            } else {",
      "                g.chmax_val + f.add_val",
      "            };",
      "            let new_chmin = new_chmin_tmp.clamp(f.chmax_val, f.chmin_val);",
      "            let new_chmax = new_chmax_tmp.clamp(f.chmax_val, f.chmin_val);",
      "            ChminChmaxAddAction {",
      "                chmin_val: new_chmin,",
      "                chmax_val: new_chmax,",
      "                add_val: new_add,",
      "            }",
      "        }",
      "        fn mapping(f: &Self::F, x: &<Self::M as Monoid>::S) -> <Self::M as Monoid>::S {",
      "            let RangeMinMax { min, max } = *x;",
      "            if min > max {",
      "                return *x;",
      "            }",
      "            let new_min = (min + f.add_val).clamp(f.chmax_val, f.chmin_val);",
      "            let new_max = (max + f.add_val).clamp(f.chmax_val, f.chmin_val);",
      "            RangeMinMax {",
      "                min: new_min,",
      "                max: new_max,",
      "            }",
      "        }",
      "    }",
      "    pub trait Bounded {",
      "        fn min_value() -> Self;",
      "        fn max_value() -> Self;",
      "    }",
      "    impl Bounded for i64 {",
      "        fn min_value() -> Self {",
      "            i64::MIN",
      "        }",
      "        fn max_value() -> Self {",
      "            i64::MAX",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct RangeChminChmaxAddRangeMinMaxSegtree<T>",
      "    where",
      "        T: Copy + Ord + From<i64> + Bounded + Add<Output = T> + Mul<Output = T>,",
      "    {",
      "        segtree: LazySegtree<RangeChminChmaxAddRangeMinMax<T>>,",
      "        len: usize,",
      "    }",
      "    impl<T> RangeChminChmaxAddRangeMinMaxSegtree<T>",
      "    where",
      "        T: Copy + Ord + From<i64> + Bounded + Add<Output = T> + Mul<Output = T>,",
      "    {",
      "        pub fn new(n: usize) -> Self {",
      "            let xs = vec![0.into(); n];",
      "            Self::from_slice(&xs)",
      "        }",
      "        pub fn from_slice(xs: &[T]) -> Self {",
      "            let len = xs.len();",
      "            let vec = xs.iter().map(|&x| RangeMinMax::unit(x)).collect::<Vec<_>>();",
      "            Self {",
      "                segtree: LazySegtree::from(vec),",
      "                len,",
      "            }",
      "        }",
      "        pub fn set(&mut self, p: usize, x: T) {",
      "            self.segtree.set(p, RangeMinMax::unit(x));",
      "        }",
      "        pub fn get(&mut self, p: usize) -> T {",
      "            self.segtree.get(p).min",
      "        }",
      "        pub fn range_minmax<R>(&mut self, range: R) -> RangeMinMax<T>",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range)",
      "        }",
      "        pub fn range_min<R>(&mut self, range: R) -> T",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range).min",
      "        }",
      "        pub fn range_max<R>(&mut self, range: R) -> T",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range).max",
      "        }",
      "        pub fn all_minmax(&self) -> RangeMinMax<T> {",
      "            self.segtree.all_prod()",
      "        }",
      "        pub fn all_min(&self) -> T {",
      "            self.segtree.all_prod().min",
      "        }",
      "        pub fn all_max(&self) -> T {",
      "            self.segtree.all_prod().max",
      "        }",
      "        pub fn range_chmin<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree",
      "                .apply_range(range, ChminChmaxAddAction::new_chmin(x))",
      "        }",
      "        pub fn range_chmax<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree",
      "                .apply_range(range, ChminChmaxAddAction::new_chmax(x))",
      "        }",
      "        pub fn range_add<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree",
      "                .apply_range(range, ChminChmaxAddAction::new_add(x))",
      "        }",
      "        pub fn range_update<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree",
      "                .apply_range(range, ChminChmaxAddAction::new_update(x))",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<T> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_chmin_chmax_add_range_sum_beats": {
    "scope": "rust",
    "prefix": "range_chmin_chmax_add_range_sum_beats",
    "body": [
      "use abstract_segtree_beats::*;",
      "use range_chmin_chmax_add_range_sum_beats::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod abstract_segtree_beats {",
      "    fn ceil_pow2(n: u32) -> u32 {",
      "        32 - n.saturating_sub(1).leading_zeros()",
      "    }",
      "    pub trait MonoidBeats {",
      "        type S: Clone;",
      "        fn identity() -> Self::S;",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S;",
      "        fn fails(a: &Self::S) -> bool;",
      "    }",
      "    pub trait MapMonoidBeats {",
      "        type M: MonoidBeats;",
      "        type F: Clone;",
      "        fn identity_element() -> <Self::M as MonoidBeats>::S {",
      "            Self::M::identity()",
      "        }",
      "        fn binary_operation(",
      "            a: &<Self::M as MonoidBeats>::S,",
      "            b: &<Self::M as MonoidBeats>::S,",
      "        ) -> <Self::M as MonoidBeats>::S {",
      "            Self::M::binary_operation(a, b)",
      "        }",
      "        fn fails(a: &<Self::M as MonoidBeats>::S) -> bool {",
      "            Self::M::fails(a)",
      "        }",
      "        fn identity_map() -> Self::F;",
      "        fn mapping(f: &Self::F, x: &<Self::M as MonoidBeats>::S) -> <Self::M as MonoidBeats>::S;",
      "        fn composition(f: &Self::F, g: &Self::F) -> Self::F;",
      "    }",
      "    impl<F: MapMonoidBeats> Default for SegtreeBeats<F> {",
      "        fn default() -> Self {",
      "            Self::new(0)",
      "        }",
      "    }",
      "    impl<F: MapMonoidBeats> SegtreeBeats<F> {",
      "        pub fn new(n: usize) -> Self {",
      "            vec![F::identity_element(); n].into()",
      "        }",
      "    }",
      "    impl<F: MapMonoidBeats> From<Vec<<F::M as MonoidBeats>::S>> for SegtreeBeats<F> {",
      "        fn from(v: Vec<<F::M as MonoidBeats>::S>) -> Self {",
      "            let n = v.len();",
      "            let log = ceil_pow2(n as u32) as usize;",
      "            let size = 1 << log;",
      "            let mut d = vec![F::identity_element(); 2 * size];",
      "            let lz = vec![F::identity_map(); size];",
      "            d[size..(size + n)].clone_from_slice(&v);",
      "            let mut ret = SegtreeBeats {",
      "                n,",
      "                size,",
      "                log,",
      "                d,",
      "                lz,",
      "            };",
      "            for i in (1..size).rev() {",
      "                ret.update(i);",
      "            }",
      "            ret",
      "        }",
      "    }",
      "    impl<F: MapMonoidBeats> SegtreeBeats<F> {",
      "        pub fn set(&mut self, mut p: usize, x: <F::M as MonoidBeats>::S) {",
      "            assert!(p < self.n);",
      "            p += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(p >> i);",
      "            }",
      "            self.d[p] = x;",
      "            for i in 1..=self.log {",
      "                self.update(p >> i);",
      "            }",
      "        }",
      "        pub fn get(&mut self, mut p: usize) -> <F::M as MonoidBeats>::S {",
      "            assert!(p < self.n);",
      "            p += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(p >> i);",
      "            }",
      "            self.d[p].clone()",
      "        }",
      "        pub fn prod<R>(&mut self, range: R) -> <F::M as MonoidBeats>::S",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            if range.start_bound() == Bound::Unbounded && range.end_bound() == Bound::Unbounded {",
      "                return self.all_prod();",
      "            }",
      "            let mut r = match range.end_bound() {",
      "                Bound::Included(r) => r + 1,",
      "                Bound::Excluded(r) => *r,",
      "                Bound::Unbounded => self.n,",
      "            };",
      "            let mut l = match range.start_bound() {",
      "                Bound::Included(l) => *l,",
      "                Bound::Excluded(l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            assert!(l <= r && r <= self.n);",
      "            if l == r {",
      "                return F::identity_element();",
      "            }",
      "            l += self.size;",
      "            r += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                if ((l >> i) << i) != l {",
      "                    self.push(l >> i);",
      "                }",
      "                if ((r >> i) << i) != r {",
      "                    self.push(r >> i);",
      "                }",
      "            }",
      "            let mut sml = F::identity_element();",
      "            let mut smr = F::identity_element();",
      "            while l < r {",
      "                if l & 1 != 0 {",
      "                    sml = F::binary_operation(&sml, &self.d[l]);",
      "                    l += 1;",
      "                }",
      "                if r & 1 != 0 {",
      "                    r -= 1;",
      "                    smr = F::binary_operation(&self.d[r], &smr);",
      "                }",
      "                l >>= 1;",
      "                r >>= 1;",
      "            }",
      "            F::binary_operation(&sml, &smr)",
      "        }",
      "        pub fn all_prod(&self) -> <F::M as MonoidBeats>::S {",
      "            self.d[1].clone()",
      "        }",
      "        pub fn apply(&mut self, mut p: usize, f: F::F) {",
      "            assert!(p < self.n);",
      "            p += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(p >> i);",
      "            }",
      "            self.d[p] = F::mapping(&f, &self.d[p]);",
      "            for i in 1..=self.log {",
      "                self.update(p >> i);",
      "            }",
      "        }",
      "        pub fn apply_range<R>(&mut self, range: R, f: F::F)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            let mut r = match range.end_bound() {",
      "                Bound::Included(r) => r + 1,",
      "                Bound::Excluded(r) => *r,",
      "                Bound::Unbounded => self.n,",
      "            };",
      "            let mut l = match range.start_bound() {",
      "                Bound::Included(l) => *l,",
      "                Bound::Excluded(l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            assert!(l <= r && r <= self.n);",
      "            if l == r {",
      "                return;",
      "            }",
      "            l += self.size;",
      "            r += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                if ((l >> i) << i) != l {",
      "                    self.push(l >> i);",
      "                }",
      "                if ((r >> i) << i) != r {",
      "                    self.push((r - 1) >> i);",
      "                }",
      "            }",
      "            {",
      "                let l2 = l;",
      "                let r2 = r;",
      "                while l < r {",
      "                    if l & 1 != 0 {",
      "                        self.all_apply(l, f.clone());",
      "                        l += 1;",
      "                    }",
      "                    if r & 1 != 0 {",
      "                        r -= 1;",
      "                        self.all_apply(r, f.clone());",
      "                    }",
      "                    l >>= 1;",
      "                    r >>= 1;",
      "                }",
      "                l = l2;",
      "                r = r2;",
      "            }",
      "            for i in 1..=self.log {",
      "                if ((l >> i) << i) != l {",
      "                    self.update(l >> i);",
      "                }",
      "                if ((r >> i) << i) != r {",
      "                    self.update((r - 1) >> i);",
      "                }",
      "            }",
      "        }",
      "        pub fn max_right<G>(&mut self, mut l: usize, g: G) -> usize",
      "        where",
      "            G: Fn(<F::M as MonoidBeats>::S) -> bool,",
      "        {",
      "            assert!(l <= self.n);",
      "            assert!(g(F::identity_element()));",
      "            if l == self.n {",
      "                return self.n;",
      "            }",
      "            l += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(l >> i);",
      "            }",
      "            let mut sm = F::identity_element();",
      "            while {",
      "                while l % 2 == 0 {",
      "                    l >>= 1;",
      "                }",
      "                if !g(F::binary_operation(&sm, &self.d[l])) {",
      "                    while l < self.size {",
      "                        self.push(l);",
      "                        l *= 2;",
      "                        let res = F::binary_operation(&sm, &self.d[l]);",
      "                        if g(res.clone()) {",
      "                            sm = res;",
      "                            l += 1;",
      "                        }",
      "                    }",
      "                    return l - self.size;",
      "                }",
      "                sm = F::binary_operation(&sm, &self.d[l]);",
      "                l += 1;",
      "                {",
      "                    let l = l as isize;",
      "                    (l & -l) != l",
      "                }",
      "            } {}",
      "            self.n",
      "        }",
      "        pub fn min_left<G>(&mut self, mut r: usize, g: G) -> usize",
      "        where",
      "            G: Fn(<F::M as MonoidBeats>::S) -> bool,",
      "        {",
      "            assert!(r <= self.n);",
      "            assert!(g(F::identity_element()));",
      "            if r == 0 {",
      "                return 0;",
      "            }",
      "            r += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push((r - 1) >> i);",
      "            }",
      "            let mut sm = F::identity_element();",
      "            while {",
      "                r -= 1;",
      "                while r > 1 && r % 2 != 0 {",
      "                    r >>= 1;",
      "                }",
      "                if !g(F::binary_operation(&self.d[r], &sm)) {",
      "                    while r < self.size {",
      "                        self.push(r);",
      "                        r = 2 * r + 1;",
      "                        let res = F::binary_operation(&self.d[r], &sm);",
      "                        if g(res.clone()) {",
      "                            sm = res;",
      "                            r -= 1;",
      "                        }",
      "                    }",
      "                    return r + 1 - self.size;",
      "                }",
      "                sm = F::binary_operation(&self.d[r], &sm);",
      "                {",
      "                    let r = r as isize;",
      "                    (r & -r) != r",
      "                }",
      "            } {}",
      "            0",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<<F::M as MonoidBeats>::S> {",
      "            (0..self.n).map(|i| self.get(i)).collect()",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct SegtreeBeats<F>",
      "    where",
      "        F: MapMonoidBeats,",
      "    {",
      "        n: usize,",
      "        size: usize,",
      "        log: usize,",
      "        d: Vec<<F::M as MonoidBeats>::S>,",
      "        lz: Vec<F::F>,",
      "    }",
      "    impl<F> SegtreeBeats<F>",
      "    where",
      "        F: MapMonoidBeats,",
      "    {",
      "        fn update(&mut self, k: usize) {",
      "            self.d[k] = F::binary_operation(&self.d[2 * k], &self.d[2 * k + 1]);",
      "        }",
      "        fn all_apply(&mut self, k: usize, f: F::F) {",
      "            self.d[k] = F::mapping(&f, &self.d[k]);",
      "            if k < self.size {",
      "                self.lz[k] = F::composition(&f, &self.lz[k]);",
      "                if F::fails(&self.d[k]) {",
      "                    self.push(k);",
      "                    self.update(k)",
      "                }",
      "            }",
      "        }",
      "        fn push(&mut self, k: usize) {",
      "            self.all_apply(2 * k, self.lz[k].clone());",
      "            self.all_apply(2 * k + 1, self.lz[k].clone());",
      "            self.lz[k] = F::identity_map();",
      "        }",
      "    }",
      "    use std::{",
      "        fmt::{Debug, Error, Formatter, Write},",
      "        ops::{Bound, RangeBounds},",
      "    };",
      "    impl<F> Debug for SegtreeBeats<F>",
      "    where",
      "        F: MapMonoidBeats,",
      "        F::F: Debug,",
      "        <F::M as MonoidBeats>::S: Debug,",
      "    {",
      "        fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {",
      "            for i in 0..self.log {",
      "                for j in 0..1 << i {",
      "                    f.write_fmt(format_args!(",
      "                        \"{:?}[{:?}]\\t\",",
      "                        self.d[(1 << i) + j],",
      "                        self.lz[(1 << i) + j]",
      "                    ))?;",
      "                }",
      "                f.write_char('\\n')?;",
      "            }",
      "            for i in 0..self.size {",
      "                f.write_fmt(format_args!(\"{:?}\\t\", self.d[self.size + i]))?;",
      "            }",
      "            Ok(())",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::module_inception)]",
      "pub mod range_chmin_chmax_add_range_sum_beats {",
      "    use super::{MapMonoidBeats, MonoidBeats, SegtreeBeats};",
      "    use itertools::Itertools;",
      "    use std::{",
      "        cmp::{max, min},",
      "        convert::Infallible,",
      "        ops::RangeBounds,",
      "    };",
      "    const INF: i64 = i64::MAX;",
      "    const NEG_INF: i64 = i64::MIN;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct RangeSum {",
      "        pub sum: i64,",
      "        pub len: usize,",
      "        pub max: i64,",
      "        pub max_2nd: i64,",
      "        pub max_cnt: usize,",
      "        pub min: i64,",
      "        pub min_2nd: i64,",
      "        pub min_cnt: usize,",
      "    }",
      "    impl RangeSum {",
      "        pub fn unit(x: i64) -> Option<RangeSum> {",
      "            Some(RangeSum {",
      "                sum: x,",
      "                len: 1,",
      "                max: x,",
      "                max_2nd: NEG_INF,",
      "                max_cnt: 1,",
      "                min: x,",
      "                min_2nd: INF,",
      "                min_cnt: 1,",
      "            })",
      "        }",
      "    }",
      "    fn second_lowest(a: i64, a2: i64, b: i64, b2: i64) -> i64 {",
      "        if a == b {",
      "            min(a2, b2)",
      "        } else if a2 <= b {",
      "            a2",
      "        } else if b2 <= a {",
      "            b2",
      "        } else {",
      "            max(a, b)",
      "        }",
      "    }",
      "    fn second_highest(a: i64, a2: i64, b: i64, b2: i64) -> i64 {",
      "        if a == b {",
      "            max(a2, b2)",
      "        } else if a2 >= b {",
      "            a2",
      "        } else if b2 >= a {",
      "            b2",
      "        } else {",
      "            min(a, b)",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeSumMonoid(Infallible);",
      "    impl MonoidBeats for RangeSumMonoid {",
      "        type S = Option<RangeSum>;",
      "        fn identity() -> Self::S {",
      "            Some(RangeSum {",
      "                sum: 0,",
      "                len: 0,",
      "                max: NEG_INF,",
      "                max_2nd: NEG_INF,",
      "                max_cnt: 0,",
      "                min: INF,",
      "                min_2nd: INF,",
      "                min_cnt: 0,",
      "            })",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            match (a, b) {",
      "                (None, None) => None,",
      "                (None, Some(_)) => None,",
      "                (Some(_), None) => None,",
      "                (Some(a), Some(b)) => {",
      "                    if a.len == 0 {",
      "                        return Some(*b);",
      "                    }",
      "                    if b.len == 0 {",
      "                        return Some(*a);",
      "                    }",
      "                    Some(RangeSum {",
      "                        sum: a.sum + b.sum,",
      "                        len: a.len + b.len,",
      "                        max: max(a.max, b.max),",
      "                        max_2nd: second_highest(a.max, a.max_2nd, b.max, b.max_2nd),",
      "                        max_cnt: if a.max > b.max {",
      "                            a.max_cnt",
      "                        } else if a.max < b.max {",
      "                            b.max_cnt",
      "                        } else {",
      "                            a.max_cnt + b.max_cnt",
      "                        },",
      "                        min: min(a.min, b.min),",
      "                        min_2nd: second_lowest(a.min, a.min_2nd, b.min, b.min_2nd),",
      "                        min_cnt: if a.min < b.min {",
      "                            a.min_cnt",
      "                        } else if a.min > b.min {",
      "                            b.min_cnt",
      "                        } else {",
      "                            a.min_cnt + b.min_cnt",
      "                        },",
      "                    })",
      "                }",
      "            }",
      "        }",
      "        fn fails(a: &Self::S) -> bool {",
      "            a.is_none()",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct Func {",
      "        pub add: i64,",
      "        pub upper: i64,",
      "        pub lower: i64,",
      "    }",
      "    impl Func {",
      "        pub fn new_add(add: i64) -> Self {",
      "            Func {",
      "                add,",
      "                upper: INF,",
      "                lower: NEG_INF,",
      "            }",
      "        }",
      "        pub fn new_chmin(x: i64) -> Self {",
      "            Func {",
      "                add: 0,",
      "                upper: x,",
      "                lower: NEG_INF,",
      "            }",
      "        }",
      "        pub fn new_chmax(x: i64) -> Self {",
      "            Func {",
      "                add: 0,",
      "                upper: INF,",
      "                lower: x,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeChminChmaxAddRangeSum(Infallible);",
      "    impl MapMonoidBeats for RangeChminChmaxAddRangeSum {",
      "        type F = Func;",
      "        type M = RangeSumMonoid;",
      "        fn identity_map() -> Self::F {",
      "            Func {",
      "                add: 0,",
      "                upper: INF,",
      "                lower: NEG_INF,",
      "            }",
      "        }",
      "        fn mapping(f: &Self::F, x: &<Self::M as MonoidBeats>::S) -> <Self::M as MonoidBeats>::S {",
      "            match x {",
      "                None => None,",
      "                Some(x) => {",
      "                    if x.len == 0 {",
      "                        return Some(*x);",
      "                    }",
      "                    if x.len == 1 {",
      "                        let mut next_x = *x;",
      "                        if f.add != 0 {",
      "                            next_x.sum += f.add;",
      "                            next_x.max += f.add;",
      "                            next_x.min += f.add;",
      "                        }",
      "                        if next_x.max > f.upper {",
      "                            next_x.max = f.upper;",
      "                            next_x.min = f.upper;",
      "                            next_x.sum = f.upper;",
      "                        }",
      "                        if next_x.min < f.lower {",
      "                            next_x.min = f.lower;",
      "                            next_x.max = f.lower;",
      "                            next_x.sum = f.lower;",
      "                        }",
      "                        return Some(next_x);",
      "                    }",
      "                    let mut next_x = *x;",
      "                    if f.add != 0 {",
      "                        next_x.sum += f.add * (next_x.len as i64);",
      "                        if next_x.max != NEG_INF {",
      "                            next_x.max += f.add;",
      "                        }",
      "                        if next_x.max_2nd != NEG_INF {",
      "                            next_x.max_2nd += f.add;",
      "                        }",
      "                        if next_x.min != INF {",
      "                            next_x.min += f.add;",
      "                        }",
      "                        if next_x.min_2nd != INF {",
      "                            next_x.min_2nd += f.add;",
      "                        }",
      "                    }",
      "                    if next_x.max > f.upper {",
      "                        if next_x.max_2nd < f.upper {",
      "                            next_x.sum -= (next_x.max - f.upper) * (next_x.max_cnt as i64);",
      "                            next_x.max = f.upper;",
      "                            if next_x.min > f.upper {",
      "                                next_x.min = f.upper;",
      "                            }",
      "                            if next_x.min_2nd > f.upper {",
      "                                next_x.min_2nd = f.upper;",
      "                            }",
      "                            if next_x.max == next_x.min {",
      "                                next_x.min = f.upper;",
      "                            }",
      "                        } else {",
      "                            return None;",
      "                        }",
      "                    }",
      "                    if next_x.min < f.lower {",
      "                        if next_x.min_2nd > f.lower {",
      "                            next_x.sum += (f.lower - next_x.min) * (next_x.min_cnt as i64);",
      "                            next_x.min = f.lower;",
      "                            if next_x.max < f.lower {",
      "                                next_x.max = f.lower;",
      "                            }",
      "                            if next_x.max_2nd < f.lower {",
      "                                next_x.max_2nd = f.lower;",
      "                            }",
      "                            if next_x.min == next_x.max {",
      "                                next_x.max = f.lower;",
      "                            }",
      "                        } else {",
      "                            return None;",
      "                        }",
      "                    }",
      "                    Some(next_x)",
      "                }",
      "            }",
      "        }",
      "        fn composition(f: &Self::F, g: &Self::F) -> Self::F {",
      "            let add_new = g.add + f.add;",
      "            let upper_new = min(if g.upper == INF { INF } else { g.upper + f.add }, f.upper);",
      "            let lower_new = max(",
      "                min(",
      "                    if g.lower == NEG_INF {",
      "                        NEG_INF",
      "                    } else {",
      "                        g.lower + f.add",
      "                    },",
      "                    f.upper,",
      "                ),",
      "                f.lower,",
      "            );",
      "            Func {",
      "                add: add_new,",
      "                upper: upper_new,",
      "                lower: lower_new,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct RangeChminChmaxAddRangeSumSegtree {",
      "        segtree: SegtreeBeats<RangeChminChmaxAddRangeSum>,",
      "        len: usize,",
      "    }",
      "    impl RangeChminChmaxAddRangeSumSegtree {",
      "        pub fn new(n: usize) -> Self {",
      "            let segtree = SegtreeBeats::<RangeChminChmaxAddRangeSum>::new(n);",
      "            Self { segtree, len: n }",
      "        }",
      "        pub fn from_slice(xs: &[i64]) -> Self {",
      "            let len = xs.len();",
      "            let segtree = SegtreeBeats::<RangeChminChmaxAddRangeSum>::from(",
      "                xs.iter().copied().map(RangeSum::unit).collect_vec(),",
      "            );",
      "            Self { segtree, len }",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn set(&mut self, p: usize, x: i64) {",
      "            self.segtree.set(p, RangeSum::unit(x));",
      "        }",
      "        pub fn get(&mut self, p: usize) -> i64 {",
      "            self.segtree.get(p).unwrap().sum",
      "        }",
      "        pub fn sum<R: RangeBounds<usize>>(&mut self, range: R) -> i64 {",
      "            self.segtree.prod(range).unwrap().sum",
      "        }",
      "        pub fn min<R: RangeBounds<usize>>(&mut self, range: R) -> i64 {",
      "            self.segtree.prod(range).unwrap().min",
      "        }",
      "        pub fn max<R: RangeBounds<usize>>(&mut self, range: R) -> i64 {",
      "            self.segtree.prod(range).unwrap().max",
      "        }",
      "        pub fn chmax<R: RangeBounds<usize>>(&mut self, range: R, x: i64) {",
      "            self.segtree.apply_range(range, Func::new_chmax(x));",
      "        }",
      "        pub fn chmin<R: RangeBounds<usize>>(&mut self, range: R, x: i64) {",
      "            self.segtree.apply_range(range, Func::new_chmin(x));",
      "        }",
      "        pub fn add<R: RangeBounds<usize>>(&mut self, range: R, x: i64) {",
      "            self.segtree.apply_range(range, Func::new_add(x));",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<i64> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_chmin_chmax_affine_range_min_max": {
    "scope": "rust",
    "prefix": "range_chmin_chmax_affine_range_min_max",
    "body": [
      "use range_chmin_chmax_affine_range_min_max::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_chmin_chmax_affine_range_min_max {",
      "    use ac_library::{LazySegtree, MapMonoid, Monoid};",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    use std::ops::{Add, Mul, RangeBounds};",
      "    pub trait Bounded {",
      "        fn min_value() -> Self;",
      "        fn max_value() -> Self;",
      "    }",
      "    impl Bounded for i64 {",
      "        fn min_value() -> Self {",
      "            i64::MIN",
      "        }",
      "        fn max_value() -> Self {",
      "            i64::MAX",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeMinMax<T> {",
      "        pub min: T,",
      "        pub max: T,",
      "    }",
      "    impl<T> RangeMinMax<T> {",
      "        pub fn new(min: T, max: T) -> Self {",
      "            Self { min, max }",
      "        }",
      "        pub fn unit(x: T) -> Self",
      "        where",
      "            T: Copy,",
      "        {",
      "            Self { min: x, max: x }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeMinMaxMonoid<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for RangeMinMaxMonoid<T>",
      "    where",
      "        T: Copy + Ord + Bounded,",
      "    {",
      "        type S = RangeMinMax<T>;",
      "        fn identity() -> Self::S {",
      "            RangeMinMax {",
      "                min: T::max_value(),",
      "                max: T::min_value(),",
      "            }",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            RangeMinMax {",
      "                min: a.min.min(b.min),",
      "                max: a.max.max(b.max),",
      "            }",
      "        }",
      "    }",
      "    /// ChminChmaxAffineAction は、x に対して (mul * x + add).min(chmin_value).max(chmax_value) を計算する関数を表す構造体です。",
      "    /// これは、範囲に対する chmin (最小値更新)、chmax (最大値更新)、加算、アフィン変換を一度に適用するためのアクションを定義します。",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct ChminChmaxAffineAction<T> {",
      "        chmin_val: T,",
      "        chmax_val: T,",
      "        mul_val: T,",
      "        add_val: T,",
      "    }",
      "    impl<T> ChminChmaxAffineAction<T>",
      "    where",
      "        T: Copy + Ord + Bounded + From<i64> + Add<Output = T> + Mul<Output = T>,",
      "    {",
      "        pub fn new_chmin(val: T) -> Self {",
      "            Self {",
      "                chmin_val: val,",
      "                chmax_val: T::min_value(),",
      "                mul_val: T::from(1),",
      "                add_val: T::from(0),",
      "            }",
      "        }",
      "        pub fn new_chmax(val: T) -> Self {",
      "            Self {",
      "                chmin_val: T::max_value(),",
      "                chmax_val: val,",
      "                mul_val: T::from(1),",
      "                add_val: T::from(0),",
      "            }",
      "        }",
      "        pub fn new_add(val: T) -> Self {",
      "            Self {",
      "                chmin_val: T::max_value(),",
      "                chmax_val: T::min_value(),",
      "                mul_val: T::from(1),",
      "                add_val: val,",
      "            }",
      "        }",
      "        pub fn new_update(val: T) -> Self {",
      "            Self {",
      "                chmin_val: T::max_value(),",
      "                chmax_val: T::min_value(),",
      "                mul_val: T::from(0),",
      "                add_val: val,",
      "            }",
      "        }",
      "        pub fn new_affine(mul: T, add: T) -> Self {",
      "            Self {",
      "                chmin_val: T::max_value(),",
      "                chmax_val: T::min_value(),",
      "                mul_val: mul,",
      "                add_val: add,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeChminChmaxAffineRangeMinMax<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> MapMonoid for RangeChminChmaxAffineRangeMinMax<T>",
      "    where",
      "        T: Copy + Ord + From<i64> + Bounded + Add<Output = T> + Mul<Output = T> + std::fmt::Debug,",
      "    {",
      "        type M = RangeMinMaxMonoid<T>;",
      "        type F = ChminChmaxAffineAction<T>;",
      "        fn identity_map() -> Self::F {",
      "            ChminChmaxAffineAction {",
      "                chmin_val: T::max_value(),",
      "                chmax_val: T::min_value(),",
      "                mul_val: T::from(1),",
      "                add_val: T::from(0),",
      "            }",
      "        }",
      "        fn composition(f: &Self::F, g: &Self::F) -> Self::F {",
      "            let new_mul = g.mul_val * f.mul_val;",
      "            let new_add = g.add_val * f.mul_val + f.add_val;",
      "            let mut composed_chmin_val = T::max_value();",
      "            let mut composed_chmax_val = T::min_value();",
      "            if g.chmin_val != T::max_value() {",
      "                let transformed_g_chmin = g.chmin_val * f.mul_val + f.add_val;",
      "                if f.mul_val >= T::from(0) {",
      "                    composed_chmin_val = composed_chmin_val.min(transformed_g_chmin);",
      "                } else {",
      "                    composed_chmax_val = composed_chmax_val.max(transformed_g_chmin);",
      "                }",
      "            }",
      "            if g.chmax_val != T::min_value() {",
      "                let transformed_g_chmax = g.chmax_val * f.mul_val + f.add_val;",
      "                if f.mul_val >= T::from(0) {",
      "                    composed_chmax_val = composed_chmax_val.max(transformed_g_chmax);",
      "                } else {",
      "                    composed_chmin_val = composed_chmin_val.min(transformed_g_chmax);",
      "                }",
      "            }",
      "            composed_chmin_val = composed_chmin_val.clamp(f.chmax_val, f.chmin_val);",
      "            composed_chmax_val = composed_chmax_val.clamp(f.chmax_val, f.chmin_val);",
      "            ChminChmaxAffineAction {",
      "                chmin_val: composed_chmin_val,",
      "                chmax_val: composed_chmax_val,",
      "                mul_val: new_mul,",
      "                add_val: new_add,",
      "            }",
      "        }",
      "        fn mapping(f: &Self::F, x: &<Self::M as Monoid>::S) -> <Self::M as Monoid>::S {",
      "            let RangeMinMax { min, max } = *x;",
      "            if min > max {",
      "                return *x;",
      "            }",
      "            let (mut transformed_min, mut transformed_max) = if f.mul_val >= T::from(0) {",
      "                (min * f.mul_val + f.add_val, max * f.mul_val + f.add_val)",
      "            } else {",
      "                (max * f.mul_val + f.add_val, min * f.mul_val + f.add_val)",
      "            };",
      "            if f.chmin_val != T::max_value() {",
      "                transformed_min = transformed_min.min(f.chmin_val);",
      "                transformed_max = transformed_max.min(f.chmin_val);",
      "            }",
      "            if f.chmax_val != T::min_value() {",
      "                transformed_min = transformed_min.max(f.chmax_val);",
      "                transformed_max = transformed_max.max(f.chmax_val);",
      "            }",
      "            RangeMinMax {",
      "                min: transformed_min,",
      "                max: transformed_max,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct RangeChminChmaxAffineRangeMinMaxSegtree<T>",
      "    where",
      "        T: Copy + Ord + From<i64> + Bounded + Add<Output = T> + Mul<Output = T> + std::fmt::Debug,",
      "    {",
      "        segtree: LazySegtree<RangeChminChmaxAffineRangeMinMax<T>>,",
      "        len: usize,",
      "    }",
      "    impl<T> RangeChminChmaxAffineRangeMinMaxSegtree<T>",
      "    where",
      "        T: Copy + Ord + From<i64> + Bounded + Add<Output = T> + Mul<Output = T> + std::fmt::Debug,",
      "    {",
      "        pub fn new(n: usize) -> Self {",
      "            let xs = vec![0.into(); n];",
      "            Self::from_slice(&xs)",
      "        }",
      "        pub fn from_slice(xs: &[T]) -> Self {",
      "            let len = xs.len();",
      "            let vec = xs.iter().map(|&x| RangeMinMax::unit(x)).collect::<Vec<_>>();",
      "            Self {",
      "                segtree: LazySegtree::from(vec),",
      "                len,",
      "            }",
      "        }",
      "        pub fn set(&mut self, p: usize, x: T) {",
      "            self.segtree.set(p, RangeMinMax::unit(x));",
      "        }",
      "        pub fn get(&mut self, p: usize) -> T {",
      "            self.segtree.get(p).min",
      "        }",
      "        pub fn range_minmax<R>(&mut self, range: R) -> RangeMinMax<T>",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range)",
      "        }",
      "        pub fn range_min<R>(&mut self, range: R) -> T",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range).min",
      "        }",
      "        pub fn range_max<R>(&mut self, range: R) -> T",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range).max",
      "        }",
      "        pub fn all_minmax(&self) -> RangeMinMax<T> {",
      "            self.segtree.all_prod()",
      "        }",
      "        pub fn all_min(&self) -> T {",
      "            self.segtree.all_prod().min",
      "        }",
      "        pub fn all_max(&self) -> T {",
      "            self.segtree.all_prod().max",
      "        }",
      "        pub fn range_chmin<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree",
      "                .apply_range(range, ChminChmaxAffineAction::new_chmin(x))",
      "        }",
      "        pub fn range_chmax<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree",
      "                .apply_range(range, ChminChmaxAffineAction::new_chmax(x))",
      "        }",
      "        pub fn range_add<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree",
      "                .apply_range(range, ChminChmaxAffineAction::new_add(x))",
      "        }",
      "        pub fn range_affine<R>(&mut self, range: R, mul: T, add: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree",
      "                .apply_range(range, ChminChmaxAffineAction::new_affine(mul, add))",
      "        }",
      "        pub fn range_update<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree",
      "                .apply_range(range, ChminChmaxAffineAction::new_update(x))",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<T> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_chmin_chmax_range_min": {
    "scope": "rust",
    "prefix": "range_chmin_chmax_range_min",
    "body": [
      "use range_chmin_chmax_range_min::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_chmin_chmax_range_min {",
      "    use ac_library::{LazySegtree, MapMonoid, Monoid};",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    use std::ops::{Add, Mul, RangeBounds};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeMin<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for RangeMin<T>",
      "    where",
      "        T: Copy + Ord + Bounded,",
      "    {",
      "        type S = T;",
      "        fn identity() -> T {",
      "            T::max_value()",
      "        }",
      "        fn binary_operation(a: &T, b: &T) -> T {",
      "            *a.min(b)",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct ChminChmaxAction<T> {",
      "        chmin_val: T,",
      "        chmax_val: T,",
      "    }",
      "    impl<T> ChminChmaxAction<T>",
      "    where",
      "        T: Copy + Ord + Bounded,",
      "    {",
      "        pub fn new_chmin(val: T) -> Self {",
      "            Self {",
      "                chmin_val: val,",
      "                chmax_val: T::min_value(),",
      "            }",
      "        }",
      "        pub fn new_chmax(val: T) -> Self {",
      "            Self {",
      "                chmin_val: T::max_value(),",
      "                chmax_val: val,",
      "            }",
      "        }",
      "        pub fn new_update(val: T) -> Self {",
      "            Self {",
      "                chmin_val: val,",
      "                chmax_val: val,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeChminChmaxRangeMin<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> MapMonoid for RangeChminChmaxRangeMin<T>",
      "    where",
      "        T: Copy + Ord + From<i64> + Bounded + Add<Output = T> + Mul<Output = T>,",
      "    {",
      "        type M = RangeMin<T>;",
      "        type F = ChminChmaxAction<T>;",
      "        fn identity_map() -> Self::F {",
      "            ChminChmaxAction {",
      "                chmin_val: T::max_value(),",
      "                chmax_val: T::min_value(),",
      "            }",
      "        }",
      "        fn composition(f: &Self::F, g: &Self::F) -> Self::F {",
      "            let res_chmin = g.chmin_val.clamp(f.chmax_val, f.chmin_val);",
      "            let res_chmax = g.chmax_val.clamp(f.chmax_val, f.chmin_val);",
      "            ChminChmaxAction {",
      "                chmin_val: res_chmin,",
      "                chmax_val: res_chmax,",
      "            }",
      "        }",
      "        fn mapping(f: &Self::F, x: &<Self::M as Monoid>::S) -> <Self::M as Monoid>::S {",
      "            (*x).clamp(f.chmax_val, f.chmin_val)",
      "        }",
      "    }",
      "    pub trait Bounded {",
      "        fn min_value() -> Self;",
      "        fn max_value() -> Self;",
      "    }",
      "    impl Bounded for i64 {",
      "        fn min_value() -> Self {",
      "            i64::MIN",
      "        }",
      "        fn max_value() -> Self {",
      "            i64::MAX",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct RangeChminChmaxRangeMinSegtree<T>",
      "    where",
      "        T: Copy + Ord + From<i64> + Bounded + Add<Output = T> + Mul<Output = T>,",
      "    {",
      "        segtree: LazySegtree<RangeChminChmaxRangeMin<T>>,",
      "        len: usize,",
      "    }",
      "    impl<T> RangeChminChmaxRangeMinSegtree<T>",
      "    where",
      "        T: Copy + Ord + From<i64> + Bounded + Add<Output = T> + Mul<Output = T>,",
      "    {",
      "        pub fn new(n: usize) -> Self {",
      "            let xs = vec![0.into(); n];",
      "            Self::from_slice(&xs)",
      "        }",
      "        pub fn from_slice(xs: &[T]) -> RangeChminChmaxRangeMinSegtree<T> {",
      "            let len = xs.len();",
      "            RangeChminChmaxRangeMinSegtree {",
      "                segtree: LazySegtree::from(xs.to_vec()),",
      "                len,",
      "            }",
      "        }",
      "        pub fn set(&mut self, p: usize, x: T) {",
      "            self.segtree.set(p, x);",
      "        }",
      "        pub fn get(&mut self, p: usize) -> T {",
      "            self.segtree.get(p)",
      "        }",
      "        pub fn range_min<R>(&mut self, range: R) -> T",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range)",
      "        }",
      "        pub fn all_min(&self) -> T {",
      "            self.segtree.all_prod()",
      "        }",
      "        pub fn chmin(&mut self, p: usize, x: T) {",
      "            self.segtree.apply(p, ChminChmaxAction::new_chmin(x))",
      "        }",
      "        pub fn chmax(&mut self, p: usize, x: T) {",
      "            self.segtree.apply(p, ChminChmaxAction::new_chmax(x))",
      "        }",
      "        pub fn range_chmin<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree",
      "                .apply_range(range, ChminChmaxAction::new_chmin(x))",
      "        }",
      "        pub fn range_chmax<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree",
      "                .apply_range(range, ChminChmaxAction::new_chmax(x))",
      "        }",
      "        pub fn range_update<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree",
      "                .apply_range(range, ChminChmaxAction::new_update(x))",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<T> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_chmin_range_min": {
    "scope": "rust",
    "prefix": "range_chmin_range_min",
    "body": [
      "use range_chmin_range_min::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_chmin_range_min {",
      "    use ac_library::lazysegtree::MapMonoid;",
      "    use ac_library::LazySegtree;",
      "    use ac_library::Min;",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    use std::ops::RangeBounds;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeChminRangeMin(Infallible);",
      "    impl MapMonoid for RangeChminRangeMin {",
      "        type M = Min<i64>;",
      "        type F = i64;",
      "        fn identity_map() -> Self::F {",
      "            i64::MAX",
      "        }",
      "        fn mapping(",
      "            f: &Self::F,",
      "            x: &<Self::M as ac_library::Monoid>::S,",
      "        ) -> <Self::M as ac_library::Monoid>::S {",
      "            (*f).min(*x)",
      "        }",
      "        fn composition(f: &Self::F, g: &Self::F) -> Self::F {",
      "            (*f).min(*g)",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct RangeChminRangeMinSegtree {",
      "        segtree: LazySegtree<RangeChminRangeMin>,",
      "        len: usize,",
      "    }",
      "    impl RangeChminRangeMinSegtree {",
      "        pub fn new(n: usize) -> Self {",
      "            let xs = vec![0; n];",
      "            Self::from_slice(&xs)",
      "        }",
      "        pub fn from_slice(xs: &[i64]) -> RangeChminRangeMinSegtree {",
      "            let len = xs.len();",
      "            RangeChminRangeMinSegtree {",
      "                segtree: LazySegtree::from(xs.to_vec()),",
      "                len,",
      "            }",
      "        }",
      "        pub fn set(&mut self, p: usize, x: i64) {",
      "            self.segtree.set(p, x);",
      "        }",
      "        pub fn get(&mut self, p: usize) -> i64 {",
      "            self.segtree.get(p)",
      "        }",
      "        pub fn range_min<R>(&mut self, range: R) -> i64",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range)",
      "        }",
      "        pub fn all_min(&self) -> i64 {",
      "            self.segtree.all_prod()",
      "        }",
      "        pub fn chmin(&mut self, p: usize, x: i64) {",
      "            self.segtree.apply(p, x)",
      "        }",
      "        pub fn range_chmin<R>(&mut self, range: R, x: i64)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, x)",
      "        }",
      "        /// 左端 `l` を固定し、区間 `[l, r)` での最小値が述語 `g` を満たすような最大の `r` を返します。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn max_right<G>(&mut self, l: usize, g: G) -> usize",
      "        where",
      "            G: Fn(i64) -> bool,",
      "        {",
      "            self.segtree.max_right(l, g)",
      "        }",
      "        /// 右端 `r` を固定し、区間 `[l, r)` での最小値が述語 `g` を満たすような最小の `l` を返します。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn min_left<G>(&mut self, r: usize, g: G) -> usize",
      "        where",
      "            G: Fn(i64) -> bool,",
      "        {",
      "            self.segtree.min_left(r, g)",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<i64> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_chmin_range_sum": {
    "scope": "rust",
    "prefix": "range_chmin_range_sum",
    "body": [
      "use abstract_segtree_beats::*;",
      "use range_chmin_range_sum::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod abstract_segtree_beats {",
      "    fn ceil_pow2(n: u32) -> u32 {",
      "        32 - n.saturating_sub(1).leading_zeros()",
      "    }",
      "    pub trait MonoidBeats {",
      "        type S: Clone;",
      "        fn identity() -> Self::S;",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S;",
      "        fn fails(a: &Self::S) -> bool;",
      "    }",
      "    pub trait MapMonoidBeats {",
      "        type M: MonoidBeats;",
      "        type F: Clone;",
      "        fn identity_element() -> <Self::M as MonoidBeats>::S {",
      "            Self::M::identity()",
      "        }",
      "        fn binary_operation(",
      "            a: &<Self::M as MonoidBeats>::S,",
      "            b: &<Self::M as MonoidBeats>::S,",
      "        ) -> <Self::M as MonoidBeats>::S {",
      "            Self::M::binary_operation(a, b)",
      "        }",
      "        fn fails(a: &<Self::M as MonoidBeats>::S) -> bool {",
      "            Self::M::fails(a)",
      "        }",
      "        fn identity_map() -> Self::F;",
      "        fn mapping(f: &Self::F, x: &<Self::M as MonoidBeats>::S) -> <Self::M as MonoidBeats>::S;",
      "        fn composition(f: &Self::F, g: &Self::F) -> Self::F;",
      "    }",
      "    impl<F: MapMonoidBeats> Default for SegtreeBeats<F> {",
      "        fn default() -> Self {",
      "            Self::new(0)",
      "        }",
      "    }",
      "    impl<F: MapMonoidBeats> SegtreeBeats<F> {",
      "        pub fn new(n: usize) -> Self {",
      "            vec![F::identity_element(); n].into()",
      "        }",
      "    }",
      "    impl<F: MapMonoidBeats> From<Vec<<F::M as MonoidBeats>::S>> for SegtreeBeats<F> {",
      "        fn from(v: Vec<<F::M as MonoidBeats>::S>) -> Self {",
      "            let n = v.len();",
      "            let log = ceil_pow2(n as u32) as usize;",
      "            let size = 1 << log;",
      "            let mut d = vec![F::identity_element(); 2 * size];",
      "            let lz = vec![F::identity_map(); size];",
      "            d[size..(size + n)].clone_from_slice(&v);",
      "            let mut ret = SegtreeBeats {",
      "                n,",
      "                size,",
      "                log,",
      "                d,",
      "                lz,",
      "            };",
      "            for i in (1..size).rev() {",
      "                ret.update(i);",
      "            }",
      "            ret",
      "        }",
      "    }",
      "    impl<F: MapMonoidBeats> SegtreeBeats<F> {",
      "        pub fn set(&mut self, mut p: usize, x: <F::M as MonoidBeats>::S) {",
      "            assert!(p < self.n);",
      "            p += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(p >> i);",
      "            }",
      "            self.d[p] = x;",
      "            for i in 1..=self.log {",
      "                self.update(p >> i);",
      "            }",
      "        }",
      "        pub fn get(&mut self, mut p: usize) -> <F::M as MonoidBeats>::S {",
      "            assert!(p < self.n);",
      "            p += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(p >> i);",
      "            }",
      "            self.d[p].clone()",
      "        }",
      "        pub fn prod<R>(&mut self, range: R) -> <F::M as MonoidBeats>::S",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            if range.start_bound() == Bound::Unbounded && range.end_bound() == Bound::Unbounded {",
      "                return self.all_prod();",
      "            }",
      "            let mut r = match range.end_bound() {",
      "                Bound::Included(r) => r + 1,",
      "                Bound::Excluded(r) => *r,",
      "                Bound::Unbounded => self.n,",
      "            };",
      "            let mut l = match range.start_bound() {",
      "                Bound::Included(l) => *l,",
      "                Bound::Excluded(l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            assert!(l <= r && r <= self.n);",
      "            if l == r {",
      "                return F::identity_element();",
      "            }",
      "            l += self.size;",
      "            r += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                if ((l >> i) << i) != l {",
      "                    self.push(l >> i);",
      "                }",
      "                if ((r >> i) << i) != r {",
      "                    self.push(r >> i);",
      "                }",
      "            }",
      "            let mut sml = F::identity_element();",
      "            let mut smr = F::identity_element();",
      "            while l < r {",
      "                if l & 1 != 0 {",
      "                    sml = F::binary_operation(&sml, &self.d[l]);",
      "                    l += 1;",
      "                }",
      "                if r & 1 != 0 {",
      "                    r -= 1;",
      "                    smr = F::binary_operation(&self.d[r], &smr);",
      "                }",
      "                l >>= 1;",
      "                r >>= 1;",
      "            }",
      "            F::binary_operation(&sml, &smr)",
      "        }",
      "        pub fn all_prod(&self) -> <F::M as MonoidBeats>::S {",
      "            self.d[1].clone()",
      "        }",
      "        pub fn apply(&mut self, mut p: usize, f: F::F) {",
      "            assert!(p < self.n);",
      "            p += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(p >> i);",
      "            }",
      "            self.d[p] = F::mapping(&f, &self.d[p]);",
      "            for i in 1..=self.log {",
      "                self.update(p >> i);",
      "            }",
      "        }",
      "        pub fn apply_range<R>(&mut self, range: R, f: F::F)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            let mut r = match range.end_bound() {",
      "                Bound::Included(r) => r + 1,",
      "                Bound::Excluded(r) => *r,",
      "                Bound::Unbounded => self.n,",
      "            };",
      "            let mut l = match range.start_bound() {",
      "                Bound::Included(l) => *l,",
      "                Bound::Excluded(l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            assert!(l <= r && r <= self.n);",
      "            if l == r {",
      "                return;",
      "            }",
      "            l += self.size;",
      "            r += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                if ((l >> i) << i) != l {",
      "                    self.push(l >> i);",
      "                }",
      "                if ((r >> i) << i) != r {",
      "                    self.push((r - 1) >> i);",
      "                }",
      "            }",
      "            {",
      "                let l2 = l;",
      "                let r2 = r;",
      "                while l < r {",
      "                    if l & 1 != 0 {",
      "                        self.all_apply(l, f.clone());",
      "                        l += 1;",
      "                    }",
      "                    if r & 1 != 0 {",
      "                        r -= 1;",
      "                        self.all_apply(r, f.clone());",
      "                    }",
      "                    l >>= 1;",
      "                    r >>= 1;",
      "                }",
      "                l = l2;",
      "                r = r2;",
      "            }",
      "            for i in 1..=self.log {",
      "                if ((l >> i) << i) != l {",
      "                    self.update(l >> i);",
      "                }",
      "                if ((r >> i) << i) != r {",
      "                    self.update((r - 1) >> i);",
      "                }",
      "            }",
      "        }",
      "        pub fn max_right<G>(&mut self, mut l: usize, g: G) -> usize",
      "        where",
      "            G: Fn(<F::M as MonoidBeats>::S) -> bool,",
      "        {",
      "            assert!(l <= self.n);",
      "            assert!(g(F::identity_element()));",
      "            if l == self.n {",
      "                return self.n;",
      "            }",
      "            l += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push(l >> i);",
      "            }",
      "            let mut sm = F::identity_element();",
      "            while {",
      "                while l % 2 == 0 {",
      "                    l >>= 1;",
      "                }",
      "                if !g(F::binary_operation(&sm, &self.d[l])) {",
      "                    while l < self.size {",
      "                        self.push(l);",
      "                        l *= 2;",
      "                        let res = F::binary_operation(&sm, &self.d[l]);",
      "                        if g(res.clone()) {",
      "                            sm = res;",
      "                            l += 1;",
      "                        }",
      "                    }",
      "                    return l - self.size;",
      "                }",
      "                sm = F::binary_operation(&sm, &self.d[l]);",
      "                l += 1;",
      "                {",
      "                    let l = l as isize;",
      "                    (l & -l) != l",
      "                }",
      "            } {}",
      "            self.n",
      "        }",
      "        pub fn min_left<G>(&mut self, mut r: usize, g: G) -> usize",
      "        where",
      "            G: Fn(<F::M as MonoidBeats>::S) -> bool,",
      "        {",
      "            assert!(r <= self.n);",
      "            assert!(g(F::identity_element()));",
      "            if r == 0 {",
      "                return 0;",
      "            }",
      "            r += self.size;",
      "            for i in (1..=self.log).rev() {",
      "                self.push((r - 1) >> i);",
      "            }",
      "            let mut sm = F::identity_element();",
      "            while {",
      "                r -= 1;",
      "                while r > 1 && r % 2 != 0 {",
      "                    r >>= 1;",
      "                }",
      "                if !g(F::binary_operation(&self.d[r], &sm)) {",
      "                    while r < self.size {",
      "                        self.push(r);",
      "                        r = 2 * r + 1;",
      "                        let res = F::binary_operation(&self.d[r], &sm);",
      "                        if g(res.clone()) {",
      "                            sm = res;",
      "                            r -= 1;",
      "                        }",
      "                    }",
      "                    return r + 1 - self.size;",
      "                }",
      "                sm = F::binary_operation(&self.d[r], &sm);",
      "                {",
      "                    let r = r as isize;",
      "                    (r & -r) != r",
      "                }",
      "            } {}",
      "            0",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<<F::M as MonoidBeats>::S> {",
      "            (0..self.n).map(|i| self.get(i)).collect()",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct SegtreeBeats<F>",
      "    where",
      "        F: MapMonoidBeats,",
      "    {",
      "        n: usize,",
      "        size: usize,",
      "        log: usize,",
      "        d: Vec<<F::M as MonoidBeats>::S>,",
      "        lz: Vec<F::F>,",
      "    }",
      "    impl<F> SegtreeBeats<F>",
      "    where",
      "        F: MapMonoidBeats,",
      "    {",
      "        fn update(&mut self, k: usize) {",
      "            self.d[k] = F::binary_operation(&self.d[2 * k], &self.d[2 * k + 1]);",
      "        }",
      "        fn all_apply(&mut self, k: usize, f: F::F) {",
      "            self.d[k] = F::mapping(&f, &self.d[k]);",
      "            if k < self.size {",
      "                self.lz[k] = F::composition(&f, &self.lz[k]);",
      "                if F::fails(&self.d[k]) {",
      "                    self.push(k);",
      "                    self.update(k)",
      "                }",
      "            }",
      "        }",
      "        fn push(&mut self, k: usize) {",
      "            self.all_apply(2 * k, self.lz[k].clone());",
      "            self.all_apply(2 * k + 1, self.lz[k].clone());",
      "            self.lz[k] = F::identity_map();",
      "        }",
      "    }",
      "    use std::{",
      "        fmt::{Debug, Error, Formatter, Write},",
      "        ops::{Bound, RangeBounds},",
      "    };",
      "    impl<F> Debug for SegtreeBeats<F>",
      "    where",
      "        F: MapMonoidBeats,",
      "        F::F: Debug,",
      "        <F::M as MonoidBeats>::S: Debug,",
      "    {",
      "        fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {",
      "            for i in 0..self.log {",
      "                for j in 0..1 << i {",
      "                    f.write_fmt(format_args!(",
      "                        \"{:?}[{:?}]\\t\",",
      "                        self.d[(1 << i) + j],",
      "                        self.lz[(1 << i) + j]",
      "                    ))?;",
      "                }",
      "                f.write_char('\\n')?;",
      "            }",
      "            for i in 0..self.size {",
      "                f.write_fmt(format_args!(\"{:?}\\t\", self.d[self.size + i]))?;",
      "            }",
      "            Ok(())",
      "        }",
      "    }",
      "}",
      "pub mod range_chmin_range_sum {",
      "    use super::{MapMonoidBeats, MonoidBeats, SegtreeBeats};",
      "    use itertools::Itertools;",
      "    use std::{",
      "        cmp::{max, min},",
      "        convert::Infallible,",
      "        ops::RangeBounds,",
      "    };",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct RangeSum {",
      "        pub sum: i64,",
      "        pub len: usize,",
      "        pub max: i64,",
      "        pub max_cnt: usize,",
      "        pub max_2nd: i64,",
      "    }",
      "    impl RangeSum {",
      "        pub fn unit(x: i64) -> Option<RangeSum> {",
      "            Some(RangeSum {",
      "                sum: x,",
      "                len: 1,",
      "                max: x,",
      "                max_cnt: 1,",
      "                max_2nd: i64::MIN,",
      "            })",
      "        }",
      "    }",
      "    fn second_largest(a0: i64, a1: i64, b0: i64, b1: i64) -> i64 {",
      "        if a0 == b0 {",
      "            max(a1, b1)",
      "        } else if a1 >= b0 {",
      "            a1",
      "        } else if b1 >= a0 {",
      "            b1",
      "        } else {",
      "            min(a0, b0)",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeSumMonoid(Infallible);",
      "    impl MonoidBeats for RangeSumMonoid {",
      "        type S = Option<RangeSum>;",
      "        fn identity() -> Self::S {",
      "            Some(RangeSum {",
      "                sum: 0,",
      "                len: 0,",
      "                max: i64::MIN,",
      "                max_cnt: 0,",
      "                max_2nd: i64::MIN,",
      "            })",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            match (a, b) {",
      "                (None, None) => None,",
      "                (None, Some(_)) => None,",
      "                (Some(_), None) => None,",
      "                (Some(a), Some(b)) => Some(RangeSum {",
      "                    sum: a.sum + b.sum,",
      "                    len: a.len + b.len,",
      "                    max: max(a.max, b.max),",
      "                    max_cnt: a.max_cnt * (a.max >= b.max) as usize",
      "                        + b.max_cnt * (b.max >= a.max) as usize,",
      "                    max_2nd: second_largest(a.max, a.max_2nd, b.max, b.max_2nd),",
      "                }),",
      "            }",
      "        }",
      "        fn fails(a: &Self::S) -> bool {",
      "            a.is_none()",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct ChminFunc {",
      "        pub chmin_val: i64,",
      "    }",
      "    impl ChminFunc {",
      "        pub fn new(x: i64) -> Self {",
      "            ChminFunc { chmin_val: x }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeChminRangeSum(Infallible);",
      "    impl MapMonoidBeats for RangeChminRangeSum {",
      "        type F = ChminFunc;",
      "        type M = RangeSumMonoid;",
      "        fn identity_map() -> Self::F {",
      "            ChminFunc {",
      "                chmin_val: i64::MAX,",
      "            }",
      "        }",
      "        #[allow(clippy::if_same_then_else)]",
      "        fn mapping(f: &Self::F, x: &<Self::M as MonoidBeats>::S) -> <Self::M as MonoidBeats>::S {",
      "            match x {",
      "                None => None,",
      "                Some(x) => {",
      "                    if x.len == 0 {",
      "                        Some(*x)",
      "                    } else if f.chmin_val >= x.max {",
      "                        Some(*x)",
      "                    } else if f.chmin_val > x.max_2nd {",
      "                        Some(RangeSum {",
      "                            sum: x.sum + (f.chmin_val - x.max) * x.max_cnt as i64,",
      "                            len: x.len,",
      "                            max: f.chmin_val,",
      "                            max_cnt: x.max_cnt,",
      "                            max_2nd: x.max_2nd,",
      "                        })",
      "                    } else {",
      "                        None",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        fn composition(f: &Self::F, g: &Self::F) -> Self::F {",
      "            ChminFunc {",
      "                chmin_val: min(f.chmin_val, g.chmin_val),",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct RangeChminRangeSumSegtree {",
      "        segtree: SegtreeBeats<RangeChminRangeSum>,",
      "        len: usize,",
      "    }",
      "    impl RangeChminRangeSumSegtree {",
      "        pub fn new(n: usize) -> Self {",
      "            let segtree = SegtreeBeats::<RangeChminRangeSum>::new(n);",
      "            Self { segtree, len: n }",
      "        }",
      "        pub fn from_slice(xs: &[i64]) -> Self {",
      "            let len = xs.len();",
      "            let segtree = SegtreeBeats::<RangeChminRangeSum>::from(",
      "                xs.iter().copied().map(RangeSum::unit).collect_vec(),",
      "            );",
      "            Self { segtree, len }",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn set(&mut self, p: usize, x: i64) {",
      "            self.segtree.set(p, RangeSum::unit(x));",
      "        }",
      "        pub fn get(&mut self, p: usize) -> i64 {",
      "            self.segtree.get(p).unwrap().sum",
      "        }",
      "        pub fn sum<R: RangeBounds<usize>>(&mut self, range: R) -> i64 {",
      "            self.segtree.prod(range).unwrap().sum",
      "        }",
      "        pub fn all_sum(&mut self) -> i64 {",
      "            self.segtree.all_prod().unwrap().sum",
      "        }",
      "        pub fn chmin<R: RangeBounds<usize>>(&mut self, range: R, x: i64) {",
      "            self.segtree.apply_range(range, ChminFunc::new(x));",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<i64> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_div_ceil_range_min_max": {
    "scope": "rust",
    "prefix": "range_div_ceil_range_min_max",
    "body": [
      "use range_div_ceil_range_min_max::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_div_ceil_range_min_max {",
      "    use ac_library::{LazySegtree, MapMonoid, Monoid};",
      "    use itertools::Itertools;",
      "    use num_integer::Integer;",
      "    use std::convert::Infallible;",
      "    use std::ops::RangeBounds;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct RangeMinMax {",
      "        pub min: i64,",
      "        pub max: i64,",
      "    }",
      "    impl RangeMinMax {",
      "        pub fn new(min: i64, max: i64) -> Self {",
      "            Self { min, max }",
      "        }",
      "        pub fn unit(x: i64) -> Self {",
      "            Self { min: x, max: x }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeMinMaxMonoid(Infallible);",
      "    impl Monoid for RangeMinMaxMonoid {",
      "        type S = RangeMinMax;",
      "        fn identity() -> RangeMinMax {",
      "            RangeMinMax {",
      "                min: i64::MAX,",
      "                max: i64::MIN,",
      "            }",
      "        }",
      "        fn binary_operation(a: &RangeMinMax, b: &RangeMinMax) -> RangeMinMax {",
      "            RangeMinMax {",
      "                min: i64::min(a.min, b.min),",
      "                max: i64::max(a.max, b.max),",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeDivCeilRangeMinMax(Infallible);",
      "    impl MapMonoid for RangeDivCeilRangeMinMax {",
      "        type M = RangeMinMaxMonoid;",
      "        type F = i64;",
      "        fn identity_map() -> i64 {",
      "            1",
      "        }",
      "        fn composition(a: &i64, b: &i64) -> i64 {",
      "            a.saturating_mul(*b)",
      "        }",
      "        fn mapping(f: &i64, x: &RangeMinMax) -> RangeMinMax {",
      "            let min_v = if x.min == i64::MAX {",
      "                i64::MAX",
      "            } else {",
      "                Integer::div_ceil(&x.min, f)",
      "            };",
      "            let max_v = if x.max == i64::MIN {",
      "                i64::MIN",
      "            } else {",
      "                Integer::div_ceil(&x.max, f)",
      "            };",
      "            RangeMinMax {",
      "                min: min_v,",
      "                max: max_v,",
      "            }",
      "        }",
      "    }",
      "    /// 区間切り上げ除算と区間最小値・最大値取得を行う遅延セグメント木。",
      "    /// 以下の操作をサポートします。",
      "    /// - **区間切り上げ除算**: 区間 `[l, r)` の各要素 `a_i` を `ceil(a_i / x)` に更新します。",
      "    /// - **区間最小値・最大値取得**: 区間 `[l, r)` の要素の最小値と最大値 `(min, max)` を取得します。",
      "    /// # 制約",
      "    /// - 更新に使う値 `x` （割る数）は正の整数である必要があります。",
      "    /// - セグメント木に乗せるデータは正負どちらでも問題ありません。",
      "    #[derive(Clone)]",
      "    pub struct RangeDivCeilRangeMinMaxSegtree {",
      "        segtree: LazySegtree<RangeDivCeilRangeMinMax>,",
      "        len: usize,",
      "    }",
      "    impl RangeDivCeilRangeMinMaxSegtree {",
      "        pub fn new(n: usize) -> Self {",
      "            let xs = vec![0; n];",
      "            Self::from_slice(&xs)",
      "        }",
      "        pub fn from_slice(xs: &[i64]) -> RangeDivCeilRangeMinMaxSegtree {",
      "            let len = xs.len();",
      "            let initial_data: Vec<RangeMinMax> = xs.iter().map(|&x| RangeMinMax::unit(x)).collect();",
      "            RangeDivCeilRangeMinMaxSegtree {",
      "                segtree: LazySegtree::from(initial_data),",
      "                len,",
      "            }",
      "        }",
      "        pub fn set(&mut self, p: usize, x: i64) {",
      "            self.segtree.set(p, RangeMinMax::unit(x));",
      "        }",
      "        pub fn get(&mut self, p: usize) -> i64 {",
      "            self.segtree.get(p).min",
      "        }",
      "        pub fn range_min<R>(&mut self, range: R) -> i64",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range).min",
      "        }",
      "        pub fn range_max<R>(&mut self, range: R) -> i64",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range).max",
      "        }",
      "        pub fn all_min(&self) -> i64 {",
      "            self.segtree.all_prod().min",
      "        }",
      "        pub fn all_max(&self) -> i64 {",
      "            self.segtree.all_prod().max",
      "        }",
      "        /// A[p] <- ceil(A[p] / x) を計算する",
      "        pub fn div_ceil(&mut self, p: usize, x: i64) {",
      "            self.segtree.apply(p, x)",
      "        }",
      "        /// p in range に対して A[p] <- ceil(A[p] / x) を計算する",
      "        pub fn range_div_ceil<R>(&mut self, range: R, x: i64)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, x)",
      "        }",
      "        pub fn max_right<G>(&mut self, l: usize, g: G) -> usize",
      "        where",
      "            G: Fn(RangeMinMax) -> bool,",
      "        {",
      "            self.segtree.max_right(l, g)",
      "        }",
      "        pub fn min_left<G>(&mut self, r: usize, g: G) -> usize",
      "        where",
      "            G: Fn(RangeMinMax) -> bool,",
      "        {",
      "            self.segtree.min_left(r, g)",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<i64> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_div_floor_range_max": {
    "scope": "rust",
    "prefix": "range_div_floor_range_max",
    "body": [
      "use range_div_floor_range_max::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_div_floor_range_max {",
      "    use ac_library::{LazySegtree, MapMonoid, Monoid};",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    use std::ops::RangeBounds;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeMax(Infallible);",
      "    impl Monoid for RangeMax {",
      "        type S = i64;",
      "        fn identity() -> i64 {",
      "            i64::MIN",
      "        }",
      "        fn binary_operation(a: &i64, b: &i64) -> i64 {",
      "            i64::max(*a, *b)",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeDivFloorRangeMax(Infallible);",
      "    impl MapMonoid for RangeDivFloorRangeMax {",
      "        type M = RangeMax;",
      "        type F = i64;",
      "        fn identity_map() -> i64 {",
      "            1",
      "        }",
      "        fn composition(a: &i64, b: &i64) -> i64 {",
      "            a.saturating_mul(*b)",
      "        }",
      "        fn mapping(f: &i64, x: &i64) -> i64 {",
      "            if *x == i64::MIN {",
      "                i64::MIN",
      "            } else {",
      "                x.div_euclid(*f)",
      "            }",
      "        }",
      "    }",
      "    /// 区間切り捨て除算と区間最大値取得を行う遅延セグメント木。",
      "    /// 以下の操作をサポートします。",
      "    /// - **区間切り捨て除算**: 区間 `[l, r)` の各要素 `a_i` を `floor(a_i / x)` に更新します。",
      "    /// - **区間最大値取得**: 区間 `[l, r)` の要素の最大値を取得します。",
      "    /// # 制約",
      "    /// - 更新に使う値 `x` （割る数）は正の整数である必要があります。",
      "    /// - セグメント木に乗せるデータは正負どちらでも問題ありません。",
      "    #[derive(Clone)]",
      "    pub struct RangeDivFloorRangeMaxSegtree {",
      "        segtree: LazySegtree<RangeDivFloorRangeMax>,",
      "        len: usize,",
      "    }",
      "    impl RangeDivFloorRangeMaxSegtree {",
      "        pub fn new(n: usize) -> Self {",
      "            let xs = vec![0; n];",
      "            Self::from_slice(&xs)",
      "        }",
      "        pub fn from_slice(xs: &[i64]) -> RangeDivFloorRangeMaxSegtree {",
      "            let len = xs.len();",
      "            RangeDivFloorRangeMaxSegtree {",
      "                segtree: LazySegtree::from(xs.to_vec()),",
      "                len,",
      "            }",
      "        }",
      "        pub fn set(&mut self, p: usize, x: i64) {",
      "            self.segtree.set(p, x);",
      "        }",
      "        pub fn get(&mut self, p: usize) -> i64 {",
      "            self.segtree.get(p)",
      "        }",
      "        pub fn range_max<R>(&mut self, range: R) -> i64",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range)",
      "        }",
      "        pub fn all_max(&self) -> i64 {",
      "            self.segtree.all_prod()",
      "        }",
      "        /// A[p] <- A[p] / x  を計算する",
      "        pub fn div_floor(&mut self, p: usize, x: i64) {",
      "            self.segtree.apply(p, x)",
      "        }",
      "        /// p in range に対して A[p] <- A[p] / x  を計算する",
      "        pub fn range_div_floor<R>(&mut self, range: R, x: i64)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, x)",
      "        }",
      "        /// 左端 `l` を固定し、区間 `[l, r)` での最大値が述語 `g` を満たすような最大の `r` を返します。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn max_right<G>(&mut self, l: usize, g: G) -> usize",
      "        where",
      "            G: Fn(i64) -> bool,",
      "        {",
      "            self.segtree.max_right(l, g)",
      "        }",
      "        /// 右端 `r` を固定し、区間 `[l, r)` での最大値が述語 `g` を満たすような最小の `l` を返します。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn min_left<G>(&mut self, r: usize, g: G) -> usize",
      "        where",
      "            G: Fn(i64) -> bool,",
      "        {",
      "            self.segtree.min_left(r, g)",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<i64> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_div_floor_range_min_max": {
    "scope": "rust",
    "prefix": "range_div_floor_range_min_max",
    "body": [
      "use range_div_floor_range_min_max::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_div_floor_range_min_max {",
      "    use ac_library::{LazySegtree, MapMonoid, Monoid};",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    use std::ops::RangeBounds;",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct RangeMinMax {",
      "        pub min: i64,",
      "        pub max: i64,",
      "    }",
      "    impl RangeMinMax {",
      "        pub fn new(min: i64, max: i64) -> Self {",
      "            Self { min, max }",
      "        }",
      "        pub fn unit(x: i64) -> Self {",
      "            Self { min: x, max: x }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeMinMaxMonoid(Infallible);",
      "    impl Monoid for RangeMinMaxMonoid {",
      "        type S = RangeMinMax;",
      "        fn identity() -> RangeMinMax {",
      "            RangeMinMax {",
      "                min: i64::MAX,",
      "                max: i64::MIN,",
      "            }",
      "        }",
      "        fn binary_operation(a: &RangeMinMax, b: &RangeMinMax) -> RangeMinMax {",
      "            RangeMinMax {",
      "                min: i64::min(a.min, b.min),",
      "                max: i64::max(a.max, b.max),",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeDivFloorRangeMinMax(Infallible);",
      "    impl MapMonoid for RangeDivFloorRangeMinMax {",
      "        type M = RangeMinMaxMonoid;",
      "        type F = i64;",
      "        fn identity_map() -> i64 {",
      "            1",
      "        }",
      "        fn composition(a: &i64, b: &i64) -> i64 {",
      "            a.saturating_mul(*b)",
      "        }",
      "        fn mapping(f: &i64, x: &RangeMinMax) -> RangeMinMax {",
      "            let min_v = if x.min == i64::MAX {",
      "                i64::MAX",
      "            } else {",
      "                x.min.div_euclid(*f)",
      "            };",
      "            let max_v = if x.max == i64::MIN {",
      "                i64::MIN",
      "            } else {",
      "                x.max.div_euclid(*f)",
      "            };",
      "            RangeMinMax {",
      "                min: min_v,",
      "                max: max_v,",
      "            }",
      "        }",
      "    }",
      "    /// 区間切り捨て除算と区間最小値・最大値取得を行う遅延セグメント木。",
      "    /// 以下の操作をサポートします。",
      "    /// - **区間切り捨て除算**: 区間 `[l, r)` の各要素 `a_i` を `floor(a_i / x)` に更新します。",
      "    /// - **区間最小値・最大値取得**: 区間 `[l, r)` の要素の最小値と最大値 `(min, max)` を取得します。",
      "    /// # 制約",
      "    /// - 更新に使う値 `x` （割る数）は正の整数である必要があります。",
      "    /// - セグメント木に乗せるデータは正負どちらでも問題ありません。",
      "    #[derive(Clone)]",
      "    pub struct RangeDivFloorRangeMinMaxSegtree {",
      "        segtree: LazySegtree<RangeDivFloorRangeMinMax>,",
      "        len: usize,",
      "    }",
      "    impl RangeDivFloorRangeMinMaxSegtree {",
      "        pub fn new(n: usize) -> Self {",
      "            let xs = vec![0; n];",
      "            Self::from_slice(&xs)",
      "        }",
      "        pub fn from_slice(xs: &[i64]) -> RangeDivFloorRangeMinMaxSegtree {",
      "            let len = xs.len();",
      "            let initial_data: Vec<RangeMinMax> = xs.iter().map(|&x| RangeMinMax::unit(x)).collect();",
      "            RangeDivFloorRangeMinMaxSegtree {",
      "                segtree: LazySegtree::from(initial_data),",
      "                len,",
      "            }",
      "        }",
      "        pub fn set(&mut self, p: usize, x: i64) {",
      "            self.segtree.set(p, RangeMinMax::unit(x));",
      "        }",
      "        pub fn get(&mut self, p: usize) -> i64 {",
      "            self.segtree.get(p).min",
      "        }",
      "        pub fn range_min<R>(&mut self, range: R) -> i64",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range).min",
      "        }",
      "        pub fn range_max<R>(&mut self, range: R) -> i64",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range).max",
      "        }",
      "        pub fn all_min(&self) -> i64 {",
      "            self.segtree.all_prod().min",
      "        }",
      "        pub fn all_max(&self) -> i64 {",
      "            self.segtree.all_prod().max",
      "        }",
      "        /// A[p] <- A[p] / x  を計算する",
      "        pub fn div_floor(&mut self, p: usize, x: i64) {",
      "            self.segtree.apply(p, x)",
      "        }",
      "        /// p in range に対して A[p] <- A[p] / x  を計算する",
      "        pub fn range_div_floor<R>(&mut self, range: R, x: i64)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, x)",
      "        }",
      "        pub fn max_right<G>(&mut self, l: usize, g: G) -> usize",
      "        where",
      "            G: Fn(RangeMinMax) -> bool,",
      "        {",
      "            self.segtree.max_right(l, g)",
      "        }",
      "        pub fn min_left<G>(&mut self, r: usize, g: G) -> usize",
      "        where",
      "            G: Fn(RangeMinMax) -> bool,",
      "        {",
      "            self.segtree.min_left(r, g)",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<i64> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_linear_add_range_sum": {
    "scope": "rust",
    "prefix": "range_linear_add_range_sum",
    "body": [
      "use range_linear_add_range_sum::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_linear_add_range_sum {",
      "    use ac_library::{LazySegtree, MapMonoid, Monoid};",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    use std::ops::{Add, Div, Mul, RangeBounds, Sub};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeSum<T> {",
      "        pub sum: T,",
      "        pub len: i64,",
      "        pub sum_idx: T,",
      "    }",
      "    impl<T> RangeSum<T>",
      "    where",
      "        T: From<i64>,",
      "    {",
      "        pub fn unit(x: T, idx: i64) -> RangeSum<T> {",
      "            RangeSum {",
      "                sum: x,",
      "                len: 1,",
      "                sum_idx: idx.into(),",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct ValueLenSum<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for ValueLenSum<T>",
      "    where",
      "        T: Copy + Add<Output = T> + From<i64>,",
      "    {",
      "        type S = RangeSum<T>;",
      "        fn identity() -> RangeSum<T> {",
      "            RangeSum {",
      "                sum: 0.into(),",
      "                len: 0,",
      "                sum_idx: 0.into(),",
      "            }",
      "        }",
      "        fn binary_operation(a: &RangeSum<T>, b: &RangeSum<T>) -> RangeSum<T> {",
      "            RangeSum {",
      "                sum: a.sum + b.sum,",
      "                len: a.len + b.len,",
      "                sum_idx: a.sum_idx + b.sum_idx,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct Linear<T> {",
      "        intercept: T,",
      "        slope: T,",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeLinearAddRangeSum<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> MapMonoid for RangeLinearAddRangeSum<T>",
      "    where",
      "        T: Copy + Add<Output = T> + Mul<Output = T> + Div<Output = T> + Sub<Output = T> + From<i64>,",
      "    {",
      "        type M = ValueLenSum<T>;",
      "        type F = Linear<T>;",
      "        fn identity_map() -> Linear<T> {",
      "            Linear {",
      "                intercept: 0.into(),",
      "                slope: 0.into(),",
      "            }",
      "        }",
      "        fn composition(f_outer: &Linear<T>, f_inner: &Linear<T>) -> Linear<T> {",
      "            Linear {",
      "                intercept: f_outer.intercept + f_inner.intercept,",
      "                slope: f_outer.slope + f_inner.slope,",
      "            }",
      "        }",
      "        fn mapping(f: &Linear<T>, x: &RangeSum<T>) -> RangeSum<T> {",
      "            RangeSum {",
      "                sum: x.sum + f.intercept * x.len.into() + f.slope * x.sum_idx,",
      "                len: x.len,",
      "                sum_idx: x.sum_idx,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct RangeLinearAddRangeSumSegtree<T>",
      "    where",
      "        T: Copy + Add<Output = T> + Mul<Output = T> + Div<Output = T> + Sub<Output = T> + From<i64>,",
      "    {",
      "        segtree: LazySegtree<RangeLinearAddRangeSum<T>>,",
      "        len: usize,",
      "    }",
      "    impl<T> RangeLinearAddRangeSumSegtree<T>",
      "    where",
      "        T: Copy + Add<Output = T> + Mul<Output = T> + Div<Output = T> + Sub<Output = T> + From<i64>,",
      "    {",
      "        pub fn new(n: usize) -> Self {",
      "            let xs = vec![0.into(); n];",
      "            Self::from_slice(&xs)",
      "        }",
      "        pub fn from_slice(xs: &[T]) -> RangeLinearAddRangeSumSegtree<T> {",
      "            let xs = xs",
      "                .iter()",
      "                .copied()",
      "                .enumerate()",
      "                .map(|(i, x)| RangeSum::unit(x, i as i64))",
      "                .collect_vec();",
      "            let len = xs.len();",
      "            RangeLinearAddRangeSumSegtree {",
      "                segtree: LazySegtree::from(xs),",
      "                len,",
      "            }",
      "        }",
      "        pub fn set(&mut self, p: usize, x: T) {",
      "            self.segtree.set(p, RangeSum::unit(x, p as i64));",
      "        }",
      "        pub fn get(&mut self, p: usize) -> T {",
      "            self.segtree.get(p).sum",
      "        }",
      "        pub fn range_sum<R>(&mut self, range: R) -> T",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range).sum",
      "        }",
      "        pub fn all_sum(&self) -> T {",
      "            self.segtree.all_prod().sum",
      "        }",
      "        /// range が l..r であるとする。",
      "        /// `i` in `l..r` に対して、`self[i] += init + diff * (i - l)` を計算する",
      "        pub fn range_linear_add<R>(&mut self, range: R, init: T, diff: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            use std::ops::Bound;",
      "            let l = match range.start_bound() {",
      "                Bound::Included(val) => *val,",
      "                Bound::Excluded(val) => *val + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            let intercept = init - diff * (l as i64).into();",
      "            let linear = Linear {",
      "                intercept,",
      "                slope: diff,",
      "            };",
      "            self.segtree.apply_range(range, linear);",
      "        }",
      "        /// 左端 `l` を固定し、区間 `[l, r)` での総和が述語 `g` を満たすような最大の `r` を返します。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn max_right<G>(&mut self, l: usize, g: G) -> usize",
      "        where",
      "            G: Fn(T) -> bool,",
      "        {",
      "            self.segtree.max_right(l, |x| g(x.sum))",
      "        }",
      "        /// 右端 `r` を固定し、区間 `[l, r)` での総和が述語 `g` を満たすような最小の `l` を返します。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn min_left<G>(&mut self, r: usize, g: G) -> usize",
      "        where",
      "            G: Fn(T) -> bool,",
      "        {",
      "            self.segtree.min_left(r, |x| g(x.sum))",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<T> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_linear_update_range_sum": {
    "scope": "rust",
    "prefix": "range_linear_update_range_sum",
    "body": [
      "use range_linear_update_range_sum::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_linear_update_range_sum {",
      "    use ac_library::{LazySegtree, MapMonoid, Monoid};",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    use std::ops::{Add, Div, Mul, RangeBounds, Sub};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeSum<T> {",
      "        pub sum: T,",
      "        pub len: i64,",
      "        pub sum_idx: T,",
      "    }",
      "    impl<T> RangeSum<T>",
      "    where",
      "        T: From<i64>,",
      "    {",
      "        pub fn unit(x: T, idx: i64) -> RangeSum<T> {",
      "            RangeSum {",
      "                sum: x,",
      "                len: 1,",
      "                sum_idx: idx.into(),",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct ValueLenSum<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for ValueLenSum<T>",
      "    where",
      "        T: Copy + Add<Output = T> + From<i64>,",
      "    {",
      "        type S = RangeSum<T>;",
      "        fn identity() -> RangeSum<T> {",
      "            RangeSum {",
      "                sum: 0.into(),",
      "                len: 0,",
      "                sum_idx: 0.into(),",
      "            }",
      "        }",
      "        fn binary_operation(a: &RangeSum<T>, b: &RangeSum<T>) -> RangeSum<T> {",
      "            RangeSum {",
      "                sum: a.sum + b.sum,",
      "                len: a.len + b.len,",
      "                sum_idx: a.sum_idx + b.sum_idx,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct Linear<T> {",
      "        intercept: T,",
      "        slope: T,",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeLinearUpdateRangeSum<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> MapMonoid for RangeLinearUpdateRangeSum<T>",
      "    where",
      "        T: Copy + Add<Output = T> + Mul<Output = T> + Div<Output = T> + Sub<Output = T> + From<i64>,",
      "    {",
      "        type M = ValueLenSum<T>;",
      "        type F = Option<Linear<T>>;",
      "        fn identity_map() -> Option<Linear<T>> {",
      "            None",
      "        }",
      "        fn composition(",
      "            f_outer: &Option<Linear<T>>,",
      "            f_inner: &Option<Linear<T>>,",
      "        ) -> Option<Linear<T>> {",
      "            if f_outer.is_some() {",
      "                *f_outer",
      "            } else {",
      "                *f_inner",
      "            }",
      "        }",
      "        fn mapping(f: &Option<Linear<T>>, x: &RangeSum<T>) -> RangeSum<T> {",
      "            if let Some(f) = f {",
      "                RangeSum {",
      "                    sum: f.intercept * x.len.into() + f.slope * x.sum_idx,",
      "                    len: x.len,",
      "                    sum_idx: x.sum_idx,",
      "                }",
      "            } else {",
      "                *x",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct RangeLinearUpdateRangeSumSegtree<T>",
      "    where",
      "        T: Copy + Add<Output = T> + Mul<Output = T> + Div<Output = T> + Sub<Output = T> + From<i64>,",
      "    {",
      "        segtree: LazySegtree<RangeLinearUpdateRangeSum<T>>,",
      "        len: usize,",
      "    }",
      "    impl<T> RangeLinearUpdateRangeSumSegtree<T>",
      "    where",
      "        T: Copy + Add<Output = T> + Mul<Output = T> + Div<Output = T> + Sub<Output = T> + From<i64>,",
      "    {",
      "        pub fn new(n: usize) -> Self {",
      "            let xs = vec![0.into(); n];",
      "            Self::from_slice(&xs)",
      "        }",
      "        pub fn from_slice(xs: &[T]) -> RangeLinearUpdateRangeSumSegtree<T> {",
      "            let xs = xs",
      "                .iter()",
      "                .copied()",
      "                .enumerate()",
      "                .map(|(i, x)| RangeSum::unit(x, i as i64))",
      "                .collect_vec();",
      "            let len = xs.len();",
      "            RangeLinearUpdateRangeSumSegtree {",
      "                segtree: LazySegtree::from(xs),",
      "                len,",
      "            }",
      "        }",
      "        pub fn set(&mut self, p: usize, x: T) {",
      "            self.segtree.set(p, RangeSum::unit(x, p as i64));",
      "        }",
      "        pub fn get(&mut self, p: usize) -> T {",
      "            self.segtree.get(p).sum",
      "        }",
      "        pub fn range_sum<R>(&mut self, range: R) -> T",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range).sum",
      "        }",
      "        pub fn all_sum(&self) -> T {",
      "            self.segtree.all_prod().sum",
      "        }",
      "        /// range が l..r であるとする。",
      "        /// `i` in `l..r` に対して、`self[i] += init + diff * (i - l)` を計算する",
      "        pub fn range_linear_update<R>(&mut self, range: R, init: T, diff: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            use std::ops::Bound;",
      "            let l = match range.start_bound() {",
      "                Bound::Included(val) => *val,",
      "                Bound::Excluded(val) => *val + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            let intercept = init - diff * (l as i64).into();",
      "            let linear = Linear {",
      "                intercept,",
      "                slope: diff,",
      "            };",
      "            self.segtree.apply_range(range, Some(linear));",
      "        }",
      "        /// 左端 `l` を固定し、区間 `[l, r)` での総和が述語 `g` を満たすような最大の `r` を返します。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn max_right<G>(&mut self, l: usize, g: G) -> usize",
      "        where",
      "            G: Fn(T) -> bool,",
      "        {",
      "            self.segtree.max_right(l, |x| g(x.sum))",
      "        }",
      "        /// 右端 `r` を固定し、区間 `[l, r)` での総和が述語 `g` を満たすような最小の `l` を返します。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn min_left<G>(&mut self, r: usize, g: G) -> usize",
      "        where",
      "            G: Fn(T) -> bool,",
      "        {",
      "            self.segtree.min_left(r, |x| g(x.sum))",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<T> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_max_segtree": {
    "scope": "rust",
    "prefix": "range_max_segtree",
    "body": [
      "use min_max_monoid::*;",
      "use range_max_segtree::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod min_max_monoid {",
      "    use ac_library::Monoid;",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    pub trait BoundedBelow {",
      "        fn min_value() -> Self;",
      "    }",
      "    pub trait BoundedAbove {",
      "        fn max_value() -> Self;",
      "    }",
      "    macro_rules ! impl_bounded {(\\$ (\\$ ty : ty ) ,* ) => {\\$ (impl BoundedBelow for \\$ ty {# [inline ] fn min_value () -> Self {Self :: MIN } } impl BoundedAbove for \\$ ty {# [inline ] fn max_value () -> Self {Self :: MAX } } ) * } ; }",
      "    impl_bounded!(i8, i16, i32, i64, i128, isize, u8, u16, u32, u64, u128, usize);",
      "    impl<T: BoundedAbove> BoundedBelow for std::cmp::Reverse<T> {",
      "        #[inline]",
      "        fn min_value() -> Self {",
      "            std::cmp::Reverse(T::max_value())",
      "        }",
      "    }",
      "    impl<T: BoundedBelow> BoundedAbove for std::cmp::Reverse<T> {",
      "        #[inline]",
      "        fn max_value() -> Self {",
      "            std::cmp::Reverse(T::min_value())",
      "        }",
      "    }",
      "    macro_rules ! impl_bounded_tuples {(\\$ head : ident ) => {} ; (\\$ head : ident , \\$ (\\$ tail : ident ) ,* ) => {impl <\\$ head , \\$ (\\$ tail ) ,*> BoundedBelow for (\\$ head , \\$ (\\$ tail ) ,* ) where \\$ head : BoundedBelow , \\$ (\\$ tail : BoundedBelow ) ,* {# [inline ] fn min_value () -> Self {(\\$ head :: min_value () , \\$ (\\$ tail :: min_value () ) ,* ) } } impl <\\$ head , \\$ (\\$ tail ) ,*> BoundedAbove for (\\$ head , \\$ (\\$ tail ) ,* ) where \\$ head : BoundedAbove , \\$ (\\$ tail : BoundedAbove ) ,* {# [inline ] fn max_value () -> Self {(\\$ head :: max_value () , \\$ (\\$ tail :: max_value () ) ,* ) } } impl_bounded_tuples ! (\\$ (\\$ tail ) ,* ) ; } ; () => {} ; }",
      "    impl_bounded_tuples!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12);",
      "    /// 辞書式順序で最小の要素を管理するモノイド (単位元は最大値)",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct MinMonoid<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for MinMonoid<T>",
      "    where",
      "        T: BoundedAbove + Ord + Clone,",
      "    {",
      "        type S = T;",
      "        fn identity() -> Self::S {",
      "            T::max_value()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            std::cmp::min(a, b).clone()",
      "        }",
      "    }",
      "    /// 辞書式順序で最大の要素を管理するモノイド (単位元は最小値)",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct MaxMonoid<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for MaxMonoid<T>",
      "    where",
      "        T: BoundedBelow + Ord + Clone,",
      "    {",
      "        type S = T;",
      "        fn identity() -> Self::S {",
      "            T::min_value()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            std::cmp::max(a, b).clone()",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::module_inception)]",
      "pub mod range_max_segtree {",
      "    use super::MaxMonoid;",
      "    use ac_library::{Monoid, Segtree};",
      "    use itertools::Itertools;",
      "    use std::ops::RangeBounds;",
      "    /// ACL の Segtree を使用した区間最大セグメント木。",
      "    /// 数値型 T に対して点更新・区間最大取得を行う。",
      "    #[derive(Clone)]",
      "    pub struct RangeMaxSegtree<T>",
      "    where",
      "        MaxMonoid<T>: Monoid<S = T>,",
      "        T: Clone,",
      "    {",
      "        segtree: Segtree<MaxMonoid<T>>,",
      "        len: usize,",
      "    }",
      "    impl<T> RangeMaxSegtree<T>",
      "    where",
      "        MaxMonoid<T>: Monoid<S = T>,",
      "        T: Copy + Ord,",
      "    {",
      "        /// 単位元で初期化されたセグメント木を構築する",
      "        pub fn new(n: usize) -> Self {",
      "            Self {",
      "                segtree: Segtree::<MaxMonoid<T>>::new(n),",
      "                len: n,",
      "            }",
      "        }",
      "        /// 配列からセグメント木を構築する",
      "        pub fn from_slice(xs: &[T]) -> Self {",
      "            let len = xs.len();",
      "            Self {",
      "                segtree: Segtree::<MaxMonoid<T>>::from(xs.to_vec()),",
      "                len,",
      "            }",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        /// p 番目の要素を x に更新する",
      "        pub fn set(&mut self, p: usize, x: T) {",
      "            self.segtree.set(p, x);",
      "        }",
      "        /// p 番目の要素を取得する",
      "        pub fn get(&self, p: usize) -> T {",
      "            self.segtree.get(p)",
      "        }",
      "        /// range の最大値を取得する",
      "        pub fn range_max<R>(&self, range: R) -> T",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range)",
      "        }",
      "        /// 全要素の最大値を取得する",
      "        pub fn all_max(&self) -> T {",
      "            self.segtree.all_prod()",
      "        }",
      "        /// セグメント木上の二分探索。",
      "        /// [l, r) の最大値 s について f(&s) が true となる最大の r を返す。",
      "        pub fn max_right<F>(&self, l: usize, f: F) -> usize",
      "        where",
      "            F: Fn(&T) -> bool,",
      "        {",
      "            self.segtree.max_right(l, f)",
      "        }",
      "        /// セグメント木上の二分探索。",
      "        /// [l, r) の最大値 s について f(&s) が true となる最小の l を返す。",
      "        pub fn min_left<F>(&self, r: usize, f: F) -> usize",
      "        where",
      "            F: Fn(&T) -> bool,",
      "        {",
      "            self.segtree.min_left(r, f)",
      "        }",
      "        /// p 番目の要素を max(current, x) に更新する",
      "        pub fn chmax(&mut self, p: usize, x: T) {",
      "            let current = self.get(p);",
      "            self.set(p, std::cmp::max(current, x));",
      "        }",
      "        /// 現在の状態を Vec として返す",
      "        pub fn to_vec(&self) -> Vec<T> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_min_segtree": {
    "scope": "rust",
    "prefix": "range_min_segtree",
    "body": [
      "use min_max_monoid::*;",
      "use range_min_segtree::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod min_max_monoid {",
      "    use ac_library::Monoid;",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    pub trait BoundedBelow {",
      "        fn min_value() -> Self;",
      "    }",
      "    pub trait BoundedAbove {",
      "        fn max_value() -> Self;",
      "    }",
      "    macro_rules ! impl_bounded {(\\$ (\\$ ty : ty ) ,* ) => {\\$ (impl BoundedBelow for \\$ ty {# [inline ] fn min_value () -> Self {Self :: MIN } } impl BoundedAbove for \\$ ty {# [inline ] fn max_value () -> Self {Self :: MAX } } ) * } ; }",
      "    impl_bounded!(i8, i16, i32, i64, i128, isize, u8, u16, u32, u64, u128, usize);",
      "    impl<T: BoundedAbove> BoundedBelow for std::cmp::Reverse<T> {",
      "        #[inline]",
      "        fn min_value() -> Self {",
      "            std::cmp::Reverse(T::max_value())",
      "        }",
      "    }",
      "    impl<T: BoundedBelow> BoundedAbove for std::cmp::Reverse<T> {",
      "        #[inline]",
      "        fn max_value() -> Self {",
      "            std::cmp::Reverse(T::min_value())",
      "        }",
      "    }",
      "    macro_rules ! impl_bounded_tuples {(\\$ head : ident ) => {} ; (\\$ head : ident , \\$ (\\$ tail : ident ) ,* ) => {impl <\\$ head , \\$ (\\$ tail ) ,*> BoundedBelow for (\\$ head , \\$ (\\$ tail ) ,* ) where \\$ head : BoundedBelow , \\$ (\\$ tail : BoundedBelow ) ,* {# [inline ] fn min_value () -> Self {(\\$ head :: min_value () , \\$ (\\$ tail :: min_value () ) ,* ) } } impl <\\$ head , \\$ (\\$ tail ) ,*> BoundedAbove for (\\$ head , \\$ (\\$ tail ) ,* ) where \\$ head : BoundedAbove , \\$ (\\$ tail : BoundedAbove ) ,* {# [inline ] fn max_value () -> Self {(\\$ head :: max_value () , \\$ (\\$ tail :: max_value () ) ,* ) } } impl_bounded_tuples ! (\\$ (\\$ tail ) ,* ) ; } ; () => {} ; }",
      "    impl_bounded_tuples!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12);",
      "    /// 辞書式順序で最小の要素を管理するモノイド (単位元は最大値)",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct MinMonoid<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for MinMonoid<T>",
      "    where",
      "        T: BoundedAbove + Ord + Clone,",
      "    {",
      "        type S = T;",
      "        fn identity() -> Self::S {",
      "            T::max_value()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            std::cmp::min(a, b).clone()",
      "        }",
      "    }",
      "    /// 辞書式順序で最大の要素を管理するモノイド (単位元は最小値)",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct MaxMonoid<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for MaxMonoid<T>",
      "    where",
      "        T: BoundedBelow + Ord + Clone,",
      "    {",
      "        type S = T;",
      "        fn identity() -> Self::S {",
      "            T::min_value()",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            std::cmp::max(a, b).clone()",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::module_inception)]",
      "pub mod range_min_segtree {",
      "    use super::MinMonoid;",
      "    use ac_library::{Monoid, Segtree};",
      "    use itertools::Itertools;",
      "    use std::ops::RangeBounds;",
      "    /// ACL の Segtree を使用した区間最小セグメント木。",
      "    /// 数値型 T に対して点更新・区間最小取得を行う。",
      "    #[derive(Clone)]",
      "    pub struct RangeMinSegtree<T>",
      "    where",
      "        MinMonoid<T>: Monoid<S = T>,",
      "        T: Clone,",
      "    {",
      "        segtree: Segtree<MinMonoid<T>>,",
      "        len: usize,",
      "    }",
      "    impl<T> RangeMinSegtree<T>",
      "    where",
      "        MinMonoid<T>: Monoid<S = T>,",
      "        T: Copy + Ord,",
      "    {",
      "        /// 単位元で初期化されたセグメント木を構築する",
      "        pub fn new(n: usize) -> Self {",
      "            Self {",
      "                segtree: Segtree::<MinMonoid<T>>::new(n),",
      "                len: n,",
      "            }",
      "        }",
      "        /// 配列からセグメント木を構築する",
      "        pub fn from_slice(xs: &[T]) -> Self {",
      "            let len = xs.len();",
      "            Self {",
      "                segtree: Segtree::<MinMonoid<T>>::from(xs.to_vec()),",
      "                len,",
      "            }",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        /// p 番目の要素を x に更新する",
      "        pub fn set(&mut self, p: usize, x: T) {",
      "            self.segtree.set(p, x);",
      "        }",
      "        /// p 番目の要素を取得する",
      "        pub fn get(&self, p: usize) -> T {",
      "            self.segtree.get(p)",
      "        }",
      "        /// range の最小値を取得する",
      "        pub fn range_min<R>(&self, range: R) -> T",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range)",
      "        }",
      "        /// 全要素の最小値を取得する",
      "        pub fn all_min(&self) -> T {",
      "            self.segtree.all_prod()",
      "        }",
      "        /// セグメント木上の二分探索。",
      "        /// [l, r) の最小値 s について f(&s) が true となる最大の r を返す。",
      "        pub fn max_right<F>(&self, l: usize, f: F) -> usize",
      "        where",
      "            F: Fn(&T) -> bool,",
      "        {",
      "            self.segtree.max_right(l, f)",
      "        }",
      "        /// セグメント木上の二分探索。",
      "        /// [l, r) の最小値 s について f(&s) が true となる最小の l を返す。",
      "        pub fn min_left<F>(&self, r: usize, f: F) -> usize",
      "        where",
      "            F: Fn(&T) -> bool,",
      "        {",
      "            self.segtree.min_left(r, f)",
      "        }",
      "        /// p 番目の要素を min(current, x) に更新する",
      "        pub fn chmin(&mut self, p: usize, x: T) {",
      "            let current = self.get(p);",
      "            self.set(p, std::cmp::min(current, x));",
      "        }",
      "        /// 現在の状態を Vec として返す",
      "        pub fn to_vec(&self) -> Vec<T> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_mult_range_prod": {
    "scope": "rust",
    "prefix": "range_mult_range_prod",
    "body": [
      "use range_mult_range_prod::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_mult_range_prod {",
      "    use ac_library::{LazySegtree, MapMonoid, Monoid};",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    use std::ops::{Mul, RangeBounds};",
      "    fn power<T>(base: T, exp: u64) -> T",
      "    where",
      "        T: Copy + Mul<Output = T> + From<i64>,",
      "    {",
      "        let mut res = 1.into();",
      "        let mut base = base;",
      "        let mut exp = exp;",
      "        while exp > 0 {",
      "            if exp % 2 == 1 {",
      "                res = res * base;",
      "            }",
      "            base = base * base;",
      "            exp /= 2;",
      "        }",
      "        res",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeProd<T> {",
      "        pub prod: T,",
      "        pub len: i64,",
      "    }",
      "    impl<T> RangeProd<T> {",
      "        pub fn unit(x: T) -> RangeProd<T> {",
      "            RangeProd { prod: x, len: 1 }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct ValueLenProd<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for ValueLenProd<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + From<i64>,",
      "    {",
      "        type S = RangeProd<T>;",
      "        fn identity() -> RangeProd<T> {",
      "            RangeProd {",
      "                prod: 1.into(),",
      "                len: 0,",
      "            }",
      "        }",
      "        fn binary_operation(a: &RangeProd<T>, b: &RangeProd<T>) -> RangeProd<T> {",
      "            RangeProd {",
      "                prod: a.prod * b.prod,",
      "                len: a.len + b.len,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeMultRangeProd<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> MapMonoid for RangeMultRangeProd<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + From<i64>,",
      "    {",
      "        type M = ValueLenProd<T>;",
      "        type F = T;",
      "        fn identity_map() -> T {",
      "            1.into()",
      "        }",
      "        fn composition(a: &T, b: &T) -> T {",
      "            *a * *b",
      "        }",
      "        fn mapping(f: &T, x: &RangeProd<T>) -> RangeProd<T> {",
      "            RangeProd {",
      "                prod: x.prod * power(*f, x.len as u64),",
      "                len: x.len,",
      "            }",
      "        }",
      "    }",
      "    /// 計算量が O((log N)^2) な点に注意。",
      "    /// (作用で累乗計算をしている関係で log が1つ多い)",
      "    #[derive(Clone)]",
      "    pub struct RangeMultRangeProdSegtree<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + From<i64>,",
      "    {",
      "        segtree: LazySegtree<RangeMultRangeProd<T>>,",
      "        len: usize,",
      "    }",
      "    impl<T> RangeMultRangeProdSegtree<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + From<i64>,",
      "    {",
      "        pub fn new(n: usize) -> Self {",
      "            let xs = vec![0.into(); n];",
      "            Self::from_slice(&xs)",
      "        }",
      "        pub fn from_slice(xs: &[T]) -> RangeMultRangeProdSegtree<T> {",
      "            let xs = xs.iter().copied().map(RangeProd::unit).collect_vec();",
      "            let len = xs.len();",
      "            RangeMultRangeProdSegtree {",
      "                segtree: LazySegtree::from(xs),",
      "                len,",
      "            }",
      "        }",
      "        pub fn set(&mut self, p: usize, x: T) {",
      "            self.segtree.set(p, RangeProd::unit(x));",
      "        }",
      "        pub fn get(&mut self, p: usize) -> T {",
      "            self.segtree.get(p).prod",
      "        }",
      "        pub fn range_prod<R>(&mut self, range: R) -> T",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range).prod",
      "        }",
      "        pub fn all_prod(&self) -> T {",
      "            self.segtree.all_prod().prod",
      "        }",
      "        pub fn mult(&mut self, p: usize, x: T) {",
      "            self.segtree.apply(p, x)",
      "        }",
      "        pub fn range_mult<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, x)",
      "        }",
      "        /// 左端 `l` を固定し、区間 `[l, r)` での総積が述語 `g` を満たすような最大の `r` を返します。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn max_right<G>(&mut self, l: usize, g: G) -> usize",
      "        where",
      "            G: Fn(T) -> bool,",
      "        {",
      "            self.segtree.max_right(l, |x| g(x.prod))",
      "        }",
      "        /// 右端 `r` を固定し、区間 `[l, r)` での総積が述語 `g` を満たすような最小の `l` を返します。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn min_left<G>(&mut self, r: usize, g: G) -> usize",
      "        where",
      "            G: Fn(T) -> bool,",
      "        {",
      "            self.segtree.min_left(r, |x| g(x.prod))",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<T> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_quadratic_add_range_sum": {
    "scope": "rust",
    "prefix": "range_quadratic_add_range_sum",
    "body": [
      "use range_quadratic_add_range_sum::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_quadratic_add_range_sum {",
      "    use ac_library::{LazySegtree, MapMonoid, Monoid};",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    use std::ops::{Add, Div, Mul, RangeBounds, Sub};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeSum<T> {",
      "        pub sum: T,",
      "        pub len: i64,",
      "        pub sum_idx: T,",
      "        pub sum_sq_idx: T,",
      "    }",
      "    impl<T> RangeSum<T>",
      "    where",
      "        T: From<i64> + Copy + Mul<Output = T>,",
      "    {",
      "        pub fn unit(x: T, idx: i64) -> RangeSum<T> {",
      "            let idx: T = idx.into();",
      "            RangeSum {",
      "                sum: x,",
      "                len: 1,",
      "                sum_idx: idx,",
      "                sum_sq_idx: idx * idx,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct ValueLenSum<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for ValueLenSum<T>",
      "    where",
      "        T: Copy + Add<Output = T> + From<i64>,",
      "    {",
      "        type S = RangeSum<T>;",
      "        fn identity() -> RangeSum<T> {",
      "            RangeSum {",
      "                sum: 0.into(),",
      "                len: 0,",
      "                sum_idx: 0.into(),",
      "                sum_sq_idx: 0.into(),",
      "            }",
      "        }",
      "        fn binary_operation(a: &RangeSum<T>, b: &RangeSum<T>) -> RangeSum<T> {",
      "            RangeSum {",
      "                sum: a.sum + b.sum,",
      "                len: a.len + b.len,",
      "                sum_idx: a.sum_idx + b.sum_idx,",
      "                sum_sq_idx: a.sum_sq_idx + b.sum_sq_idx,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    pub struct Quadratic<T> {",
      "        coef0: T,",
      "        coef1: T,",
      "        coef2: T,",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeQuadraticAddRangeSum<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> MapMonoid for RangeQuadraticAddRangeSum<T>",
      "    where",
      "        T: Copy + Add<Output = T> + Mul<Output = T> + Div<Output = T> + Sub<Output = T> + From<i64>,",
      "    {",
      "        type M = ValueLenSum<T>;",
      "        type F = Quadratic<T>;",
      "        fn identity_map() -> Quadratic<T> {",
      "            Quadratic {",
      "                coef0: 0.into(),",
      "                coef1: 0.into(),",
      "                coef2: 0.into(),",
      "            }",
      "        }",
      "        fn composition(f_outer: &Quadratic<T>, f_inner: &Quadratic<T>) -> Quadratic<T> {",
      "            Quadratic {",
      "                coef0: f_outer.coef0 + f_inner.coef0,",
      "                coef1: f_outer.coef1 + f_inner.coef1,",
      "                coef2: f_outer.coef2 + f_inner.coef2,",
      "            }",
      "        }",
      "        fn mapping(f: &Quadratic<T>, x: &RangeSum<T>) -> RangeSum<T> {",
      "            RangeSum {",
      "                sum: x.sum + f.coef0 * x.len.into() + f.coef1 * x.sum_idx + f.coef2 * x.sum_sq_idx,",
      "                len: x.len,",
      "                sum_idx: x.sum_idx,",
      "                sum_sq_idx: x.sum_sq_idx,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct RangeQuadraticAddRangeSumSegtree<T>",
      "    where",
      "        T: Copy + Add<Output = T> + Mul<Output = T> + Div<Output = T> + Sub<Output = T> + From<i64>,",
      "    {",
      "        segtree: LazySegtree<RangeQuadraticAddRangeSum<T>>,",
      "        len: usize,",
      "    }",
      "    impl<T> RangeQuadraticAddRangeSumSegtree<T>",
      "    where",
      "        T: Copy + Add<Output = T> + Mul<Output = T> + Div<Output = T> + Sub<Output = T> + From<i64>,",
      "    {",
      "        pub fn new(n: usize) -> Self {",
      "            let xs = vec![0.into(); n];",
      "            Self::from_slice(&xs)",
      "        }",
      "        pub fn from_slice(xs: &[T]) -> RangeQuadraticAddRangeSumSegtree<T> {",
      "            let xs = xs",
      "                .iter()",
      "                .copied()",
      "                .enumerate()",
      "                .map(|(i, x)| RangeSum::unit(x, i as i64))",
      "                .collect_vec();",
      "            let len = xs.len();",
      "            RangeQuadraticAddRangeSumSegtree {",
      "                segtree: LazySegtree::from(xs),",
      "                len,",
      "            }",
      "        }",
      "        pub fn set(&mut self, p: usize, x: T) {",
      "            self.segtree.set(p, RangeSum::unit(x, p as i64));",
      "        }",
      "        pub fn get(&mut self, p: usize) -> T {",
      "            self.segtree.get(p).sum",
      "        }",
      "        pub fn range_sum<R>(&mut self, range: R) -> T",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range).sum",
      "        }",
      "        pub fn all_sum(&self) -> T {",
      "            self.segtree.all_prod().sum",
      "        }",
      "        /// range が l..r であるとする。",
      "        /// `i` in `l..r` に対して、`self[i] += coef0 + coef1 * (i - l) + coef2 * (i - l)^2` を計算する",
      "        pub fn range_quadratic_add<R>(&mut self, range: R, coef0: T, coef1: T, coef2: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            use std::ops::Bound;",
      "            let l = match range.start_bound() {",
      "                Bound::Included(val) => *val,",
      "                Bound::Excluded(val) => *val + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            let l: T = (l as i64).into();",
      "            let new_coef0 = coef0 - coef1 * l + coef2 * l * l;",
      "            let new_coef1 = coef1 - coef2 * l * 2.into();",
      "            let new_coef2 = coef2;",
      "            let quad = Quadratic {",
      "                coef0: new_coef0,",
      "                coef1: new_coef1,",
      "                coef2: new_coef2,",
      "            };",
      "            self.segtree.apply_range(range, quad);",
      "        }",
      "        /// 左端 `l` を固定し、区間 `[l, r)` での総和が述語 `g` を満たすような最大の `r` を返します。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn max_right<G>(&mut self, l: usize, g: G) -> usize",
      "        where",
      "            G: Fn(T) -> bool,",
      "        {",
      "            self.segtree.max_right(l, |x| g(x.sum))",
      "        }",
      "        /// 右端 `r` を固定し、区間 `[l, r)` での総和が述語 `g` を満たすような最小の `l` を返します。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn min_left<G>(&mut self, r: usize, g: G) -> usize",
      "        where",
      "            G: Fn(T) -> bool,",
      "        {",
      "            self.segtree.min_left(r, |x| g(x.sum))",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<T> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_set": {
    "scope": "rust",
    "prefix": "range_set",
    "body": [
      "use range_set::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_set {",
      "    use std::collections::BTreeMap;",
      "    /// 整数の集合を隣り合わない半開区間の直和で管理するデータ構造。",
      "    /// # 機能",
      "    /// - 区間内の整数の追加 (`insert_range`)",
      "    /// - 区間内の整数の削除 (`remove_range`)",
      "    /// - 点が区間集合に含まれるかの判定 (`contains`)",
      "    /// - 区間が完全にカバーされているかの判定 (`covers`)",
      "    /// - 全区間の長さの合計 (`len`)",
      "    /// - x 以上で集合に含まれない最小値 (`min_exclusive_geq`、いわゆる mex)",
      "    /// - x 以下で集合に含まれない最大値 (`max_exclusive_leq`)",
      "    /// - など",
      "    #[derive(Debug, Clone, PartialEq, Eq, Hash)]",
      "    pub struct RangeSet {",
      "        map: BTreeMap<i64, i64>,",
      "        total_length: i64,",
      "    }",
      "    impl Default for RangeSet {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "    impl RangeSet {",
      "        /// 空の `RangeSet` を作成する。",
      "        pub fn new() -> Self {",
      "            Self {",
      "                map: BTreeMap::new(),",
      "                total_length: 0,",
      "            }",
      "        }",
      "        /// 区間 `[l, r)` の各値を集合に追加する。",
      "        /// # 計算量",
      "        /// amortized O(log N)",
      "        pub fn insert_range(&mut self, l: i64, r: i64) {",
      "            assert!(l <= r);",
      "            if r == l {",
      "                return;",
      "            }",
      "            let mut start = l;",
      "            let mut end = r;",
      "            let mut to_remove = Vec::new();",
      "            let mut removed_len = 0;",
      "            for (&l_i, &r_i) in self.map.range(..=r).rev().take_while(|&(_, r_i)| l <= *r_i) {",
      "                start = start.min(l_i);",
      "                end = end.max(r_i);",
      "                to_remove.push(l_i);",
      "                removed_len += r_i - l_i;",
      "            }",
      "            for l_i in to_remove {",
      "                self.map.remove(&l_i);",
      "            }",
      "            let added_len = end - start;",
      "            self.total_length += added_len - removed_len;",
      "            self.map.insert(start, end);",
      "        }",
      "        /// 区間 `[l, r)` の各値を集合から削除する。",
      "        /// # 計算量",
      "        /// amortized O(log N)",
      "        pub fn remove_range(&mut self, l: i64, r: i64) {",
      "            assert!(l <= r);",
      "            if r == l {",
      "                return;",
      "            }",
      "            let mut to_add = Vec::new();",
      "            let mut to_remove = Vec::new();",
      "            let mut len_change = 0;",
      "            for (&l_i, &r_i) in self.map.range(..r).rev().take_while(|&(_, r_i)| l < *r_i) {",
      "                to_remove.push(l_i);",
      "                len_change -= r_i - l_i;",
      "                if l_i < l {",
      "                    to_add.push((l_i, l));",
      "                    len_change += l - l_i;",
      "                }",
      "                if r < r_i {",
      "                    to_add.push((r, r_i));",
      "                    len_change += r_i - r;",
      "                }",
      "            }",
      "            for l_i in to_remove {",
      "                self.map.remove(&l_i);",
      "            }",
      "            for (l_add, r_add) in to_add {",
      "                self.map.insert(l_add, r_add);",
      "            }",
      "            self.total_length += len_change;",
      "        }",
      "        /// 集合に `x` を追加する。",
      "        /// # 計算量",
      "        /// amortized O(log N)",
      "        pub fn insert(&mut self, x: i64) {",
      "            self.insert_range(x, x + 1);",
      "        }",
      "        /// 集合から `x` を削除する。",
      "        /// # 計算量",
      "        /// amortized O(log N)",
      "        pub fn remove(&mut self, x: i64) {",
      "            self.remove_range(x, x + 1);",
      "        }",
      "        /// 集合が `x` を含んでいるかを返す。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn contains(&self, x: i64) -> bool {",
      "            self.find_range(x).is_some()",
      "        }",
      "        /// 集合が区間 `[l, r)` を含んでいるかを返す。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn covers(&self, l: i64, r: i64) -> bool {",
      "            assert!(l <= r);",
      "            if r == l {",
      "                return true;",
      "            }",
      "            if let Some((_start, end)) = self.find_range(l) {",
      "                r <= end",
      "            } else {",
      "                false",
      "            }",
      "        }",
      "        /// 集合が空かどうかを返す。",
      "        /// # 計算量",
      "        /// O(1)",
      "        pub fn is_empty(&self) -> bool {",
      "            self.map.is_empty()",
      "        }",
      "        /// 集合の要素数を返す。",
      "        /// # 計算量",
      "        /// O(1)",
      "        pub fn len(&self) -> i64 {",
      "            self.total_length",
      "        }",
      "        /// 集合に含まれる最小値を返す。",
      "        /// 集合が空の場合は `None` を返す。",
      "        /// # 計算量",
      "        /// O(1)",
      "        pub fn min(&self) -> Option<i64> {",
      "            self.map.keys().next().copied()",
      "        }",
      "        /// 集合に含まれる最大値を返す。",
      "        /// 集合が空の場合は `None` を返す。",
      "        /// # 計算量",
      "        /// O(1)",
      "        pub fn max(&self) -> Option<i64> {",
      "            self.map.iter().next_back().map(|(_, &r)| r - 1)",
      "        }",
      "        /// 指定した区間 `[l, r)` と集合が共通部分を持たない（重ならない）かを返す。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn is_disjoint(&self, l: i64, r: i64) -> bool {",
      "            if l >= r {",
      "                return true;",
      "            }",
      "            if let Some((_, &r_i)) = self.map.range(..r).next_back() {",
      "                r_i <= l",
      "            } else {",
      "                true",
      "            }",
      "        }",
      "        /// 集合全体が指定した区間 `[l, r)` に完全に含まれているかを返す。",
      "        /// # 計算量",
      "        /// O(1)",
      "        pub fn is_covered_by(&self, l: i64, r: i64) -> bool {",
      "            if self.is_empty() {",
      "                return true;",
      "            }",
      "            if l >= r {",
      "                return false;",
      "            }",
      "            if let Some(min_val) = self.min() {",
      "                if min_val < l {",
      "                    return false;",
      "                }",
      "            }",
      "            if let Some(max_val) = self.max() {",
      "                if max_val >= r {",
      "                    return false;",
      "                }",
      "            }",
      "            true",
      "        }",
      "        /// x 以上で self に入っていない値の最小値を返す (いわゆる mex)",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn min_exclusive_geq(&self, x: i64) -> i64 {",
      "            if let Some((_, r)) = self.find_range(x) {",
      "                r",
      "            } else {",
      "                x",
      "            }",
      "        }",
      "        /// x 以下で self に入っていない値の最大値を返す",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn max_exclusive_leq(&self, x: i64) -> i64 {",
      "            if let Some((l, _)) = self.find_range(x) {",
      "                l - 1",
      "            } else {",
      "                x",
      "            }",
      "        }",
      "        /// x 以上で集合に含まれる最小の値を返す。",
      "        /// 集合に含まれる値が存在しない場合は None を返す。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn min_inclusive_geq(&self, x: i64) -> Option<i64> {",
      "            if self.contains(x) {",
      "                return Some(x);",
      "            }",
      "            self.map.range(x..).next().map(|(&l, _)| l)",
      "        }",
      "        /// x 以下で集合に含まれる最大の値を返す。",
      "        /// 集合に含まれる値が存在しない場合は None を返す。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn max_inclusive_leq(&self, x: i64) -> Option<i64> {",
      "            if self.contains(x) {",
      "                return Some(x);",
      "            }",
      "            self.map.range(..x).last().map(|(_, &r)| r - 1)",
      "        }",
      "        /// `x` が含まれる区間 `[l, r)` を検索し、`Some((l, r))` で返す。",
      "        /// `x` を含む区間が見つからない場合は `None` を返す。",
      "        fn find_range(&self, x: i64) -> Option<(i64, i64)> {",
      "            if let Some((&l, &r)) = self.map.range(..=x).last() {",
      "                if x < r {",
      "                    Some((l, r))",
      "                } else {",
      "                    None",
      "                }",
      "            } else {",
      "                None",
      "            }",
      "        }",
      "        /// 管理しているすべての区間 `[l, r)` のイテレータを返す。",
      "        #[cfg(test)]",
      "        pub(crate) fn ranges(&self) -> impl Iterator<Item = (i64, i64)> + '_ {",
      "            self.map.iter().map(|(&l, &r)| (l, r))",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_sum_fenwick_tree": {
    "scope": "rust",
    "prefix": "range_sum_fenwick_tree",
    "body": [
      "use ab_group::*;",
      "use range_sum_fenwick_tree::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod ab_group {",
      "    use std::{",
      "        convert::Infallible,",
      "        iter::Sum,",
      "        marker::PhantomData,",
      "        ops::{Add, Neg, Sub},",
      "    };",
      "    /// 可換群 (Abelian Group)",
      "    pub trait AbGroup {",
      "        type S: Clone;",
      "        fn zero() -> Self::S;",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S;",
      "        fn neg(a: &Self::S) -> Self::S;",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            Self::add(a, &Self::neg(b))",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct AdditiveAbGroup<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T: Sum + Add<Output = T> + Sub<Output = T> + Neg<Output = T> + Copy> AbGroup",
      "        for AdditiveAbGroup<T>",
      "    {",
      "        type S = T;",
      "        fn zero() -> Self::S {",
      "            std::iter::empty().sum()",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a + *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            -(*a)",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a - *b",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct XorAbGroup(Infallible);",
      "    impl AbGroup for XorAbGroup {",
      "        type S = u64;",
      "        fn zero() -> Self::S {",
      "            0",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            *a",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::module_inception)]",
      "pub mod range_sum_fenwick_tree {",
      "    use super::{AbGroup, AdditiveAbGroup};",
      "    use std::ops::{Bound, RangeBounds};",
      "    /// 可換群 (AbGroup) を用いた汎用的な Fenwick Tree (Binary Indexed Tree)。",
      "    /// 0-indexed で実装されています。",
      "    /// 基本的な加算・区間和クエリに加え、get/set や、二分探索 (max_right / min_left) を提供します。",
      "    #[derive(Clone)]",
      "    pub struct RangeSumFenwickTreeArbitrary<G: AbGroup> {",
      "        n: usize,",
      "        pub(crate) ary: Vec<G::S>,",
      "    }",
      "    /// i64 の加算群を用いた標準的な Fenwick Tree のエイリアス。",
      "    pub type RangeSumFenwickTreeI64 = RangeSumFenwickTreeArbitrary<AdditiveAbGroup<i64>>;",
      "    /// 任意の数値型 T の加算群を用いた Fenwick Tree のエイリアス。",
      "    pub type RangeSumFenwickTree<T> = RangeSumFenwickTreeArbitrary<AdditiveAbGroup<T>>;",
      "    pub type FenwickTree<T> = RangeSumFenwickTree<T>;",
      "    impl<G: AbGroup> RangeSumFenwickTreeArbitrary<G> {",
      "        /// サイズ `n` の Fenwick Tree を作成します。",
      "        /// 要素はすべて `G::zero()` で初期化されます。",
      "        /// # 計算量",
      "        /// O(n)",
      "        pub fn new(n: usize) -> Self {",
      "            let ary = vec![G::zero(); n];",
      "            RangeSumFenwickTreeArbitrary { n, ary }",
      "        }",
      "        /// 配列スライスから Fenwick Tree を作成します。",
      "        /// # 計算量",
      "        /// O(n)",
      "        pub fn from_slice(slice: &[G::S]) -> Self {",
      "            let n = slice.len();",
      "            let mut ary = slice.to_vec();",
      "            for i in 0..n {",
      "                let j = i | (i + 1);",
      "                if j < n {",
      "                    let val_i = ary[i].clone();",
      "                    ary[j] = G::add(&ary[j], &val_i);",
      "                }",
      "            }",
      "            RangeSumFenwickTreeArbitrary { n, ary }",
      "        }",
      "        /// `[0, idx)` の区間の総和を計算します。",
      "        /// # Panics",
      "        /// `idx > n` の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn prefix_sum(&self, mut idx: usize) -> G::S {",
      "            assert!(",
      "                idx <= self.n,",
      "                \"RangeSumFenwickTreeArbitrary::prefix_sum: index out of bounds. idx: {}, n: {}\",",
      "                idx,",
      "                self.n",
      "            );",
      "            let mut sum = G::zero();",
      "            while idx > 0 {",
      "                sum = G::add(&sum, &self.ary[idx - 1]);",
      "                idx &= idx - 1;",
      "            }",
      "            sum",
      "        }",
      "        /// `idx` 番目の要素に `val` を加算（群の演算を適用）します。",
      "        /// # Panics",
      "        /// `idx >= n` の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn add(&mut self, mut idx: usize, val: G::S) {",
      "            assert!(",
      "                idx < self.n,",
      "                \"RangeSumFenwickTreeArbitrary::add: index out of bounds. idx: {}, n: {}\",",
      "                idx,",
      "                self.n",
      "            );",
      "            let n = self.n;",
      "            idx += 1;",
      "            while idx <= n {",
      "                self.ary[idx - 1] = G::add(&self.ary[idx - 1], &val);",
      "                idx += idx & idx.wrapping_neg();",
      "            }",
      "        }",
      "        fn resolve_range<R: RangeBounds<usize>>(&self, range: R) -> (usize, usize) {",
      "            let l = match range.start_bound() {",
      "                Bound::Included(&l) => l,",
      "                Bound::Excluded(&l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            let r = match range.end_bound() {",
      "                Bound::Included(&r) => r + 1,",
      "                Bound::Excluded(&r) => r,",
      "                Bound::Unbounded => self.n,",
      "            };",
      "            (l, r)",
      "        }",
      "        /// 指定された範囲の区間和を計算します。",
      "        /// # Panics",
      "        /// 範囲が不正、または `n` を超える場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn range_sum<R>(&self, range: R) -> G::S",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            let (l, r) = self.resolve_range(range);",
      "            assert!(",
      "                l <= r && r <= self.n,",
      "                \"RangeSumFenwickTreeArbitrary::range_sum: invalid range. l: {}, r: {}, n: {}\",",
      "                l,",
      "                r,",
      "                self.n",
      "            );",
      "            G::sub(&self.prefix_sum(r), &self.prefix_sum(l))",
      "        }",
      "        /// `l` を左端として、`f(sum(l..r))` が true になる最大の `r` を返します。",
      "        /// `f` は単調性を持つ必要があります。",
      "        /// 具体的には、`f(sum(l..i))` が true ならば、任意の `j < i` に対して `f(sum(l..j))` も true である必要があります。",
      "        /// また、`f(zero)` は true である必要があります。",
      "        /// # Panics",
      "        /// `l > n` または `f(zero)` が false の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn max_right<F>(&self, l: usize, mut f: F) -> usize",
      "        where",
      "            F: FnMut(&G::S) -> bool,",
      "        {",
      "            assert!(",
      "                l <= self.n,",
      "                \"RangeSumFenwickTreeArbitrary::max_right: index out of bounds. l: {}, n: {}\",",
      "                l,",
      "                self.n",
      "            );",
      "            let zero = G::zero();",
      "            assert!(",
      "                f(&zero),",
      "                \"RangeSumFenwickTreeArbitrary::max_right: The predicate f(zero) must be true.\"",
      "            );",
      "            let val_l = self.prefix_sum(l);",
      "            let mut r = 0;",
      "            let mut current_val = G::zero();",
      "            let mut k = if self.n == 0 {",
      "                0",
      "            } else {",
      "                1 << (usize::BITS - 1 - self.n.leading_zeros())",
      "            };",
      "            while k > 0 {",
      "                if r + k <= self.n {",
      "                    let next_val = G::add(&current_val, &self.ary[r + k - 1]);",
      "                    if r + k <= l || f(&G::sub(&next_val, &val_l)) {",
      "                        r += k;",
      "                        current_val = next_val;",
      "                    }",
      "                }",
      "                k >>= 1;",
      "            }",
      "            r",
      "        }",
      "        /// `r` を右端として、`f(sum(l..r))` が true になる最小の `l` を返します。",
      "        /// `f` は単調性を持つ必要があります。",
      "        /// 具体的には、`f(sum(i..r))` が true ならば、任意の `j > i` に対して `f(sum(j..r))` も true である必要があります。",
      "        /// また、`f(zero)` は true である必要があります。",
      "        /// # Panics",
      "        /// `r > n` または `f(zero)` が false の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn min_left<F>(&self, r: usize, mut f: F) -> usize",
      "        where",
      "            F: FnMut(&G::S) -> bool,",
      "        {",
      "            assert!(",
      "                r <= self.n,",
      "                \"RangeSumFenwickTreeArbitrary::min_left: index out of bounds. r: {}, n: {}\",",
      "                r,",
      "                self.n",
      "            );",
      "            let zero = G::zero();",
      "            assert!(",
      "                f(&zero),",
      "                \"RangeSumFenwickTreeArbitrary::min_left: The predicate f(zero) must be true.\"",
      "            );",
      "            let val_r = self.prefix_sum(r);",
      "            if f(&val_r) {",
      "                return 0;",
      "            }",
      "            let mut idx = 0;",
      "            let mut current_val = G::zero();",
      "            let mut k = if self.n == 0 {",
      "                0",
      "            } else {",
      "                1 << (usize::BITS - 1 - self.n.leading_zeros())",
      "            };",
      "            while k > 0 {",
      "                if idx + k <= r {",
      "                    let next_val = G::add(&current_val, &self.ary[idx + k - 1]);",
      "                    if !f(&G::sub(&val_r, &next_val)) {",
      "                        idx += k;",
      "                        current_val = next_val;",
      "                    }",
      "                }",
      "                k >>= 1;",
      "            }",
      "            idx + 1",
      "        }",
      "        /// `idx` 番目の要素の値を取得します。",
      "        /// # Panics",
      "        /// `idx >= n` の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn get(&self, idx: usize) -> G::S {",
      "            assert!(",
      "                idx < self.n,",
      "                \"RangeSumFenwickTreeArbitrary::get: index out of bounds. idx: {}, n: {}\",",
      "                idx,",
      "                self.n",
      "            );",
      "            self.range_sum(idx..=idx)",
      "        }",
      "        /// `idx` 番目の要素の値を `val` に設定します。",
      "        /// # Panics",
      "        /// `idx >= n` の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log n)",
      "        pub fn set(&mut self, idx: usize, val: G::S) {",
      "            assert!(",
      "                idx < self.n,",
      "                \"RangeSumFenwickTreeArbitrary::set: index out of bounds. idx: {}, n: {}\",",
      "                idx,",
      "                self.n",
      "            );",
      "            let old_val = self.get(idx);",
      "            self.add(idx, G::sub(&val, &old_val));",
      "        }",
      "        /// Fenwick Tree の現在の状態を `Vec<G::S>` として返します。",
      "        /// # 計算量",
      "        /// O(n log n)",
      "        pub fn to_vec(&self) -> Vec<G::S> {",
      "            (0..self.n).map(|i| self.get(i)).collect()",
      "        }",
      "        /// 保持している要素数を返します。",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.n",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_sum_segtree": {
    "scope": "rust",
    "prefix": "range_sum_segtree",
    "body": [
      "use range_sum_segtree::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_sum_segtree {",
      "    use ac_library::{Monoid, Segtree};",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    use std::iter::Sum;",
      "    use std::marker::PhantomData;",
      "    use std::ops::{Add, RangeBounds};",
      "    /// 汎用的な加算モノイド。",
      "    /// `std::ops::Add` と `std::iter::Sum` を実装している型に対応。",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct GeneralAdditive<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for GeneralAdditive<T>",
      "    where",
      "        T: Sum + Add<Output = T> + Copy,",
      "    {",
      "        type S = T;",
      "        #[inline]",
      "        fn identity() -> Self::S {",
      "            std::iter::empty().sum()",
      "        }",
      "        #[inline]",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a + *b",
      "        }",
      "    }",
      "    /// ACL の Segtree を使用した区間和セグメント木。",
      "    /// 数値型 T に対して点更新・区間和取得を行う。",
      "    #[derive(Clone)]",
      "    pub struct RangeSumSegtree<T>",
      "    where",
      "        T: Sum + Add<Output = T> + Copy,",
      "    {",
      "        segtree: Segtree<GeneralAdditive<T>>,",
      "        len: usize,",
      "    }",
      "    impl<T> RangeSumSegtree<T>",
      "    where",
      "        T: Sum + Add<Output = T> + Copy,",
      "    {",
      "        /// 単位元で初期化されたセグメント木を構築する",
      "        pub fn new(n: usize) -> Self {",
      "            Self {",
      "                segtree: Segtree::<GeneralAdditive<T>>::new(n),",
      "                len: n,",
      "            }",
      "        }",
      "        /// 配列からセグメント木を構築する",
      "        pub fn from_slice(xs: &[T]) -> Self {",
      "            let len = xs.len();",
      "            Self {",
      "                segtree: Segtree::<GeneralAdditive<T>>::from(xs.to_vec()),",
      "                len,",
      "            }",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        /// p 番目の要素を x に更新する",
      "        pub fn set(&mut self, p: usize, x: T) {",
      "            self.segtree.set(p, x);",
      "        }",
      "        /// p 番目の要素を取得する",
      "        pub fn get(&self, p: usize) -> T {",
      "            self.segtree.get(p)",
      "        }",
      "        /// 指定した範囲の和を取得する",
      "        pub fn range_sum<R>(&self, range: R) -> T",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range)",
      "        }",
      "        /// 全要素の和を取得する",
      "        pub fn all_sum(&self) -> T {",
      "            self.segtree.all_prod()",
      "        }",
      "        /// p 番目の要素に x を加算する",
      "        pub fn add(&mut self, p: usize, x: T) {",
      "            let current = self.get(p);",
      "            self.set(p, current + x);",
      "        }",
      "        /// セグメント木上の二分探索。",
      "        /// [l, r) の和 s について f(&s) が true となる最大の r を返す。",
      "        pub fn max_right<F>(&self, l: usize, f: F) -> usize",
      "        where",
      "            F: Fn(&T) -> bool,",
      "        {",
      "            self.segtree.max_right(l, f)",
      "        }",
      "        /// セグメント木上の二分探索。",
      "        /// [l, r) の和 s について f(&s) が true となる最小の l を返す。",
      "        pub fn min_left<F>(&self, r: usize, f: F) -> usize",
      "        where",
      "            F: Fn(&T) -> bool,",
      "        {",
      "            self.segtree.min_left(r, f)",
      "        }",
      "        /// 現在の状態を Vec として返す",
      "        pub fn to_vec(&self) -> Vec<T> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_update_range_prod": {
    "scope": "rust",
    "prefix": "range_update_range_prod",
    "body": [
      "use range_update_range_prod::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_update_range_prod {",
      "    use ac_library::{LazySegtree, MapMonoid, Monoid};",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    use std::ops::{Mul, RangeBounds};",
      "    fn power<T>(base: T, exp: u64) -> T",
      "    where",
      "        T: Copy + Mul<Output = T> + From<i64>,",
      "    {",
      "        let mut res = 1.into();",
      "        let mut base = base;",
      "        let mut exp = exp;",
      "        while exp > 0 {",
      "            if exp % 2 == 1 {",
      "                res = res * base;",
      "            }",
      "            base = base * base;",
      "            exp /= 2;",
      "        }",
      "        res",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeProd<T> {",
      "        pub prod: T,",
      "        pub len: i64,",
      "    }",
      "    impl<T> RangeProd<T> {",
      "        pub fn unit(x: T) -> RangeProd<T> {",
      "            RangeProd { prod: x, len: 1 }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct ValueLenProd<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for ValueLenProd<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + From<i64>,",
      "    {",
      "        type S = RangeProd<T>;",
      "        fn identity() -> RangeProd<T> {",
      "            RangeProd {",
      "                prod: 1.into(),",
      "                len: 0,",
      "            }",
      "        }",
      "        fn binary_operation(a: &RangeProd<T>, b: &RangeProd<T>) -> RangeProd<T> {",
      "            RangeProd {",
      "                prod: a.prod * b.prod,",
      "                len: a.len + b.len,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeUpdateRangeProd<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> MapMonoid for RangeUpdateRangeProd<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + From<i64>,",
      "    {",
      "        type M = ValueLenProd<T>;",
      "        type F = Option<T>;",
      "        fn identity_map() -> Option<T> {",
      "            None",
      "        }",
      "        fn composition(a: &Option<T>, b: &Option<T>) -> Option<T> {",
      "            if a.is_some() {",
      "                *a",
      "            } else {",
      "                *b",
      "            }",
      "        }",
      "        fn mapping(f: &Option<T>, x: &RangeProd<T>) -> RangeProd<T> {",
      "            match f {",
      "                Some(val) => RangeProd {",
      "                    prod: power(*val, x.len as u64),",
      "                    len: x.len,",
      "                },",
      "                None => *x,",
      "            }",
      "        }",
      "    }",
      "    /// 計算量が O((log N)^2) な点に注意。",
      "    /// (作用で累乗計算をしている関係で log が1つ多い)",
      "    #[derive(Clone)]",
      "    pub struct RangeUpdateRangeProdSegtree<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + From<i64>,",
      "    {",
      "        segtree: LazySegtree<RangeUpdateRangeProd<T>>,",
      "        len: usize,",
      "    }",
      "    impl<T> RangeUpdateRangeProdSegtree<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + From<i64>,",
      "    {",
      "        pub fn new(n: usize) -> Self {",
      "            let xs = vec![0.into(); n];",
      "            Self::from_slice(&xs)",
      "        }",
      "        pub fn from_slice(xs: &[T]) -> RangeUpdateRangeProdSegtree<T> {",
      "            let xs = xs.iter().copied().map(RangeProd::unit).collect_vec();",
      "            let len = xs.len();",
      "            RangeUpdateRangeProdSegtree {",
      "                segtree: LazySegtree::from(xs),",
      "                len,",
      "            }",
      "        }",
      "        pub fn set(&mut self, p: usize, x: T) {",
      "            self.segtree.set(p, RangeProd::unit(x));",
      "        }",
      "        pub fn get(&mut self, p: usize) -> T {",
      "            self.segtree.get(p).prod",
      "        }",
      "        pub fn range_prod<R>(&mut self, range: R) -> T",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range).prod",
      "        }",
      "        pub fn all_prod(&self) -> T {",
      "            self.segtree.all_prod().prod",
      "        }",
      "        pub fn update(&mut self, p: usize, x: T) {",
      "            self.segtree.apply(p, Some(x))",
      "        }",
      "        pub fn range_update<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, Some(x))",
      "        }",
      "        /// 左端 `l` を固定し、区間 `[l, r)` での総積が述語 `g` を満たすような最大の `r` を返します。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn max_right<G>(&mut self, l: usize, g: G) -> usize",
      "        where",
      "            G: Fn(T) -> bool,",
      "        {",
      "            self.segtree.max_right(l, |x| g(x.prod))",
      "        }",
      "        /// 右端 `r` を固定し、区間 `[l, r)` での総積が述語 `g` を満たすような最小の `l` を返します。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn min_left<G>(&mut self, r: usize, g: G) -> usize",
      "        where",
      "            G: Fn(T) -> bool,",
      "        {",
      "            self.segtree.min_left(r, |x| g(x.prod))",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<T> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_update_range_sum": {
    "scope": "rust",
    "prefix": "range_update_range_sum",
    "body": [
      "use range_update_range_sum::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_update_range_sum {",
      "    use ac_library::{LazySegtree, MapMonoid, Monoid};",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    use std::ops::{Add, Mul, RangeBounds};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeSum<T> {",
      "        pub sum: T,",
      "        pub len: i64,",
      "    }",
      "    impl<T> RangeSum<T> {",
      "        pub fn unit(x: T) -> RangeSum<T> {",
      "            RangeSum { sum: x, len: 1 }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct ValueLenSum<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for ValueLenSum<T>",
      "    where",
      "        T: Copy + Add<Output = T> + From<i64>,",
      "    {",
      "        type S = RangeSum<T>;",
      "        fn identity() -> RangeSum<T> {",
      "            RangeSum {",
      "                sum: 0.into(),",
      "                len: 0,",
      "            }",
      "        }",
      "        fn binary_operation(a: &RangeSum<T>, b: &RangeSum<T>) -> RangeSum<T> {",
      "            RangeSum {",
      "                sum: a.sum + b.sum,",
      "                len: a.len + b.len,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeUpdateRangeSum<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> MapMonoid for RangeUpdateRangeSum<T>",
      "    where",
      "        T: Copy + Add<Output = T> + Mul<Output = T> + From<i64>,",
      "    {",
      "        type M = ValueLenSum<T>;",
      "        type F = Option<T>;",
      "        fn identity_map() -> Option<T> {",
      "            None",
      "        }",
      "        fn composition(a: &Option<T>, b: &Option<T>) -> Option<T> {",
      "            if a.is_some() {",
      "                *a",
      "            } else {",
      "                *b",
      "            }",
      "        }",
      "        fn mapping(f: &Option<T>, x: &RangeSum<T>) -> RangeSum<T> {",
      "            match f {",
      "                Some(val) => RangeSum {",
      "                    sum: *val * x.len.into(),",
      "                    len: x.len,",
      "                },",
      "                None => *x,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct RangeUpdateRangeSumSegtree<T>",
      "    where",
      "        T: Copy + Add<Output = T> + Mul<Output = T> + From<i64>,",
      "    {",
      "        segtree: LazySegtree<RangeUpdateRangeSum<T>>,",
      "        len: usize,",
      "    }",
      "    impl<T> RangeUpdateRangeSumSegtree<T>",
      "    where",
      "        T: Copy + Add<Output = T> + Mul<Output = T> + From<i64>,",
      "    {",
      "        pub fn new(n: usize) -> Self {",
      "            let xs = vec![0.into(); n];",
      "            Self::from_slice(&xs)",
      "        }",
      "        pub fn from_slice(xs: &[T]) -> RangeUpdateRangeSumSegtree<T> {",
      "            let xs = xs.iter().copied().map(RangeSum::unit).collect_vec();",
      "            let len = xs.len();",
      "            RangeUpdateRangeSumSegtree {",
      "                segtree: LazySegtree::from(xs),",
      "                len,",
      "            }",
      "        }",
      "        pub fn set(&mut self, p: usize, x: T) {",
      "            self.segtree.set(p, RangeSum::unit(x));",
      "        }",
      "        pub fn get(&mut self, p: usize) -> T {",
      "            self.segtree.get(p).sum",
      "        }",
      "        pub fn range_sum<R>(&mut self, range: R) -> T",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range).sum",
      "        }",
      "        pub fn all_sum(&self) -> T {",
      "            self.segtree.all_prod().sum",
      "        }",
      "        pub fn update(&mut self, p: usize, x: T) {",
      "            self.segtree.apply(p, Some(x))",
      "        }",
      "        pub fn range_update<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, Some(x))",
      "        }",
      "        /// 左端 `l` を固定し、区間 `[l, r)` での総和が述語 `g` を満たすような最大の `r` を返します。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn max_right<G>(&mut self, l: usize, g: G) -> usize",
      "        where",
      "            G: Fn(T) -> bool,",
      "        {",
      "            self.segtree.max_right(l, |x| g(x.sum))",
      "        }",
      "        /// 右端 `r` を固定し、区間 `[l, r)` での総和が述語 `g` を満たすような最小の `l` を返します。",
      "        /// # 計算量",
      "        /// O(log N)",
      "        pub fn min_left<G>(&mut self, r: usize, g: G) -> usize",
      "        where",
      "            G: Fn(T) -> bool,",
      "        {",
      "            self.segtree.min_left(r, |x| g(x.sum))",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<T> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_update_range_xor": {
    "scope": "rust",
    "prefix": "range_update_range_xor",
    "body": [
      "use range_update_range_xor::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_update_range_xor {",
      "    use ac_library::{LazySegtree, MapMonoid, Monoid};",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    use std::ops::{BitXor, RangeBounds};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeXor<T> {",
      "        pub xor: T,",
      "        pub len: i64,",
      "    }",
      "    impl<T> RangeXor<T> {",
      "        pub fn unit(x: T) -> RangeXor<T> {",
      "            RangeXor { xor: x, len: 1 }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct ValueLenXor<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for ValueLenXor<T>",
      "    where",
      "        T: Copy + BitXor<Output = T> + From<u8>,",
      "    {",
      "        type S = RangeXor<T>;",
      "        fn identity() -> RangeXor<T> {",
      "            RangeXor {",
      "                xor: 0.into(),",
      "                len: 0,",
      "            }",
      "        }",
      "        fn binary_operation(a: &RangeXor<T>, b: &RangeXor<T>) -> RangeXor<T> {",
      "            RangeXor {",
      "                xor: a.xor ^ b.xor,",
      "                len: a.len + b.len,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeUpdateRangeXor<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> MapMonoid for RangeUpdateRangeXor<T>",
      "    where",
      "        T: Copy + BitXor<Output = T> + From<u8>,",
      "    {",
      "        type M = ValueLenXor<T>;",
      "        type F = Option<T>;",
      "        fn identity_map() -> Option<T> {",
      "            None",
      "        }",
      "        fn composition(a: &Option<T>, b: &Option<T>) -> Option<T> {",
      "            if a.is_some() {",
      "                *a",
      "            } else {",
      "                *b",
      "            }",
      "        }",
      "        fn mapping(f: &Option<T>, x: &RangeXor<T>) -> RangeXor<T> {",
      "            match f {",
      "                Some(val) => RangeXor {",
      "                    xor: if x.len % 2 == 1 { *val } else { 0.into() },",
      "                    len: x.len,",
      "                },",
      "                None => *x,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct RangeUpdateRangeXorSegtree<T>",
      "    where",
      "        T: Copy + BitXor<Output = T> + From<u8>,",
      "    {",
      "        segtree: LazySegtree<RangeUpdateRangeXor<T>>,",
      "        len: usize,",
      "    }",
      "    impl<T> RangeUpdateRangeXorSegtree<T>",
      "    where",
      "        T: Copy + BitXor<Output = T> + From<u8>,",
      "    {",
      "        pub fn new(n: usize) -> Self {",
      "            let xs = vec![0.into(); n];",
      "            Self::from_slice(&xs)",
      "        }",
      "        pub fn from_slice(xs: &[T]) -> RangeUpdateRangeXorSegtree<T> {",
      "            let xs = xs.iter().copied().map(RangeXor::unit).collect_vec();",
      "            let len = xs.len();",
      "            RangeUpdateRangeXorSegtree {",
      "                segtree: LazySegtree::from(xs),",
      "                len,",
      "            }",
      "        }",
      "        pub fn set(&mut self, p: usize, x: T) {",
      "            self.segtree.set(p, RangeXor::unit(x));",
      "        }",
      "        pub fn get(&mut self, p: usize) -> T {",
      "            self.segtree.get(p).xor",
      "        }",
      "        pub fn range_xor<R>(&mut self, range: R) -> T",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range).xor",
      "        }",
      "        pub fn all_xor(&self) -> T {",
      "            self.segtree.all_prod().xor",
      "        }",
      "        pub fn update(&mut self, p: usize, x: T) {",
      "            self.segtree.apply(p, Some(x))",
      "        }",
      "        pub fn range_update<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, Some(x))",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<T> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "range_xor_range_xor_apply": {
    "scope": "rust",
    "prefix": "range_xor_range_xor_apply",
    "body": [
      "use range_xor_range_xor_apply::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod range_xor_range_xor_apply {",
      "    use ac_library::{LazySegtree, MapMonoid, Monoid};",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    use std::ops::{BitXor, RangeBounds};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeXor<T> {",
      "        pub xor: T,",
      "        pub len: i64,",
      "    }",
      "    impl<T> RangeXor<T> {",
      "        pub fn unit(x: T) -> RangeXor<T> {",
      "            RangeXor { xor: x, len: 1 }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct ValueLenXor<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for ValueLenXor<T>",
      "    where",
      "        T: Copy + BitXor<Output = T> + From<u8>,",
      "    {",
      "        type S = RangeXor<T>;",
      "        fn identity() -> RangeXor<T> {",
      "            RangeXor {",
      "                xor: 0.into(),",
      "                len: 0,",
      "            }",
      "        }",
      "        fn binary_operation(a: &RangeXor<T>, b: &RangeXor<T>) -> RangeXor<T> {",
      "            RangeXor {",
      "                xor: a.xor ^ b.xor,",
      "                len: a.len + b.len,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct RangeXorApplyRangeXor<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> MapMonoid for RangeXorApplyRangeXor<T>",
      "    where",
      "        T: Copy + BitXor<Output = T> + From<u8>,",
      "    {",
      "        type M = ValueLenXor<T>;",
      "        type F = Option<T>;",
      "        fn identity_map() -> Option<T> {",
      "            None",
      "        }",
      "        fn composition(a: &Option<T>, b: &Option<T>) -> Option<T> {",
      "            match (a, b) {",
      "                (Some(val_a), Some(val_b)) => Some(*val_a ^ *val_b),",
      "                (Some(_), None) => *a,",
      "                (None, Some(_)) => *b,",
      "                (None, None) => None,",
      "            }",
      "        }",
      "        fn mapping(f: &Option<T>, x: &RangeXor<T>) -> RangeXor<T> {",
      "            match f {",
      "                Some(val) => {",
      "                    let new_xor = if x.len % 2 == 1 { x.xor ^ *val } else { x.xor };",
      "                    RangeXor {",
      "                        xor: new_xor,",
      "                        len: x.len,",
      "                    }",
      "                }",
      "                None => *x,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct RangeXorApplyRangeXorSegtree<T>",
      "    where",
      "        T: Copy + BitXor<Output = T> + From<u8>,",
      "    {",
      "        segtree: LazySegtree<RangeXorApplyRangeXor<T>>,",
      "        len: usize,",
      "    }",
      "    impl<T> RangeXorApplyRangeXorSegtree<T>",
      "    where",
      "        T: Copy + BitXor<Output = T> + From<u8>,",
      "    {",
      "        pub fn new(n: usize) -> Self {",
      "            let xs = vec![0.into(); n];",
      "            Self::from_slice(&xs)",
      "        }",
      "        pub fn from_slice(xs: &[T]) -> RangeXorApplyRangeXorSegtree<T> {",
      "            let xs = xs.iter().copied().map(RangeXor::unit).collect_vec();",
      "            let len = xs.len();",
      "            RangeXorApplyRangeXorSegtree {",
      "                segtree: LazySegtree::from(xs),",
      "                len,",
      "            }",
      "        }",
      "        pub fn set(&mut self, p: usize, x: T) {",
      "            self.segtree.set(p, RangeXor::unit(x));",
      "        }",
      "        pub fn get(&mut self, p: usize) -> T {",
      "            self.segtree.get(p).xor",
      "        }",
      "        pub fn range_xor<R>(&mut self, range: R) -> T",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.prod(range).xor",
      "        }",
      "        pub fn all_xor(&self) -> T {",
      "            self.segtree.all_prod().xor",
      "        }",
      "        pub fn xor_apply(&mut self, p: usize, x: T) {",
      "            self.segtree.apply(p, Some(x))",
      "        }",
      "        pub fn range_xor_apply<R>(&mut self, range: R, x: T)",
      "        where",
      "            R: RangeBounds<usize>,",
      "        {",
      "            self.segtree.apply_range(range, Some(x))",
      "        }",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn to_vec(&mut self) -> Vec<T> {",
      "            (0..self.len).map(|i| self.get(i)).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "rect_add_fenwick_tree_2d": {
    "scope": "rust",
    "prefix": "rect_add_fenwick_tree_2d",
    "body": [
      "use ab_group::*;",
      "use rect_add_fenwick_tree_2d::*;",
      "use rect_sum_fenwick_tree_2d::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod rect_sum_fenwick_tree_2d {",
      "    use super::{AbGroup, AdditiveAbGroup};",
      "    use std::ops::{Bound, RangeBounds};",
      "    /// 可換群 (AbGroup) を用いた汎用的な 2次元 Fenwick Tree (Rect Sum Fenwick Tree 2D)。",
      "    /// 0-indexed で実装されています。",
      "    /// 矩形領域の和の取得（2次元累積和）と要素への加算を O(log H * log W) で行います。",
      "    #[derive(Clone)]",
      "    pub struct RectSumFenwickTree2DArbitrary<G: AbGroup> {",
      "        h: usize,",
      "        w: usize,",
      "        data: Vec<Vec<G::S>>,",
      "    }",
      "    /// i64 の加算群を用いた標準的な 2次元 Fenwick Tree のエイリアス。",
      "    pub type RectSumFenwickTree2DI64 = RectSumFenwickTree2DArbitrary<AdditiveAbGroup<i64>>;",
      "    /// 任意の数値型 T の加算群を用いた 2次元 Fenwick Tree のエイリアス。",
      "    pub type RectSumFenwickTree2D<T> = RectSumFenwickTree2DArbitrary<AdditiveAbGroup<T>>;",
      "    impl<G: AbGroup> RectSumFenwickTree2DArbitrary<G> {",
      "        /// H × W の 2次元 Fenwick Tree を作成します。",
      "        /// 要素はすべて `G::zero()` で初期化されます。",
      "        /// # 計算量",
      "        /// O(H * W)",
      "        pub fn new(h: usize, w: usize) -> Self {",
      "            let data = vec![vec![G::zero(); w]; h];",
      "            Self { h, w, data }",
      "        }",
      "        /// 配列の 2次元スライスから Fenwick Tree を作成します。",
      "        /// # 計算量",
      "        /// O(H * W)",
      "        pub fn from_slice(slice: &[Vec<G::S>]) -> Self {",
      "            let h = slice.len();",
      "            let w = if h == 0 { 0 } else { slice[0].len() };",
      "            let mut data = slice.to_vec();",
      "            for i in 0..h {",
      "                for j in 0..w {",
      "                    let next_j = j | (j + 1);",
      "                    if next_j < w {",
      "                        let val = data[i][j].clone();",
      "                        data[i][next_j] = G::add(&data[i][next_j], &val);",
      "                    }",
      "                }",
      "            }",
      "            for j in 0..w {",
      "                for i in 0..h {",
      "                    let next_i = i | (i + 1);",
      "                    if next_i < h {",
      "                        let val = data[i][j].clone();",
      "                        data[next_i][j] = G::add(&data[next_i][j], &val);",
      "                    }",
      "                }",
      "            }",
      "            Self { h, w, data }",
      "        }",
      "        /// `(y, x)` 番目の要素に `val` を加算（群の演算を適用）します。",
      "        /// # Panics",
      "        /// 座標が範囲外の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn add(&mut self, mut y: usize, x: usize, val: G::S) {",
      "            assert!(",
      "                y < self.h && x < self.w,",
      "                \"RectSumFenwickTree2D::add: out of bounds. (y, x) = ({}, {}), (h, w) = ({}, {})\",",
      "                y,",
      "                x,",
      "                self.h,",
      "                self.w",
      "            );",
      "            y += 1;",
      "            while y <= self.h {",
      "                let mut x_idx = x + 1;",
      "                while x_idx <= self.w {",
      "                    self.data[y - 1][x_idx - 1] = G::add(&self.data[y - 1][x_idx - 1], &val);",
      "                    x_idx += x_idx & x_idx.wrapping_neg();",
      "                }",
      "                y += y & y.wrapping_neg();",
      "            }",
      "        }",
      "        /// `[0, y) × [0, x)` の矩形領域の総和を計算します。",
      "        /// # Panics",
      "        /// 座標が `(H, W)` を超える場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn prefix_sum(&self, mut y: usize, x: usize) -> G::S {",
      "            assert ! (y <= self . h && x <= self . w , \"RectSumFenwickTree2D::prefix_sum: out of bounds. (y, x) = ({}, {}), (h, w) = ({}, {})\" , y , x , self . h , self . w );",
      "            let mut res = G::zero();",
      "            while y > 0 {",
      "                let mut x_idx = x;",
      "                while x_idx > 0 {",
      "                    res = G::add(&res, &self.data[y - 1][x_idx - 1]);",
      "                    x_idx &= x_idx - 1;",
      "                }",
      "                y &= y - 1;",
      "            }",
      "            res",
      "        }",
      "        /// 指定された矩形領域の和を計算します。",
      "        /// # Panics",
      "        /// 範囲が不正、または領域外の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn rect_sum<Ry, Rx>(&self, y_range: Ry, x_range: Rx) -> G::S",
      "        where",
      "            Ry: RangeBounds<usize>,",
      "            Rx: RangeBounds<usize>,",
      "        {",
      "            let (y1, y2) = Self::resolve_range(y_range, self.h);",
      "            let (x1, x2) = Self::resolve_range(x_range, self.w);",
      "            assert!(",
      "                y1 <= y2 && y2 <= self.h,",
      "                \"RectSumFenwickTree2D::rect_sum: invalid y range. y_range = {}..{}, h = {}\",",
      "                y1,",
      "                y2,",
      "                self.h",
      "            );",
      "            assert!(",
      "                x1 <= x2 && x2 <= self.w,",
      "                \"RectSumFenwickTree2D::rect_sum: invalid x range. x_range = {}..{}, w = {}\",",
      "                x1,",
      "                x2,",
      "                self.w",
      "            );",
      "            let term1 = self.prefix_sum(y2, x2);",
      "            let term2 = self.prefix_sum(y1, x2);",
      "            let term3 = self.prefix_sum(y2, x1);",
      "            let term4 = self.prefix_sum(y1, x1);",
      "            let res = G::sub(&term1, &term2);",
      "            let res = G::sub(&res, &term3);",
      "            G::add(&res, &term4)",
      "        }",
      "        fn resolve_range<R: RangeBounds<usize>>(range: R, n: usize) -> (usize, usize) {",
      "            let l = match range.start_bound() {",
      "                Bound::Included(&l) => l,",
      "                Bound::Excluded(&l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            let r = match range.end_bound() {",
      "                Bound::Included(&r) => r + 1,",
      "                Bound::Excluded(&r) => r,",
      "                Bound::Unbounded => n,",
      "            };",
      "            (l, r)",
      "        }",
      "        /// `(y, x)` 番目の要素の値を取得します。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn get(&self, y: usize, x: usize) -> G::S {",
      "            self.rect_sum(y..=y, x..=x)",
      "        }",
      "        /// `(y, x)` 番目の要素の値を `val` に設定します。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn set(&mut self, y: usize, x: usize, val: G::S) {",
      "            let old = self.get(y, x);",
      "            self.add(y, x, G::sub(&val, &old));",
      "        }",
      "        /// 2次元 Fenwick Tree の現在の状態を `Vec<Vec<G::S>>` として返します。",
      "        /// # 計算量",
      "        /// O(H * W * log H * log W)",
      "        pub fn to_vec(&self) -> Vec<Vec<G::S>> {",
      "            let mut res = vec![vec![G::zero(); self.w]; self.h];",
      "            for y in 0..self.h {",
      "                for x in 0..self.w {",
      "                    res[y][x] = self.get(y, x);",
      "                }",
      "            }",
      "            res",
      "        }",
      "        pub fn len_h(&self) -> usize {",
      "            self.h",
      "        }",
      "        pub fn len_w(&self) -> usize {",
      "            self.w",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::module_inception)]",
      "pub mod ab_group {",
      "    use std::{",
      "        convert::Infallible,",
      "        iter::Sum,",
      "        marker::PhantomData,",
      "        ops::{Add, Neg, Sub},",
      "    };",
      "    /// 可換群 (Abelian Group)",
      "    pub trait AbGroup {",
      "        type S: Clone;",
      "        fn zero() -> Self::S;",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S;",
      "        fn neg(a: &Self::S) -> Self::S;",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            Self::add(a, &Self::neg(b))",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct AdditiveAbGroup<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T: Sum + Add<Output = T> + Sub<Output = T> + Neg<Output = T> + Copy> AbGroup",
      "        for AdditiveAbGroup<T>",
      "    {",
      "        type S = T;",
      "        fn zero() -> Self::S {",
      "            std::iter::empty().sum()",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a + *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            -(*a)",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a - *b",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct XorAbGroup(Infallible);",
      "    impl AbGroup for XorAbGroup {",
      "        type S = u64;",
      "        fn zero() -> Self::S {",
      "            0",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            *a",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::module_inception)]",
      "pub mod rect_add_fenwick_tree_2d {",
      "    use super::{AbGroup, AdditiveAbGroup, RectSumFenwickTree2DArbitrary};",
      "    use std::ops::{Bound, RangeBounds};",
      "    /// 矩形加算・一点取得が可能な 2次元 Fenwick Tree (Rect Add Fenwick Tree 2D)。",
      "    /// 内部的には 2次元の階差数列を `RectSumFenwickTree2DArbitrary` で管理しています。",
      "    #[derive(Clone)]",
      "    pub struct RectAddFenwickTree2DArbitrary<G: AbGroup> {",
      "        ft: RectSumFenwickTree2DArbitrary<G>,",
      "    }",
      "    /// i64 の加算群を用いた標準的な 2次元双対 Fenwick Tree のエイリアス。",
      "    pub type RectAddFenwickTree2DI64 = RectAddFenwickTree2DArbitrary<AdditiveAbGroup<i64>>;",
      "    /// 任意の数値型 T の加算群を用いた 2次元双対 Fenwick Tree のエイリアス。",
      "    pub type RectAddFenwickTree2D<T> = RectAddFenwickTree2DArbitrary<AdditiveAbGroup<T>>;",
      "    impl<G: AbGroup> RectAddFenwickTree2DArbitrary<G> {",
      "        /// H × W の 2次元双対 Fenwick Tree を作成します。",
      "        /// 要素はすべて `G::zero()` で初期化されます。",
      "        /// # 計算量",
      "        /// O(H * W)",
      "        pub fn new(h: usize, w: usize) -> Self {",
      "            Self {",
      "                ft: RectSumFenwickTree2DArbitrary::new(h + 1, w + 1),",
      "            }",
      "        }",
      "        /// 配列の 2次元スライスから Dual Fenwick Tree を作成します。",
      "        /// # 計算量",
      "        /// O(H * W)",
      "        pub fn from_slice(slice: &[Vec<G::S>]) -> Self {",
      "            let h = slice.len();",
      "            let w = if h == 0 { 0 } else { slice[0].len() };",
      "            let mut diff = vec![vec![G::zero(); w + 1]; h + 1];",
      "            for i in 0..h {",
      "                for j in 0..w {",
      "                    let val = slice[i][j].clone();",
      "                    diff[i][j] = G::add(&diff[i][j], &val);",
      "                    diff[i][j + 1] = G::sub(&diff[i][j + 1], &val);",
      "                    diff[i + 1][j] = G::sub(&diff[i + 1][j], &val);",
      "                    diff[i + 1][j + 1] = G::add(&diff[i + 1][j + 1], &val);",
      "                }",
      "            }",
      "            Self {",
      "                ft: RectSumFenwickTree2DArbitrary::from_slice(&diff),",
      "            }",
      "        }",
      "        /// 指定された矩形領域 `y_range` × `x_range` に `val` を加算します。",
      "        /// # Panics",
      "        /// 範囲が不正、または領域外の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn rect_add<Ry, Rx>(&mut self, y_range: Ry, x_range: Rx, val: G::S)",
      "        where",
      "            Ry: RangeBounds<usize>,",
      "            Rx: RangeBounds<usize>,",
      "        {",
      "            let h = self.ft.len_h() - 1;",
      "            let w = self.ft.len_w() - 1;",
      "            let (y1, y2) = Self::resolve_range(y_range, h);",
      "            let (x1, x2) = Self::resolve_range(x_range, w);",
      "            assert!(",
      "                y1 <= y2 && y2 <= h,",
      "                \"RectAddFenwickTree2D::rect_add: invalid y range\"",
      "            );",
      "            assert!(",
      "                x1 <= x2 && x2 <= w,",
      "                \"RectAddFenwickTree2D::rect_add: invalid x range\"",
      "            );",
      "            self.ft.add(y1, x1, val.clone());",
      "            self.ft.add(y1, x2, G::neg(&val));",
      "            self.ft.add(y2, x1, G::neg(&val));",
      "            self.ft.add(y2, x2, val);",
      "        }",
      "        fn resolve_range<R: RangeBounds<usize>>(range: R, n: usize) -> (usize, usize) {",
      "            let l = match range.start_bound() {",
      "                Bound::Included(&l) => l,",
      "                Bound::Excluded(&l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            let r = match range.end_bound() {",
      "                Bound::Included(&r) => r + 1,",
      "                Bound::Excluded(&r) => r,",
      "                Bound::Unbounded => n,",
      "            };",
      "            (l, r)",
      "        }",
      "        /// `(y, x)` 番目の要素に `val` を加算します。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn add(&mut self, y: usize, x: usize, val: G::S) {",
      "            self.rect_add(y..=y, x..=x, val);",
      "        }",
      "        /// `(y, x)` 番目の要素の値を `val` に設定します。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn set(&mut self, y: usize, x: usize, val: G::S) {",
      "            let old = self.get(y, x);",
      "            self.add(y, x, G::sub(&val, &old));",
      "        }",
      "        /// `(y, x)` 番目の要素の値を取得します。",
      "        /// # Panics",
      "        /// 座標が範囲外の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn get(&self, y: usize, x: usize) -> G::S {",
      "            let h = self.ft.len_h() - 1;",
      "            let w = self.ft.len_w() - 1;",
      "            assert!(y < h && x < w, \"RectAddFenwickTree2D::get: out of bounds\");",
      "            self.ft.prefix_sum(y + 1, x + 1)",
      "        }",
      "        /// 現在の状態を `Vec<Vec<G::S>>` として返します。",
      "        /// # 計算量",
      "        /// O(H * W * log H * log W)",
      "        pub fn to_vec(&self) -> Vec<Vec<G::S>> {",
      "            let h = self.ft.len_h() - 1;",
      "            let w = self.ft.len_w() - 1;",
      "            (0..h)",
      "                .map(|y| (0..w).map(|x| self.get(y, x)).collect())",
      "                .collect()",
      "        }",
      "        pub fn len_h(&self) -> usize {",
      "            self.ft.len_h() - 1",
      "        }",
      "        pub fn len_w(&self) -> usize {",
      "            self.ft.len_w() - 1",
      "        }",
      "    }",
      "}"
    ]
  },
  "rect_add_imos": {
    "scope": "rust",
    "prefix": "rect_add_imos",
    "body": [
      "use rect_add_imos::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod rect_add_imos {",
      "    use std::ops::{Bound, RangeBounds};",
      "    /// 2次元いもす法（差分配列）を用いて、2次元配列に対する長方形領域への加算クエリを効率的に処理するデータ構造。",
      "    /// 各長方形領域への加算操作はO(1)で、最終的な配列を構築するのにO(H*W)かかる。",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct RectAddImos {",
      "        h: usize,",
      "        w: usize,",
      "        diff: Vec<Vec<i64>>,",
      "    }",
      "    impl RectAddImos {",
      "        /// サイズ `h` × `w` の `RectAddImos` インスタンスを作成する。",
      "        /// # 計算量",
      "        /// O(h * w)",
      "        pub fn new(h: usize, w: usize) -> Self {",
      "            Self {",
      "                h,",
      "                w,",
      "                diff: vec![vec![0; w + 1]; h + 1],",
      "            }",
      "        }",
      "        /// 指定された `y_range` × `x_range` の長方形領域に `val` を加算する。",
      "        /// # Panics",
      "        /// 範囲が不正な場合にパニックする。",
      "        /// # 計算量",
      "        /// O(1)",
      "        pub fn rect_add(",
      "            &mut self,",
      "            y_range: impl RangeBounds<usize>,",
      "            x_range: impl RangeBounds<usize>,",
      "            val: i64,",
      "        ) {",
      "            let y_range = open_range_bounds(y_range, self.h);",
      "            let x_range = open_range_bounds(x_range, self.w);",
      "            let y1 = y_range.start;",
      "            let y2 = y_range.end;",
      "            let x1 = x_range.start;",
      "            let x2 = x_range.end;",
      "            assert!(y1 <= y2 && y2 <= self.h);",
      "            assert!(x1 <= x2 && x2 <= self.w);",
      "            self.diff[y1][x1] += val;",
      "            self.diff[y1][x2] -= val;",
      "            self.diff[y2][x1] -= val;",
      "            self.diff[y2][x2] += val;",
      "        }",
      "        /// 差分配列から最終的な2次元配列を構築する。",
      "        /// # 計算量",
      "        /// O(h * w)",
      "        pub fn to_vec(mut self) -> Vec<Vec<i64>> {",
      "            if self.h == 0 {",
      "                return Vec::new();",
      "            }",
      "            if self.w == 0 {",
      "                return vec![vec![]; self.h];",
      "            }",
      "            for y in 0..=self.h {",
      "                for x in 1..=self.w {",
      "                    self.diff[y][x] += self.diff[y][x - 1];",
      "                }",
      "            }",
      "            for x in 0..=self.w {",
      "                for y in 1..=self.h {",
      "                    self.diff[y][x] += self.diff[y - 1][x];",
      "                }",
      "            }",
      "            self.diff.truncate(self.h);",
      "            for y in 0..self.h {",
      "                self.diff[y].truncate(self.w);",
      "            }",
      "            self.diff",
      "        }",
      "    }",
      "    fn open_range_bounds(range: impl RangeBounds<usize>, len: usize) -> std::ops::Range<usize> {",
      "        let l = match range.start_bound() {",
      "            Bound::Unbounded => 0,",
      "            Bound::Included(&x) => x,",
      "            Bound::Excluded(&x) => x + 1,",
      "        };",
      "        let r = match range.end_bound() {",
      "            Bound::Unbounded => len,",
      "            Bound::Included(&x) => x + 1,",
      "            Bound::Excluded(&x) => x,",
      "        };",
      "        l..r",
      "    }",
      "}"
    ]
  },
  "rect_add_imos_arbitrary": {
    "scope": "rust",
    "prefix": "rect_add_imos_arbitrary",
    "body": [
      "use ab_group::*;",
      "use rect_add_imos_arbitrary::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod ab_group {",
      "    use std::{",
      "        convert::Infallible,",
      "        iter::Sum,",
      "        marker::PhantomData,",
      "        ops::{Add, Neg, Sub},",
      "    };",
      "    /// 可換群 (Abelian Group)",
      "    pub trait AbGroup {",
      "        type S: Clone;",
      "        fn zero() -> Self::S;",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S;",
      "        fn neg(a: &Self::S) -> Self::S;",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            Self::add(a, &Self::neg(b))",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct AdditiveAbGroup<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T: Sum + Add<Output = T> + Sub<Output = T> + Neg<Output = T> + Copy> AbGroup",
      "        for AdditiveAbGroup<T>",
      "    {",
      "        type S = T;",
      "        fn zero() -> Self::S {",
      "            std::iter::empty().sum()",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a + *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            -(*a)",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a - *b",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct XorAbGroup(Infallible);",
      "    impl AbGroup for XorAbGroup {",
      "        type S = u64;",
      "        fn zero() -> Self::S {",
      "            0",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            *a",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::module_inception)]",
      "/// 可換群 (AbGroup) を用いた汎用的な 2次元長方形加算いもす法を扱うモジュール",
      "pub mod rect_add_imos_arbitrary {",
      "    use super::AbGroup;",
      "    use std::ops::{Bound, RangeBounds};",
      "    /// 2次元いもす法（差分配列）を用いて、2次元配列に対する長方形領域への加算クエリを効率的に処理するデータ構造 (汎用版)。",
      "    /// 各長方形領域への加算操作はO(1)で、最終的な配列を構築するのにO(H*W)かかる。",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct RectAddImosArbitrary<G: AbGroup> {",
      "        h: usize,",
      "        w: usize,",
      "        diff: Vec<Vec<G::S>>,",
      "    }",
      "    impl<G: AbGroup> RectAddImosArbitrary<G> {",
      "        /// サイズ `h` × `w` の `RectAddImosArbitrary` インスタンスを作成する。",
      "        /// # 計算量",
      "        /// O(h * w)",
      "        pub fn new(h: usize, w: usize) -> Self {",
      "            let mut diff = Vec::with_capacity(h + 1);",
      "            for _ in 0..=h {",
      "                let mut row = Vec::with_capacity(w + 1);",
      "                for _ in 0..=w {",
      "                    row.push(G::zero());",
      "                }",
      "                diff.push(row);",
      "            }",
      "            Self { h, w, diff }",
      "        }",
      "        /// 指定された `y_range` × `x_range` の長方形領域に `val` を加算する。",
      "        /// # Panics",
      "        /// 範囲が不正な場合にパニックする。",
      "        /// # 計算量",
      "        /// O(1)",
      "        pub fn rect_add(",
      "            &mut self,",
      "            y_range: impl RangeBounds<usize>,",
      "            x_range: impl RangeBounds<usize>,",
      "            val: G::S,",
      "        ) {",
      "            let y_range = open_range_bounds(y_range, self.h);",
      "            let x_range = open_range_bounds(x_range, self.w);",
      "            let y1 = y_range.start;",
      "            let y2 = y_range.end;",
      "            let x1 = x_range.start;",
      "            let x2 = x_range.end;",
      "            assert!(y1 <= y2 && y2 <= self.h);",
      "            assert!(x1 <= x2 && x2 <= self.w);",
      "            self.diff[y1][x1] = G::add(&self.diff[y1][x1], &val);",
      "            self.diff[y1][x2] = G::sub(&self.diff[y1][x2], &val);",
      "            self.diff[y2][x1] = G::sub(&self.diff[y2][x1], &val);",
      "            self.diff[y2][x2] = G::add(&self.diff[y2][x2], &val);",
      "        }",
      "        /// 差分配列から最終的な2次元配列を構築する。",
      "        /// # 計算量",
      "        /// O(h * w)",
      "        pub fn to_vec(mut self) -> Vec<Vec<G::S>> {",
      "            if self.h == 0 {",
      "                return Vec::new();",
      "            }",
      "            if self.w == 0 {",
      "                return vec![vec![]; self.h];",
      "            }",
      "            for y in 0..=self.h {",
      "                for x in 1..=self.w {",
      "                    self.diff[y][x] = G::add(&self.diff[y][x - 1], &self.diff[y][x]);",
      "                }",
      "            }",
      "            for x in 0..=self.w {",
      "                for y in 1..=self.h {",
      "                    self.diff[y][x] = G::add(&self.diff[y - 1][x], &self.diff[y][x]);",
      "                }",
      "            }",
      "            self.diff.truncate(self.h);",
      "            for y in 0..self.h {",
      "                self.diff[y].truncate(self.w);",
      "            }",
      "            self.diff",
      "        }",
      "    }",
      "    fn open_range_bounds(range: impl RangeBounds<usize>, len: usize) -> std::ops::Range<usize> {",
      "        let l = match range.start_bound() {",
      "            Bound::Unbounded => 0,",
      "            Bound::Included(&x) => x,",
      "            Bound::Excluded(&x) => x + 1,",
      "        };",
      "        let r = match range.end_bound() {",
      "            Bound::Unbounded => len,",
      "            Bound::Included(&x) => x + 1,",
      "            Bound::Excluded(&x) => x,",
      "        };",
      "        l..r",
      "    }",
      "}"
    ]
  },
  "rect_add_rect_sum_fenwick_tree": {
    "scope": "rust",
    "prefix": "rect_add_rect_sum_fenwick_tree",
    "body": [
      "use ab_group::*;",
      "use rect_add_rect_sum_fenwick_tree::*;",
      "use rect_sum_fenwick_tree_2d::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod rect_sum_fenwick_tree_2d {",
      "    use super::{AbGroup, AdditiveAbGroup};",
      "    use std::ops::{Bound, RangeBounds};",
      "    /// 可換群 (AbGroup) を用いた汎用的な 2次元 Fenwick Tree (Rect Sum Fenwick Tree 2D)。",
      "    /// 0-indexed で実装されています。",
      "    /// 矩形領域の和の取得（2次元累積和）と要素への加算を O(log H * log W) で行います。",
      "    #[derive(Clone)]",
      "    pub struct RectSumFenwickTree2DArbitrary<G: AbGroup> {",
      "        h: usize,",
      "        w: usize,",
      "        data: Vec<Vec<G::S>>,",
      "    }",
      "    /// i64 の加算群を用いた標準的な 2次元 Fenwick Tree のエイリアス。",
      "    pub type RectSumFenwickTree2DI64 = RectSumFenwickTree2DArbitrary<AdditiveAbGroup<i64>>;",
      "    /// 任意の数値型 T の加算群を用いた 2次元 Fenwick Tree のエイリアス。",
      "    pub type RectSumFenwickTree2D<T> = RectSumFenwickTree2DArbitrary<AdditiveAbGroup<T>>;",
      "    impl<G: AbGroup> RectSumFenwickTree2DArbitrary<G> {",
      "        /// H × W の 2次元 Fenwick Tree を作成します。",
      "        /// 要素はすべて `G::zero()` で初期化されます。",
      "        /// # 計算量",
      "        /// O(H * W)",
      "        pub fn new(h: usize, w: usize) -> Self {",
      "            let data = vec![vec![G::zero(); w]; h];",
      "            Self { h, w, data }",
      "        }",
      "        /// 配列の 2次元スライスから Fenwick Tree を作成します。",
      "        /// # 計算量",
      "        /// O(H * W)",
      "        pub fn from_slice(slice: &[Vec<G::S>]) -> Self {",
      "            let h = slice.len();",
      "            let w = if h == 0 { 0 } else { slice[0].len() };",
      "            let mut data = slice.to_vec();",
      "            for i in 0..h {",
      "                for j in 0..w {",
      "                    let next_j = j | (j + 1);",
      "                    if next_j < w {",
      "                        let val = data[i][j].clone();",
      "                        data[i][next_j] = G::add(&data[i][next_j], &val);",
      "                    }",
      "                }",
      "            }",
      "            for j in 0..w {",
      "                for i in 0..h {",
      "                    let next_i = i | (i + 1);",
      "                    if next_i < h {",
      "                        let val = data[i][j].clone();",
      "                        data[next_i][j] = G::add(&data[next_i][j], &val);",
      "                    }",
      "                }",
      "            }",
      "            Self { h, w, data }",
      "        }",
      "        /// `(y, x)` 番目の要素に `val` を加算（群の演算を適用）します。",
      "        /// # Panics",
      "        /// 座標が範囲外の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn add(&mut self, mut y: usize, x: usize, val: G::S) {",
      "            assert!(",
      "                y < self.h && x < self.w,",
      "                \"RectSumFenwickTree2D::add: out of bounds. (y, x) = ({}, {}), (h, w) = ({}, {})\",",
      "                y,",
      "                x,",
      "                self.h,",
      "                self.w",
      "            );",
      "            y += 1;",
      "            while y <= self.h {",
      "                let mut x_idx = x + 1;",
      "                while x_idx <= self.w {",
      "                    self.data[y - 1][x_idx - 1] = G::add(&self.data[y - 1][x_idx - 1], &val);",
      "                    x_idx += x_idx & x_idx.wrapping_neg();",
      "                }",
      "                y += y & y.wrapping_neg();",
      "            }",
      "        }",
      "        /// `[0, y) × [0, x)` の矩形領域の総和を計算します。",
      "        /// # Panics",
      "        /// 座標が `(H, W)` を超える場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn prefix_sum(&self, mut y: usize, x: usize) -> G::S {",
      "            assert ! (y <= self . h && x <= self . w , \"RectSumFenwickTree2D::prefix_sum: out of bounds. (y, x) = ({}, {}), (h, w) = ({}, {})\" , y , x , self . h , self . w );",
      "            let mut res = G::zero();",
      "            while y > 0 {",
      "                let mut x_idx = x;",
      "                while x_idx > 0 {",
      "                    res = G::add(&res, &self.data[y - 1][x_idx - 1]);",
      "                    x_idx &= x_idx - 1;",
      "                }",
      "                y &= y - 1;",
      "            }",
      "            res",
      "        }",
      "        /// 指定された矩形領域の和を計算します。",
      "        /// # Panics",
      "        /// 範囲が不正、または領域外の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn rect_sum<Ry, Rx>(&self, y_range: Ry, x_range: Rx) -> G::S",
      "        where",
      "            Ry: RangeBounds<usize>,",
      "            Rx: RangeBounds<usize>,",
      "        {",
      "            let (y1, y2) = Self::resolve_range(y_range, self.h);",
      "            let (x1, x2) = Self::resolve_range(x_range, self.w);",
      "            assert!(",
      "                y1 <= y2 && y2 <= self.h,",
      "                \"RectSumFenwickTree2D::rect_sum: invalid y range. y_range = {}..{}, h = {}\",",
      "                y1,",
      "                y2,",
      "                self.h",
      "            );",
      "            assert!(",
      "                x1 <= x2 && x2 <= self.w,",
      "                \"RectSumFenwickTree2D::rect_sum: invalid x range. x_range = {}..{}, w = {}\",",
      "                x1,",
      "                x2,",
      "                self.w",
      "            );",
      "            let term1 = self.prefix_sum(y2, x2);",
      "            let term2 = self.prefix_sum(y1, x2);",
      "            let term3 = self.prefix_sum(y2, x1);",
      "            let term4 = self.prefix_sum(y1, x1);",
      "            let res = G::sub(&term1, &term2);",
      "            let res = G::sub(&res, &term3);",
      "            G::add(&res, &term4)",
      "        }",
      "        fn resolve_range<R: RangeBounds<usize>>(range: R, n: usize) -> (usize, usize) {",
      "            let l = match range.start_bound() {",
      "                Bound::Included(&l) => l,",
      "                Bound::Excluded(&l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            let r = match range.end_bound() {",
      "                Bound::Included(&r) => r + 1,",
      "                Bound::Excluded(&r) => r,",
      "                Bound::Unbounded => n,",
      "            };",
      "            (l, r)",
      "        }",
      "        /// `(y, x)` 番目の要素の値を取得します。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn get(&self, y: usize, x: usize) -> G::S {",
      "            self.rect_sum(y..=y, x..=x)",
      "        }",
      "        /// `(y, x)` 番目の要素の値を `val` に設定します。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn set(&mut self, y: usize, x: usize, val: G::S) {",
      "            let old = self.get(y, x);",
      "            self.add(y, x, G::sub(&val, &old));",
      "        }",
      "        /// 2次元 Fenwick Tree の現在の状態を `Vec<Vec<G::S>>` として返します。",
      "        /// # 計算量",
      "        /// O(H * W * log H * log W)",
      "        pub fn to_vec(&self) -> Vec<Vec<G::S>> {",
      "            let mut res = vec![vec![G::zero(); self.w]; self.h];",
      "            for y in 0..self.h {",
      "                for x in 0..self.w {",
      "                    res[y][x] = self.get(y, x);",
      "                }",
      "            }",
      "            res",
      "        }",
      "        pub fn len_h(&self) -> usize {",
      "            self.h",
      "        }",
      "        pub fn len_w(&self) -> usize {",
      "            self.w",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::module_inception)]",
      "pub mod ab_group {",
      "    use std::{",
      "        convert::Infallible,",
      "        iter::Sum,",
      "        marker::PhantomData,",
      "        ops::{Add, Neg, Sub},",
      "    };",
      "    /// 可換群 (Abelian Group)",
      "    pub trait AbGroup {",
      "        type S: Clone;",
      "        fn zero() -> Self::S;",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S;",
      "        fn neg(a: &Self::S) -> Self::S;",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            Self::add(a, &Self::neg(b))",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct AdditiveAbGroup<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T: Sum + Add<Output = T> + Sub<Output = T> + Neg<Output = T> + Copy> AbGroup",
      "        for AdditiveAbGroup<T>",
      "    {",
      "        type S = T;",
      "        fn zero() -> Self::S {",
      "            std::iter::empty().sum()",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a + *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            -(*a)",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a - *b",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct XorAbGroup(Infallible);",
      "    impl AbGroup for XorAbGroup {",
      "        type S = u64;",
      "        fn zero() -> Self::S {",
      "            0",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            *a",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::module_inception)]",
      "pub mod rect_add_rect_sum_fenwick_tree {",
      "    use super::RectSumFenwickTree2D;",
      "    use std::iter::Sum;",
      "    use std::ops::{Add, Bound, Mul, Neg, RangeBounds, Sub};",
      "    /// 任意の数値型 T に対して矩形加算・矩形和取得が可能な 2次元 Fenwick Tree (Rect Add Rect Sum Fenwick Tree 2D)。",
      "    #[derive(Clone)]",
      "    pub struct RectAddRectSumFenwickTree<T>",
      "    where",
      "        T: Copy + Add<Output = T> + Sub<Output = T> + Mul<i64, Output = T> + Neg<Output = T> + Sum,",
      "    {",
      "        h: usize,",
      "        w: usize,",
      "        bit00: RectSumFenwickTree2D<T>,",
      "        bit01: RectSumFenwickTree2D<T>,",
      "        bit10: RectSumFenwickTree2D<T>,",
      "        bit11: RectSumFenwickTree2D<T>,",
      "    }",
      "    /// i64 の加算群を用いた標準的な 2次元矩形加算・矩形和 Fenwick Tree のエイリアス。",
      "    pub type RectAddRectSumFenwickTreeI64 = RectAddRectSumFenwickTree<i64>;",
      "    impl<T> RectAddRectSumFenwickTree<T>",
      "    where",
      "        T: Copy + Add<Output = T> + Sub<Output = T> + Mul<i64, Output = T> + Neg<Output = T> + Sum,",
      "    {",
      "        /// H × W の 2次元矩形加算・矩形和 Fenwick Tree を作成します。",
      "        /// # 計算量",
      "        /// O(H * W)",
      "        pub fn new(h: usize, w: usize) -> Self {",
      "            Self {",
      "                h,",
      "                w,",
      "                bit00: RectSumFenwickTree2D::new(h + 1, w + 1),",
      "                bit01: RectSumFenwickTree2D::new(h + 1, w + 1),",
      "                bit10: RectSumFenwickTree2D::new(h + 1, w + 1),",
      "                bit11: RectSumFenwickTree2D::new(h + 1, w + 1),",
      "            }",
      "        }",
      "        /// 配列の 2次元スライスから Rect Add Rect Sum Fenwick Tree を作成します。",
      "        /// # 計算量",
      "        /// O(H * W)",
      "        pub fn from_slice(slice: &[Vec<T>]) -> Self {",
      "            let h = slice.len();",
      "            let w = if h == 0 { 0 } else { slice[0].len() };",
      "            let zero: T = std::iter::empty::<T>().sum();",
      "            let mut d = vec![vec![zero; w + 1]; h + 1];",
      "            let mut dx = vec![vec![zero; w + 1]; h + 1];",
      "            let mut dy = vec![vec![zero; w + 1]; h + 1];",
      "            let mut dxy = vec![vec![zero; w + 1]; h + 1];",
      "            for i in 0..=h {",
      "                for j in 0..=w {",
      "                    let get_a = |y: isize, x: isize| -> T {",
      "                        if y >= 0 && (y as usize) < h && x >= 0 && (x as usize) < w {",
      "                            slice[y as usize][x as usize]",
      "                        } else {",
      "                            std::iter::empty::<T>().sum()",
      "                        }",
      "                    };",
      "                    let val = get_a(i as isize, j as isize)",
      "                        - get_a(i as isize - 1, j as isize)",
      "                        - get_a(i as isize, j as isize - 1)",
      "                        + get_a(i as isize - 1, j as isize - 1);",
      "                    d[i][j] = val;",
      "                    dx[i][j] = val * (j as i64);",
      "                    dy[i][j] = val * (i as i64);",
      "                    dxy[i][j] = val * (i as i64) * (j as i64);",
      "                }",
      "            }",
      "            Self {",
      "                h,",
      "                w,",
      "                bit00: RectSumFenwickTree2D::from_slice(&d),",
      "                bit01: RectSumFenwickTree2D::from_slice(&dx),",
      "                bit10: RectSumFenwickTree2D::from_slice(&dy),",
      "                bit11: RectSumFenwickTree2D::from_slice(&dxy),",
      "            }",
      "        }",
      "        /// 指定された矩形領域 `y_range` × `x_range` に `val` を加算します。",
      "        /// # Panics",
      "        /// 範囲が不正、または領域外の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn rect_add<Ry, Rx>(&mut self, y_range: Ry, x_range: Rx, val: T)",
      "        where",
      "            Ry: RangeBounds<usize>,",
      "            Rx: RangeBounds<usize>,",
      "        {",
      "            let (y1, y2) = Self::resolve_range(y_range, self.h);",
      "            let (x1, x2) = Self::resolve_range(x_range, self.w);",
      "            assert!(",
      "                y1 <= y2 && y2 <= self.h,",
      "                \"RectAddRectSumFenwickTree::rect_add: invalid y range: {}..{}, h={}\",",
      "                y1,",
      "                y2,",
      "                self.h",
      "            );",
      "            assert!(",
      "                x1 <= x2 && x2 <= self.w,",
      "                \"RectAddRectSumFenwickTree::rect_add: invalid x range: {}..{}, w={}\",",
      "                x1,",
      "                x2,",
      "                self.w",
      "            );",
      "            let mut add_internal = |y: usize, x: usize, v: T| {",
      "                if y <= self.h && x <= self.w {",
      "                    self.bit00.add(y, x, v);",
      "                    self.bit01.add(y, x, v * (x as i64));",
      "                    self.bit10.add(y, x, v * (y as i64));",
      "                    self.bit11.add(y, x, v * (y as i64) * (x as i64));",
      "                }",
      "            };",
      "            add_internal(y1, x1, val);",
      "            add_internal(y1, x2, -val);",
      "            add_internal(y2, x1, -val);",
      "            add_internal(y2, x2, val);",
      "        }",
      "        /// `(y, x)` 番目の要素に `val` を加算します。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn add(&mut self, y: usize, x: usize, val: T) {",
      "            self.rect_add(y..=y, x..=x, val);",
      "        }",
      "        /// `(y, x)` 番目の要素の値を `val` に設定します。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn set(&mut self, y: usize, x: usize, val: T) {",
      "            let old = self.get(y, x);",
      "            self.add(y, x, val - old);",
      "        }",
      "        /// 左上 (0,0) から右下 (y,x) までの矩形和を取得します。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn prefix_sum(&self, y: usize, x: usize) -> T {",
      "            let s00 = self.bit00.prefix_sum(y, x);",
      "            let s01 = self.bit01.prefix_sum(y, x);",
      "            let s10 = self.bit10.prefix_sum(y, x);",
      "            let s11 = self.bit11.prefix_sum(y, x);",
      "            s00 * (y as i64) * (x as i64) - s01 * (y as i64) - s10 * (x as i64) + s11",
      "        }",
      "        /// 指定された矩形領域の和を計算します。",
      "        /// # Panics",
      "        /// 範囲が不正、または領域外の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn rect_sum<Ry, Rx>(&self, y_range: Ry, x_range: Rx) -> T",
      "        where",
      "            Ry: RangeBounds<usize>,",
      "            Rx: RangeBounds<usize>,",
      "        {",
      "            let (y1, y2) = Self::resolve_range(y_range, self.h);",
      "            let (x1, x2) = Self::resolve_range(x_range, self.w);",
      "            assert!(",
      "                y1 <= y2 && y2 <= self.h,",
      "                \"RectAddRectSumFenwickTree::rect_sum: invalid y range: {}..{}, h={}\",",
      "                y1,",
      "                y2,",
      "                self.h",
      "            );",
      "            assert!(",
      "                x1 <= x2 && x2 <= self.w,",
      "                \"RectAddRectSumFenwickTree::rect_sum: invalid x range: {}..{}, w={}\",",
      "                x1,",
      "                x2,",
      "                self.w",
      "            );",
      "            self.prefix_sum(y2, x2) - self.prefix_sum(y1, x2) - self.prefix_sum(y2, x1)",
      "                + self.prefix_sum(y1, x1)",
      "        }",
      "        fn resolve_range<R: RangeBounds<usize>>(range: R, n: usize) -> (usize, usize) {",
      "            let l = match range.start_bound() {",
      "                Bound::Included(&l) => l,",
      "                Bound::Excluded(&l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            let r = match range.end_bound() {",
      "                Bound::Included(&r) => r + 1,",
      "                Bound::Excluded(&r) => r,",
      "                Bound::Unbounded => n,",
      "            };",
      "            (l, r)",
      "        }",
      "        /// `(y, x)` 番目の要素を取得します。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn get(&self, y: usize, x: usize) -> T {",
      "            self.rect_sum(y..=y, x..=x)",
      "        }",
      "        /// 現在の状態を `Vec<Vec<T>>` として返します。",
      "        /// # 計算量",
      "        /// O(H * W * log H * log W)",
      "        pub fn to_vec(&self) -> Vec<Vec<T>> {",
      "            (0..self.h)",
      "                .map(|y| (0..self.w).map(|x| self.get(y, x)).collect())",
      "                .collect()",
      "        }",
      "        pub fn len_h(&self) -> usize {",
      "            self.h",
      "        }",
      "        pub fn len_w(&self) -> usize {",
      "            self.w",
      "        }",
      "    }",
      "}"
    ]
  },
  "rect_sum_fenwick_tree_2d": {
    "scope": "rust",
    "prefix": "rect_sum_fenwick_tree_2d",
    "body": [
      "use ab_group::*;",
      "use rect_sum_fenwick_tree_2d::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod ab_group {",
      "    use std::{",
      "        convert::Infallible,",
      "        iter::Sum,",
      "        marker::PhantomData,",
      "        ops::{Add, Neg, Sub},",
      "    };",
      "    /// 可換群 (Abelian Group)",
      "    pub trait AbGroup {",
      "        type S: Clone;",
      "        fn zero() -> Self::S;",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S;",
      "        fn neg(a: &Self::S) -> Self::S;",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            Self::add(a, &Self::neg(b))",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct AdditiveAbGroup<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T: Sum + Add<Output = T> + Sub<Output = T> + Neg<Output = T> + Copy> AbGroup",
      "        for AdditiveAbGroup<T>",
      "    {",
      "        type S = T;",
      "        fn zero() -> Self::S {",
      "            std::iter::empty().sum()",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a + *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            -(*a)",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a - *b",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct XorAbGroup(Infallible);",
      "    impl AbGroup for XorAbGroup {",
      "        type S = u64;",
      "        fn zero() -> Self::S {",
      "            0",
      "        }",
      "        fn add(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "        fn neg(a: &Self::S) -> Self::S {",
      "            *a",
      "        }",
      "        fn sub(a: &Self::S, b: &Self::S) -> Self::S {",
      "            *a ^ *b",
      "        }",
      "    }",
      "}",
      "#[allow(clippy::module_inception)]",
      "pub mod rect_sum_fenwick_tree_2d {",
      "    use super::{AbGroup, AdditiveAbGroup};",
      "    use std::ops::{Bound, RangeBounds};",
      "    /// 可換群 (AbGroup) を用いた汎用的な 2次元 Fenwick Tree (Rect Sum Fenwick Tree 2D)。",
      "    /// 0-indexed で実装されています。",
      "    /// 矩形領域の和の取得（2次元累積和）と要素への加算を O(log H * log W) で行います。",
      "    #[derive(Clone)]",
      "    pub struct RectSumFenwickTree2DArbitrary<G: AbGroup> {",
      "        h: usize,",
      "        w: usize,",
      "        data: Vec<Vec<G::S>>,",
      "    }",
      "    /// i64 の加算群を用いた標準的な 2次元 Fenwick Tree のエイリアス。",
      "    pub type RectSumFenwickTree2DI64 = RectSumFenwickTree2DArbitrary<AdditiveAbGroup<i64>>;",
      "    /// 任意の数値型 T の加算群を用いた 2次元 Fenwick Tree のエイリアス。",
      "    pub type RectSumFenwickTree2D<T> = RectSumFenwickTree2DArbitrary<AdditiveAbGroup<T>>;",
      "    impl<G: AbGroup> RectSumFenwickTree2DArbitrary<G> {",
      "        /// H × W の 2次元 Fenwick Tree を作成します。",
      "        /// 要素はすべて `G::zero()` で初期化されます。",
      "        /// # 計算量",
      "        /// O(H * W)",
      "        pub fn new(h: usize, w: usize) -> Self {",
      "            let data = vec![vec![G::zero(); w]; h];",
      "            Self { h, w, data }",
      "        }",
      "        /// 配列の 2次元スライスから Fenwick Tree を作成します。",
      "        /// # 計算量",
      "        /// O(H * W)",
      "        pub fn from_slice(slice: &[Vec<G::S>]) -> Self {",
      "            let h = slice.len();",
      "            let w = if h == 0 { 0 } else { slice[0].len() };",
      "            let mut data = slice.to_vec();",
      "            for i in 0..h {",
      "                for j in 0..w {",
      "                    let next_j = j | (j + 1);",
      "                    if next_j < w {",
      "                        let val = data[i][j].clone();",
      "                        data[i][next_j] = G::add(&data[i][next_j], &val);",
      "                    }",
      "                }",
      "            }",
      "            for j in 0..w {",
      "                for i in 0..h {",
      "                    let next_i = i | (i + 1);",
      "                    if next_i < h {",
      "                        let val = data[i][j].clone();",
      "                        data[next_i][j] = G::add(&data[next_i][j], &val);",
      "                    }",
      "                }",
      "            }",
      "            Self { h, w, data }",
      "        }",
      "        /// `(y, x)` 番目の要素に `val` を加算（群の演算を適用）します。",
      "        /// # Panics",
      "        /// 座標が範囲外の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn add(&mut self, mut y: usize, x: usize, val: G::S) {",
      "            assert!(",
      "                y < self.h && x < self.w,",
      "                \"RectSumFenwickTree2D::add: out of bounds. (y, x) = ({}, {}), (h, w) = ({}, {})\",",
      "                y,",
      "                x,",
      "                self.h,",
      "                self.w",
      "            );",
      "            y += 1;",
      "            while y <= self.h {",
      "                let mut x_idx = x + 1;",
      "                while x_idx <= self.w {",
      "                    self.data[y - 1][x_idx - 1] = G::add(&self.data[y - 1][x_idx - 1], &val);",
      "                    x_idx += x_idx & x_idx.wrapping_neg();",
      "                }",
      "                y += y & y.wrapping_neg();",
      "            }",
      "        }",
      "        /// `[0, y) × [0, x)` の矩形領域の総和を計算します。",
      "        /// # Panics",
      "        /// 座標が `(H, W)` を超える場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn prefix_sum(&self, mut y: usize, x: usize) -> G::S {",
      "            assert ! (y <= self . h && x <= self . w , \"RectSumFenwickTree2D::prefix_sum: out of bounds. (y, x) = ({}, {}), (h, w) = ({}, {})\" , y , x , self . h , self . w );",
      "            let mut res = G::zero();",
      "            while y > 0 {",
      "                let mut x_idx = x;",
      "                while x_idx > 0 {",
      "                    res = G::add(&res, &self.data[y - 1][x_idx - 1]);",
      "                    x_idx &= x_idx - 1;",
      "                }",
      "                y &= y - 1;",
      "            }",
      "            res",
      "        }",
      "        /// 指定された矩形領域の和を計算します。",
      "        /// # Panics",
      "        /// 範囲が不正、または領域外の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn rect_sum<Ry, Rx>(&self, y_range: Ry, x_range: Rx) -> G::S",
      "        where",
      "            Ry: RangeBounds<usize>,",
      "            Rx: RangeBounds<usize>,",
      "        {",
      "            let (y1, y2) = Self::resolve_range(y_range, self.h);",
      "            let (x1, x2) = Self::resolve_range(x_range, self.w);",
      "            assert!(",
      "                y1 <= y2 && y2 <= self.h,",
      "                \"RectSumFenwickTree2D::rect_sum: invalid y range. y_range = {}..{}, h = {}\",",
      "                y1,",
      "                y2,",
      "                self.h",
      "            );",
      "            assert!(",
      "                x1 <= x2 && x2 <= self.w,",
      "                \"RectSumFenwickTree2D::rect_sum: invalid x range. x_range = {}..{}, w = {}\",",
      "                x1,",
      "                x2,",
      "                self.w",
      "            );",
      "            let term1 = self.prefix_sum(y2, x2);",
      "            let term2 = self.prefix_sum(y1, x2);",
      "            let term3 = self.prefix_sum(y2, x1);",
      "            let term4 = self.prefix_sum(y1, x1);",
      "            let res = G::sub(&term1, &term2);",
      "            let res = G::sub(&res, &term3);",
      "            G::add(&res, &term4)",
      "        }",
      "        fn resolve_range<R: RangeBounds<usize>>(range: R, n: usize) -> (usize, usize) {",
      "            let l = match range.start_bound() {",
      "                Bound::Included(&l) => l,",
      "                Bound::Excluded(&l) => l + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            let r = match range.end_bound() {",
      "                Bound::Included(&r) => r + 1,",
      "                Bound::Excluded(&r) => r,",
      "                Bound::Unbounded => n,",
      "            };",
      "            (l, r)",
      "        }",
      "        /// `(y, x)` 番目の要素の値を取得します。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn get(&self, y: usize, x: usize) -> G::S {",
      "            self.rect_sum(y..=y, x..=x)",
      "        }",
      "        /// `(y, x)` 番目の要素の値を `val` に設定します。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn set(&mut self, y: usize, x: usize, val: G::S) {",
      "            let old = self.get(y, x);",
      "            self.add(y, x, G::sub(&val, &old));",
      "        }",
      "        /// 2次元 Fenwick Tree の現在の状態を `Vec<Vec<G::S>>` として返します。",
      "        /// # 計算量",
      "        /// O(H * W * log H * log W)",
      "        pub fn to_vec(&self) -> Vec<Vec<G::S>> {",
      "            let mut res = vec![vec![G::zero(); self.w]; self.h];",
      "            for y in 0..self.h {",
      "                for x in 0..self.w {",
      "                    res[y][x] = self.get(y, x);",
      "                }",
      "            }",
      "            res",
      "        }",
      "        pub fn len_h(&self) -> usize {",
      "            self.h",
      "        }",
      "        pub fn len_w(&self) -> usize {",
      "            self.w",
      "        }",
      "    }",
      "}"
    ]
  },
  "reroot": {
    "scope": "rust",
    "prefix": "reroot",
    "body": [
      "use reroot::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod reroot {",
      "    use ac_library::Max;",
      "    #[allow(dead_code)]",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct DistMaxReroot();",
      "    impl Reroot for DistMaxReroot {",
      "        type M = Max<u64>;",
      "        fn add_vertex(&self, x: &<Self::M as Monoid>::S, _v: usize) -> <Self::M as Monoid>::S {",
      "            *x",
      "        }",
      "        fn add_edge(",
      "            &self,",
      "            x: &<Self::M as Monoid>::S,",
      "            _v: usize,",
      "            _ei: usize,",
      "        ) -> <Self::M as Monoid>::S {",
      "            x + 1",
      "        }",
      "    }",
      "    /// 全方位木DP",
      "    pub trait Reroot {",
      "        type M: Monoid;",
      "        fn add_vertex(&self, x: &<Self::M as Monoid>::S, v: usize) -> <Self::M as Monoid>::S;",
      "        fn add_edge(",
      "            &self,",
      "            x: &<Self::M as Monoid>::S,",
      "            v: usize,",
      "            ei: usize,",
      "        ) -> <Self::M as Monoid>::S;",
      "        fn prod(xs: &[<Self::M as Monoid>::S]) -> <Self::M as Monoid>::S {",
      "            xs.iter().fold(Self::M::identity(), |acc, x| {",
      "                Self::M::binary_operation(&acc, x)",
      "            })",
      "        }",
      "        /// 全方位木DPを実行し、各頂点を根としたときの値を求めます。",
      "        /// # Arguments",
      "        /// * `adj` - 木の隣接リスト",
      "        /// # Returns",
      "        /// 各頂点を根としたときの計算結果の `Vec`",
      "        /// # 計算量",
      "        /// O(V) (V は頂点数)",
      "        fn reroot(&self, adj: &[Vec<usize>]) -> Vec<<Self::M as Monoid>::S> {",
      "            let nv = adj.len();",
      "            let mut dp: Vec<Vec<<Self::M as Monoid>::S>> = adj",
      "                .iter()",
      "                .map(|next_list| {",
      "                    let degree = next_list.len();",
      "                    vec![Self::M::identity(); degree]",
      "                })",
      "                .collect_vec();",
      "            {",
      "                let dfs_post_order = dfs_post_order(adj, 0);",
      "                let mut visited = vec![false; nv];",
      "                for &current_v in &dfs_post_order {",
      "                    visited[current_v] = true;",
      "                    for (current_e, next_v) in adj[current_v].iter().copied().enumerate() {",
      "                        if !visited[next_v] {",
      "                            continue;",
      "                        }",
      "                        dp[current_v][current_e] = {",
      "                            let edge_dp_next = dp[next_v]",
      "                                .iter()",
      "                                .enumerate()",
      "                                .filter(|(next_e, _)| adj[next_v][*next_e] != current_v)",
      "                                .map(|(next_e, x)| self.add_edge(x, next_v, next_e))",
      "                                .collect_vec();",
      "                            let prod = Self::prod(&edge_dp_next);",
      "                            self.add_vertex(&prod, next_v)",
      "                        };",
      "                    }",
      "                }",
      "            }",
      "            {",
      "                let bfs_order = bfs_order(adj, 0);",
      "                let mut visited = vec![false; nv];",
      "                for &current_v in &bfs_order {",
      "                    visited[current_v] = true;",
      "                    let edge_dp_current = dp[current_v]",
      "                        .iter()",
      "                        .enumerate()",
      "                        .map(|(current_e, x)| self.add_edge(x, current_v, current_e))",
      "                        .collect_vec();",
      "                    let cum_monoid = CumMonoid::<Self::M>::new(&edge_dp_current);",
      "                    for (current_e, next_v) in adj[current_v].iter().copied().enumerate() {",
      "                        if visited[next_v] {",
      "                            continue;",
      "                        }",
      "                        let rev_current_e =",
      "                            adj[next_v].iter().position(|&v| v == current_v).unwrap();",
      "                        dp[next_v][rev_current_e] = {",
      "                            let prod = cum_monoid.prod_without1(current_e);",
      "                            self.add_vertex(&prod, current_v)",
      "                        };",
      "                    }",
      "                }",
      "            }",
      "            dp.iter()",
      "                .enumerate()",
      "                .map(|(current_v, dp_current)| {",
      "                    let edge_dp_current = dp_current",
      "                        .iter()",
      "                        .enumerate()",
      "                        .map(|(current_e, x)| self.add_edge(x, current_v, current_e))",
      "                        .collect_vec();",
      "                    self.add_vertex(&Self::prod(&edge_dp_current), current_v)",
      "                })",
      "                .collect_vec()",
      "        }",
      "    }",
      "    fn bfs_order(adj: &[Vec<usize>], init: usize) -> Vec<usize> {",
      "        let nv = adj.len();",
      "        let mut order = vec![];",
      "        let mut visited = vec![false; nv];",
      "        let mut open = Queue::new();",
      "        open.push(init);",
      "        order.push(init);",
      "        visited[init] = true;",
      "        while let Some(current) = open.pop() {",
      "            for &next in &adj[current] {",
      "                if !visited[next] {",
      "                    order.push(next);",
      "                    visited[next] = true;",
      "                    open.push(next);",
      "                }",
      "            }",
      "        }",
      "        order",
      "    }",
      "    fn dfs_post_order(adj: &[Vec<usize>], init: usize) -> Vec<usize> {",
      "        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "        enum State {",
      "            Pre(usize),",
      "            Post(usize),",
      "        }",
      "        let nv = adj.len();",
      "        let mut order = vec![];",
      "        let mut visited = vec![false; nv];",
      "        let mut open = Stack::new();",
      "        open.push(State::Post(init));",
      "        open.push(State::Pre(init));",
      "        while let Some(current) = open.pop() {",
      "            match current {",
      "                State::Pre(v) => {",
      "                    visited[v] = true;",
      "                    for &edge in &adj[v] {",
      "                        if !visited[edge] {",
      "                            open.push(State::Post(edge));",
      "                            open.push(State::Pre(edge));",
      "                        }",
      "                    }",
      "                }",
      "                State::Post(v) => {",
      "                    order.push(v);",
      "                }",
      "            }",
      "        }",
      "        order",
      "    }",
      "    use ac_library::Monoid;",
      "    use cum_monoid::*;",
      "    pub mod cum_monoid {",
      "        use ac_library::Monoid;",
      "        #[derive(Clone, Debug)]",
      "        pub struct CumMonoid<M>",
      "        where",
      "            M: Monoid,",
      "        {",
      "            prefix_prod: Vec<M::S>,",
      "            suffix_prod: Vec<M::S>,",
      "        }",
      "        impl<M> CumMonoid<M>",
      "        where",
      "            M: Monoid,",
      "        {",
      "            pub fn new(xs: &[M::S]) -> CumMonoid<M> {",
      "                let mut prefix_prod = vec![M::identity(); xs.len() + 1];",
      "                let mut suffix_prod = vec![M::identity(); xs.len() + 1];",
      "                for i in 0..xs.len() {",
      "                    prefix_prod[i + 1] = M::binary_operation(&prefix_prod[i], &xs[i]);",
      "                }",
      "                for i in (0..xs.len()).rev() {",
      "                    suffix_prod[i] = M::binary_operation(&xs[i], &suffix_prod[i + 1]);",
      "                }",
      "                CumMonoid {",
      "                    prefix_prod,",
      "                    suffix_prod,",
      "                }",
      "            }",
      "            /// [0, i), [i + 1, n) の区間で総積を取る",
      "            pub fn prod_without1(&self, i: usize) -> M::S {",
      "                M::binary_operation(&self.prefix_prod[i], &self.suffix_prod[i + 1])",
      "            }",
      "        }",
      "    }",
      "    use itertools::Itertools;",
      "    use mod_stack::*;",
      "    pub mod mod_stack {",
      "        #[derive(Clone, Debug, PartialEq, Eq)]",
      "        pub struct Stack<T> {",
      "            raw: Vec<T>,",
      "        }",
      "        impl<T> Stack<T> {",
      "            pub fn new() -> Self {",
      "                Stack { raw: Vec::new() }",
      "            }",
      "            pub fn push(&mut self, value: T) {",
      "                self.raw.push(value)",
      "            }",
      "            pub fn pop(&mut self) -> Option<T> {",
      "                self.raw.pop()",
      "            }",
      "            pub fn peek(&self) -> Option<&T> {",
      "                self.raw.last()",
      "            }",
      "            pub fn is_empty(&self) -> bool {",
      "                self.raw.is_empty()",
      "            }",
      "            pub fn len(&self) -> usize {",
      "                self.raw.len()",
      "            }",
      "        }",
      "        impl<T> Default for Stack<T> {",
      "            fn default() -> Self {",
      "                Self::new()",
      "            }",
      "        }",
      "    }",
      "    use mod_queue::*;",
      "    pub mod mod_queue {",
      "        use std::collections::VecDeque;",
      "        #[derive(Clone, Debug, PartialEq, Eq)]",
      "        pub struct Queue<T> {",
      "            raw: VecDeque<T>,",
      "        }",
      "        impl<T> Queue<T> {",
      "            pub fn new() -> Self {",
      "                Queue {",
      "                    raw: VecDeque::new(),",
      "                }",
      "            }",
      "            pub fn push(&mut self, value: T) {",
      "                self.raw.push_back(value)",
      "            }",
      "            pub fn pop(&mut self) -> Option<T> {",
      "                self.raw.pop_front()",
      "            }",
      "            pub fn peek(&self) -> Option<&T> {",
      "                self.raw.front()",
      "            }",
      "            pub fn is_empty(&self) -> bool {",
      "                self.raw.is_empty()",
      "            }",
      "            pub fn len(&self) -> usize {",
      "                self.raw.len()",
      "            }",
      "        }",
      "        impl<T> Default for Queue<T> {",
      "            fn default() -> Self {",
      "                Self::new()",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "rollback_dsu": {
    "scope": "rust",
    "prefix": "rollback_dsu",
    "body": [
      "#[allow(clippy::module_inception)]",
      "pub mod rollback_dsu {",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "    /// DSU 内の各要素の状態（親のインデックスまたは集合のサイズ）を保持する構造体。",
      "    /// メモリ効率（32ビット整数 1 つ分）を維持したまま、以下の 2 つの状態を表現します。",
      "    /// 1. **Root (根)**:",
      "    ///    - 値が負の場合、その要素は集合の代表元（リーダー）です。",
      "    ///    - 値の絶対値 `|v|` は、その集合に属する要素の数（サイズ）を表します。",
      "    ///    - 例: `-1` はサイズ 1 の集合の根、`-5` はサイズ 5 の集合の根。",
      "    /// 2. **Child (子)**:",
      "    ///    - 値が 0 以上の場合、その要素は他の要素を親に持っています。",
      "    ///    - 値 `v` は、親要素のインデックスを表します。",
      "    struct Node(i32);",
      "    impl Node {",
      "        fn root(size: usize) -> Self {",
      "            Self(-(size as i32))",
      "        }",
      "        fn child(parent: usize) -> Self {",
      "            Self(parent as i32)",
      "        }",
      "        fn is_root(&self) -> bool {",
      "            self.0 < 0",
      "        }",
      "        fn parent(&self) -> usize {",
      "            self.0 as usize",
      "        }",
      "        fn size(&self) -> usize {",
      "            (-self.0) as usize",
      "        }",
      "    }",
      "    /// ロールバック可能なUnion-Find。",
      "    /// 経路圧縮を行わないため、各操作の計算量は O(log N) となる。",
      "    /// `merge`操作による変更は`rollback`で巻き戻すことができる。",
      "    #[derive(Clone, Debug)]",
      "    pub struct RollbackDsu {",
      "        n: usize,",
      "        nodes: Vec<Node>,",
      "        history: Vec<(usize, Node)>,",
      "    }",
      "    impl RollbackDsu {",
      "        /// `size`要素のUnion-Findを生成する。",
      "        pub fn new(size: usize) -> Self {",
      "            Self {",
      "                n: size,",
      "                nodes: vec![Node::root(1); size],",
      "                history: Vec::new(),",
      "            }",
      "        }",
      "        /// `a`が属するグループのリーダーを返す。経路圧縮は行わない。",
      "        pub fn leader(&self, mut a: usize) -> usize {",
      "            while !self.nodes[a].is_root() {",
      "                a = self.nodes[a].parent();",
      "            }",
      "            a",
      "        }",
      "        /// `a`と`b`が同じグループに属するかどうかを返す。",
      "        pub fn same(&self, a: usize, b: usize) -> bool {",
      "            self.leader(a) == self.leader(b)",
      "        }",
      "        /// `a`が属するグループのサイズを返す。",
      "        pub fn size(&self, a: usize) -> usize {",
      "            let leader = self.leader(a);",
      "            self.nodes[leader].size()",
      "        }",
      "        /// 2 つの要素 `a` と `b` が属する集合を統合する",
      "        /// # 戻り値",
      "        /// - `Some((leader, merged))`:",
      "        ///   - `leader` は統合後の集合の代表元（リーダー）",
      "        ///   - `merged` は統合されて消える側の旧代表元",
      "        /// - `None`:",
      "        ///   - `a` と `b` がすでに同じ集合に属していた場合",
      "        pub fn merge(&mut self, a: usize, b: usize) -> Option<(usize, usize)> {",
      "            let (mut leader_a, mut leader_b) = (self.leader(a), self.leader(b));",
      "            if leader_a == leader_b {",
      "                return None;",
      "            }",
      "            if self.nodes[leader_a].size() < self.nodes[leader_b].size() {",
      "                std::mem::swap(&mut leader_a, &mut leader_b);",
      "            }",
      "            self.history.push((leader_a, self.nodes[leader_a]));",
      "            self.history.push((leader_b, self.nodes[leader_b]));",
      "            let size_a = self.nodes[leader_a].size();",
      "            let size_b = self.nodes[leader_b].size();",
      "            self.nodes[leader_a] = Node::root(size_a + size_b);",
      "            self.nodes[leader_b] = Node::child(leader_a);",
      "            Some((leader_a, leader_b))",
      "        }",
      "        /// 現在の状態を記録するスナップショットを作成する。",
      "        /// このスナップショットは`rollback`メソッドに渡して使用する。",
      "        pub fn snapshot(&self) -> usize {",
      "            self.history.len()",
      "        }",
      "        /// `snapshot`で指定された時点まで状態を巻き戻す。",
      "        pub fn rollback(&mut self, snapshot: usize) {",
      "            while self.history.len() > snapshot {",
      "                let (index, value) = self.history.pop().unwrap();",
      "                self.nodes[index] = value;",
      "            }",
      "        }",
      "        pub fn groups(&mut self) -> Vec<Vec<usize>> {",
      "            let mut leader_buf = vec![0; self.n];",
      "            let mut group_size = vec![0; self.n];",
      "            for i in 0..self.n {",
      "                leader_buf[i] = self.leader(i);",
      "                group_size[leader_buf[i]] += 1;",
      "            }",
      "            let mut result = vec![Vec::new(); self.n];",
      "            for i in 0..self.n {",
      "                result[i].reserve(group_size[i]);",
      "            }",
      "            for i in 0..self.n {",
      "                result[leader_buf[i]].push(i);",
      "            }",
      "            result",
      "                .into_iter()",
      "                .filter(|x| !x.is_empty())",
      "                .collect::<Vec<Vec<usize>>>()",
      "        }",
      "    }",
      "}"
    ]
  },
  "rolling_hash": {
    "scope": "rust",
    "prefix": "rolling_hash",
    "body": [
      "use modint_u64::*;",
      "use rolling_hash::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod modint_u64 {",
      "    use std::{",
      "        convert::Infallible,",
      "        fmt,",
      "        hash::{Hash, Hasher},",
      "        iter::{Product, Sum},",
      "        marker::PhantomData,",
      "        ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign},",
      "        str::FromStr,",
      "    };",
      "    /// 2^61 -1",
      "    pub type ModInt2305843009213693951 = StaticModInt<Mod2305843009213693951>;",
      "    /// 10^18 + 3",
      "    pub type ModInt1000000000000000003 = StaticModInt<Mod1000000000000000003>;",
      "    pub type ModInt1000000007 = StaticModInt<Mod1000000007>;",
      "    pub type ModInt998244353 = StaticModInt<Mod998244353>;",
      "    /// Represents \\$\\mathbb{Z}/m\\mathbb{Z}\\$ where \\$m\\$ is a constant value.",
      "    /// Corresponds to `atcoder::static_modint` in the original ACL.",
      "    /// # Example",
      "    /// ```",
      "    /// use ac_library::ModInt1000000007 as Mint;",
      "    /// use proconio::{input, source::once::OnceSource};",
      "    /// input! {",
      "    ///     from OnceSource::from(\"1000000006 2\\n\"),",
      "    ///     a: Mint,",
      "    ///     b: Mint,",
      "    /// }",
      "    /// println!(\"{}\", a + b); // `1`",
      "    /// ```",
      "    #[derive(Copy, Clone, Eq, PartialEq)]",
      "    #[repr(transparent)]",
      "    pub struct StaticModInt<M> {",
      "        val: u64,",
      "        phantom: PhantomData<fn() -> M>,",
      "    }",
      "    impl<M: Modulus> StaticModInt<M> {",
      "        /// Returns the modulus, which is [`<M as Modulus>::VALUE`].",
      "        /// Corresponds to `atcoder::static_modint::mod` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::ModInt1000000007 as Mint;",
      "        /// assert_eq!(1_000_000_007, Mint::modulus());",
      "        /// ```",
      "        /// [`<M as Modulus>::VALUE`]: ../trait.Modulus.html#associatedconstant.VALUE",
      "        #[inline(always)]",
      "        pub fn modulus() -> u64 {",
      "            M::VALUE",
      "        }",
      "        /// Creates a new `StaticModInt`.",
      "        /// Takes [any primitive integer].",
      "        /// Corresponds to the constructor of `atcoder::static_modint` in the original ACL.",
      "        /// [any primitive integer]:  ../trait.RemEuclidU32.html",
      "        #[inline]",
      "        pub fn new<T: RemEuclidU64>(val: T) -> Self {",
      "            Self::raw(val.rem_euclid_u64(M::VALUE))",
      "        }",
      "        /// Constructs a `StaticModInt` from a `val < Self::modulus()` without checking it.",
      "        /// Corresponds to `atcoder::static_modint::raw` in the original ACL.",
      "        /// # Constraints",
      "        /// - `val` is less than `Self::modulus()`",
      "        /// See [`ModIntBase::raw`] for more more details.",
      "        /// [`ModIntBase::raw`]: ./trait.ModIntBase.html#tymethod.raw",
      "        #[inline]",
      "        pub fn raw(val: u64) -> Self {",
      "            Self {",
      "                val,",
      "                phantom: PhantomData,",
      "            }",
      "        }",
      "        /// Retruns the representative.",
      "        /// Corresponds to `atcoder::static_modint::val` in the original ACL.",
      "        #[inline]",
      "        pub fn val(self) -> u64 {",
      "            self.val",
      "        }",
      "        /// Returns `self` to the power of `n`.",
      "        /// Corresponds to `atcoder::static_modint::pow` in the original ACL.",
      "        #[inline]",
      "        pub fn pow(self, n: u64) -> Self {",
      "            <Self as ModIntBase>::pow(self, n)",
      "        }",
      "        /// Retruns the multiplicative inverse of `self`.",
      "        /// Corresponds to `atcoder::static_modint::inv` in the original ACL.",
      "        /// # Panics",
      "        /// Panics if the multiplicative inverse does not exist.",
      "        #[inline]",
      "        pub fn inv(self) -> Self {",
      "            if self.val() == 0 {",
      "                panic!(\"attempt to divide by zero\");",
      "            }",
      "            self.pow(M::VALUE - 2)",
      "        }",
      "    }",
      "    /// These methods are implemented for the struct.",
      "    /// You don't need to `use` `ModIntBase` to call methods of `StaticModInt`.",
      "    impl<M: Modulus> ModIntBase for StaticModInt<M> {",
      "        #[inline(always)]",
      "        fn modulus() -> u64 {",
      "            Self::modulus()",
      "        }",
      "        #[inline]",
      "        fn raw(val: u64) -> Self {",
      "            Self::raw(val)",
      "        }",
      "        #[inline]",
      "        fn val(self) -> u64 {",
      "            self.val()",
      "        }",
      "        #[inline]",
      "        fn inv(self) -> Self {",
      "            self.inv()",
      "        }",
      "    }",
      "    /// Represents a modulus.",
      "    /// # Example",
      "    /// ```",
      "    /// macro_rules! modulus {",
      "    ///     (\\$(\\$name:ident(\\$value:expr, \\$is_prime:expr)),*) => {",
      "    ///         \\$(",
      "    ///             #[derive(Copy, Clone, Eq, PartialEq)]",
      "    ///             enum \\$name {}",
      "    ///             impl ac_library::modint::Modulus for \\$name {",
      "    ///                 const VALUE: u32 = \\$value;",
      "    ///                 const HINT_VALUE_IS_PRIME: bool = \\$is_prime;",
      "    ///                 fn butterfly_cache() -> &'static ::std::thread::LocalKey<::std::cell::RefCell<::std::option::Option<ac_library::modint::ButterflyCache<Self>>>> {",
      "    ///                     thread_local! {",
      "    ///                         static BUTTERFLY_CACHE: ::std::cell::RefCell<::std::option::Option<ac_library::modint::ButterflyCache<\\$name>>> = ::std::default::Default::default();",
      "    ///                     }",
      "    ///                     &BUTTERFLY_CACHE",
      "    ///                 }",
      "    ///             }",
      "    ///         )*",
      "    ///     };",
      "    /// }",
      "    /// use ac_library::StaticModInt;",
      "    /// modulus!(Mod101(101, true), Mod103(103, true));",
      "    /// type Z101 = StaticModInt<Mod101>;",
      "    /// type Z103 = StaticModInt<Mod103>;",
      "    /// assert_eq!(Z101::new(101), Z101::new(0));",
      "    /// assert_eq!(Z103::new(103), Z103::new(0));",
      "    /// ```",
      "    pub trait Modulus: 'static + Copy + Eq {",
      "        const VALUE: u64;",
      "        const HINT_VALUE_IS_PRIME: bool;",
      "    }",
      "    /// Represents \\$2^{61}-1 = 2305843009213693951\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod2305843009213693951 {}",
      "    impl Modulus for Mod2305843009213693951 {",
      "        const VALUE: u64 = 2_305_843_009_213_693_951;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// Represents \\$10^{18}+3 = 1000000000000000003\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod1000000000000000003 {}",
      "    impl Modulus for Mod1000000000000000003 {",
      "        const VALUE: u64 = 1_000_000_000_000_000_003;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// Represents \\$1000000007\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod1000000007 {}",
      "    impl Modulus for Mod1000000007 {",
      "        const VALUE: u64 = 1_000_000_007;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// Represents \\$998244353\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod998244353 {}",
      "    impl Modulus for Mod998244353 {",
      "        const VALUE: u64 = 998_244_353;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// A trait for [`StaticModInt`] and [`DynamicModInt`].",
      "    /// Corresponds to `atcoder::internal::modint_base` in the original ACL.",
      "    /// [`StaticModInt`]: ../struct.StaticModInt.html",
      "    /// [`DynamicModInt`]: ../struct.DynamicModInt.html",
      "    pub trait ModIntBase:",
      "        Default",
      "        + FromStr",
      "        + From<i8>",
      "        + From<i16>",
      "        + From<i32>",
      "        + From<i64>",
      "        + From<i128>",
      "        + From<isize>",
      "        + From<u8>",
      "        + From<u16>",
      "        + From<u32>",
      "        + From<u64>",
      "        + From<u128>",
      "        + From<usize>",
      "        + Copy",
      "        + Eq",
      "        + Hash",
      "        + fmt::Display",
      "        + fmt::Debug",
      "        + Neg<Output = Self>",
      "        + Add<Output = Self>",
      "        + Sub<Output = Self>",
      "        + Mul<Output = Self>",
      "        + Div<Output = Self>",
      "        + AddAssign",
      "        + SubAssign",
      "        + MulAssign",
      "        + DivAssign",
      "    {",
      "        /// Returns the modulus.",
      "        /// Corresponds to `atcoder::static_modint::mod` and `atcoder::dynamic_modint::mod` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() {",
      "        ///     let _: u32 = Z::modulus();",
      "        /// }",
      "        /// ```",
      "        fn modulus() -> u64;",
      "        /// Constructs a `Self` from a `val < Self::modulus()` without checking it.",
      "        /// Corresponds to `atcoder::static_modint::raw` and `atcoder::dynamic_modint::raw` in the original ACL.",
      "        /// # Constraints",
      "        /// - `val` is less than `Self::modulus()`",
      "        /// **Note that all operations assume that inner values are smaller than the modulus.**",
      "        /// If `val` is greater than or equal to `Self::modulus()`, the behaviors are not defined.",
      "        /// ```should_panic",
      "        /// use ac_library::ModInt1000000007 as Mint;",
      "        /// let x = Mint::raw(1_000_000_007);",
      "        /// let y = x + x;",
      "        /// assert_eq!(0, y.val());",
      "        /// ```",
      "        /// ```text",
      "        /// thread 'main' panicked at 'assertion failed: `(left == right)`",
      "        ///   left: `0`,",
      "        ///  right: `1000000007`', src/modint.rs:8:1",
      "        /// note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace",
      "        /// ```",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() -> Z {",
      "        ///     debug_assert!(Z::modulus() >= 100);",
      "        ///     let mut acc = Z::new(0);",
      "        ///     for i in 0..100 {",
      "        ///         if i % 3 == 0 {",
      "        ///             // I know `i` is smaller than the modulus!",
      "        ///             acc += Z::raw(i);",
      "        ///         }",
      "        ///     }",
      "        ///     acc",
      "        /// }",
      "        /// ```",
      "        fn raw(val: u64) -> Self;",
      "        /// Retruns the representative.",
      "        /// Corresponds to `atcoder::static_modint::val` and `atcoder::dynamic_modint::val` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>(x: Z) {",
      "        ///     let _: u32 = x.val();",
      "        /// }",
      "        /// ```",
      "        fn val(self) -> u64;",
      "        /// Retruns the multiplicative inverse of `self`.",
      "        /// Corresponds to `atcoder::static_modint::inv` and `atcoder::dynamic_modint::inv` in the original ACL.",
      "        /// # Panics",
      "        /// Panics if the multiplicative inverse does not exist.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>(x: Z) {",
      "        ///     let _: Z = x.inv();",
      "        /// }",
      "        /// ```",
      "        fn inv(self) -> Self;",
      "        /// Creates a new `Self`.",
      "        /// Takes [any primitive integer].",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() {",
      "        ///     let _ = Z::new(1u32);",
      "        ///     let _ = Z::new(1usize);",
      "        ///     let _ = Z::new(-1i64);",
      "        /// }",
      "        /// ```",
      "        /// [any primitive integer]:  ../trait.RemEuclidU32.html",
      "        #[inline]",
      "        fn new<T: RemEuclidU64>(val: T) -> Self {",
      "            Self::raw(val.rem_euclid_u64(Self::modulus()))",
      "        }",
      "        /// Returns `self` to the power of `n`.",
      "        /// Corresponds to `atcoder::static_modint::pow` and `atcoder::dynamic_modint::pow` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() {",
      "        ///     let _: Z = Z::new(2).pow(3);",
      "        /// }",
      "        /// ```",
      "        #[inline]",
      "        fn pow(self, mut n: u64) -> Self {",
      "            let mut x = self;",
      "            let mut r = Self::raw(1);",
      "            while n > 0 {",
      "                if n & 1 == 1 {",
      "                    r *= x;",
      "                }",
      "                x *= x;",
      "                n >>= 1;",
      "            }",
      "            r",
      "        }",
      "    }",
      "    /// A trait for `{StaticModInt, DynamicModInt, ModIntBase}::new`.",
      "    pub trait RemEuclidU64 {",
      "        /// Calculates `self` \\$\\bmod\\$ `modulus` losslessly.",
      "        fn rem_euclid_u64(self, modulus: u64) -> u64;",
      "    }",
      "    macro_rules ! impl_rem_euclid_u64_for_small_signed {(\\$ (\\$ ty : tt ) ,* ) => {\\$ (impl RemEuclidU64 for \\$ ty {# [inline ] fn rem_euclid_u64 (self , modulus : u64 ) -> u64 {(self as i128 ) . rem_euclid (i128 :: from (modulus ) ) as _ } } ) * } }",
      "    impl_rem_euclid_u64_for_small_signed!(i8, i16, i32, i64, isize);",
      "    impl RemEuclidU64 for i128 {",
      "        #[inline]",
      "        fn rem_euclid_u64(self, modulus: u64) -> u64 {",
      "            self.rem_euclid(i128::from(modulus)) as _",
      "        }",
      "    }",
      "    macro_rules ! impl_rem_euclid_u64_for_small_unsigned {(\\$ (\\$ ty : tt ) ,* ) => {\\$ (impl RemEuclidU64 for \\$ ty {# [inline ] fn rem_euclid_u64 (self , modulus : u64 ) -> u64 {self as u64 % modulus } } ) * } }",
      "    macro_rules ! impl_rem_euclid_u64_for_large_unsigned {(\\$ (\\$ ty : tt ) ,* ) => {\\$ (impl RemEuclidU64 for \\$ ty {# [inline ] fn rem_euclid_u64 (self , modulus : u64 ) -> u64 {(self % (modulus as \\$ ty ) ) as _ } } ) * } }",
      "    impl_rem_euclid_u64_for_small_unsigned!(u8, u16, u32, u64, usize);",
      "    impl_rem_euclid_u64_for_large_unsigned!(u128);",
      "    trait InternalImplementations: ModIntBase {",
      "        #[inline]",
      "        fn default_impl() -> Self {",
      "            Self::raw(0)",
      "        }",
      "        #[inline]",
      "        fn from_str_impl(s: &str) -> Result<Self, Infallible> {",
      "            Ok(s.parse::<i64>()",
      "                .map(Self::new)",
      "                .unwrap_or_else(|_| todo!(\"parsing as an arbitrary precision integer?\")))",
      "        }",
      "        #[inline]",
      "        fn hash_impl(this: &Self, state: &mut impl Hasher) {",
      "            this.val().hash(state)",
      "        }",
      "        #[inline]",
      "        fn display_impl(this: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "            fmt::Display::fmt(&this.val(), f)",
      "        }",
      "        #[inline]",
      "        fn debug_impl(this: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "            fmt::Debug::fmt(&this.val(), f)",
      "        }",
      "        #[inline]",
      "        fn neg_impl(this: Self) -> Self {",
      "            Self::sub_impl(Self::raw(0), this)",
      "        }",
      "        #[inline]",
      "        fn add_impl(lhs: Self, rhs: Self) -> Self {",
      "            let modulus = Self::modulus();",
      "            let mut val = lhs.val() + rhs.val();",
      "            if val >= modulus {",
      "                val -= modulus;",
      "            }",
      "            Self::raw(val)",
      "        }",
      "        #[inline]",
      "        fn sub_impl(lhs: Self, rhs: Self) -> Self {",
      "            let modulus = Self::modulus();",
      "            let mut val = lhs.val().wrapping_sub(rhs.val());",
      "            if val >= modulus {",
      "                val = val.wrapping_add(modulus)",
      "            }",
      "            Self::raw(val)",
      "        }",
      "        fn mul_impl(lhs: Self, rhs: Self) -> Self;",
      "        #[inline]",
      "        fn div_impl(lhs: Self, rhs: Self) -> Self {",
      "            Self::mul_impl(lhs, rhs.inv())",
      "        }",
      "    }",
      "    impl<M: Modulus> InternalImplementations for StaticModInt<M> {",
      "        #[inline]",
      "        fn mul_impl(lhs: Self, rhs: Self) -> Self {",
      "            Self::raw((u128::from(lhs.val()) * u128::from(rhs.val()) % u128::from(M::VALUE)) as u64)",
      "        }",
      "    }",
      "    macro_rules ! impl_basic_traits {() => {} ; (impl <\\$ generic_param : ident : \\$ generic_param_bound : tt > _ for \\$ self : ty ; \\$ (\\$ rest : tt ) * ) => {impl <\\$ generic_param : \\$ generic_param_bound > Default for \\$ self {# [inline ] fn default () -> Self {Self :: default_impl () } } impl <\\$ generic_param : \\$ generic_param_bound > FromStr for \\$ self {type Err = Infallible ; # [inline ] fn from_str (s : & str ) -> Result < Self , Infallible > {Self :: from_str_impl (s ) } } impl <\\$ generic_param : \\$ generic_param_bound , V : RemEuclidU64 > From < V > for \\$ self {# [inline ] fn from (from : V ) -> Self {Self :: new (from ) } } # [allow (clippy :: derived_hash_with_manual_eq ) ] impl <\\$ generic_param : \\$ generic_param_bound > Hash for \\$ self {# [inline ] fn hash < H : Hasher > (& self , state : & mut H ) {Self :: hash_impl (self , state ) } } impl <\\$ generic_param : \\$ generic_param_bound > fmt :: Display for \\$ self {# [inline ] fn fmt (& self , f : & mut fmt :: Formatter <'_ > ) -> fmt :: Result {Self :: display_impl (self , f ) } } impl <\\$ generic_param : \\$ generic_param_bound > fmt :: Debug for \\$ self {# [inline ] fn fmt (& self , f : & mut fmt :: Formatter <'_ > ) -> fmt :: Result {Self :: debug_impl (self , f ) } } impl <\\$ generic_param : \\$ generic_param_bound > Neg for \\$ self {type Output = \\$ self ; # [inline ] fn neg (self ) -> \\$ self {Self :: neg_impl (self ) } } impl <\\$ generic_param : \\$ generic_param_bound > Neg for &'_ \\$ self {type Output = \\$ self ; # [inline ] fn neg (self ) -> \\$ self {<\\$ self >:: neg_impl (* self ) } } impl_basic_traits ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    impl_basic_traits! {impl < M : Modulus > _ for StaticModInt < M > ; }",
      "    macro_rules ! impl_bin_ops {() => {} ; (for <\\$ (\\$ generic_param : ident : \\$ generic_param_bound : tt ) ,*> <\\$ lhs_ty : ty > ~ <\\$ rhs_ty : ty > -> \\$ output : ty {{\\$ lhs_body : expr_2021 } ~ {\\$ rhs_body : expr_2021 } } \\$ (\\$ rest : tt ) * ) => {impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Add <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn add (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: add_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Sub <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn sub (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: sub_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Mul <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn mul (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: mul_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Div <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn div (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: div_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl_bin_ops ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    macro_rules ! impl_assign_ops {() => {} ; (for <\\$ (\\$ generic_param : ident : \\$ generic_param_bound : tt ) ,*> <\\$ lhs_ty : ty > ~= <\\$ rhs_ty : ty > {_ ~= {\\$ rhs_body : expr_2021 } } \\$ (\\$ rest : tt ) * ) => {impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> AddAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn add_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self + apply (\\$ rhs_body , rhs ) ; } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> SubAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn sub_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self - apply (\\$ rhs_body , rhs ) ; } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> MulAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn mul_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self * apply (\\$ rhs_body , rhs ) ; } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> DivAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn div_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self / apply (\\$ rhs_body , rhs ) ; } } impl_assign_ops ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    #[inline]",
      "    fn apply<F: FnOnce(X) -> O, X, O>(f: F, x: X) -> O {",
      "        f(x)",
      "    }",
      "    impl_bin_ops! {for < M : Modulus > < StaticModInt < M > > ~ < StaticModInt < M > > -> StaticModInt < M > {{| x | x } ~ {| x | x } } for < M : Modulus > < StaticModInt < M > > ~ <&'_ StaticModInt < M > > -> StaticModInt < M > {{| x | x } ~ {|& x | x } } for < M : Modulus > <&'_ StaticModInt < M > > ~ < StaticModInt < M > > -> StaticModInt < M > {{|& x | x } ~ {| x | x } } for < M : Modulus > <&'_ StaticModInt < M > > ~ <&'_ StaticModInt < M > > -> StaticModInt < M > {{|& x | x } ~ {|& x | x } } for < M : Modulus , T : RemEuclidU64 > < StaticModInt < M > > ~ < T > -> StaticModInt < M > {{| x | x } ~ {StaticModInt ::< M >:: new } } }",
      "    impl_assign_ops! {for < M : Modulus > < StaticModInt < M > > ~= < StaticModInt < M > > {_ ~= {| x | x } } for < M : Modulus > < StaticModInt < M > > ~= <&'_ StaticModInt < M > > {_ ~= {|& x | x } } for < M : Modulus , T : RemEuclidU64 > < StaticModInt < M > > ~= < T > {_ ~= {StaticModInt ::< M >:: new } } }",
      "    macro_rules ! impl_folding {() => {} ; (impl <\\$ generic_param : ident : \\$ generic_param_bound : tt > \\$ trait : ident < _ > for \\$ self : ty {fn \\$ method : ident (_ ) -> _ {_ (\\$ unit : expr_2021 , \\$ op : expr_2021 ) } } \\$ (\\$ rest : tt ) * ) => {impl <\\$ generic_param : \\$ generic_param_bound > \\$ trait < Self > for \\$ self {# [inline ] fn \\$ method < S > (iter : S ) -> Self where S : Iterator < Item = Self >, {iter . fold (\\$ unit , \\$ op ) } } impl <'a , \\$ generic_param : \\$ generic_param_bound > \\$ trait <&'a Self > for \\$ self {# [inline ] fn \\$ method < S > (iter : S ) -> Self where S : Iterator < Item = &'a Self >, {iter . fold (\\$ unit , \\$ op ) } } impl_folding ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    impl_folding! {impl < M : Modulus > Sum < _ > for StaticModInt < M > {fn sum (_ ) -> _ {_ (Self :: raw (0 ) , Add :: add ) } } impl < M : Modulus > Product < _ > for StaticModInt < M > {fn product (_ ) -> _ {_ (Self :: raw (1 ) , Mul :: mul ) } } }",
      "}",
      "#[allow(clippy::module_inception)]",
      "pub mod rolling_hash {",
      "    type Mint = super::ModInt2305843009213693951;",
      "    pub fn generate_random_base() -> i64 {",
      "        use rand::{rngs::SmallRng, Rng, SeedableRng};",
      "        let mut rng = SmallRng::from_os_rng();",
      "        rng.random_range(2..Mint::modulus() as i64)",
      "    }",
      "    /// 数列 `xs` 全体のハッシュ値を計算します。",
      "    pub fn single_rolling_hash(xs: &[i64], base: i64) -> u64 {",
      "        let base = Mint::new(base);",
      "        xs.iter()",
      "            .fold(Mint::new(0), |acc, &x| acc * base + Mint::new(x))",
      "            .val()",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    pub struct RollingHash {",
      "        hash_list: Vec<Mint>,",
      "        pow_list: Vec<Mint>,",
      "        length: usize,",
      "    }",
      "    impl RollingHash {",
      "        /// # Arguments",
      "        /// * `xs` - 値は1以上にする。0があると違う長さが同じハッシュ値になってしまう可能性が高まる。",
      "        ///   char を i64 にする場合は `ch as i64` のように変換するとよい。",
      "        /// * `base` - generate_random_base() で乱数生成した値を使う",
      "        /// # Examples",
      "        /// ```",
      "        /// use mylib::string::rolling_hash::rolling_hash::*;",
      "        /// use mylib::string::rolling_hash::rolling_hash::generate_random_base;",
      "        /// let chars = ['a', 'b', 'a', 'b', 'a'];",
      "        /// let xs = chars.iter().copied().map(|ch| ch as i64).collect::<Vec<_>>();",
      "        /// let base = generate_random_base();",
      "        /// let rh = RollingHash::new(&xs, base);",
      "        /// assert!(rh.hash(0, 3) == rh.hash(2, 5));",
      "        /// ```",
      "        pub fn new(xs: &[i64], base: i64) -> Self {",
      "            let base = Mint::new(base);",
      "            let mut hash_list = vec![Mint::new(0); xs.len() + 1];",
      "            let mut pow_list = vec![Mint::new(1); xs.len() + 1];",
      "            for i in 0..xs.len() {",
      "                hash_list[i + 1] = hash_list[i] * base + Mint::new(xs[i]);",
      "                pow_list[i + 1] = pow_list[i] * base;",
      "            }",
      "            let length = xs.len();",
      "            Self {",
      "                hash_list,",
      "                pow_list,",
      "                length,",
      "            }",
      "        }",
      "        pub fn hash(&self, begin: usize, end: usize) -> u64 {",
      "            let x = self.hash_list[end] - self.hash_list[begin] * self.pow_list[end - begin];",
      "            x.val()",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.length",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.length == 0",
      "        }",
      "    }",
      "}"
    ]
  },
  "rolling_hash_2d": {
    "scope": "rust",
    "prefix": "rolling_hash_2d",
    "body": [
      "use modint_u64::*;",
      "use rolling_hash_2d::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod modint_u64 {",
      "    use std::{",
      "        convert::Infallible,",
      "        fmt,",
      "        hash::{Hash, Hasher},",
      "        iter::{Product, Sum},",
      "        marker::PhantomData,",
      "        ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign},",
      "        str::FromStr,",
      "    };",
      "    /// 2^61 -1",
      "    pub type ModInt2305843009213693951 = StaticModInt<Mod2305843009213693951>;",
      "    /// 10^18 + 3",
      "    pub type ModInt1000000000000000003 = StaticModInt<Mod1000000000000000003>;",
      "    pub type ModInt1000000007 = StaticModInt<Mod1000000007>;",
      "    pub type ModInt998244353 = StaticModInt<Mod998244353>;",
      "    /// Represents \\$\\mathbb{Z}/m\\mathbb{Z}\\$ where \\$m\\$ is a constant value.",
      "    /// Corresponds to `atcoder::static_modint` in the original ACL.",
      "    /// # Example",
      "    /// ```",
      "    /// use ac_library::ModInt1000000007 as Mint;",
      "    /// use proconio::{input, source::once::OnceSource};",
      "    /// input! {",
      "    ///     from OnceSource::from(\"1000000006 2\\n\"),",
      "    ///     a: Mint,",
      "    ///     b: Mint,",
      "    /// }",
      "    /// println!(\"{}\", a + b); // `1`",
      "    /// ```",
      "    #[derive(Copy, Clone, Eq, PartialEq)]",
      "    #[repr(transparent)]",
      "    pub struct StaticModInt<M> {",
      "        val: u64,",
      "        phantom: PhantomData<fn() -> M>,",
      "    }",
      "    impl<M: Modulus> StaticModInt<M> {",
      "        /// Returns the modulus, which is [`<M as Modulus>::VALUE`].",
      "        /// Corresponds to `atcoder::static_modint::mod` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::ModInt1000000007 as Mint;",
      "        /// assert_eq!(1_000_000_007, Mint::modulus());",
      "        /// ```",
      "        /// [`<M as Modulus>::VALUE`]: ../trait.Modulus.html#associatedconstant.VALUE",
      "        #[inline(always)]",
      "        pub fn modulus() -> u64 {",
      "            M::VALUE",
      "        }",
      "        /// Creates a new `StaticModInt`.",
      "        /// Takes [any primitive integer].",
      "        /// Corresponds to the constructor of `atcoder::static_modint` in the original ACL.",
      "        /// [any primitive integer]:  ../trait.RemEuclidU32.html",
      "        #[inline]",
      "        pub fn new<T: RemEuclidU64>(val: T) -> Self {",
      "            Self::raw(val.rem_euclid_u64(M::VALUE))",
      "        }",
      "        /// Constructs a `StaticModInt` from a `val < Self::modulus()` without checking it.",
      "        /// Corresponds to `atcoder::static_modint::raw` in the original ACL.",
      "        /// # Constraints",
      "        /// - `val` is less than `Self::modulus()`",
      "        /// See [`ModIntBase::raw`] for more more details.",
      "        /// [`ModIntBase::raw`]: ./trait.ModIntBase.html#tymethod.raw",
      "        #[inline]",
      "        pub fn raw(val: u64) -> Self {",
      "            Self {",
      "                val,",
      "                phantom: PhantomData,",
      "            }",
      "        }",
      "        /// Retruns the representative.",
      "        /// Corresponds to `atcoder::static_modint::val` in the original ACL.",
      "        #[inline]",
      "        pub fn val(self) -> u64 {",
      "            self.val",
      "        }",
      "        /// Returns `self` to the power of `n`.",
      "        /// Corresponds to `atcoder::static_modint::pow` in the original ACL.",
      "        #[inline]",
      "        pub fn pow(self, n: u64) -> Self {",
      "            <Self as ModIntBase>::pow(self, n)",
      "        }",
      "        /// Retruns the multiplicative inverse of `self`.",
      "        /// Corresponds to `atcoder::static_modint::inv` in the original ACL.",
      "        /// # Panics",
      "        /// Panics if the multiplicative inverse does not exist.",
      "        #[inline]",
      "        pub fn inv(self) -> Self {",
      "            if self.val() == 0 {",
      "                panic!(\"attempt to divide by zero\");",
      "            }",
      "            self.pow(M::VALUE - 2)",
      "        }",
      "    }",
      "    /// These methods are implemented for the struct.",
      "    /// You don't need to `use` `ModIntBase` to call methods of `StaticModInt`.",
      "    impl<M: Modulus> ModIntBase for StaticModInt<M> {",
      "        #[inline(always)]",
      "        fn modulus() -> u64 {",
      "            Self::modulus()",
      "        }",
      "        #[inline]",
      "        fn raw(val: u64) -> Self {",
      "            Self::raw(val)",
      "        }",
      "        #[inline]",
      "        fn val(self) -> u64 {",
      "            self.val()",
      "        }",
      "        #[inline]",
      "        fn inv(self) -> Self {",
      "            self.inv()",
      "        }",
      "    }",
      "    /// Represents a modulus.",
      "    /// # Example",
      "    /// ```",
      "    /// macro_rules! modulus {",
      "    ///     (\\$(\\$name:ident(\\$value:expr, \\$is_prime:expr)),*) => {",
      "    ///         \\$(",
      "    ///             #[derive(Copy, Clone, Eq, PartialEq)]",
      "    ///             enum \\$name {}",
      "    ///             impl ac_library::modint::Modulus for \\$name {",
      "    ///                 const VALUE: u32 = \\$value;",
      "    ///                 const HINT_VALUE_IS_PRIME: bool = \\$is_prime;",
      "    ///                 fn butterfly_cache() -> &'static ::std::thread::LocalKey<::std::cell::RefCell<::std::option::Option<ac_library::modint::ButterflyCache<Self>>>> {",
      "    ///                     thread_local! {",
      "    ///                         static BUTTERFLY_CACHE: ::std::cell::RefCell<::std::option::Option<ac_library::modint::ButterflyCache<\\$name>>> = ::std::default::Default::default();",
      "    ///                     }",
      "    ///                     &BUTTERFLY_CACHE",
      "    ///                 }",
      "    ///             }",
      "    ///         )*",
      "    ///     };",
      "    /// }",
      "    /// use ac_library::StaticModInt;",
      "    /// modulus!(Mod101(101, true), Mod103(103, true));",
      "    /// type Z101 = StaticModInt<Mod101>;",
      "    /// type Z103 = StaticModInt<Mod103>;",
      "    /// assert_eq!(Z101::new(101), Z101::new(0));",
      "    /// assert_eq!(Z103::new(103), Z103::new(0));",
      "    /// ```",
      "    pub trait Modulus: 'static + Copy + Eq {",
      "        const VALUE: u64;",
      "        const HINT_VALUE_IS_PRIME: bool;",
      "    }",
      "    /// Represents \\$2^{61}-1 = 2305843009213693951\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod2305843009213693951 {}",
      "    impl Modulus for Mod2305843009213693951 {",
      "        const VALUE: u64 = 2_305_843_009_213_693_951;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// Represents \\$10^{18}+3 = 1000000000000000003\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod1000000000000000003 {}",
      "    impl Modulus for Mod1000000000000000003 {",
      "        const VALUE: u64 = 1_000_000_000_000_000_003;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// Represents \\$1000000007\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod1000000007 {}",
      "    impl Modulus for Mod1000000007 {",
      "        const VALUE: u64 = 1_000_000_007;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// Represents \\$998244353\\$.",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod998244353 {}",
      "    impl Modulus for Mod998244353 {",
      "        const VALUE: u64 = 998_244_353;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "    }",
      "    /// A trait for [`StaticModInt`] and [`DynamicModInt`].",
      "    /// Corresponds to `atcoder::internal::modint_base` in the original ACL.",
      "    /// [`StaticModInt`]: ../struct.StaticModInt.html",
      "    /// [`DynamicModInt`]: ../struct.DynamicModInt.html",
      "    pub trait ModIntBase:",
      "        Default",
      "        + FromStr",
      "        + From<i8>",
      "        + From<i16>",
      "        + From<i32>",
      "        + From<i64>",
      "        + From<i128>",
      "        + From<isize>",
      "        + From<u8>",
      "        + From<u16>",
      "        + From<u32>",
      "        + From<u64>",
      "        + From<u128>",
      "        + From<usize>",
      "        + Copy",
      "        + Eq",
      "        + Hash",
      "        + fmt::Display",
      "        + fmt::Debug",
      "        + Neg<Output = Self>",
      "        + Add<Output = Self>",
      "        + Sub<Output = Self>",
      "        + Mul<Output = Self>",
      "        + Div<Output = Self>",
      "        + AddAssign",
      "        + SubAssign",
      "        + MulAssign",
      "        + DivAssign",
      "    {",
      "        /// Returns the modulus.",
      "        /// Corresponds to `atcoder::static_modint::mod` and `atcoder::dynamic_modint::mod` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() {",
      "        ///     let _: u32 = Z::modulus();",
      "        /// }",
      "        /// ```",
      "        fn modulus() -> u64;",
      "        /// Constructs a `Self` from a `val < Self::modulus()` without checking it.",
      "        /// Corresponds to `atcoder::static_modint::raw` and `atcoder::dynamic_modint::raw` in the original ACL.",
      "        /// # Constraints",
      "        /// - `val` is less than `Self::modulus()`",
      "        /// **Note that all operations assume that inner values are smaller than the modulus.**",
      "        /// If `val` is greater than or equal to `Self::modulus()`, the behaviors are not defined.",
      "        /// ```should_panic",
      "        /// use ac_library::ModInt1000000007 as Mint;",
      "        /// let x = Mint::raw(1_000_000_007);",
      "        /// let y = x + x;",
      "        /// assert_eq!(0, y.val());",
      "        /// ```",
      "        /// ```text",
      "        /// thread 'main' panicked at 'assertion failed: `(left == right)`",
      "        ///   left: `0`,",
      "        ///  right: `1000000007`', src/modint.rs:8:1",
      "        /// note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace",
      "        /// ```",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() -> Z {",
      "        ///     debug_assert!(Z::modulus() >= 100);",
      "        ///     let mut acc = Z::new(0);",
      "        ///     for i in 0..100 {",
      "        ///         if i % 3 == 0 {",
      "        ///             // I know `i` is smaller than the modulus!",
      "        ///             acc += Z::raw(i);",
      "        ///         }",
      "        ///     }",
      "        ///     acc",
      "        /// }",
      "        /// ```",
      "        fn raw(val: u64) -> Self;",
      "        /// Retruns the representative.",
      "        /// Corresponds to `atcoder::static_modint::val` and `atcoder::dynamic_modint::val` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>(x: Z) {",
      "        ///     let _: u32 = x.val();",
      "        /// }",
      "        /// ```",
      "        fn val(self) -> u64;",
      "        /// Retruns the multiplicative inverse of `self`.",
      "        /// Corresponds to `atcoder::static_modint::inv` and `atcoder::dynamic_modint::inv` in the original ACL.",
      "        /// # Panics",
      "        /// Panics if the multiplicative inverse does not exist.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>(x: Z) {",
      "        ///     let _: Z = x.inv();",
      "        /// }",
      "        /// ```",
      "        fn inv(self) -> Self;",
      "        /// Creates a new `Self`.",
      "        /// Takes [any primitive integer].",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() {",
      "        ///     let _ = Z::new(1u32);",
      "        ///     let _ = Z::new(1usize);",
      "        ///     let _ = Z::new(-1i64);",
      "        /// }",
      "        /// ```",
      "        /// [any primitive integer]:  ../trait.RemEuclidU32.html",
      "        #[inline]",
      "        fn new<T: RemEuclidU64>(val: T) -> Self {",
      "            Self::raw(val.rem_euclid_u64(Self::modulus()))",
      "        }",
      "        /// Returns `self` to the power of `n`.",
      "        /// Corresponds to `atcoder::static_modint::pow` and `atcoder::dynamic_modint::pow` in the original ACL.",
      "        /// # Example",
      "        /// ```",
      "        /// use ac_library::modint::ModIntBase;",
      "        /// fn f<Z: ModIntBase>() {",
      "        ///     let _: Z = Z::new(2).pow(3);",
      "        /// }",
      "        /// ```",
      "        #[inline]",
      "        fn pow(self, mut n: u64) -> Self {",
      "            let mut x = self;",
      "            let mut r = Self::raw(1);",
      "            while n > 0 {",
      "                if n & 1 == 1 {",
      "                    r *= x;",
      "                }",
      "                x *= x;",
      "                n >>= 1;",
      "            }",
      "            r",
      "        }",
      "    }",
      "    /// A trait for `{StaticModInt, DynamicModInt, ModIntBase}::new`.",
      "    pub trait RemEuclidU64 {",
      "        /// Calculates `self` \\$\\bmod\\$ `modulus` losslessly.",
      "        fn rem_euclid_u64(self, modulus: u64) -> u64;",
      "    }",
      "    macro_rules ! impl_rem_euclid_u64_for_small_signed {(\\$ (\\$ ty : tt ) ,* ) => {\\$ (impl RemEuclidU64 for \\$ ty {# [inline ] fn rem_euclid_u64 (self , modulus : u64 ) -> u64 {(self as i128 ) . rem_euclid (i128 :: from (modulus ) ) as _ } } ) * } }",
      "    impl_rem_euclid_u64_for_small_signed!(i8, i16, i32, i64, isize);",
      "    impl RemEuclidU64 for i128 {",
      "        #[inline]",
      "        fn rem_euclid_u64(self, modulus: u64) -> u64 {",
      "            self.rem_euclid(i128::from(modulus)) as _",
      "        }",
      "    }",
      "    macro_rules ! impl_rem_euclid_u64_for_small_unsigned {(\\$ (\\$ ty : tt ) ,* ) => {\\$ (impl RemEuclidU64 for \\$ ty {# [inline ] fn rem_euclid_u64 (self , modulus : u64 ) -> u64 {self as u64 % modulus } } ) * } }",
      "    macro_rules ! impl_rem_euclid_u64_for_large_unsigned {(\\$ (\\$ ty : tt ) ,* ) => {\\$ (impl RemEuclidU64 for \\$ ty {# [inline ] fn rem_euclid_u64 (self , modulus : u64 ) -> u64 {(self % (modulus as \\$ ty ) ) as _ } } ) * } }",
      "    impl_rem_euclid_u64_for_small_unsigned!(u8, u16, u32, u64, usize);",
      "    impl_rem_euclid_u64_for_large_unsigned!(u128);",
      "    trait InternalImplementations: ModIntBase {",
      "        #[inline]",
      "        fn default_impl() -> Self {",
      "            Self::raw(0)",
      "        }",
      "        #[inline]",
      "        fn from_str_impl(s: &str) -> Result<Self, Infallible> {",
      "            Ok(s.parse::<i64>()",
      "                .map(Self::new)",
      "                .unwrap_or_else(|_| todo!(\"parsing as an arbitrary precision integer?\")))",
      "        }",
      "        #[inline]",
      "        fn hash_impl(this: &Self, state: &mut impl Hasher) {",
      "            this.val().hash(state)",
      "        }",
      "        #[inline]",
      "        fn display_impl(this: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "            fmt::Display::fmt(&this.val(), f)",
      "        }",
      "        #[inline]",
      "        fn debug_impl(this: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "            fmt::Debug::fmt(&this.val(), f)",
      "        }",
      "        #[inline]",
      "        fn neg_impl(this: Self) -> Self {",
      "            Self::sub_impl(Self::raw(0), this)",
      "        }",
      "        #[inline]",
      "        fn add_impl(lhs: Self, rhs: Self) -> Self {",
      "            let modulus = Self::modulus();",
      "            let mut val = lhs.val() + rhs.val();",
      "            if val >= modulus {",
      "                val -= modulus;",
      "            }",
      "            Self::raw(val)",
      "        }",
      "        #[inline]",
      "        fn sub_impl(lhs: Self, rhs: Self) -> Self {",
      "            let modulus = Self::modulus();",
      "            let mut val = lhs.val().wrapping_sub(rhs.val());",
      "            if val >= modulus {",
      "                val = val.wrapping_add(modulus)",
      "            }",
      "            Self::raw(val)",
      "        }",
      "        fn mul_impl(lhs: Self, rhs: Self) -> Self;",
      "        #[inline]",
      "        fn div_impl(lhs: Self, rhs: Self) -> Self {",
      "            Self::mul_impl(lhs, rhs.inv())",
      "        }",
      "    }",
      "    impl<M: Modulus> InternalImplementations for StaticModInt<M> {",
      "        #[inline]",
      "        fn mul_impl(lhs: Self, rhs: Self) -> Self {",
      "            Self::raw((u128::from(lhs.val()) * u128::from(rhs.val()) % u128::from(M::VALUE)) as u64)",
      "        }",
      "    }",
      "    macro_rules ! impl_basic_traits {() => {} ; (impl <\\$ generic_param : ident : \\$ generic_param_bound : tt > _ for \\$ self : ty ; \\$ (\\$ rest : tt ) * ) => {impl <\\$ generic_param : \\$ generic_param_bound > Default for \\$ self {# [inline ] fn default () -> Self {Self :: default_impl () } } impl <\\$ generic_param : \\$ generic_param_bound > FromStr for \\$ self {type Err = Infallible ; # [inline ] fn from_str (s : & str ) -> Result < Self , Infallible > {Self :: from_str_impl (s ) } } impl <\\$ generic_param : \\$ generic_param_bound , V : RemEuclidU64 > From < V > for \\$ self {# [inline ] fn from (from : V ) -> Self {Self :: new (from ) } } # [allow (clippy :: derived_hash_with_manual_eq ) ] impl <\\$ generic_param : \\$ generic_param_bound > Hash for \\$ self {# [inline ] fn hash < H : Hasher > (& self , state : & mut H ) {Self :: hash_impl (self , state ) } } impl <\\$ generic_param : \\$ generic_param_bound > fmt :: Display for \\$ self {# [inline ] fn fmt (& self , f : & mut fmt :: Formatter <'_ > ) -> fmt :: Result {Self :: display_impl (self , f ) } } impl <\\$ generic_param : \\$ generic_param_bound > fmt :: Debug for \\$ self {# [inline ] fn fmt (& self , f : & mut fmt :: Formatter <'_ > ) -> fmt :: Result {Self :: debug_impl (self , f ) } } impl <\\$ generic_param : \\$ generic_param_bound > Neg for \\$ self {type Output = \\$ self ; # [inline ] fn neg (self ) -> \\$ self {Self :: neg_impl (self ) } } impl <\\$ generic_param : \\$ generic_param_bound > Neg for &'_ \\$ self {type Output = \\$ self ; # [inline ] fn neg (self ) -> \\$ self {<\\$ self >:: neg_impl (* self ) } } impl_basic_traits ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    impl_basic_traits! {impl < M : Modulus > _ for StaticModInt < M > ; }",
      "    macro_rules ! impl_bin_ops {() => {} ; (for <\\$ (\\$ generic_param : ident : \\$ generic_param_bound : tt ) ,*> <\\$ lhs_ty : ty > ~ <\\$ rhs_ty : ty > -> \\$ output : ty {{\\$ lhs_body : expr_2021 } ~ {\\$ rhs_body : expr_2021 } } \\$ (\\$ rest : tt ) * ) => {impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Add <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn add (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: add_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Sub <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn sub (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: sub_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Mul <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn mul (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: mul_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> Div <\\$ rhs_ty > for \\$ lhs_ty {type Output = \\$ output ; # [inline ] fn div (self , rhs : \\$ rhs_ty ) -> \\$ output {<\\$ output >:: div_impl (apply (\\$ lhs_body , self ) , apply (\\$ rhs_body , rhs ) ) } } impl_bin_ops ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    macro_rules ! impl_assign_ops {() => {} ; (for <\\$ (\\$ generic_param : ident : \\$ generic_param_bound : tt ) ,*> <\\$ lhs_ty : ty > ~= <\\$ rhs_ty : ty > {_ ~= {\\$ rhs_body : expr_2021 } } \\$ (\\$ rest : tt ) * ) => {impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> AddAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn add_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self + apply (\\$ rhs_body , rhs ) ; } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> SubAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn sub_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self - apply (\\$ rhs_body , rhs ) ; } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> MulAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn mul_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self * apply (\\$ rhs_body , rhs ) ; } } impl <\\$ (\\$ generic_param : \\$ generic_param_bound ) ,*> DivAssign <\\$ rhs_ty > for \\$ lhs_ty {# [inline ] fn div_assign (& mut self , rhs : \\$ rhs_ty ) {* self = * self / apply (\\$ rhs_body , rhs ) ; } } impl_assign_ops ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    #[inline]",
      "    fn apply<F: FnOnce(X) -> O, X, O>(f: F, x: X) -> O {",
      "        f(x)",
      "    }",
      "    impl_bin_ops! {for < M : Modulus > < StaticModInt < M > > ~ < StaticModInt < M > > -> StaticModInt < M > {{| x | x } ~ {| x | x } } for < M : Modulus > < StaticModInt < M > > ~ <&'_ StaticModInt < M > > -> StaticModInt < M > {{| x | x } ~ {|& x | x } } for < M : Modulus > <&'_ StaticModInt < M > > ~ < StaticModInt < M > > -> StaticModInt < M > {{|& x | x } ~ {| x | x } } for < M : Modulus > <&'_ StaticModInt < M > > ~ <&'_ StaticModInt < M > > -> StaticModInt < M > {{|& x | x } ~ {|& x | x } } for < M : Modulus , T : RemEuclidU64 > < StaticModInt < M > > ~ < T > -> StaticModInt < M > {{| x | x } ~ {StaticModInt ::< M >:: new } } }",
      "    impl_assign_ops! {for < M : Modulus > < StaticModInt < M > > ~= < StaticModInt < M > > {_ ~= {| x | x } } for < M : Modulus > < StaticModInt < M > > ~= <&'_ StaticModInt < M > > {_ ~= {|& x | x } } for < M : Modulus , T : RemEuclidU64 > < StaticModInt < M > > ~= < T > {_ ~= {StaticModInt ::< M >:: new } } }",
      "    macro_rules ! impl_folding {() => {} ; (impl <\\$ generic_param : ident : \\$ generic_param_bound : tt > \\$ trait : ident < _ > for \\$ self : ty {fn \\$ method : ident (_ ) -> _ {_ (\\$ unit : expr_2021 , \\$ op : expr_2021 ) } } \\$ (\\$ rest : tt ) * ) => {impl <\\$ generic_param : \\$ generic_param_bound > \\$ trait < Self > for \\$ self {# [inline ] fn \\$ method < S > (iter : S ) -> Self where S : Iterator < Item = Self >, {iter . fold (\\$ unit , \\$ op ) } } impl <'a , \\$ generic_param : \\$ generic_param_bound > \\$ trait <&'a Self > for \\$ self {# [inline ] fn \\$ method < S > (iter : S ) -> Self where S : Iterator < Item = &'a Self >, {iter . fold (\\$ unit , \\$ op ) } } impl_folding ! (\\$ (\\$ rest ) * ) ; } ; }",
      "    impl_folding! {impl < M : Modulus > Sum < _ > for StaticModInt < M > {fn sum (_ ) -> _ {_ (Self :: raw (0 ) , Add :: add ) } } impl < M : Modulus > Product < _ > for StaticModInt < M > {fn product (_ ) -> _ {_ (Self :: raw (1 ) , Mul :: mul ) } } }",
      "}",
      "/// 2次元ローリングハッシュ。",
      "/// 2次元グリッド \\$X\\$ の各要素 \\$X_{i,j}\\$ に対し、2つの基数 \\$B_0, B_1\\$ を用いてハッシュ値を以下のように定義します：",
      "/// \\$H(X) = \\sum_{i=0}^{H-1} \\sum_{j=0}^{W-1} X_{i,j} B_0^{H-1-i} B_1^{W-1-j} \\pmod M\\$",
      "/// 構築に \\$O(HW)\\$、任意の矩形領域のハッシュ値取得を \\$O(1)\\$ で行います。",
      "pub mod rolling_hash_2d {",
      "    type Mint = super::ModInt2305843009213693951;",
      "    pub fn generate_random_base() -> i64 {",
      "        use rand::{rngs::SmallRng, Rng, SeedableRng};",
      "        let mut rng = SmallRng::from_os_rng();",
      "        rng.random_range(2..Mint::modulus() as i64)",
      "    }",
      "    /// 2次元数列 `xss` 全体のハッシュ値を計算します。",
      "    pub fn single_rolling_hash(xss: &[Vec<i64>], base0: i64, base1: i64) -> u64 {",
      "        let b0 = Mint::new(base0);",
      "        let b1 = Mint::new(base1);",
      "        xss.iter()",
      "            .fold(Mint::new(0), |acc_y, row| {",
      "                let row_hash = row",
      "                    .iter()",
      "                    .fold(Mint::new(0), |acc_x, &x| acc_x * b1 + Mint::new(x));",
      "                acc_y * b0 + row_hash",
      "            })",
      "            .val()",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    pub struct RollingHash2D {",
      "        hash_list: Vec<Vec<Mint>>,",
      "        pow0_list: Vec<Mint>,",
      "        pow1_list: Vec<Mint>,",
      "        height: usize,",
      "        width: usize,",
      "    }",
      "    impl RollingHash2D {",
      "        /// # Arguments",
      "        /// * `base0` - generate_random_base() で乱数生成した値を使う",
      "        /// * `base1` - generate_random_base() で乱数生成した値を使う",
      "        pub fn new(xss: &[Vec<i64>], base0: i64, base1: i64) -> Self {",
      "            let base0 = Mint::new(base0);",
      "            let base1 = Mint::new(base1);",
      "            let height = xss.len();",
      "            let width = xss[0].len();",
      "            let mut hash_list = vec![vec![Mint::new(0); width + 1]; height + 1];",
      "            let mut pow0_list = vec![Mint::new(1); height + 1];",
      "            let mut pow1_list = vec![Mint::new(1); width + 1];",
      "            for i in 0..height {",
      "                pow0_list[i + 1] = pow0_list[i] * base0;",
      "            }",
      "            for i in 0..width {",
      "                pow1_list[i + 1] = pow1_list[i] * base1;",
      "            }",
      "            for y in 0..height {",
      "                for x in 0..width {",
      "                    hash_list[y + 1][x + 1] = hash_list[y][x + 1] * base0",
      "                        + hash_list[y + 1][x] * base1",
      "                        - hash_list[y][x] * base0 * base1",
      "                        + xss[y][x]",
      "                }",
      "            }",
      "            Self {",
      "                hash_list,",
      "                pow0_list,",
      "                pow1_list,",
      "                height,",
      "                width,",
      "            }",
      "        }",
      "        pub fn hash(",
      "            &self,",
      "            row_begin: usize,",
      "            row_end: usize,",
      "            col_begin: usize,",
      "            col_end: usize,",
      "        ) -> u64 {",
      "            let x = self.hash_list[row_end][col_end]",
      "                - self.hash_list[row_begin][col_end] * self.pow0_list[row_end - row_begin]",
      "                - self.hash_list[row_end][col_begin] * self.pow1_list[col_end - col_begin]",
      "                + self.hash_list[row_begin][col_begin]",
      "                    * self.pow0_list[row_end - row_begin]",
      "                    * self.pow1_list[col_end - col_begin];",
      "            x.val()",
      "        }",
      "        pub fn width(&self) -> usize {",
      "            self.width",
      "        }",
      "        pub fn height(&self) -> usize {",
      "            self.height",
      "        }",
      "    }",
      "}"
    ]
  },
  "root_tracking_union_find": {
    "scope": "rust",
    "prefix": "root_tracking_union_find",
    "body": [
      "use simple_union_find::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod root_tracking_union_find {",
      "    use itertools::Itertools;",
      "    use std::collections::BTreeSet;",
      "    #[derive(Clone, Debug)]",
      "    struct RootInfo {",
      "        count: usize,",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    struct NonRootInfo {",
      "        parent: usize,",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    enum Node {",
      "        Root(RootInfo),",
      "        NonRoot(NonRootInfo),",
      "    }",
      "    impl Node {",
      "        fn root(count: usize) -> Node {",
      "            Node::Root(RootInfo { count })",
      "        }",
      "        fn non_root(parent: usize) -> Node {",
      "            Node::NonRoot(NonRootInfo { parent })",
      "        }",
      "        fn as_root(&self) -> &RootInfo {",
      "            match self {",
      "                Node::Root(info) => info,",
      "                Node::NonRoot(_) => panic!(),",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    pub struct UnionFind {",
      "        nodes: Vec<Node>,",
      "        cnt_groups: usize,",
      "        root_set: BTreeSet<usize>,",
      "    }",
      "    impl UnionFind {",
      "        pub fn new(n: usize) -> UnionFind {",
      "            let nodes = (0..n).map(|_| Node::root(1)).collect_vec();",
      "            let root_set = (0..n).collect::<BTreeSet<_>>();",
      "            UnionFind {",
      "                nodes,",
      "                cnt_groups: n,",
      "                root_set,",
      "            }",
      "        }",
      "        pub fn root(&mut self, index: usize) -> usize {",
      "            match &self.nodes[index] {",
      "                Node::Root(_) => index,",
      "                Node::NonRoot(info) => {",
      "                    let root = self.root(info.parent);",
      "                    self.nodes[index] = Node::non_root(root);",
      "                    root",
      "                }",
      "            }",
      "        }",
      "        pub fn same_count(&mut self, index: usize) -> usize {",
      "            let root_index = self.root(index);",
      "            self.nodes[root_index].as_root().count",
      "        }",
      "        pub fn same(&mut self, x: usize, y: usize) -> bool {",
      "            self.root(x) == self.root(y)",
      "        }",
      "        pub fn num_groups(&self) -> usize {",
      "            self.cnt_groups",
      "        }",
      "        pub fn unite(&mut self, x: usize, y: usize) -> bool {",
      "            if self.same(x, y) {",
      "                return false;",
      "            }",
      "            self.cnt_groups -= 1;",
      "            let (smaller_root, larger_root) = {",
      "                let x_root = self.root(x);",
      "                let y_root = self.root(y);",
      "                let x_count = self.nodes[x_root].as_root().count;",
      "                let y_count = self.nodes[y_root].as_root().count;",
      "                if x_count < y_count {",
      "                    (x_root, y_root)",
      "                } else {",
      "                    (y_root, x_root)",
      "                }",
      "            };",
      "            let count_sum =",
      "                self.nodes[smaller_root].as_root().count + self.nodes[larger_root].as_root().count;",
      "            self.nodes[smaller_root] = Node::non_root(larger_root);",
      "            self.root_set.remove(&smaller_root);",
      "            self.nodes[larger_root] = Node::root(count_sum);",
      "            true",
      "        }",
      "        pub fn root_set(&self) -> &BTreeSet<usize> {",
      "            &self.root_set",
      "        }",
      "        pub fn groups(&mut self) -> Vec<Vec<usize>> {",
      "            let n = self.nodes.len();",
      "            let roots = (0..n).map(|i| self.root(i)).collect_vec();",
      "            let group_size = (0..n).map(|i| roots[i]).fold(vec![0; n], |mut acc, x| {",
      "                acc[x] += 1;",
      "                acc",
      "            });",
      "            let result = {",
      "                let mut result = vec![Vec::new(); n];",
      "                for i in 0..n {",
      "                    result[i].reserve(group_size[i]);",
      "                }",
      "                for i in 0..n {",
      "                    result[roots[i]].push(i);",
      "                }",
      "                result",
      "            };",
      "            result.into_iter().filter(|x| !x.is_empty()).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "scan_iter": {
    "scope": "rust",
    "prefix": "scan_iter",
    "body": [
      "use scan_iter::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod scan_iter {",
      "    #[derive(Clone)]",
      "    pub struct Scanl<I, B, F> {",
      "        iter: I,",
      "        state: Option<B>,",
      "        f: F,",
      "    }",
      "    impl<I, B, F> Scanl<I, B, F> {",
      "        fn new(iter: I, init: B, f: F) -> Scanl<I, B, F> {",
      "            Scanl {",
      "                iter,",
      "                state: Some(init),",
      "                f,",
      "            }",
      "        }",
      "    }",
      "    impl<I, B, F> Iterator for Scanl<I, B, F>",
      "    where",
      "        B: Copy,",
      "        I: Iterator,",
      "        F: FnMut(&mut B, I::Item) -> B,",
      "    {",
      "        type Item = B;",
      "        #[inline]",
      "        fn next(&mut self) -> Option<B> {",
      "            let retval = self.state?;",
      "            let a_opt = self.iter.next();",
      "            self.state = self",
      "                .state",
      "                .and_then(|mut s| a_opt.map(|a| (self.f)(&mut s, a)));",
      "            Some(retval)",
      "        }",
      "    }",
      "    pub trait IteratorExtScanLeft: Iterator + Sized {",
      "        fn scanl<B, F>(self, init: B, f: F) -> Scanl<Self, B, F>",
      "        where",
      "            Self: Sized,",
      "            F: FnMut(&mut B, Self::Item) -> B,",
      "        {",
      "            Scanl::new(self, init, f)",
      "        }",
      "    }",
      "    impl<T: Iterator> IteratorExtScanLeft for T {}",
      "}"
    ]
  },
  "segtree_2d": {
    "scope": "rust",
    "prefix": "segtree_2d",
    "body": [
      "use segtree_2d::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod segtree_2d {",
      "    use ac_library::Monoid;",
      "    use std::ops::{Bound, Range, RangeBounds};",
      "    #[derive(Clone)]",
      "    pub struct Segtree2D<M: Monoid> {",
      "        h_orig: usize,",
      "        w_orig: usize,",
      "        h_size: usize,",
      "        w_size: usize,",
      "        nodes: Vec<Vec<M::S>>,",
      "    }",
      "    impl<M: Monoid> Segtree2D<M>",
      "    where",
      "        M::S: Clone,",
      "    {",
      "        /// `h` x `w` サイズの新しい2次元セグメントツリーを作成します。",
      "        /// # 計算量",
      "        /// O(H_size * W_size)",
      "        pub fn new(h: usize, w: usize) -> Self {",
      "            let h_size = h.next_power_of_two();",
      "            let w_size = w.next_power_of_two();",
      "            let nodes = vec![vec![M::identity(); 2 * w_size]; 2 * h_size];",
      "            Self {",
      "                h_orig: h,",
      "                w_orig: w,",
      "                h_size,",
      "                w_size,",
      "                nodes,",
      "            }",
      "        }",
      "        /// 点 `(y, x)` の値を `val` に更新します。",
      "        /// # Panics",
      "        /// `y` または `x` が範囲外の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn set(&mut self, y: usize, x: usize, val: M::S) {",
      "            assert!(",
      "                y < self.h_orig,",
      "                \"y is out of bounds: {} >= {}\",",
      "                y,",
      "                self.h_orig",
      "            );",
      "            assert!(",
      "                x < self.w_orig,",
      "                \"x is out of bounds: {} >= {}\",",
      "                x,",
      "                self.w_orig",
      "            );",
      "            let y_idx = y + self.h_size;",
      "            let x_idx_in_row = x + self.w_size;",
      "            self.nodes[y_idx][x_idx_in_row] = val.clone();",
      "            for x_p in",
      "                std::iter::successors(Some(x_idx_in_row), |&i| (i > 1).then_some(i >> 1)).skip(1)",
      "            {",
      "                self.nodes[y_idx][x_p] = M::binary_operation(",
      "                    &self.nodes[y_idx][x_p * 2],",
      "                    &self.nodes[y_idx][x_p * 2 + 1],",
      "                );",
      "            }",
      "            for y_p in std::iter::successors(Some(y_idx), |&i| (i > 1).then_some(i >> 1)).skip(1) {",
      "                let y_child_left = y_p * 2;",
      "                let y_child_right = y_p * 2 + 1;",
      "                for x_idx in",
      "                    std::iter::successors(Some(x_idx_in_row), |&i| (i > 1).then_some(i >> 1))",
      "                {",
      "                    self.nodes[y_p][x_idx] = M::binary_operation(",
      "                        &self.nodes[y_child_left][x_idx],",
      "                        &self.nodes[y_child_right][x_idx],",
      "                    );",
      "                }",
      "            }",
      "        }",
      "        /// 矩形範囲 `[y1, y2) × [x1, x2)` の要素の結合結果をクエリします。",
      "        /// `y_range` はy座標の範囲、`x_range` はx座標の範囲です。",
      "        /// # Panics",
      "        /// 範囲が不正な場合にパニックします。",
      "        /// # 計算量",
      "        /// O(log H * log W)",
      "        pub fn prod(",
      "            &self,",
      "            y_range: impl RangeBounds<usize>,",
      "            x_range: impl RangeBounds<usize>,",
      "        ) -> M::S {",
      "            let y_range = open_range_bounds(y_range, self.h_orig);",
      "            let x_range = open_range_bounds(x_range, self.w_orig);",
      "            let y1 = y_range.start;",
      "            let x1 = x_range.start;",
      "            let y2 = y_range.end;",
      "            let x2 = x_range.end;",
      "            assert!(",
      "                y1 <= y2 && y2 <= self.h_orig,",
      "                \"y range invalid: y1={}, y2={}, h_orig={}\",",
      "                y1,",
      "                y2,",
      "                self.h_orig",
      "            );",
      "            assert!(",
      "                x1 <= x2 && x2 <= self.w_orig,",
      "                \"x range invalid: x1={}, x2={}, w_orig={}\",",
      "                x1,",
      "                x2,",
      "                self.w_orig",
      "            );",
      "            let mut sml = M::identity();",
      "            let mut smr = M::identity();",
      "            let mut y_cur_l = y1 + self.h_size;",
      "            let mut y_cur_r = y2 + self.h_size;",
      "            let x_l = x1 + self.w_size;",
      "            let x_r = x2 + self.w_size;",
      "            while y_cur_l < y_cur_r {",
      "                if y_cur_l & 1 == 1 {",
      "                    sml = M::binary_operation(&sml, &self.query_x_tree(y_cur_l, x_l, x_r));",
      "                    y_cur_l += 1;",
      "                }",
      "                if y_cur_r & 1 == 1 {",
      "                    y_cur_r -= 1;",
      "                    smr = M::binary_operation(&self.query_x_tree(y_cur_r, x_l, x_r), &smr);",
      "                }",
      "                y_cur_l >>= 1;",
      "                y_cur_r >>= 1;",
      "            }",
      "            M::binary_operation(&sml, &smr)",
      "        }",
      "        fn query_x_tree(&self, y_node_idx: usize, mut x_cur_l: usize, mut x_cur_r: usize) -> M::S {",
      "            let mut sml = M::identity();",
      "            let mut smr = M::identity();",
      "            while x_cur_l < x_cur_r {",
      "                if x_cur_l & 1 == 1 {",
      "                    sml = M::binary_operation(&sml, &self.nodes[y_node_idx][x_cur_l]);",
      "                    x_cur_l += 1;",
      "                }",
      "                if x_cur_r & 1 == 1 {",
      "                    x_cur_r -= 1;",
      "                    smr = M::binary_operation(&self.nodes[y_node_idx][x_cur_r], &smr);",
      "                }",
      "                x_cur_l >>= 1;",
      "                x_cur_r >>= 1;",
      "            }",
      "            M::binary_operation(&sml, &smr)",
      "        }",
      "        /// グリッド全体の要素の結合結果をクエリします。",
      "        /// 矩形範囲 `[0, h_orig) × [0, w_orig)` と同じです。",
      "        /// # 計算量",
      "        /// O(1)",
      "        pub fn all_prod(&self) -> M::S {",
      "            self.nodes[1][1].clone()",
      "        }",
      "        /// 点 `(y, x)` の値を取得します。",
      "        /// これは `self.nodes` のリーフノードに直接アクセスするため、O(1)です。",
      "        /// # Panics",
      "        /// `y` または `x` が範囲外の場合にパニックします。",
      "        /// # 計算量",
      "        /// O(1)",
      "        pub fn get(&self, y: usize, x: usize) -> M::S {",
      "            assert!(",
      "                y < self.h_orig,",
      "                \"y is out of bounds: {} >= {}\",",
      "                y,",
      "                self.h_orig",
      "            );",
      "            assert!(",
      "                x < self.w_orig,",
      "                \"x is out of bounds: {} >= {}\",",
      "                x,",
      "                self.w_orig",
      "            );",
      "            self.nodes[y + self.h_size][x + self.w_size].clone()",
      "        }",
      "        /// グリッド全体を `Vec<Vec<M::S>>` として返します。",
      "        /// # 計算量",
      "        /// O(H_orig * W_orig)",
      "        pub fn to_vec(&self) -> Vec<Vec<M::S>> {",
      "            let mut result = vec![vec![M::identity(); self.w_orig]; self.h_orig];",
      "            for y in 0..self.h_orig {",
      "                for x in 0..self.w_orig {",
      "                    result[y][x] = self.get(y, x);",
      "                }",
      "            }",
      "            result",
      "        }",
      "    }",
      "    fn open_range_bounds(range: impl RangeBounds<usize>, len: usize) -> Range<usize> {",
      "        let l = match range.start_bound() {",
      "            Bound::Unbounded => 0,",
      "            Bound::Included(&x) => x,",
      "            Bound::Excluded(&x) => x + 1,",
      "        };",
      "        let r = match range.end_bound() {",
      "            Bound::Unbounded => len,",
      "            Bound::Included(&x) => x + 1,",
      "            Bound::Excluded(&x) => x,",
      "        };",
      "        l..r",
      "    }",
      "}"
    ]
  },
  "segtree_to_vec": {
    "scope": "rust",
    "prefix": "segtree_to_vec",
    "body": [
      "pub fn segtree_to_vec<M: ac_library::Monoid>(",
      "    seg: &ac_library::Segtree<M>,",
      "    len: usize,",
      ") -> Vec<M::S> {",
      "    (0..len).map(|i| seg.get(i)).collect()",
      "}"
    ]
  },
  "shakutori": {
    "scope": "rust",
    "prefix": "shakutori",
    "body": [
      "use shakutori::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod shakutori {",
      "    /// 各開始位置 `left` に対し、区間 `[left, right)` が条件を満たすような最大の `right` を求める。",
      "    /// # 引数",
      "    /// * `xs` - 対象の配列",
      "    /// * `init` - 空の区間に対応する初期状態",
      "    /// * `add` - 状態に要素を追加する関数。追加可能なら追加して `true`、不可なら状態を変更せずに `false` を返す。",
      "    /// * `remove` - 状態から要素を削除する関数。",
      "    /// # 戻り値",
      "    /// `Vec<usize>`: 長さ `n + 1` の Vec。",
      "    /// 各 `left` (0 <= left <= n) に対し、`result[left]` には区間 `[left, right)` が条件を満たす最大の `right` が格納される。",
      "    pub fn shakutori_max_right<T, S, Add, Rem>(",
      "        xs: &[T],",
      "        init: S,",
      "        mut add: Add,",
      "        mut remove: Rem,",
      "    ) -> Vec<usize>",
      "    where",
      "        Add: FnMut(&mut S, &T) -> bool,",
      "        Rem: FnMut(&mut S, &T),",
      "    {",
      "        let n = xs.len();",
      "        let mut state = init;",
      "        let mut left = 0;",
      "        let mut right = 0;",
      "        let mut result = vec![0; n + 1];",
      "        while left < n {",
      "            if right < n && add(&mut state, &xs[right]) {",
      "                right += 1;",
      "            } else if left < right {",
      "                result[left] = right;",
      "                remove(&mut state, &xs[left]);",
      "                left += 1;",
      "            } else {",
      "                result[left] = right;",
      "                right += 1;",
      "                left += 1;",
      "            }",
      "        }",
      "        result[n] = n;",
      "        result",
      "    }",
      "    /// 各終了位置 `right` に対し、区間 `[left, right)` が条件を満たすような最小の `left` を求める。",
      "    /// # 引数",
      "    /// * `xs` - 対象の配列",
      "    /// * `init` - 空の区間に対応する初期状態",
      "    /// * `add` - 状態に要素を追加する関数。追加可能なら追加して `true`、不可なら状態を変更せずに `false` を返す。",
      "    /// * `remove` - 状態から要素を削除する関数。",
      "    /// # 戻り値",
      "    /// `Vec<usize>`: 長さ `n + 1` の Vec。",
      "    /// 各 `right` (0 <= right <= n) に対し、`result[right]` には区間 `[left, right)` が条件を満たす最小の `left` が格納される。",
      "    pub fn shakutori_min_left<T, S, Add, Rem>(",
      "        xs: &[T],",
      "        init: S,",
      "        mut add: Add,",
      "        mut remove: Rem,",
      "    ) -> Vec<usize>",
      "    where",
      "        Add: FnMut(&mut S, &T) -> bool,",
      "        Rem: FnMut(&mut S, &T),",
      "    {",
      "        let n = xs.len();",
      "        let mut state = init;",
      "        let mut left = 0;",
      "        let mut right = 0;",
      "        let mut result = vec![0; n + 1];",
      "        while right < n {",
      "            if add(&mut state, &xs[right]) {",
      "                right += 1;",
      "                result[right] = left;",
      "            } else if left < right {",
      "                remove(&mut state, &xs[left]);",
      "                left += 1;",
      "            } else {",
      "                right += 1;",
      "                left += 1;",
      "                result[right] = left;",
      "            }",
      "        }",
      "        result",
      "    }",
      "}"
    ]
  },
  "simple_union_find": {
    "scope": "rust",
    "prefix": "simple_union_find",
    "body": [
      "use simple_union_find::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod simple_union_find {",
      "    use itertools::Itertools;",
      "    #[derive(Clone, Debug)]",
      "    struct RootInfo {",
      "        count: usize,",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    struct NonRootInfo {",
      "        parent: usize,",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    enum Node {",
      "        Root(RootInfo),",
      "        NonRoot(NonRootInfo),",
      "    }",
      "    impl Node {",
      "        fn root(count: usize) -> Node {",
      "            Node::Root(RootInfo { count })",
      "        }",
      "        fn non_root(parent: usize) -> Node {",
      "            Node::NonRoot(NonRootInfo { parent })",
      "        }",
      "        fn as_root(&self) -> &RootInfo {",
      "            match self {",
      "                Node::Root(info) => info,",
      "                Node::NonRoot(_) => panic!(),",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Debug)]",
      "    pub struct UnionFind {",
      "        nodes: Vec<Node>,",
      "        cnt_groups: usize,",
      "    }",
      "    impl UnionFind {",
      "        pub fn new(n: usize) -> UnionFind {",
      "            let nodes = (0..n).map(|_| Node::root(1)).collect_vec();",
      "            UnionFind {",
      "                nodes,",
      "                cnt_groups: n,",
      "            }",
      "        }",
      "        pub fn root(&mut self, index: usize) -> usize {",
      "            match &self.nodes[index] {",
      "                Node::Root(_) => index,",
      "                Node::NonRoot(info) => {",
      "                    let root = self.root(info.parent);",
      "                    self.nodes[index] = Node::non_root(root);",
      "                    root",
      "                }",
      "            }",
      "        }",
      "        pub fn same_count(&mut self, index: usize) -> usize {",
      "            let root_index = self.root(index);",
      "            self.nodes[root_index].as_root().count",
      "        }",
      "        pub fn same(&mut self, x: usize, y: usize) -> bool {",
      "            self.root(x) == self.root(y)",
      "        }",
      "        pub fn num_groups(&self) -> usize {",
      "            self.cnt_groups",
      "        }",
      "        pub fn unite(&mut self, x: usize, y: usize) -> bool {",
      "            if self.same(x, y) {",
      "                return false;",
      "            }",
      "            self.cnt_groups -= 1;",
      "            let (smaller_root, larger_root) = {",
      "                let x_root = self.root(x);",
      "                let y_root = self.root(y);",
      "                let x_count = self.nodes[x_root].as_root().count;",
      "                let y_count = self.nodes[y_root].as_root().count;",
      "                if x_count < y_count {",
      "                    (x_root, y_root)",
      "                } else {",
      "                    (y_root, x_root)",
      "                }",
      "            };",
      "            let count_sum =",
      "                self.nodes[smaller_root].as_root().count + self.nodes[larger_root].as_root().count;",
      "            self.nodes[smaller_root] = Node::non_root(larger_root);",
      "            self.nodes[larger_root] = Node::root(count_sum);",
      "            true",
      "        }",
      "        pub fn groups(&mut self) -> Vec<Vec<usize>> {",
      "            let n = self.nodes.len();",
      "            let roots = (0..n).map(|i| self.root(i)).collect_vec();",
      "            let group_size = (0..n).map(|i| roots[i]).fold(vec![0; n], |mut acc, x| {",
      "                acc[x] += 1;",
      "                acc",
      "            });",
      "            let result = {",
      "                let mut result = vec![Vec::new(); n];",
      "                for i in 0..n {",
      "                    result[i].reserve(group_size[i]);",
      "                }",
      "                for i in 0..n {",
      "                    result[roots[i]].push(i);",
      "                }",
      "                result",
      "            };",
      "            result.into_iter().filter(|x| !x.is_empty()).collect_vec()",
      "        }",
      "    }",
      "}"
    ]
  },
  "static_mod_int": {
    "scope": "rust",
    "prefix": "static_mod_int",
    "body": [
      "use static_mod_int::*;",
      "pub mod static_mod_int {",
      "    use ac_library::{ButterflyCache, Modulus, StaticModInt};",
      "    use std::{cell::RefCell, thread::LocalKey};",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod2 {}",
      "    impl Modulus for Mod2 {",
      "        const VALUE: u32 = 2;",
      "        const HINT_VALUE_IS_PRIME: bool = true;",
      "        fn butterfly_cache() -> &'static LocalKey<RefCell<Option<ButterflyCache<Self>>>> {",
      "            thread_local! {static BUTTERFLY_CACHE : RefCell < Option < ButterflyCache < Mod2 >>> = RefCell :: default () ; }",
      "            &BUTTERFLY_CACHE",
      "        }",
      "    }",
      "    pub type ModInt2 = StaticModInt<Mod2>;",
      "    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]",
      "    pub enum Mod1e9 {}",
      "    impl Modulus for Mod1e9 {",
      "        const VALUE: u32 = 1_000_000_000;",
      "        const HINT_VALUE_IS_PRIME: bool = false;",
      "        fn butterfly_cache() -> &'static LocalKey<RefCell<Option<ButterflyCache<Self>>>> {",
      "            thread_local! {static BUTTERFLY_CACHE : RefCell < Option < ButterflyCache < Mod1e9 >>> = RefCell :: default () ; }",
      "            &BUTTERFLY_CACHE",
      "        }",
      "    }",
      "    pub type ModInt1e9 = StaticModInt<Mod1e9>;",
      "}"
    ]
  },
  "subtraction_game": {
    "scope": "rust",
    "prefix": "subtraction_game",
    "body": [
      "use subtraction_game::*;",
      "pub mod subtraction_game {",
      "    use itertools::Itertools;",
      "    fn mex(xs: &[usize]) -> usize {",
      "        let contains = xs",
      "            .iter()",
      "            .copied()",
      "            .fold(vec![false; xs.len()], |mut acc, x| {",
      "                if x < xs.len() {",
      "                    acc[x] |= true;",
      "                }",
      "                acc",
      "            });",
      "        contains",
      "            .iter()",
      "            .copied()",
      "            .position(|p| !p)",
      "            .unwrap_or(xs.len())",
      "    }",
      "    /// subtraction_game の 0 から n - 1 までの grundy 数を求める",
      "    pub fn subtraction_game_grundy(subtractions: &[usize], n: usize) -> Vec<usize> {",
      "        let mut grundy = vec![usize::MAX; n];",
      "        for x in 0..n {",
      "            let next_grundy_list = subtractions",
      "                .iter()",
      "                .copied()",
      "                .filter(|sub| x >= *sub)",
      "                .map(|sub| grundy[x - sub])",
      "                .collect_vec();",
      "            grundy[x] = mex(&next_grundy_list)",
      "        }",
      "        grundy",
      "    }",
      "}"
    ]
  },
  "symmetric_group": {
    "scope": "rust",
    "prefix": "symmetric_group",
    "body": [
      "use symmetric_group::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod symmetric_group {",
      "    /// 置換を巡回置換の積で表したときの巡回置換のリストを返す。",
      "    /// 例: `make_cycles(&[1, 0, 3, 2]) == vec![vec![0, 1], vec![2, 3]]`",
      "    /// # 計算量",
      "    /// O(N)",
      "    pub fn make_cycles(ps: &[usize]) -> Vec<Vec<usize>> {",
      "        let n = ps.len();",
      "        let mut visited = vec![false; n];",
      "        let mut cycles = vec![];",
      "        for init in 0..n {",
      "            if visited[init] {",
      "                continue;",
      "            }",
      "            let mut cycle = vec![];",
      "            let mut cur = init;",
      "            while !visited[cur] {",
      "                cycle.push(cur);",
      "                visited[cur] = true;",
      "                cur = ps[cur];",
      "            }",
      "            cycles.push(cycle);",
      "        }",
      "        cycles",
      "    }",
      "    /// 置換の積を計算する",
      "    /// # 計算量",
      "    /// O(N)",
      "    pub fn mul_of_permutation(ps: &[usize], mut qs: Vec<usize>) -> Vec<usize> {",
      "        for q in qs.iter_mut() {",
      "            *q = ps[*q];",
      "        }",
      "        qs",
      "    }",
      "    /// 置換の `k` 乗を計算する",
      "    /// # 計算量",
      "    /// O(N)",
      "    pub fn pow_of_permutation(ps: &[usize], k: u64) -> Vec<usize> {",
      "        let n = ps.len();",
      "        let mut ret = vec![0; n];",
      "        let cycles = make_cycles(ps);",
      "        for cycle in cycles {",
      "            let len = cycle.len() as u64;",
      "            let k = (k % len) as usize;",
      "            for (i, &x) in cycle.iter().enumerate() {",
      "                ret[x] = cycle[(i + k) % cycle.len()];",
      "            }",
      "        }",
      "        ret",
      "    }",
      "    /// 逆置換を計算する",
      "    /// # 計算量",
      "    /// O(N)",
      "    pub fn inv_of_permutation(ps: &[usize]) -> Vec<usize> {",
      "        let n = ps.len();",
      "        let mut ret = vec![0; n];",
      "        for (i, &p) in ps.iter().enumerate() {",
      "            ret[p] = i;",
      "        }",
      "        ret",
      "    }",
      "    /// 転倒数を計算する",
      "    /// # 計算量",
      "    /// O(N log N)",
      "    pub fn inversion_number(ps: &[usize]) -> i64 {",
      "        use ac_library::FenwickTree;",
      "        let n = ps.len();",
      "        let mut ft = FenwickTree::new(n, 0_i64);",
      "        let mut ans = 0;",
      "        for &p in ps {",
      "            ans += ft.sum(p + 1..n);",
      "            ft.add(p, 1);",
      "        }",
      "        ans",
      "    }",
      "}"
    ]
  },
  "ternary_search": {
    "scope": "rust",
    "prefix": "ternary_search",
    "body": [
      "/// 実数領域における三分探索を行い、単峰な関数（下に凸など）の最小値を与える引数 `x` を返す。",
      "/// 200回の反復を行うことで、元の区間幅の (2/3)^200 倍（約 6.0 * 10^-36 程度）の精度で値を求める。",
      "/// ## 単峰性の前提",
      "/// 探索範囲 `[l, r]` において、関数 `f` が単峰（値が減少してから増加する）である必要がある。",
      "/// ## Arguments",
      "/// * `l`: 探索範囲の下限",
      "/// * `r`: 探索範囲の上限",
      "/// * `f`: 評価関数",
      "/// ## Return",
      "/// 最小値を与える `x` の近似値を返す。",
      "pub fn ternary_search<T, F>(mut l: f64, mut r: f64, mut f: F) -> f64",
      "where",
      "    T: PartialOrd,",
      "    F: FnMut(f64) -> T,",
      "{",
      "    assert!(l <= r);",
      "    const NUM_ITERATION: i64 = 200;",
      "    for _ in 0..NUM_ITERATION {",
      "        let ml = (l * 2.0 + r) / 3.0;",
      "        let mr = (l + r * 2.0) / 3.0;",
      "        if f(ml) < f(mr) {",
      "            r = mr;",
      "        } else {",
      "            l = ml;",
      "        }",
      "    }",
      "    (l + r) / 2.0",
      "}"
    ]
  },
  "ternary_search_i64": {
    "scope": "rust",
    "prefix": "ternary_search_i64",
    "body": [
      "/// 整数領域における三分探索を行い、単峰な関数（下に凸など）の最小値を与える引数 `x` を返す。",
      "/// ## 単峰性の前提",
      "/// 探索範囲 `[l, r]` において、関数 `f` が単峰（値が減少してから増加する）である必要がある。",
      "/// ## Arguments",
      "/// * `l`: 探索範囲の下限",
      "/// * `r`: 探索範囲の上限",
      "/// * `f`: 評価関数",
      "/// ## Return",
      "/// 最小値を与える `x` を返す。",
      "pub fn ternary_search_i64<T, F>(mut l: i64, mut r: i64, mut f: F) -> i64",
      "where",
      "    T: PartialOrd,",
      "    F: FnMut(i64) -> T,",
      "{",
      "    assert!(l <= r);",
      "    while r - l > 5 {",
      "        let m1 = l + (r - l) / 3;",
      "        let m2 = r - (r - l) / 3;",
      "        if f(m1) < f(m2) {",
      "            r = m2;",
      "        } else {",
      "            l = m1;",
      "        }",
      "    }",
      "    let mut min_x = l;",
      "    let mut min_val = f(l);",
      "    for x in l + 1..=r {",
      "        let val = f(x);",
      "        if val < min_val {",
      "            min_val = val;",
      "            min_x = x;",
      "        }",
      "    }",
      "    min_x",
      "}"
    ]
  },
  "time_keeper": {
    "scope": "rust",
    "prefix": "time_keeper",
    "body": [
      "use time_keeper::*;",
      "pub mod time_keeper {",
      "    #[derive(Debug, Clone)]",
      "    pub struct TimeKeeper {",
      "        start_time: std::time::Instant,",
      "        time_threshold_sec: f64,",
      "    }",
      "    impl TimeKeeper {",
      "        /// time_threshold_sec: 制限時間(秒数)",
      "        pub fn new(time_threshold_sec: f64) -> Self {",
      "            TimeKeeper {",
      "                start_time: std::time::Instant::now(),",
      "                time_threshold_sec,",
      "            }",
      "        }",
      "        #[inline]",
      "        pub fn is_time_over(&self) -> bool {",
      "            let elapsed_time = self.start_time.elapsed().as_nanos() as f64 * 1e-9;",
      "            elapsed_time >= self.time_threshold_sec",
      "        }",
      "    }",
      "}"
    ]
  },
  "topo_sort": {
    "scope": "rust",
    "prefix": "topo_sort",
    "body": [
      "use mod_queue::*;",
      "pub mod mod_queue {",
      "    use std::collections::VecDeque;",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Queue<T> {",
      "        raw: VecDeque<T>,",
      "    }",
      "    impl<T> Queue<T> {",
      "        pub fn new() -> Self {",
      "            Queue {",
      "                raw: VecDeque::new(),",
      "            }",
      "        }",
      "        pub fn push(&mut self, value: T) {",
      "            self.raw.push_back(value)",
      "        }",
      "        pub fn pop(&mut self) -> Option<T> {",
      "            self.raw.pop_front()",
      "        }",
      "        pub fn peek(&self) -> Option<&T> {",
      "            self.raw.front()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.raw.len()",
      "        }",
      "    }",
      "    impl<T> Default for Queue<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "}",
      "/// トポロジカルソートを行います。",
      "/// # Arguments",
      "/// * `adj` - 隣接リスト",
      "/// # Returns",
      "/// トポロジカルソートされた頂点のリスト。サイクルが含まれる場合、リストの長さは `adj.len()` 未満になります。",
      "/// # 計算量",
      "/// O(V + E) (V は頂点数, E は辺数)",
      "pub fn topo_sort(adj: &[Vec<usize>]) -> Vec<usize> {",
      "    let n_vertex = adj.len();",
      "    let mut in_deg = vec![0; n_vertex];",
      "    for neighbors in adj {",
      "        for &next in neighbors {",
      "            in_deg[next] += 1;",
      "        }",
      "    }",
      "    let mut open: Queue<usize> = Queue::new();",
      "    for (v, &deg) in in_deg.iter().enumerate() {",
      "        if deg == 0 {",
      "            open.push(v);",
      "        }",
      "    }",
      "    let mut ans = vec![];",
      "    while let Some(current) = open.pop() {",
      "        ans.push(current);",
      "        for &next in &adj[current] {",
      "            in_deg[next] -= 1;",
      "            if in_deg[next] == 0 {",
      "                open.push(next);",
      "            }",
      "        }",
      "    }",
      "    ans",
      "}"
    ]
  },
  "tree_diameter": {
    "scope": "rust",
    "prefix": "tree_diameter",
    "body": [
      "use mod_queue::*;",
      "pub mod mod_queue {",
      "    use std::collections::VecDeque;",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Queue<T> {",
      "        raw: VecDeque<T>,",
      "    }",
      "    impl<T> Queue<T> {",
      "        pub fn new() -> Self {",
      "            Queue {",
      "                raw: VecDeque::new(),",
      "            }",
      "        }",
      "        pub fn push(&mut self, value: T) {",
      "            self.raw.push_back(value)",
      "        }",
      "        pub fn pop(&mut self) -> Option<T> {",
      "            self.raw.pop_front()",
      "        }",
      "        pub fn peek(&self) -> Option<&T> {",
      "            self.raw.front()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.raw.len()",
      "        }",
      "    }",
      "    impl<T> Default for Queue<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "}",
      "/// 木の直径を求める(直径の長さと直径を構成する頂点のリストを返す)",
      "/// # Arguments",
      "/// * `edges` - 辺の情報 (頂点, 頂点, コスト) のリスト",
      "/// # Returns",
      "/// `(直径の長さ, 直径を構成する頂点のリスト)`",
      "/// # 計算量",
      "/// O(V) (V は頂点数)",
      "pub fn tree_diameter(edges: &[(usize, usize, i64)]) -> (i64, Vec<usize>) {",
      "    let nv = edges.len() + 1;",
      "    let adj = edges",
      "        .iter()",
      "        .copied()",
      "        .fold(vec![vec![]; nv], |mut acc, (u, v, cost)| {",
      "            acc[u].push((v, cost));",
      "            acc[v].push((u, cost));",
      "            acc",
      "        });",
      "    fn bfs(adj: &[Vec<(usize, i64)>], init: usize) -> (i64, Vec<usize>) {",
      "        let n = adj.len();",
      "        let mut dist = vec![0; n];",
      "        let mut prev = vec![None; n];",
      "        let mut visited = vec![false; n];",
      "        let mut open = Queue::new();",
      "        open.push(init);",
      "        visited[init] = true;",
      "        while let Some(current) = open.pop() {",
      "            for &(next, cost) in &adj[current] {",
      "                if !visited[next] {",
      "                    dist[next] = dist[current] + cost;",
      "                    prev[next] = Some(current);",
      "                    visited[next] = true;",
      "                    open.push(next);",
      "                }",
      "            }",
      "        }",
      "        let (furthest, max_dist) = dist",
      "            .iter()",
      "            .copied()",
      "            .enumerate()",
      "            .max_by_key(|(_, d)| *d)",
      "            .unwrap();",
      "        let path: Vec<usize> = {",
      "            let mut path: Vec<usize> =",
      "                std::iter::successors(Some(furthest), |&i| prev[i]).collect();",
      "            path.reverse();",
      "            path",
      "        };",
      "        (max_dist, path)",
      "    }",
      "    let x = *bfs(&adj, 0).1.last().unwrap();",
      "    bfs(&adj, x)",
      "}"
    ]
  },
  "tree_diameter_no_weight": {
    "scope": "rust",
    "prefix": "tree_diameter_no_weight",
    "body": [
      "use mod_queue::*;",
      "/// 木の直径を求める(直径の長さと直径を構成する頂点のリストを返す)",
      "/// # Arguments",
      "/// * `edges` - 辺の情報 (頂点, 頂点, コスト) のリスト",
      "/// # Returns",
      "/// `(直径の長さ, 直径を構成する頂点のリスト)`",
      "/// # 計算量",
      "/// O(V) (V は頂点数)",
      "pub fn tree_diameter(edges: &[(usize, usize, i64)]) -> (i64, Vec<usize>) {",
      "    let nv = edges.len() + 1;",
      "    let adj = edges",
      "        .iter()",
      "        .copied()",
      "        .fold(vec![vec![]; nv], |mut acc, (u, v, cost)| {",
      "            acc[u].push((v, cost));",
      "            acc[v].push((u, cost));",
      "            acc",
      "        });",
      "    fn bfs(adj: &[Vec<(usize, i64)>], init: usize) -> (i64, Vec<usize>) {",
      "        let n = adj.len();",
      "        let mut dist = vec![0; n];",
      "        let mut prev = vec![None; n];",
      "        let mut visited = vec![false; n];",
      "        let mut open = Queue::new();",
      "        open.push(init);",
      "        visited[init] = true;",
      "        while let Some(current) = open.pop() {",
      "            for &(next, cost) in &adj[current] {",
      "                if !visited[next] {",
      "                    dist[next] = dist[current] + cost;",
      "                    prev[next] = Some(current);",
      "                    visited[next] = true;",
      "                    open.push(next);",
      "                }",
      "            }",
      "        }",
      "        let (furthest, max_dist) = dist",
      "            .iter()",
      "            .copied()",
      "            .enumerate()",
      "            .max_by_key(|(_, d)| *d)",
      "            .unwrap();",
      "        let path: Vec<usize> = {",
      "            let mut path: Vec<usize> =",
      "                std::iter::successors(Some(furthest), |&i| prev[i]).collect();",
      "            path.reverse();",
      "            path",
      "        };",
      "        (max_dist, path)",
      "    }",
      "    let x = *bfs(&adj, 0).1.last().unwrap();",
      "    bfs(&adj, x)",
      "}",
      "pub mod mod_queue {",
      "    use std::collections::VecDeque;",
      "    #[derive(Clone, Debug, PartialEq, Eq)]",
      "    pub struct Queue<T> {",
      "        raw: VecDeque<T>,",
      "    }",
      "    impl<T> Queue<T> {",
      "        pub fn new() -> Self {",
      "            Queue {",
      "                raw: VecDeque::new(),",
      "            }",
      "        }",
      "        pub fn push(&mut self, value: T) {",
      "            self.raw.push_back(value)",
      "        }",
      "        pub fn pop(&mut self) -> Option<T> {",
      "            self.raw.pop_front()",
      "        }",
      "        pub fn peek(&self) -> Option<&T> {",
      "            self.raw.front()",
      "        }",
      "        pub fn is_empty(&self) -> bool {",
      "            self.raw.is_empty()",
      "        }",
      "        pub fn len(&self) -> usize {",
      "            self.raw.len()",
      "        }",
      "    }",
      "    impl<T> Default for Queue<T> {",
      "        fn default() -> Self {",
      "            Self::new()",
      "        }",
      "    }",
      "}",
      "/// 重みなし木の直径を求める(直径の長さと直径を構成する頂点のリストを返す)",
      "/// # Arguments",
      "/// * `edges` - 辺の情報 (頂点, 頂点) のリスト",
      "/// # Returns",
      "/// `(直径の長さ, 直径を構成する頂点のリスト)`",
      "/// # 計算量",
      "/// O(V) (V は頂点数)",
      "pub fn tree_diameter_no_weight(edges: &[(usize, usize)]) -> (i64, Vec<usize>) {",
      "    let edges: Vec<(usize, usize, i64)> = edges.iter().copied().map(|(u, v)| (u, v, 1)).collect();",
      "    tree_diameter(&edges)",
      "}"
    ]
  },
  "two_sequence_range_affine_range_sum": {
    "scope": "rust",
    "prefix": "two_sequence_range_affine_range_sum",
    "body": [
      "use two_sequence_range_affine_range_sum::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod two_sequence_range_affine_range_sum {",
      "    use ac_library::{LazySegtree, MapMonoid, Monoid};",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    use std::ops::{Add, Mul, RangeBounds};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct TwoSequenceData<T> {",
      "        pub sum_x: T,",
      "        pub sum_y: T,",
      "        pub sum_xy: T,",
      "        pub len: i64,",
      "    }",
      "    impl<T> TwoSequenceData<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        pub fn unit(x_val: T, y_val: T) -> Self {",
      "            Self {",
      "                sum_x: x_val,",
      "                sum_y: y_val,",
      "                sum_xy: x_val * y_val,",
      "                len: 1,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct TwoSequenceDataMonoid<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for TwoSequenceDataMonoid<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        type S = TwoSequenceData<T>;",
      "        fn identity() -> Self::S {",
      "            Self::S {",
      "                sum_x: 0.into(),",
      "                sum_y: 0.into(),",
      "                sum_xy: 0.into(),",
      "                len: 0,",
      "            }",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            Self::S {",
      "                sum_x: a.sum_x + b.sum_x,",
      "                sum_y: a.sum_y + b.sum_y,",
      "                sum_xy: a.sum_xy + b.sum_xy,",
      "                len: a.len + b.len,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct TwoSequenceAffine<T> {",
      "        pub a: T,",
      "        pub b: T,",
      "        pub c: T,",
      "        pub d: T,",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct TwoSequenceRangeAffineRangeSum<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> MapMonoid for TwoSequenceRangeAffineRangeSum<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        type M = TwoSequenceDataMonoid<T>;",
      "        type F = TwoSequenceAffine<T>;",
      "        fn identity_map() -> Self::F {",
      "            Self::F {",
      "                a: 1.into(),",
      "                b: 0.into(),",
      "                c: 1.into(),",
      "                d: 0.into(),",
      "            }",
      "        }",
      "        fn composition(f1: &Self::F, f2: &Self::F) -> Self::F {",
      "            Self::F {",
      "                a: f1.a * f2.a,",
      "                b: f1.a * f2.b + f1.b,",
      "                c: f1.c * f2.c,",
      "                d: f1.c * f2.d + f1.d,",
      "            }",
      "        }",
      "        fn mapping(f: &Self::F, x: &TwoSequenceData<T>) -> TwoSequenceData<T> {",
      "            TwoSequenceData {",
      "                sum_xy: f.a * f.c * x.sum_xy",
      "                    + f.a * f.d * x.sum_x",
      "                    + f.b * f.c * x.sum_y",
      "                    + f.b * f.d * x.len.into(),",
      "                sum_x: f.a * x.sum_x + f.b * x.len.into(),",
      "                sum_y: f.c * x.sum_y + f.d * x.len.into(),",
      "                len: x.len,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct TwoSequenceRangeAffineRangeSumSegtree<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        segtree: LazySegtree<TwoSequenceRangeAffineRangeSum<T>>,",
      "        len: usize,",
      "    }",
      "    impl<T> TwoSequenceRangeAffineRangeSumSegtree<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        /// `xs` と `ys` の初期シーケンスでセグメント木を構築します。",
      "        pub fn new(n: usize) -> Self {",
      "            let xs = vec![0.into(); n];",
      "            let ys = vec![0.into(); n];",
      "            Self::from_slice(&xs, &ys)",
      "        }",
      "        pub fn from_slice(xs: &[T], ys: &[T]) -> Self {",
      "            assert_eq!(xs.len(), ys.len(), \"xs and ys must have the same length\");",
      "            let xs_ys = xs",
      "                .iter()",
      "                .zip(ys.iter())",
      "                .map(|(&x, &y)| TwoSequenceData::unit(x, y))",
      "                .collect_vec();",
      "            let len = xs_ys.len();",
      "            Self {",
      "                segtree: LazySegtree::from(xs_ys),",
      "                len,",
      "            }",
      "        }",
      "        /// 指定された区間 `range` に対して、`xs[i] ← a * xs[i] + b`, `ys[i] ← c * ys[i] + d`",
      "        /// のアフィン変換を適用します。",
      "        pub fn range_affine(&mut self, range: impl RangeBounds<usize>, a: T, b: T, c: T, d: T) {",
      "            self.segtree",
      "                .apply_range(range, TwoSequenceAffine { a, b, c, d })",
      "        }",
      "        /// 指定された区間 `range` に対して、`xs[i] ← a * xs[i] + b` のアフィン変換を適用します。",
      "        pub fn range_affine_x(&mut self, range: impl RangeBounds<usize>, a: T, b: T) {",
      "            self.range_affine(range, a, b, 1.into(), 0.into())",
      "        }",
      "        /// 指定された区間 `range` に対して、`ys[i] ← c * ys[i] + d` のアフィン変換を適用します。",
      "        pub fn range_affine_y(&mut self, range: impl RangeBounds<usize>, c: T, d: T) {",
      "            self.range_affine(range, 1.into(), 0.into(), c, d)",
      "        }",
      "        /// 指定された区間 `range` に対して、`xs[i] ← xs[i] + b` の加算を適用します。",
      "        pub fn range_add_x(&mut self, range: impl RangeBounds<usize>, b: T) {",
      "            self.range_affine_x(range, 1.into(), b)",
      "        }",
      "        /// 指定された区間 `range` に対して、`xs[i] ← x` の更新を適用します。",
      "        pub fn range_update_x(&mut self, range: impl RangeBounds<usize>, x: T) {",
      "            self.range_affine_x(range, 0.into(), x)",
      "        }",
      "        /// 指定された区間 `range` に対して、`ys[i] ← ys[i] + d` の加算を適用します。",
      "        pub fn range_add_y(&mut self, range: impl RangeBounds<usize>, d: T) {",
      "            self.range_affine_y(range, 1.into(), d)",
      "        }",
      "        /// 指定された区間 `range` に対して、`ys[i] ← y` の更新を適用します。",
      "        pub fn range_update_y(&mut self, range: impl RangeBounds<usize>, y: T) {",
      "            self.range_affine_y(range, 0.into(), y)",
      "        }",
      "        /// 指定された区間 `range` の `sum(xs[i] * ys[i])` を計算して返します。",
      "        pub fn range_sum_xy(&mut self, range: impl RangeBounds<usize>) -> T {",
      "            self.segtree.prod(range).sum_xy",
      "        }",
      "        /// 指定された区間 `range` の `sum(xs[i])` を計算して返します。",
      "        pub fn range_sum_x(&mut self, range: impl RangeBounds<usize>) -> T {",
      "            self.segtree.prod(range).sum_x",
      "        }",
      "        /// 指定された区間 `range` の `sum(ys[i])` を計算して返します。",
      "        pub fn range_sum_y(&mut self, range: impl RangeBounds<usize>) -> T {",
      "            self.segtree.prod(range).sum_y",
      "        }",
      "        /// 指定されたインデックス `p` の `xs[p]` と `ys[p]` の値を更新します。",
      "        pub fn set(&mut self, p: usize, x: T, y: T) {",
      "            self.segtree.set(p, TwoSequenceData::unit(x, y));",
      "        }",
      "        /// 指定されたインデックス `p` の `xs[p]` の値を更新します。",
      "        pub fn set_x(&mut self, p: usize, x: T) {",
      "            let (_, y) = self.get(p);",
      "            self.set(p, x, y);",
      "        }",
      "        /// 指定されたインデックス `p` の `ys[p]` の値を更新します。",
      "        pub fn set_y(&mut self, p: usize, y: T) {",
      "            let (x, _) = self.get(p);",
      "            self.set(p, x, y);",
      "        }",
      "        /// 指定されたインデックス `p` の `xs[p]` と `ys[p]` の値を取得します。",
      "        pub fn get(&mut self, p: usize) -> (T, T) {",
      "            let data = self.segtree.get(p);",
      "            (data.sum_x, data.sum_y)",
      "        }",
      "        /// セグメント木の現在の状態を `(Vec<T>, Vec<T>)` として返します。",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn to_vec(&mut self) -> (Vec<T>, Vec<T>) {",
      "            (0..self.len).map(|i| self.get(i)).unzip()",
      "        }",
      "    }",
      "}"
    ]
  },
  "two_sequence_range_affine_range_sum_of_quadratic": {
    "scope": "rust",
    "prefix": "two_sequence_range_affine_range_sum_of_quadratic",
    "body": [
      "use two_sequence_range_affine_range_sum_of_quadratic::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod two_sequence_range_affine_range_sum_of_quadratic {",
      "    use ac_library::{LazySegtree, MapMonoid, Monoid};",
      "    use itertools::Itertools;",
      "    use std::convert::Infallible;",
      "    use std::marker::PhantomData;",
      "    use std::ops::{Add, Mul, RangeBounds};",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct TwoSequenceQuadraticData<T> {",
      "        pub sum_x: T,",
      "        pub sum_y: T,",
      "        pub sum_x2: T,",
      "        pub sum_y2: T,",
      "        pub sum_xy: T,",
      "        pub len: i64,",
      "    }",
      "    impl<T> TwoSequenceQuadraticData<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        pub fn unit(x_val: T, y_val: T) -> Self {",
      "            Self {",
      "                sum_x: x_val,",
      "                sum_y: y_val,",
      "                sum_x2: x_val * x_val,",
      "                sum_y2: y_val * y_val,",
      "                sum_xy: x_val * y_val,",
      "                len: 1,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct TwoSequenceQuadraticDataMonoid<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> Monoid for TwoSequenceQuadraticDataMonoid<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        type S = TwoSequenceQuadraticData<T>;",
      "        fn identity() -> Self::S {",
      "            Self::S {",
      "                sum_x: 0.into(),",
      "                sum_y: 0.into(),",
      "                sum_x2: 0.into(),",
      "                sum_y2: 0.into(),",
      "                sum_xy: 0.into(),",
      "                len: 0,",
      "            }",
      "        }",
      "        fn binary_operation(a: &Self::S, b: &Self::S) -> Self::S {",
      "            Self::S {",
      "                sum_x: a.sum_x + b.sum_x,",
      "                sum_y: a.sum_y + b.sum_y,",
      "                sum_x2: a.sum_x2 + b.sum_x2,",
      "                sum_y2: a.sum_y2 + b.sum_y2,",
      "                sum_xy: a.sum_xy + b.sum_xy,",
      "                len: a.len + b.len,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct TwoSequenceAffine<T> {",
      "        pub a: T,",
      "        pub b: T,",
      "        pub c: T,",
      "        pub d: T,",
      "    }",
      "    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
      "    pub struct TwoSequenceRangeAffineRangeSumOfQuadratic<T>(Infallible, PhantomData<fn() -> T>);",
      "    impl<T> MapMonoid for TwoSequenceRangeAffineRangeSumOfQuadratic<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        type M = TwoSequenceQuadraticDataMonoid<T>;",
      "        type F = TwoSequenceAffine<T>;",
      "        fn identity_map() -> Self::F {",
      "            Self::F {",
      "                a: 1.into(),",
      "                b: 0.into(),",
      "                c: 1.into(),",
      "                d: 0.into(),",
      "            }",
      "        }",
      "        fn composition(f1: &Self::F, f2: &Self::F) -> Self::F {",
      "            Self::F {",
      "                a: f1.a * f2.a,",
      "                b: f1.a * f2.b + f1.b,",
      "                c: f1.c * f2.c,",
      "                d: f1.c * f2.d + f1.d,",
      "            }",
      "        }",
      "        fn mapping(f: &Self::F, data: &TwoSequenceQuadraticData<T>) -> TwoSequenceQuadraticData<T> {",
      "            let a = f.a;",
      "            let b = f.b;",
      "            let c = f.c;",
      "            let d = f.d;",
      "            let len_t: T = data.len.into();",
      "            let new_sum_x = a * data.sum_x + b * len_t;",
      "            let new_sum_y = c * data.sum_y + d * len_t;",
      "            let new_sum_x2 = a * a * data.sum_x2 + (a + a) * b * data.sum_x + b * b * len_t;",
      "            let new_sum_y2 = c * c * data.sum_y2 + (c + c) * d * data.sum_y + d * d * len_t;",
      "            let new_sum_xy =",
      "                a * c * data.sum_xy + a * d * data.sum_x + b * c * data.sum_y + b * d * len_t;",
      "            TwoSequenceQuadraticData {",
      "                sum_x: new_sum_x,",
      "                sum_y: new_sum_y,",
      "                sum_x2: new_sum_x2,",
      "                sum_y2: new_sum_y2,",
      "                sum_xy: new_sum_xy,",
      "                len: data.len,",
      "            }",
      "        }",
      "    }",
      "    #[derive(Clone)]",
      "    pub struct TwoSequenceRangeAffineRangeSumOfQuadraticSegtree<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        segtree: LazySegtree<TwoSequenceRangeAffineRangeSumOfQuadratic<T>>,",
      "        len: usize,",
      "    }",
      "    impl<T> TwoSequenceRangeAffineRangeSumOfQuadraticSegtree<T>",
      "    where",
      "        T: Copy + Mul<Output = T> + Add<Output = T> + From<i64>,",
      "    {",
      "        /// `xs` と `ys` の初期シーケンスでセグメント木を構築します。",
      "        pub fn new(n: usize) -> Self {",
      "            let xs = vec![0.into(); n];",
      "            let ys = vec![0.into(); n];",
      "            Self::from_slice(&xs, &ys)",
      "        }",
      "        pub fn from_slice(xs: &[T], ys: &[T]) -> Self {",
      "            assert_eq!(xs.len(), ys.len(), \"xs and ys must have the same length\");",
      "            let xs_ys = xs",
      "                .iter()",
      "                .zip(ys.iter())",
      "                .map(|(&x, &y)| TwoSequenceQuadraticData::unit(x, y))",
      "                .collect_vec();",
      "            let len = xs_ys.len();",
      "            Self {",
      "                segtree: LazySegtree::from(xs_ys),",
      "                len,",
      "            }",
      "        }",
      "        /// 指定された区間 `range` に対して、`xs[i] ← a * xs[i] + b`, `ys[i] ← c * ys[i] + d` のアフィン変換を適用します。",
      "        pub fn range_affine(&mut self, range: impl RangeBounds<usize>, a: T, b: T, c: T, d: T) {",
      "            self.segtree",
      "                .apply_range(range, TwoSequenceAffine { a, b, c, d })",
      "        }",
      "        /// 指定された区間 `range` に対して、`xs[i] ← a * xs[i] + b` のアフィン変換を適用します。",
      "        pub fn range_affine_x(&mut self, range: impl RangeBounds<usize>, a: T, b: T) {",
      "            self.range_affine(range, a, b, 1.into(), 0.into())",
      "        }",
      "        /// 指定された区間 `range` に対して、`ys[i] ← c * ys[i] + d` のアフィン変換を適用します。",
      "        pub fn range_affine_y(&mut self, range: impl RangeBounds<usize>, c: T, d: T) {",
      "            self.range_affine(range, 1.into(), 0.into(), c, d)",
      "        }",
      "        /// 指定された区間 `range` に対して、`xs[i] ← xs[i] + b` の加算を適用します。",
      "        pub fn range_add_x(&mut self, range: impl RangeBounds<usize>, b: T) {",
      "            self.range_affine_x(range, 1.into(), b)",
      "        }",
      "        /// 指定された区間 `range` に対して、`xs[i] ← x` の更新を適用します。",
      "        pub fn range_update_x(&mut self, range: impl RangeBounds<usize>, x: T) {",
      "            self.range_affine_x(range, 0.into(), x)",
      "        }",
      "        /// 指定された区間 `range` に対して、`ys[i] ← ys[i] + d` の加算を適用します。",
      "        pub fn range_add_y(&mut self, range: impl RangeBounds<usize>, d: T) {",
      "            self.range_affine_y(range, 1.into(), d)",
      "        }",
      "        /// 指定された区間 `range` に対して、`ys[i] ← y` の更新を適用します。",
      "        pub fn range_update_y(&mut self, range: impl RangeBounds<usize>, y: T) {",
      "            self.range_affine_y(range, 0.into(), y)",
      "        }",
      "        /// 指定された区間 `range` の `sum(xs[i] * ys[i])` を計算して返します。",
      "        pub fn range_sum_xy(&mut self, range: impl RangeBounds<usize>) -> T {",
      "            self.segtree.prod(range).sum_xy",
      "        }",
      "        /// 指定された区間 `range` の `sum(xs[i] * xs[i])` を計算して返します。",
      "        pub fn range_sum_x2(&mut self, range: impl RangeBounds<usize>) -> T {",
      "            self.segtree.prod(range).sum_x2",
      "        }",
      "        /// 指定された区間 `range` の `sum(ys[i] * ys[i])` を計算して返します。",
      "        pub fn range_sum_y2(&mut self, range: impl RangeBounds<usize>) -> T {",
      "            self.segtree.prod(range).sum_y2",
      "        }",
      "        /// 指定された区間 `range` の `sum(xs[i])` を計算して返します。",
      "        pub fn range_sum_x(&mut self, range: impl RangeBounds<usize>) -> T {",
      "            self.segtree.prod(range).sum_x",
      "        }",
      "        /// 指定された区間 `range` の `sum(ys[i])` を計算して返します。",
      "        pub fn range_sum_y(&mut self, range: impl RangeBounds<usize>) -> T {",
      "            self.segtree.prod(range).sum_y",
      "        }",
      "        /// 指定されたインデックス `p` の `xs[p]` と `ys[p]` の値を更新します。",
      "        pub fn set(&mut self, p: usize, x: T, y: T) {",
      "            self.segtree.set(p, TwoSequenceQuadraticData::unit(x, y));",
      "        }",
      "        /// 指定されたインデックス `p` の `xs[p]` の値を更新します。",
      "        pub fn set_x(&mut self, p: usize, x: T) {",
      "            let (_, y) = self.get(p);",
      "            self.set(p, x, y);",
      "        }",
      "        /// 指定されたインデックス `p` の `ys[p]` の値を更新します。",
      "        pub fn set_y(&mut self, p: usize, y: T) {",
      "            let (x, _) = self.get(p);",
      "            self.set(p, x, y);",
      "        }",
      "        /// 指定されたインデックス `p` の `xs[p]` と `ys[p]` の値を取得します。",
      "        pub fn get(&mut self, p: usize) -> (T, T) {",
      "            let data = self.segtree.get(p);",
      "            (data.sum_x, data.sum_y)",
      "        }",
      "        /// セグメント木の現在の状態を `(Vec<T>, Vec<T>)` として返します。",
      "        #[allow(clippy::len_without_is_empty)]",
      "        pub fn len(&self) -> usize {",
      "            self.len",
      "        }",
      "        pub fn to_vec(&mut self) -> (Vec<T>, Vec<T>) {",
      "            (0..self.len).map(|i| self.get(i)).unzip()",
      "        }",
      "    }",
      "}"
    ]
  },
  "upper_bound": {
    "scope": "rust",
    "prefix": "upper_bound",
    "body": [
      "/// 二分探索をする。",
      "/// ```text",
      "/// ng ng ng ok ok ok",
      "///          ↑ここの引数の値を返す",
      "/// ```",
      "/// # 計算量",
      "/// O(log(|ok - ng|))",
      "/// ## Arguments",
      "/// * ok != ng",
      "/// * |ok - ng| <= 2^63 - 1, |ok + ng| <= 2^63 - 1",
      "/// * p の定義域について",
      "///     * ng < ok の場合、p は区間 ng..ok で定義されている。",
      "///     * ok < ng の場合、p は区間 ok..ng で定義されている。",
      "/// * p の単調性について",
      "///     * ng < ok の場合、p は単調増加",
      "///     * ok < ng の場合、p は単調減少",
      "/// ## Return",
      "/// * ng < ok の場合: I = { i in ng..ok | p(i) == true } としたとき",
      "///     * I が空でなければ、min I を返す。",
      "///     * I が空ならば、ok を返す。",
      "/// * ok < ng の場合: I = { i in ok..ng | p(i) == true } としたとき",
      "///     * I が空でなければ、max I を返す。",
      "///     * I が空ならば、ok を返す。",
      "pub fn bin_search<F>(mut ok: i64, mut ng: i64, mut p: F) -> i64",
      "where",
      "    F: FnMut(i64) -> bool,",
      "{",
      "    debug_assert!(ok != ng);",
      "    debug_assert!(ok.checked_sub(ng).is_some());",
      "    debug_assert!(ok.checked_add(ng).is_some());",
      "    while num::abs(ok - ng) > 1 {",
      "        let mid = (ok + ng) / 2;",
      "        debug_assert!(mid != ok);",
      "        debug_assert!(mid != ng);",
      "        if p(mid) {",
      "            ok = mid;",
      "        } else {",
      "            ng = mid;",
      "        }",
      "    }",
      "    ok",
      "}",
      "/// 指定された要素より大きい値が現れる最初の位置を返す。",
      "/// # 計算量",
      "/// O(log(|xs|))",
      "/// ## Arguments",
      "/// * xs: 単調増加",
      "///     * 単調増加でなくても、 `|i| xs[i] > key` が単調ならOK",
      "/// ## Return",
      "/// `I = {i in 0..xs.len() | xs[i] > key}` としたとき、`min I` を返す。",
      "/// ただし、`I` が空の場合は `xs.len()` を返す。",
      "/// 戻り値は、区間 `0..=xs.len()` の間で返る。",
      "pub fn upper_bound<T: PartialOrd>(xs: &[T], key: T) -> usize {",
      "    let pred = |i: i64| xs[i as usize] > key;",
      "    bin_search(xs.len() as i64, -1_i64, pred) as usize",
      "}"
    ]
  },
  "upper_bound_dec": {
    "scope": "rust",
    "prefix": "upper_bound_dec",
    "body": [
      "/// 二分探索をする。",
      "/// ```text",
      "/// ng ng ng ok ok ok",
      "///          ↑ここの引数の値を返す",
      "/// ```",
      "/// # 計算量",
      "/// O(log(|ok - ng|))",
      "/// ## Arguments",
      "/// * ok != ng",
      "/// * |ok - ng| <= 2^63 - 1, |ok + ng| <= 2^63 - 1",
      "/// * p の定義域について",
      "///     * ng < ok の場合、p は区間 ng..ok で定義されている。",
      "///     * ok < ng の場合、p は区間 ok..ng で定義されている。",
      "/// * p の単調性について",
      "///     * ng < ok の場合、p は単調増加",
      "///     * ok < ng の場合、p は単調減少",
      "/// ## Return",
      "/// * ng < ok の場合: I = { i in ng..ok | p(i) == true } としたとき",
      "///     * I が空でなければ、min I を返す。",
      "///     * I が空ならば、ok を返す。",
      "/// * ok < ng の場合: I = { i in ok..ng | p(i) == true } としたとき",
      "///     * I が空でなければ、max I を返す。",
      "///     * I が空ならば、ok を返す。",
      "pub fn bin_search<F>(mut ok: i64, mut ng: i64, mut p: F) -> i64",
      "where",
      "    F: FnMut(i64) -> bool,",
      "{",
      "    debug_assert!(ok != ng);",
      "    debug_assert!(ok.checked_sub(ng).is_some());",
      "    debug_assert!(ok.checked_add(ng).is_some());",
      "    while num::abs(ok - ng) > 1 {",
      "        let mid = (ok + ng) / 2;",
      "        debug_assert!(mid != ok);",
      "        debug_assert!(mid != ng);",
      "        if p(mid) {",
      "            ok = mid;",
      "        } else {",
      "            ng = mid;",
      "        }",
      "    }",
      "    ok",
      "}",
      "/// 指定された要素より小さい値が現れる最初の位置を返す。",
      "/// # 計算量",
      "/// O(log(|xs|))",
      "/// ## Arguments",
      "/// * xs: 単勝減少",
      "///     * 単調減少でなくても、 `|i| xs[i] < key` が単調ならOK",
      "/// ## Return",
      "/// `I = {i in 0..xs.len() | xs[i] < key}` としたとき、`min I` を返す。",
      "/// ただし、`I` が空の場合は `xs.len()` を返す。",
      "/// 戻り値は、区間 `0..=xs.len()` の間で返る。",
      "pub fn upper_bound_dec<T: PartialOrd>(xs: &[T], key: T) -> usize {",
      "    let pred = |i: i64| xs[i as usize] < key;",
      "    bin_search(xs.len() as i64, -1_i64, pred) as usize",
      "}"
    ]
  },
  "vec_at": {
    "scope": "rust",
    "prefix": "vec_at",
    "body": [
      "use vec_at::*;",
      "#[allow(clippy::module_inception)]",
      "pub mod vec_at {",
      "    use easy_ext::ext;",
      "    #[ext(VecAt)]",
      "    impl<T> Vec<T> {",
      "        pub fn at(&self, index: i64) -> &T {",
      "            &self[index as usize]",
      "        }",
      "        pub fn at_mut(&mut self, index: i64) -> &mut T {",
      "            &mut self[index as usize]",
      "        }",
      "    }",
      "}"
    ]
  },
  "vec_vec_at": {
    "scope": "rust",
    "prefix": "vec_vec_at",
    "body": [
      "use vec_vec_at::*;",
      "pub mod vec_vec_at {",
      "    use super::pos::*;",
      "    use easy_ext::ext;",
      "    use std::ops::{Index, IndexMut};",
      "    #[ext(ExtVecVec)]",
      "    impl<T> Vec<Vec<T>> {",
      "        pub fn width(&self) -> usize {",
      "            if self.is_empty() {",
      "                0",
      "            } else {",
      "                self[0].len()",
      "            }",
      "        }",
      "        pub fn height(&self) -> usize {",
      "            self.len()",
      "        }",
      "        pub fn is_within(&self, pos: Pos) -> bool {",
      "            (0..self.width() as i64).contains(&pos.x) && (0..self.height() as i64).contains(&pos.y)",
      "        }",
      "    }",
      "    impl<T> Index<Pos> for Vec<Vec<T>> {",
      "        type Output = T;",
      "        fn index(&self, index: Pos) -> &Self::Output {",
      "            if cfg!(debug_assertions) && !self.is_within(index) {",
      "                panic ! (\"index out of bounds: the size (w, h) is ({}, {}) but the index (x, y) is ({}, {})\" , self . width () , self . height () , index . x , index . y );",
      "            }",
      "            &self[index.y as usize][index.x as usize]",
      "        }",
      "    }",
      "    impl<T> IndexMut<Pos> for Vec<Vec<T>> {",
      "        fn index_mut(&mut self, index: Pos) -> &mut Self::Output {",
      "            if cfg!(debug_assertions) && !self.is_within(index) {",
      "                panic ! (\"index out of bounds: the size (w, h) is ({}, {}) but the index (x, y) is ({}, {})\" , self . width () , self . height () , index . x , index . y );",
      "            }",
      "            &mut self[index.y as usize][index.x as usize]",
      "        }",
      "    }",
      "}"
    ]
  },
  "vec_vec_vec_at": {
    "scope": "rust",
    "prefix": "vec_vec_vec_at",
    "body": [
      "use vec_vec_vec_at::*;",
      "pub mod vec_vec_vec_at {",
      "    use super::pos3d::*;",
      "    use easy_ext::ext;",
      "    use std::ops::{Index, IndexMut};",
      "    #[ext(ExtVecVecVec)]",
      "    impl<T> Vec<Vec<Vec<T>>> {",
      "        pub fn width(&self) -> usize {",
      "            if self.is_empty() || self[0].is_empty() {",
      "                0",
      "            } else {",
      "                self[0][0].len()",
      "            }",
      "        }",
      "        pub fn height(&self) -> usize {",
      "            if self.is_empty() {",
      "                0",
      "            } else {",
      "                self[0].len()",
      "            }",
      "        }",
      "        pub fn depth(&self) -> usize {",
      "            self.len()",
      "        }",
      "        pub fn is_within(&self, pos: Pos3d) -> bool {",
      "            (0..self.width() as i64).contains(&pos.x)",
      "                && (0..self.height() as i64).contains(&pos.y)",
      "                && (0..self.depth() as i64).contains(&pos.z)",
      "        }",
      "    }",
      "    impl<T> Index<Pos3d> for Vec<Vec<Vec<T>>> {",
      "        type Output = T;",
      "        fn index(&self, index: Pos3d) -> &Self::Output {",
      "            if cfg!(debug_assertions) && !self.is_within(index) {",
      "                panic ! (\"index out of bounds: the size (w, h, d) is ({}, {}, {}) but the index (x, y, z) is ({}, {}, {})\" , self . width () , self . height () , self . depth () , index . x , index . y , index . z );",
      "            }",
      "            &self[index.z as usize][index.y as usize][index.x as usize]",
      "        }",
      "    }",
      "    impl<T> IndexMut<Pos3d> for Vec<Vec<Vec<T>>> {",
      "        fn index_mut(&mut self, index: Pos3d) -> &mut Self::Output {",
      "            if cfg!(debug_assertions) && !self.is_within(index) {",
      "                panic ! (\"index out of bounds: the size (w, h, d) is ({}, {}, {}) but the index (x, y, z) is ({}, {}, {})\" , self . width () , self . height () , self . depth () , index . x , index . y , index . z );",
      "            }",
      "            &mut self[index.z as usize][index.y as usize][index.x as usize]",
      "        }",
      "    }",
      "}"
    ]
  }
}
