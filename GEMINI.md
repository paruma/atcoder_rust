# Gemini プロジェクト設定

## 1. プロジェクトの基本

### 1.1. 概要

これは、AtCoderのような競技プログラミングのコンテスト問題をRust言語で解くためのリポジトリです。
コンテスト問題のコードに加えて、ライブラリも同梱されています。

### 1.2. プロジェクトの構造

本プロジェクトは Cargo ワークスペースで構成されており、以下の単位でパッケージ管理されています。

- **ワークスペースルート (`Cargo.toml`)**:
  - 全体の構成（members）と、共通の依存ライブラリのバージョンを一括管理。
- **年度別パッケージ (`src/contest/YYYY/Cargo.toml`)**:
  - 該当年度の各問題（`abcXXX/q/q.rs`）をバイナリターゲットとして定義・管理。
- **共通ライブラリパッケージ (`src/mylib/Cargo.toml`)**:
  - 競プロ用コードスニペットを `mylib` クレートとして管理。
- **サンプルパッケージ (`src/example/Cargo.toml`)**:
  - 特定のアルゴリズムやデータ構造の練習用コードを `example` クレートとして管理。
- **検証用パッケージ (`src/library_checker/Cargo.toml`)**:
  - Library Checker 用の検証コードを `library_checker` パッケージとして管理。
- **テンプレート用パッケージ (`src/contest/Cargo.toml`)**:
  - `template.rs` 等のテンプレートファイルを即座に実行・検証するためのパッケージ。

### 1.3. 支援ツール

開発を補助するためのスクリプト群です。これらは人間が使うことを想定していて、AIエージェントが使うことは想定していません。

- `contest.py`: 指定したコンテスト・問題用のディレクトリ作成とファイル配置を自動化し、`Cargo.toml` 用の定義を出力します。
- `script.sh`: `oj test` や提出、ビルド・実行などの頻用コマンドをエイリアス（`ojt`, `ojs`, `exe` 等）として提供します（`source script.sh` で使用）。

## 2. 開発の進め方

### 2.1. 基本ルール

- **実装指示の尊重**: 具体的な実装指示があるまで、ファイルへの書き込みは行わないでください。
    - 「レビューして」「確認して」という依頼に対しては、絶対にファイルへの書き込み（`replace`, `write_file`）を行わないでください。
    - ユーザーの意図を慎重に判断し、不明な場合は実装方針を提案して同意を得てください。
- **解法提示の制限**: ユーザーが解法を明示的に求めていない状況で、未実装の問題に対する解法やアルゴリズムの詳細を提示しないでください。これは、ユーザー自身の「振り返り」「考察」「試行錯誤」といった自律的な学習・成長プロセスを阻害する可能性があるためです。
- **Git利用**: `git commit` `git reset` `git checkout` などのリポジトリや編集中のファイルに副作用を及ぼすコマンドは使用しないでください。過去の状態を参照したい場合は安全に取り出す方法（git show や git diff）を用いてください。
- **ファイル管理**: 作業中に作成したスクリプトファイルや、実装途中のコードは、ユーザーの確認が済むまで削除しないでください。
- **計算量への配慮**: 競技プログラミングでは計算量が重要です。計算量が異なるアルゴリズムは、機能が同じでも別物として扱います。
- **指示してないことを無断で行わない**: 指示した内容以外でコードのリファクタリングをしたほうが良いと判断した内容はユーザに確認を取ってください。指示されたインターフェースやアルゴリズムと異なる方針を採るほうが良いと判断した場合も、実装前に必ず提案し、承諾を得てください。
    - **抱き合わせ実装（Bundled Implementation）の禁止**: 承認された「指示」を実行する際、まだ承諾を得ていない「提案」を混ぜてはならない。「Aの修正ついでに、提案していたBも適用しました」といった、善意に基づく独断での同時実装は厳禁とする。複数の変更を行う場合は、指示された内容と提案した内容を明確に分け、それぞれに対して個別に承諾を得ること。
    - ユーザに確認を取るまでは指示した内容以外の変更を行わないでください。
- **提案先行プロトコル**: 技術的制約（Rustの型システムによる制限等）により、当初の指示通りの実装が困難であると判明した場合、独断で代替案（メソッド化等）を実装せず、まず状況を報告し、代替案を提案してユーザーの同意を得てください。

### 2.2. ライブラリ開発

ライブラリのコードを編集した際は、**必ず `code-verifier` スキルを活性化し、その指示（The Verification Flow）に厳格に従ってください**。

また、設計にあたっては `lib-dev-standards` スキルの指針を遵守してください。
これらのスキルは、作業開始時に適切に活性化されるべきものです。

### 2.3. コーディング規約

コーディング規約（`rand` クレートの利用、コメント、スタイル、インポートルール等）については、**`lib-dev-standards` スキルの「4. コーディング規約」に従ってください**。

また、ランダムテストの実装については同スキルの [random-testing.md](.gemini/skills/lib-dev-standards/references/random-testing.md) を参照してください。

### 2.4. コンテスト問題のコードについて

- テンプレートファイルは `src/contest/template.rs` および `src/contest/template2.rs` に配置されています。
- `src/contest/YYYY/abcXXX/q/q.rs` 等のコンテスト問題用ファイルに含まれる `tests` モジュール（ランダムテスト用テンプレート）や `print_util` モジュール（出力用ユーティリティ）は、**テンプレートのままであっても問題ありません**。
- これらは必要に応じて使用するものであり、使用しない場合に無理に削除したり、空の実装を埋めたりする必要はありません。
- **原則として、コードの直接編集は絶対に行わないでください。** 修正やリファクタリングが必要と判断した場合でも、必ず**修正提案に留めてください**。
- リファクタリングの際も、これらのテンプレートコードが未使用であることを理由に削除提案をする必要はありません。

### 2.5. ライブラリの利用形態

`mylib` のコードは、`cargo-snippet` を用いてコンテスト問題のソースファイル（`q.rs` 等）に展開して使用します。これにより、提出時には全てのコードが単一のクレート（ファイル）内に収まります。
この「スニペット展開」により、本来クレート境界で阻害されるインライン展開や定数伝播などのコンパイラ最適化が強力に機能するため、汎用的なライブラリ関数であっても、手書きコードと同等のパフォーマンスが期待できます。


## 3. 開発環境

### 3.1. サンドボックス環境

- Rust と Python (uv) が利用可能です。
- サンドボックス環境の詳細は `.gemini/Dockerfile` を参照してください。

## 4. 開発のテクニック

1. **修正箇所は1箇所とは限らない**: ある箇所を指摘されて修正した場合は、同様のパターンや構造を持つ他の箇所にも適用可能であるかを調査してください。
1. **周りのコードも見る**: 一部のコードを修正したらその周りのコードも見て、整合性が取れているか確認してください。一部を修正した結果、周りと整合性が取れていないことがよくあります。
1. **推測よりも観測を優先する**: 「修正が必要なはずだ」という推測だけでコードを書き換えるのではなく、まず現状の挙動を実際のデータや実行結果（ログ）で確認すること。不具合の存在を事実として確認してから修正に入り、修正後も同様に観測によって解決を証明するプロセスを徹底する。
1. **正確な文字数カウント**: 文字数をカウントする場合は、手作業を避け、必ず Python スクリプトを使用してください。実行時は `Total Length` だけでなく、カウント対象とした文字列そのものも出力に含めてください。
1. **数式の表記**: `gemini-cli` は LaTeX がレンダリングされない。Markdown ファイルに書き出す場合以外は、LaTeX ではなく Unicode 数式（Σ, √, ≤, ≥ など）を利用すること。
1. **手順変更時の動作検証**: スキル（`SKILL.md`）やドキュメントに記載された手順・コマンドを変更した際は、変更後の手順が現在の環境で正しく動作することを必ず実機（`run_shell_command` 等）で確認すること。推測だけで手順を書き換えないこと。
