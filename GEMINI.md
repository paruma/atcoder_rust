# Gemini プロジェクト設定

## 1. プロジェクトの基本

### 1.1. 概要

これは、AtCoderのような競技プログラミングのコンテスト問題をRust言語で解くためのリポジトリです。
コンテスト問題のコードに加えて、ライブラリも同梱されています。

### 1.2. ディレクトリ構成

- `src/contest/YYYY/abcXXX/q/q.rs`: `YYYY`年に開催されたコンテスト`abcXXX`の問題`q`の解答ファイル。
- `src/mylib/`: 再利用可能なモジュールやコードスニペット（例: グラフアルゴリズム、データ構造）。
- `src/example/`: 特定のアルゴリズムやデータ構造の練習用コード。
- `Cargo.toml`: ワークスペースの定義と共通の依存関係を定義。バイナリターゲットは各年度配下の `Cargo.toml` で定義。
- `contest.py`: コンテスト用のディレクトリとファイルをセットアップするためのヘルパースクリプト。

## 2. 開発の進め方

### 2.1. 基本ルール

- **実装指示の尊重**: 具体的な実装指示があるまで、ファイルへの書き込みは行わないでください。ユーザーの意図を慎重に判断し、不明な場合は実装方針を提案して同意を得てください。
- **Git利用**: `git commit` `git reset` `git checkout` などのリポジトリや編集中のファイルに副作用を及ぼすコマンドは使用しないでください。過去の状態を参照したい場合は安全に取り出す方法（git show や git diff）を用いてください。
- **ファイル管理**: 作業中に作成したスクリプトファイルや、実装途中のコードは、ユーザーの確認が済むまで削除しないでください。
- **計算量への配慮**: 競技プログラミングでは計算量が重要です。計算量が異なるアルゴリズムは、機能が同じでも別物として扱います。
- **指示してないことを無断で行わない**: 指示した内容以外でコードのリファクタリングをしたほうが良いと判断した内容はユーザに確認を取ってください。ユーザに確認を取るまでは指示した内容以外の変更を行わないでください

### 2.2. ライブラリ開発

ライブラリのコードを編集した際は、以下の手順を遵守してください。

1. **テストの実行**
    - 該当するテスト（`#[ignore]`も含む）を実行してください。`--include-ignored` オプションを使ってください。テストを実行する場合は編集したファイルのテストのみを対象にしてください
      - 例: `cargo test --package mylib --lib data_structure::range_set::tests -- --include-ignored --show-output`
    - コメントの変更だけの場合もテストを実行してください。コメントの修正だけのつもりがほかの部分も意図せず変更されちゃうことがあるからです。
2. **カバレッジの確認**
    - テスト実装後は、意図せずテストが通っていない行がないかカバレッジを確認してください。
    - まずは、以下のコマンドでインストールを実行してください。
      - `rustup component add llvm-tools-preview`
      - `cargo install cargo-llvm-cov`
    - `lcov.info` を生成・更新するには以下のコマンドを実行してください。
      - `cargo llvm-cov test --lcov --output-path lcov.info --package mylib --lib <モジュールパス> -- --include-ignored`
    - `lcov.info` ファイルを解析することで、未実行行（`DA:行番号,0`）を特定できます。
      - 例: `sed -n '\|SF:.*/対象ファイル名.rs|,\|end_of_record|p' lcov.info | grep "DA:.*,0"`
3. **フォーマッタの適用**: `cargo fmt` を実行してください。
4. **差分の確認**: `git diff` を使用して、意図しない変更がないか確認してください。関係のないファイルに変更があった場合は、ユーザーに報告・確認してください。

### 2.3. コーディング規約

- **`rand` クレートの利用**: `rand` クレートのバージョンは `0.9.2` です。古い記法は使用しないでください。
    - `rng.random_range` を使用してください (`rng.gen_range` は不可。)。
    - `from_os_rng` を使用してください (`from_entropy` は不可)。
    - rand クレートに関してあなたの知識は間違っている可能性が高いです。この文章を正として扱ってください。
- **ランダムテスト**: ランダムテストを実装する際には `#[ignore]` 属性を付与してください。
- **コメントについて**
    - コメントは日本語で書いてください
    - コードを読めばわかる「何をしているか（What）」ではなく、そのコードが存在する「なぜ（Why）」や、複雑なロジックの「要点」を説明するコメントを書いてください
    - コードから直接読み取れる自明なコメントは、ノイズになるため書かないでください
    - 「ここを変更」のように将来的に不要なコメントは付けないでください
    - 「極めて高い精度」のような主観的な表現はしないでください。
- **コーディングスタイルについて**
    - できるだけ手続き的ではなく宣言的なコードなコードを書いてください
    - できるだけ mutable な変数より immutable な変数を使った実装を書いてください。
    - ただし、手続き的・mutable な変数を使ったほうが読みやすい、または計算量が減らせる場合は、手続き的に mutable な変数を使っても構いません。

### 2.4. ランダムテスト実装について

#### ランダムテストの概要

ランダムテストの主な目的は、開発者が予期しないバグを見つけ出し、その信頼性と品質を広範なテストを通じて高めることである。これは、手動でテストケースを作成する際に開発者が考慮しきれない多様な入力パターンや組み合わせを自動的に生成することで、より網羅的かつ客観的なテストを可能にする点で、手動テストとは異なる大きなメリットを持つ。

高効率だが複雑なデータ構造の正しさを保証するために、シンプルで自明なリファレンス実装（計算量を気にしない愚直な実装）を用意し、両者に対して同一のランダムな操作を実行し、内部状態が常に一致することを検証する戦略は非常に有効である。

#### リファレンス実装をシンプルにする

リファレンス実装を設計する上で、最も重要な原則は**その実装が何よりもまずシンプルで、自明に正しいこと**です。リファレンス実装自体に誤りがあっては、テストの意味が失われてしまう。
リファレンス実装は、テスト対象のデータ構造が提供する機能のコア部分を、最も直接的で、理解しやすい方法で実装すべきである。。複雑な最適化や、エッジケースへの過度な対応は避けること。

ランダムテストで扱うデータ構造のサイズ（例: `len`）を比較的小さな範囲（例: `1..=30`）でランダム化してテストすることは、コーナーケースのバグを発見する上で非常に有効である。

#### テストに使うデータのサイズや値を小さくする

サイズが小さいと、生成される操作が互いに密接に重なり合ったり、隣接したりする頻度が高くなる。これにより、データ構造の境界処理やエッジケースなどの潜在的なバグの検出力が向上する。また、問題が発見された際に、テストケースの規模が小さいためデバッグが容易になるという利点もある。

値についても 0 などのコーナーケースが低くない確率で引けるように、ランダムに生成する値の範囲を調整すべきである。

#### 再現性を確保する

ランダムテストは実行ごとに異なる入力データを生成するため、テスト失敗時のデバッグが困難になる場合がある。この問題を解決するため、テスト実行時に乱数シードを固定することが重要である。テストが失敗した際には、使用したシード値を記録することで、同じ入力を再生成し、問題の再現およびデバッグを容易にすることができる。

#### デバッグしやすいアサーションの実装

テスト失敗時のデバッグ効率を最大化するため、アサーションメッセージにはデバッグに役立つ関連情報を含めることが極めて有効である。これにより、失敗を再現し、原因を特定するまでの時間を大幅に短縮できる。


## 3. コマンドリファレンス

### 3.1. よく使うコマンド

- **コードのフォーマット**:
  ```bash
  cargo fmt
  ```
- **ライブラリのテスト**:
  - 通常のテスト:
    ```bash
    cargo test --package mylib --lib -- segtree_lib::lazy_segtree::range_update_range_sum::test_range_update_range_sum::test_random_update --exact --show-output
    ```
  - `ignored` 指定のテスト:
    ```bash
    cargo test --package mylib --lib -- segtree_lib::lazy_segtree::range_update_range_sum::test_range_update_range_sum::test_random_update --exact --show-output --ignored
    ```

## 4. 開発環境

### 4.1. サンドボックス環境

- Rust と Python (pip, venv) が利用可能です。
- サンドボックス環境の詳細は `.gemini/Dockerfile` を参照してください。
- Pythonでサードパーティライブラリを使用する場合は、`.venv-gemini` の仮想環境を利用してください。

### 4.2. ソースコードの場所

- **サードパーティクレート**: `/home/node/.cargo` にあります。`read_file`で読めない場合は `cat` コマンドを使用してください（`cargo build`が事前に必要です）。
- **標準ライブラリ**: `/home/node/.rustup` にあります。`read_file`で読めない場合は `cat` コマンドを使用してください（`rustup component add rust-src` が必要になる場合があります）。

## 5. 開発のテクニック

1. **修正箇所は1箇所とは限らない**: ある箇所を指摘されて修正した場合は、同様のパターンや構造を持つ他の箇所にも適用可能であるかを調査してください。
1. **周りのコードも見る**: 一部のコードを修正したらその周りのコードも見て、整合性が取れているか確認してください。一部を修正した結果、周りと整合性が取れていないことがよくあります。
